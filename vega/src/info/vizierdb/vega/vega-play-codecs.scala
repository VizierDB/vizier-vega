package info.vizierdb.vega
/********************************************/
/********************************************/
/*** THIS FILE IS AUTOMATICALLY GENERATED ***/
/***   (by scripts/load_json_schema.sc)   ***/
/********************************************/
/********************************************/
/********************************************/
/********************************************/
/********************************************/
/***                                      ***/
/***        DO NOT MODIFY THIS FILE       ***/
/***                                      ***/
/********************************************/
/********************************************/
/********************************************/
/********************************************/
/********************************************/

import play.api.libs.json._
import info.vizierdb.vega.ExternalSupport._
/**
 * Play Json Encoders/Decoders for Vega operations
 **/

////////////////////////////////////////////////////////////////////////
// ProjectionFit (UnionType)
object ProjectionFitCodec {
  def decode(j: JsValue): ProjectionFit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionFit] =
    ArrayOfAnyCodec.decodeOpt(j).map { ProjectionFitAsArrayOfAny(_) }.orElse {
    ArrayOfFitCodec.decodeOpt(j).map { ProjectionFitAsArrayOfFit(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: ProjectionFit): JsValue =
    j match {
      case ProjectionFitAsArrayOfAny(x) /* Base, ArrayType */ => ArrayOfAnyCodec.encode(x)
      case ProjectionFitAsArrayOfFit(x) /* Base, ArrayType */ => ArrayOfFitCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BindInput (StructType)
object BindInputCodec {
  def decode(j: JsValue): BindInput =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BindInput] =
    Some(BindInput(
      `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `placeholder` = (j \ "placeholder").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `element` = (j \ "element").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `autocomplete` = (j \ "autocomplete").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `input` = (j \ "input").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `debounce` = (j \ "debounce").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
    ))

  def encode(j: BindInput): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`placeholder`.map { x => "placeholder" -> Json.toJson(x) },
        j.`element`.map { x => "element" -> Json.toJson(x) },
        j.`autocomplete`.map { x => "autocomplete" -> Json.toJson(x) },
        j.`input`.map { x => "input" -> Json.toJson(x) },
        j.`debounce`.map { x => "debounce" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// FieldLTEPredicateLte (UnionType)
object FieldLTEPredicateLteCodec {
  def decode(j: JsValue): FieldLTEPredicateLte =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldLTEPredicateLte] =
    j.asOpt[String].map { FieldLTEPredicateLteAsString(_) }.orElse {
    j.asOpt[JsNumber].map { FieldLTEPredicateLteAsNumber(_) }.orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: FieldLTEPredicateLte): JsValue =
    j match {
      case FieldLTEPredicateLteAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case FieldLTEPredicateLteAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfig (StructType)
object ProjectionConfigCodec {
  def decode(j: JsValue): ProjectionConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ProjectionConfig] =
    Some(ProjectionConfig(
      `fraction` = (j \ "fraction").asOpt[JsValue].flatMap { x => ProjectionConfigFractionCodec.decodeOpt(x) },
      `extent` = (j \ "extent").asOpt[JsValue].flatMap { x => ProjectionConfigExtentCodec.decodeOpt(x) },
      `center` = (j \ "center").asOpt[JsValue].flatMap { x => ProjectionConfigCenterCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ProjectionConfigScaleCodec.decodeOpt(x) },
      `fit` = (j \ "fit").asOpt[JsValue].flatMap { x => ProjectionConfigFitCodec.decodeOpt(x) },
      `reflectX` = (j \ "reflectX").asOpt[JsValue].flatMap { x => ProjectionConfigReflectXCodec.decodeOpt(x) },
      `rotate` = (j \ "rotate").asOpt[JsValue].flatMap { x => ProjectionConfigRotateCodec.decodeOpt(x) },
      `clipAngle` = (j \ "clipAngle").asOpt[JsValue].flatMap { x => ProjectionConfigClipAngleCodec.decodeOpt(x) },
      `lobes` = (j \ "lobes").asOpt[JsValue].flatMap { x => ProjectionConfigLobesCodec.decodeOpt(x) },
      `parallels` = (j \ "parallels").asOpt[JsValue].flatMap { x => ProjectionConfigParallelsCodec.decodeOpt(x) },
      `translate` = (j \ "translate").asOpt[JsValue].flatMap { x => ProjectionConfigTranslateCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => ProjectionConfigTypeCodec.decodeOpt(x) },
      `spacing` = (j \ "spacing").asOpt[JsValue].flatMap { x => ProjectionConfigSpacingCodec.decodeOpt(x) },
      `clipExtent` = (j \ "clipExtent").asOpt[JsValue].flatMap { x => ProjectionConfigClipExtentCodec.decodeOpt(x) },
      `coefficient` = (j \ "coefficient").asOpt[JsValue].flatMap { x => ProjectionConfigCoefficientCodec.decodeOpt(x) },
      `precision` = (j \ "precision").asOpt[JsValue].flatMap { x => ProjectionConfigPrecisionCodec.decodeOpt(x) },
      `size` = (j \ "size").asOpt[JsValue].flatMap { x => ProjectionConfigSizeCodec.decodeOpt(x) },
      `reflectY` = (j \ "reflectY").asOpt[JsValue].flatMap { x => ProjectionConfigReflectYCodec.decodeOpt(x) },
      `radius` = (j \ "radius").asOpt[JsValue].flatMap { x => ProjectionConfigRadiusCodec.decodeOpt(x) },
      `tilt` = (j \ "tilt").asOpt[JsValue].flatMap { x => ProjectionConfigTiltCodec.decodeOpt(x) },
      `pointRadius` = (j \ "pointRadius").asOpt[JsValue].flatMap { x => ProjectionConfigPointRadiusCodec.decodeOpt(x) },
      `ratio` = (j \ "ratio").asOpt[JsValue].flatMap { x => ProjectionConfigRatioCodec.decodeOpt(x) },
      `parallel` = (j \ "parallel").asOpt[JsValue].flatMap { x => ProjectionConfigParallelCodec.decodeOpt(x) },
      `distance` = (j \ "distance").asOpt[JsValue].flatMap { x => ProjectionConfigDistanceCodec.decodeOpt(x) },
    ))

  def encode(j: ProjectionConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`fraction`.map { x => "fraction" -> ProjectionConfigFractionCodec.encode(x) },
        j.`extent`.map { x => "extent" -> ProjectionConfigExtentCodec.encode(x) },
        j.`center`.map { x => "center" -> ProjectionConfigCenterCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ProjectionConfigScaleCodec.encode(x) },
        j.`fit`.map { x => "fit" -> ProjectionConfigFitCodec.encode(x) },
        j.`reflectX`.map { x => "reflectX" -> ProjectionConfigReflectXCodec.encode(x) },
        j.`rotate`.map { x => "rotate" -> ProjectionConfigRotateCodec.encode(x) },
        j.`clipAngle`.map { x => "clipAngle" -> ProjectionConfigClipAngleCodec.encode(x) },
        j.`lobes`.map { x => "lobes" -> ProjectionConfigLobesCodec.encode(x) },
        j.`parallels`.map { x => "parallels" -> ProjectionConfigParallelsCodec.encode(x) },
        j.`translate`.map { x => "translate" -> ProjectionConfigTranslateCodec.encode(x) },
        j.`type`.map { x => "type" -> ProjectionConfigTypeCodec.encode(x) },
        j.`spacing`.map { x => "spacing" -> ProjectionConfigSpacingCodec.encode(x) },
        j.`clipExtent`.map { x => "clipExtent" -> ProjectionConfigClipExtentCodec.encode(x) },
        j.`coefficient`.map { x => "coefficient" -> ProjectionConfigCoefficientCodec.encode(x) },
        j.`precision`.map { x => "precision" -> ProjectionConfigPrecisionCodec.encode(x) },
        j.`size`.map { x => "size" -> ProjectionConfigSizeCodec.encode(x) },
        j.`reflectY`.map { x => "reflectY" -> ProjectionConfigReflectYCodec.encode(x) },
        j.`radius`.map { x => "radius" -> ProjectionConfigRadiusCodec.encode(x) },
        j.`tilt`.map { x => "tilt" -> ProjectionConfigTiltCodec.encode(x) },
        j.`pointRadius`.map { x => "pointRadius" -> ProjectionConfigPointRadiusCodec.encode(x) },
        j.`ratio`.map { x => "ratio" -> ProjectionConfigRatioCodec.encode(x) },
        j.`parallel`.map { x => "parallel" -> ProjectionConfigParallelCodec.encode(x) },
        j.`distance`.map { x => "distance" -> ProjectionConfigDistanceCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AxisLabelLimit (UnionType)
object AxisLabelLimitCodec {
  def decode(j: JsValue): AxisLabelLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisLabelLimit] =
    j.asOpt[JsNumber].map { AxisLabelLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisLabelLimit): JsValue =
    j match {
      case AxisLabelLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigStrokeMiterLimit (UnionType)
object RectConfigStrokeMiterLimitCodec {
  def decode(j: JsValue): RectConfigStrokeMiterLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigStrokeMiterLimit] =
    j.asOpt[JsNumber].map { RectConfigStrokeMiterLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigStrokeMiterLimit): JsValue =
    j match {
      case RectConfigStrokeMiterLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigStrokeDash (UnionType)
object RectConfigStrokeDashCodec {
  def decode(j: JsValue): RectConfigStrokeDash =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigStrokeDash] =
    ArrayOfNumberCodec.decodeOpt(j).map { RectConfigStrokeDashAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigStrokeDash): JsValue =
    j match {
      case RectConfigStrokeDashAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigStrokeWidth (UnionType)
object BarConfigStrokeWidthCodec {
  def decode(j: JsValue): BarConfigStrokeWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigStrokeWidth] =
    BarConfigStrokeWidthAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigStrokeWidth): JsValue =
    j match {
      case x:BarConfigStrokeWidthAsNumber /* TypeRef */ => BarConfigStrokeWidthAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelUnitSpecBounds (EnumType)
object TopLevelUnitSpecBoundsCodec {
  def decode(j: JsValue): TopLevelUnitSpecBounds =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelUnitSpecBounds] =
    j match {
      case JsString("full") => Some(TopLevelUnitSpecBoundsFull)
      case JsString("flush") => Some(TopLevelUnitSpecBoundsFlush)
      case _ => None
    }
  def encode(j: TopLevelUnitSpecBounds): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// LineConfigEndAngle (UnionType)
object LineConfigEndAngleCodec {
  def decode(j: JsValue): LineConfigEndAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigEndAngle] =
    j.asOpt[JsNumber].map { LineConfigEndAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigEndAngle): JsValue =
    j match {
      case LineConfigEndAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// NonLayerRepeatSpecSpacing (UnionType)
object NonLayerRepeatSpecSpacingCodec {
  def decode(j: JsValue): NonLayerRepeatSpecSpacing =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[NonLayerRepeatSpecSpacing] =
    j.asOpt[JsNumber].map { NonLayerRepeatSpecSpacingAsNumber(_) }.orElse {
    RowColNumberCodec.decodeOpt(j) } 
  def encode(j: NonLayerRepeatSpecSpacing): JsValue =
    j match {
      case NonLayerRepeatSpecSpacingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:RowColNumber /* TypeRef */ => RowColNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldGTPredicate (StructType)
object FieldGTPredicateCodec {
  def decode(j: JsValue): FieldGTPredicate =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldGTPredicate] =
    {
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`field`.isEmpty) { return None }
      val `gt` = (j \ "gt").asOpt[JsValue].flatMap { x => FieldGTPredicateGtCodec.decodeOpt(x) }
      if(`gt`.isEmpty) { return None }
      val `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => FieldGTPredicateTimeUnitCodec.decodeOpt(x) }
      return Some(FieldGTPredicate(
        `field` = `field`.get,
        `gt` = `gt`.get,
        `timeUnit` = `timeUnit`,
      ))
    }

  def encode(j: FieldGTPredicate): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("field" -> Json.toJson(j.`field`)),
        Some("gt" -> FieldGTPredicateGtCodec.encode(j.`gt`)),
        j.`timeUnit`.map { x => "timeUnit" -> FieldGTPredicateTimeUnitCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionDatumDefStringNull (StructType)
object FieldOrDatumDefWithConditionDatumDefStringNullCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionDatumDefStringNull =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionDatumDefStringNull] =
    Some(FieldOrDatumDefWithConditionDatumDefStringNull(
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionDatumDefStringNullDatumCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionDatumDefStringNullBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionDatumDefStringNullConditionCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeCodec.decodeOpt(x) },
    ))

  def encode(j: FieldOrDatumDefWithConditionDatumDefStringNull): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`datum`.map { x => "datum" -> FieldOrDatumDefWithConditionDatumDefStringNullDatumCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> FieldOrDatumDefWithConditionDatumDefStringNullBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> FieldOrDatumDefWithConditionDatumDefStringNullConditionCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TopLevelSpec (UnionType)
object TopLevelSpecCodec {
  def decode(j: JsValue): TopLevelSpec =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelSpec] =
    TopLevelLayerSpecCodec.decodeOpt(j).orElse {
    TopLevelVConcatSpecCodec.decodeOpt(j).orElse {
    TopLevelRepeatSpecCodec.decodeOpt(j).orElse {
    TopLevelUnitSpecCodec.decodeOpt(j).orElse {
    TopLevelFacetSpecCodec.decodeOpt(j).orElse {
    TopLevelHConcatSpecCodec.decodeOpt(j).orElse {
    TopLevelConcatSpecCodec.decodeOpt(j) } } } } } } 
  def encode(j: TopLevelSpec): JsValue =
    j match {
      case x:TopLevelLayerSpec /* TypeRef */ => TopLevelLayerSpecCodec.encode(x)
      case x:TopLevelVConcatSpec /* TypeRef */ => TopLevelVConcatSpecCodec.encode(x)
      case x:TopLevelRepeatSpec /* TypeRef */ => TopLevelRepeatSpecCodec.encode(x)
      case x:TopLevelUnitSpec /* TypeRef */ => TopLevelUnitSpecCodec.encode(x)
      case x:TopLevelFacetSpec /* TypeRef */ => TopLevelFacetSpecCodec.encode(x)
      case x:TopLevelHConcatSpec /* TypeRef */ => TopLevelHConcatSpecCodec.encode(x)
      case x:TopLevelConcatSpec /* TypeRef */ => TopLevelConcatSpecCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingUrlBandPosition (ConstrainedType)
object SharedEncodingUrlBandPositionCodec {
  def decode(j: JsValue): SharedEncodingUrlBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingUrlBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingUrlBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingUrlBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// SelectionResolution (EnumType)
object SelectionResolutionCodec {
  def decode(j: JsValue): SelectionResolution =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SelectionResolution] =
    j match {
      case JsString("global") => Some(SelectionResolutionGlobal)
      case JsString("union") => Some(SelectionResolutionUnion)
      case JsString("intersect") => Some(SelectionResolutionIntersect)
      case _ => None
    }
  def encode(j: SelectionResolution): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// ArrayOfTopLevelFacetSpecParamsElement (ArrayType)
object ArrayOfTopLevelFacetSpecParamsElementCodec {
  def decode(j: JsValue): Seq[TopLevelFacetSpecParamsElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[TopLevelFacetSpecParamsElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      TopLevelFacetSpecParamsElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[TopLevelFacetSpecParamsElement]): JsArray =
      JsArray(j.map { x => TopLevelFacetSpecParamsElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// ViewConfigStrokeDash (UnionType)
object ViewConfigStrokeDashCodec {
  def decode(j: JsValue): ViewConfigStrokeDash =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewConfigStrokeDash] =
    ArrayOfNumberCodec.decodeOpt(j).map { ViewConfigStrokeDashAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ViewConfigStrokeDash): JsValue =
    j match {
      case ViewConfigStrokeDashAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// VConcatSpecGenericSpec (StructType)
object VConcatSpecGenericSpecCodec {
  def decode(j: JsValue): VConcatSpecGenericSpec =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[VConcatSpecGenericSpec] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `center` = (j \ "center").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `description` = (j \ "description").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `data` = (j \ "data").asOpt[JsValue].flatMap { x => DataCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `vconcat` = (j \ "vconcat").asOpt[JsValue].flatMap { x => ArrayOfSpecCodec.decodeOpt(x) }
      if(`vconcat`.isEmpty) { return None }
      val `bounds` = (j \ "bounds").asOpt[JsValue].flatMap { x => VConcatSpecGenericSpecBoundsCodec.decodeOpt(x) }
      val `resolve` = (j \ "resolve").asOpt[JsValue].flatMap { x => ResolveCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => VConcatSpecGenericSpecTitleCodec.decodeOpt(x) }
      val `spacing` = (j \ "spacing").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `transform` = (j \ "transform").asOpt[JsValue].flatMap { x => ArrayOfTransformCodec.decodeOpt(x) }
      return Some(VConcatSpecGenericSpec(
        `name` = `name`,
        `center` = `center`,
        `description` = `description`,
        `data` = `data`,
        `vconcat` = `vconcat`.get,
        `bounds` = `bounds`,
        `resolve` = `resolve`,
        `title` = `title`,
        `spacing` = `spacing`,
        `transform` = `transform`,
      ))
    }

  def encode(j: VConcatSpecGenericSpec): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`center`.map { x => "center" -> Json.toJson(x) },
        j.`description`.map { x => "description" -> Json.toJson(x) },
        j.`data`.map { x => "data" -> DataCodec.encode(x) },
        Some("vconcat" -> ArrayOfSpecCodec.encode(j.`vconcat`)),
        j.`bounds`.map { x => "bounds" -> VConcatSpecGenericSpecBoundsCodec.encode(x) },
        j.`resolve`.map { x => "resolve" -> ResolveCodec.encode(x) },
        j.`title`.map { x => "title" -> VConcatSpecGenericSpecTitleCodec.encode(x) },
        j.`spacing`.map { x => "spacing" -> Json.toJson(x) },
        j.`transform`.map { x => "transform" -> ArrayOfTransformCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AxisConfigDomainColor (UnionType)
object AxisConfigDomainColorCodec {
  def decode(j: JsValue): AxisConfigDomainColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigDomainColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => AxisConfigDomainColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigDomainColor): JsValue =
    j match {
      case AxisConfigDomainColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingX2Value (UnionType)
object SharedEncodingX2ValueCodec {
  def decode(j: JsValue): SharedEncodingX2Value =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingX2Value] =
    j.asOpt[JsNumber].map { SharedEncodingX2ValueAsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingX2Value): JsValue =
    j match {
      case SharedEncodingX2ValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateStringFieldDefTimeUnit (UnionType)
object ConditionalPredicateStringFieldDefTimeUnitCodec {
  def decode(j: JsValue): ConditionalPredicateStringFieldDefTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateStringFieldDefTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: ConditionalPredicateStringFieldDefTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateMarkPropFieldOrDatumDefAsObject2 (StructType)
object ConditionalPredicateMarkPropFieldOrDatumDefAsObject2Codec {
  def decode(j: JsValue): ConditionalPredicateMarkPropFieldOrDatumDefAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateMarkPropFieldOrDatumDefAsObject2] =
    {
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      val `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => ConditionalPredicateMarkPropFieldOrDatumDefAsObject2DatumCodec.decodeOpt(x) }
      val `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => ConditionalPredicateMarkPropFieldOrDatumDefAsObject2BandPositionCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeCodec.decodeOpt(x) }
      return Some(ConditionalPredicateMarkPropFieldOrDatumDefAsObject2(
        `test` = `test`.get,
        `scale` = `scale`,
        `datum` = `datum`,
        `legend` = `legend`,
        `bandPosition` = `bandPosition`,
        `title` = `title`,
        `type` = `type`,
      ))
    }

  def encode(j: ConditionalPredicateMarkPropFieldOrDatumDefAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> ConditionalPredicateMarkPropFieldOrDatumDefAsObject2DatumCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> ConditionalPredicateMarkPropFieldOrDatumDefAsObject2BandPositionCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// BoxPlotConfigOutliers (UnionType)
object BoxPlotConfigOutliersCodec {
  def decode(j: JsValue): BoxPlotConfigOutliers =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BoxPlotConfigOutliers] =
    j.asOpt[Boolean].map { BoxPlotConfigOutliersAsBool(_) }.orElse {
    MarkConfigCodec.decodeOpt(j) } 
  def encode(j: BoxPlotConfigOutliers): JsValue =
    j match {
      case BoxPlotConfigOutliersAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:MarkConfig /* TypeRef */ => MarkConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldRangePredicateRange (ConstrainedType)
// see FieldRangePredicateRange (UnionType)

////////////////////////////////////////////////////////////////////////
// SharedEncodingYValue (UnionType)
object SharedEncodingYValueCodec {
  def decode(j: JsValue): SharedEncodingYValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingYValue] =
    j.asOpt[JsNumber].map { SharedEncodingYValueAsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingYValue): JsValue =
    j match {
      case SharedEncodingYValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RadialGradient (StructType)
object RadialGradientCodec {
  def decode(j: JsValue): RadialGradient =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RadialGradient] =
    {
      val `gradient` = (j \ "gradient").asOpt[JsValue].flatMap { x => RadialGradientGradientCodec.decodeOpt(x) }
      if(`gradient`.isEmpty) { return None }
      val `x2` = (j \ "x2").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `id` = (j \ "id").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `r2` = (j \ "r2").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `stops` = (j \ "stops").asOpt[JsValue].flatMap { x => ArrayOfGradientStopCodec.decodeOpt(x) }
      if(`stops`.isEmpty) { return None }
      val `y1` = (j \ "y1").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `r1` = (j \ "r1").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `y2` = (j \ "y2").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `x1` = (j \ "x1").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      return Some(RadialGradient(
        `gradient` = `gradient`.get,
        `x2` = `x2`,
        `id` = `id`,
        `r2` = `r2`,
        `stops` = `stops`.get,
        `y1` = `y1`,
        `r1` = `r1`,
        `y2` = `y2`,
        `x1` = `x1`,
      ))
    }

  def encode(j: RadialGradient): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("gradient" -> RadialGradientGradientCodec.encode(j.`gradient`)),
        j.`x2`.map { x => "x2" -> Json.toJson(x) },
        j.`id`.map { x => "id" -> Json.toJson(x) },
        j.`r2`.map { x => "r2" -> Json.toJson(x) },
        Some("stops" -> ArrayOfGradientStopCodec.encode(j.`stops`)),
        j.`y1`.map { x => "y1" -> Json.toJson(x) },
        j.`r1`.map { x => "r1" -> Json.toJson(x) },
        j.`y2`.map { x => "y2" -> Json.toJson(x) },
        j.`x1`.map { x => "x1" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// FacetEncodingFieldDefCenter (UnionType)
object FacetEncodingFieldDefCenterCodec {
  def decode(j: JsValue): FacetEncodingFieldDefCenter =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetEncodingFieldDefCenter] =
    j.asOpt[Boolean].map { FacetEncodingFieldDefCenterAsBool(_) }.orElse {
    RowColBooleanCodec.decodeOpt(j) } 
  def encode(j: FacetEncodingFieldDefCenter): JsValue =
    j match {
      case FacetEncodingFieldDefCenterAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:RowColBoolean /* TypeRef */ => RowColBooleanCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTickWidthAsNumber (ConstrainedType)
object AxisConfigTickWidthAsNumberCodec {
  def decode(j: JsValue): AxisConfigTickWidthAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AxisConfigTickWidthAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AxisConfigTickWidthAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AxisConfigTickWidthAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// RectConfigY2 (UnionType)
object RectConfigY2Codec {
  def decode(j: JsValue): RectConfigY2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigY2] =
    j.asOpt[JsNumber].map { RectConfigY2AsNumber(_) }.orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: RectConfigY2): JsValue =
    j match {
      case RectConfigY2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigFillColor (UnionType)
object LegendConfigFillColorCodec {
  def decode(j: JsValue): LegendConfigFillColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigFillColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => LegendConfigFillColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: LegendConfigFillColor): JsValue =
    j match {
      case LegendConfigFillColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigFontSize (UnionType)
object LineConfigFontSizeCodec {
  def decode(j: JsValue): LineConfigFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigFontSize] =
    LineConfigFontSizeAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigFontSize): JsValue =
    j match {
      case x:LineConfigFontSizeAsNumber /* TypeRef */ => LineConfigFontSizeAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BoxPlot (ConstantType)
object BoxPlotCodec {
  def decode(j: JsValue): BoxPlot =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BoxPlot] =
    j match {
      case JsString("boxplot") => Some(BoxPlot())
      case _ => None
    }
  def encode(j: BoxPlot): JsValue =
    JsString("boxplot")
}


////////////////////////////////////////////////////////////////////////
// AxisConfigTitleLimitAsNumber (ConstrainedType)
object AxisConfigTitleLimitAsNumberCodec {
  def decode(j: JsValue): AxisConfigTitleLimitAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AxisConfigTitleLimitAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AxisConfigTitleLimitAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AxisConfigTitleLimitAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkDefStrokeOpacity (UnionType)
object MarkDefStrokeOpacityCodec {
  def decode(j: JsValue): MarkDefStrokeOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefStrokeOpacity] =
    MarkDefStrokeOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefStrokeOpacity): JsValue =
    j match {
      case x:MarkDefStrokeOpacityAsNumber /* TypeRef */ => MarkDefStrokeOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigLineHeight (UnionType)
object TickConfigLineHeightCodec {
  def decode(j: JsValue): TickConfigLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigLineHeight] =
    j.asOpt[JsNumber].map { TickConfigLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigLineHeight): JsValue =
    j match {
      case TickConfigLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingXStack (UnionType)
object SharedEncodingXStackCodec {
  def decode(j: JsValue): SharedEncodingXStack =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingXStack] =
    StackOffsetCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingXStackAsNull }.orElse {
    j.asOpt[Boolean].map { SharedEncodingXStackAsBool(_) } } } 
  def encode(j: SharedEncodingXStack): JsValue =
    j match {
      case x:StackOffset /* TypeRef */ => StackOffsetCodec.encode(x)
      case SharedEncodingXStackAsNull /* Global, NullType$ */ => JsNull
      case SharedEncodingXStackAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefOuterRadius (ConstrainedType)
// see OverlayMarkDefOuterRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// TickConfigY2 (UnionType)
object TickConfigY2Codec {
  def decode(j: JsValue): TickConfigY2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigY2] =
    j.asOpt[JsNumber].map { TickConfigY2AsNumber(_) }.orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: TickConfigY2): JsValue =
    j match {
      case TickConfigY2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderConfigLabelBaseline (UnionType)
object HeaderConfigLabelBaselineCodec {
  def decode(j: JsValue): HeaderConfigLabelBaseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigLabelBaseline] =
    TextBaselineCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderConfigLabelBaseline): JsValue =
    j match {
      case x:TextBaseline /* TypeRef */ => TextBaselineCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigOuterRadius (UnionType)
object BarConfigOuterRadiusCodec {
  def decode(j: JsValue): BarConfigOuterRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigOuterRadius] =
    j.asOpt[JsNumber].map { BarConfigOuterRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigOuterRadius): JsValue =
    j match {
      case BarConfigOuterRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefInnerRadius (ConstrainedType)
// see OverlayMarkDefInnerRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefY (UnionType)
object OverlayMarkDefYCodec {
  def decode(j: JsValue): OverlayMarkDefY =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefY] =
    j.asOpt[JsNumber].map { OverlayMarkDefYAsNumber(_) }.orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: OverlayMarkDefY): JsValue =
    j match {
      case OverlayMarkDefYAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfConditionalValueDefTextExprRef (ArrayType)
object ArrayOfConditionalValueDefTextExprRefCodec {
  def decode(j: JsValue): Seq[ConditionalValueDefTextExprRef] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[ConditionalValueDefTextExprRef]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      ConditionalValueDefTextExprRefCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[ConditionalValueDefTextExprRef]): JsArray =
      JsArray(j.map { x => ConditionalValueDefTextExprRefCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfigPrecision (UnionType)
object ProjectionConfigPrecisionCodec {
  def decode(j: JsValue): ProjectionConfigPrecision =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigPrecision] =
    j.asOpt[JsNumber].map { ProjectionConfigPrecisionAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigPrecision): JsValue =
    j match {
      case ProjectionConfigPrecisionAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfigLobes (UnionType)
object ProjectionConfigLobesCodec {
  def decode(j: JsValue): ProjectionConfigLobes =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigLobes] =
    j.asOpt[JsNumber].map { ProjectionConfigLobesAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigLobes): JsValue =
    j match {
      case ProjectionConfigLobesAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigAria (UnionType)
object RectConfigAriaCodec {
  def decode(j: JsValue): RectConfigAria =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigAria] =
    j.asOpt[Boolean].map { RectConfigAriaAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigAria): JsValue =
    j match {
      case RectConfigAriaAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigFontStyle (UnionType)
object LineConfigFontStyleCodec {
  def decode(j: JsValue): LineConfigFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigFontStyle] =
    j.asOpt[String].map { LineConfigFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigFontStyle): JsValue =
    j match {
      case LineConfigFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BoxPlotConfigBox (UnionType)
object BoxPlotConfigBoxCodec {
  def decode(j: JsValue): BoxPlotConfigBox =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BoxPlotConfigBox] =
    j.asOpt[Boolean].map { BoxPlotConfigBoxAsBool(_) }.orElse {
    MarkConfigCodec.decodeOpt(j) } 
  def encode(j: BoxPlotConfigBox): JsValue =
    j match {
      case BoxPlotConfigBoxAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:MarkConfig /* TypeRef */ => MarkConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigPointPadding (ConstrainedType)
// see ScaleConfigPointPadding (UnionType)

////////////////////////////////////////////////////////////////////////
// Padding (UnionType)
object PaddingCodec {
  def decode(j: JsValue): Padding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Padding] =
    j.asOpt[JsNumber].map { PaddingAsNumber(_) }.orElse {
    PaddingAsObject2Codec.decodeOpt(j) } 
  def encode(j: Padding): JsValue =
    j match {
      case PaddingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:PaddingAsObject2 /* TypeRef */ => PaddingAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfig (StructType)
object AxisConfigCodec {
  def decode(j: JsValue): AxisConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AxisConfig] =
    Some(AxisConfig(
      `labelOpacity` = (j \ "labelOpacity").asOpt[JsValue].flatMap { x => AxisConfigLabelOpacityCodec.decodeOpt(x) },
      `domainCap` = (j \ "domainCap").asOpt[JsValue].flatMap { x => AxisConfigDomainCapCodec.decodeOpt(x) },
      `domainColor` = (j \ "domainColor").asOpt[JsValue].flatMap { x => AxisConfigDomainColorCodec.decodeOpt(x) },
      `style` = (j \ "style").asOpt[JsValue].flatMap { x => AxisConfigStyleCodec.decodeOpt(x) },
      `domain` = (j \ "domain").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `offset` = (j \ "offset").asOpt[JsValue].flatMap { x => AxisConfigOffsetCodec.decodeOpt(x) },
      `gridOpacity` = (j \ "gridOpacity").asOpt[JsValue].flatMap { x => AxisConfigGridOpacityCodec.decodeOpt(x) },
      `labelFontSize` = (j \ "labelFontSize").asOpt[JsValue].flatMap { x => AxisConfigLabelFontSizeCodec.decodeOpt(x) },
      `format` = (j \ "format").asOpt[JsValue].flatMap { x => AxisConfigFormatCodec.decodeOpt(x) },
      `gridWidth` = (j \ "gridWidth").asOpt[JsValue].flatMap { x => AxisConfigGridWidthCodec.decodeOpt(x) },
      `tickCount` = (j \ "tickCount").asOpt[JsValue].flatMap { x => AxisConfigTickCountCodec.decodeOpt(x) },
      `gridCap` = (j \ "gridCap").asOpt[JsValue].flatMap { x => AxisConfigGridCapCodec.decodeOpt(x) },
      `labelAngle` = (j \ "labelAngle").asOpt[JsValue].flatMap { x => AxisConfigLabelAngleCodec.decodeOpt(x) },
      `domainOpacity` = (j \ "domainOpacity").asOpt[JsValue].flatMap { x => AxisConfigDomainOpacityCodec.decodeOpt(x) },
      `description` = (j \ "description").asOpt[JsValue].flatMap { x => AxisConfigDescriptionCodec.decodeOpt(x) },
      `titleFont` = (j \ "titleFont").asOpt[JsValue].flatMap { x => AxisConfigTitleFontCodec.decodeOpt(x) },
      `titleFontStyle` = (j \ "titleFontStyle").asOpt[JsValue].flatMap { x => AxisConfigTitleFontStyleCodec.decodeOpt(x) },
      `tickDashOffset` = (j \ "tickDashOffset").asOpt[JsValue].flatMap { x => AxisConfigTickDashOffsetCodec.decodeOpt(x) },
      `labelColor` = (j \ "labelColor").asOpt[JsValue].flatMap { x => AxisConfigLabelColorCodec.decodeOpt(x) },
      `domainDashOffset` = (j \ "domainDashOffset").asOpt[JsValue].flatMap { x => AxisConfigDomainDashOffsetCodec.decodeOpt(x) },
      `labelFontWeight` = (j \ "labelFontWeight").asOpt[JsValue].flatMap { x => AxisConfigLabelFontWeightCodec.decodeOpt(x) },
      `gridDash` = (j \ "gridDash").asOpt[JsValue].flatMap { x => AxisConfigGridDashCodec.decodeOpt(x) },
      `minExtent` = (j \ "minExtent").asOpt[JsValue].flatMap { x => AxisConfigMinExtentCodec.decodeOpt(x) },
      `titleLineHeight` = (j \ "titleLineHeight").asOpt[JsValue].flatMap { x => AxisConfigTitleLineHeightCodec.decodeOpt(x) },
      `labelLineHeight` = (j \ "labelLineHeight").asOpt[JsValue].flatMap { x => AxisConfigLabelLineHeightCodec.decodeOpt(x) },
      `tickCap` = (j \ "tickCap").asOpt[JsValue].flatMap { x => AxisConfigTickCapCodec.decodeOpt(x) },
      `titleX` = (j \ "titleX").asOpt[JsValue].flatMap { x => AxisConfigTitleXCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => AxisConfigBandPositionCodec.decodeOpt(x) },
      `tickExtra` = (j \ "tickExtra").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `grid` = (j \ "grid").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `tickBand` = (j \ "tickBand").asOpt[JsValue].flatMap { x => AxisConfigTickBandCodec.decodeOpt(x) },
      `titlePadding` = (j \ "titlePadding").asOpt[JsValue].flatMap { x => AxisConfigTitlePaddingCodec.decodeOpt(x) },
      `tickMinStep` = (j \ "tickMinStep").asOpt[JsValue].flatMap { x => AxisConfigTickMinStepCodec.decodeOpt(x) },
      `titleY` = (j \ "titleY").asOpt[JsValue].flatMap { x => AxisConfigTitleYCodec.decodeOpt(x) },
      `labels` = (j \ "labels").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `labelFlush` = (j \ "labelFlush").asOpt[JsValue].flatMap { x => AxisConfigLabelFlushCodec.decodeOpt(x) },
      `zindex` = (j \ "zindex").asOpt[JsValue].flatMap { x => AxisConfigZindexCodec.decodeOpt(x) },
      `formatType` = (j \ "formatType").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `labelLimit` = (j \ "labelLimit").asOpt[JsValue].flatMap { x => AxisConfigLabelLimitCodec.decodeOpt(x) },
      `gridDashOffset` = (j \ "gridDashOffset").asOpt[JsValue].flatMap { x => AxisConfigGridDashOffsetCodec.decodeOpt(x) },
      `titleAnchor` = (j \ "titleAnchor").asOpt[JsValue].flatMap { x => AxisConfigTitleAnchorCodec.decodeOpt(x) },
      `titleColor` = (j \ "titleColor").asOpt[JsValue].flatMap { x => AxisConfigTitleColorCodec.decodeOpt(x) },
      `labelOverlap` = (j \ "labelOverlap").asOpt[JsValue].flatMap { x => AxisConfigLabelOverlapCodec.decodeOpt(x) },
      `translate` = (j \ "translate").asOpt[JsValue].flatMap { x => AxisConfigTranslateCodec.decodeOpt(x) },
      `labelFlushOffset` = (j \ "labelFlushOffset").asOpt[JsValue].flatMap { x => AxisConfigLabelFlushOffsetCodec.decodeOpt(x) },
      `domainWidth` = (j \ "domainWidth").asOpt[JsValue].flatMap { x => AxisConfigDomainWidthCodec.decodeOpt(x) },
      `tickRound` = (j \ "tickRound").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `labelOffset` = (j \ "labelOffset").asOpt[JsValue].flatMap { x => AxisConfigLabelOffsetCodec.decodeOpt(x) },
      `ticks` = (j \ "ticks").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `orient` = (j \ "orient").asOpt[JsValue].flatMap { x => AxisConfigOrientCodec.decodeOpt(x) },
      `domainDash` = (j \ "domainDash").asOpt[JsValue].flatMap { x => AxisConfigDomainDashCodec.decodeOpt(x) },
      `labelAlign` = (j \ "labelAlign").asOpt[JsValue].flatMap { x => AxisConfigLabelAlignCodec.decodeOpt(x) },
      `disable` = (j \ "disable").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `values` = (j \ "values").asOpt[JsValue].flatMap { x => AxisConfigValuesCodec.decodeOpt(x) },
      `position` = (j \ "position").asOpt[JsValue].flatMap { x => AxisConfigPositionCodec.decodeOpt(x) },
      `titleAngle` = (j \ "titleAngle").asOpt[JsValue].flatMap { x => AxisConfigTitleAngleCodec.decodeOpt(x) },
      `labelPadding` = (j \ "labelPadding").asOpt[JsValue].flatMap { x => AxisConfigLabelPaddingCodec.decodeOpt(x) },
      `aria` = (j \ "aria").asOpt[JsValue].flatMap { x => AxisConfigAriaCodec.decodeOpt(x) },
      `labelExpr` = (j \ "labelExpr").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `tickWidth` = (j \ "tickWidth").asOpt[JsValue].flatMap { x => AxisConfigTickWidthCodec.decodeOpt(x) },
      `tickOffset` = (j \ "tickOffset").asOpt[JsValue].flatMap { x => AxisConfigTickOffsetCodec.decodeOpt(x) },
      `maxExtent` = (j \ "maxExtent").asOpt[JsValue].flatMap { x => AxisConfigMaxExtentCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `tickDash` = (j \ "tickDash").asOpt[JsValue].flatMap { x => AxisConfigTickDashCodec.decodeOpt(x) },
      `labelBound` = (j \ "labelBound").asOpt[JsValue].flatMap { x => AxisConfigLabelBoundCodec.decodeOpt(x) },
      `gridColor` = (j \ "gridColor").asOpt[JsValue].flatMap { x => AxisConfigGridColorCodec.decodeOpt(x) },
      `titleLimit` = (j \ "titleLimit").asOpt[JsValue].flatMap { x => AxisConfigTitleLimitCodec.decodeOpt(x) },
      `labelFont` = (j \ "labelFont").asOpt[JsValue].flatMap { x => AxisConfigLabelFontCodec.decodeOpt(x) },
      `labelFontStyle` = (j \ "labelFontStyle").asOpt[JsValue].flatMap { x => AxisConfigLabelFontStyleCodec.decodeOpt(x) },
      `titleOpacity` = (j \ "titleOpacity").asOpt[JsValue].flatMap { x => AxisConfigTitleOpacityCodec.decodeOpt(x) },
      `titleAlign` = (j \ "titleAlign").asOpt[JsValue].flatMap { x => AxisConfigTitleAlignCodec.decodeOpt(x) },
      `labelSeparation` = (j \ "labelSeparation").asOpt[JsValue].flatMap { x => AxisConfigLabelSeparationCodec.decodeOpt(x) },
      `titleBaseline` = (j \ "titleBaseline").asOpt[JsValue].flatMap { x => AxisConfigTitleBaselineCodec.decodeOpt(x) },
      `tickColor` = (j \ "tickColor").asOpt[JsValue].flatMap { x => AxisConfigTickColorCodec.decodeOpt(x) },
      `titleFontSize` = (j \ "titleFontSize").asOpt[JsValue].flatMap { x => AxisConfigTitleFontSizeCodec.decodeOpt(x) },
      `titleFontWeight` = (j \ "titleFontWeight").asOpt[JsValue].flatMap { x => AxisConfigTitleFontWeightCodec.decodeOpt(x) },
      `tickSize` = (j \ "tickSize").asOpt[JsValue].flatMap { x => AxisConfigTickSizeCodec.decodeOpt(x) },
      `tickOpacity` = (j \ "tickOpacity").asOpt[JsValue].flatMap { x => AxisConfigTickOpacityCodec.decodeOpt(x) },
      `labelBaseline` = (j \ "labelBaseline").asOpt[JsValue].flatMap { x => AxisConfigLabelBaselineCodec.decodeOpt(x) },
    ))

  def encode(j: AxisConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`labelOpacity`.map { x => "labelOpacity" -> AxisConfigLabelOpacityCodec.encode(x) },
        j.`domainCap`.map { x => "domainCap" -> AxisConfigDomainCapCodec.encode(x) },
        j.`domainColor`.map { x => "domainColor" -> AxisConfigDomainColorCodec.encode(x) },
        j.`style`.map { x => "style" -> AxisConfigStyleCodec.encode(x) },
        j.`domain`.map { x => "domain" -> Json.toJson(x) },
        j.`offset`.map { x => "offset" -> AxisConfigOffsetCodec.encode(x) },
        j.`gridOpacity`.map { x => "gridOpacity" -> AxisConfigGridOpacityCodec.encode(x) },
        j.`labelFontSize`.map { x => "labelFontSize" -> AxisConfigLabelFontSizeCodec.encode(x) },
        j.`format`.map { x => "format" -> AxisConfigFormatCodec.encode(x) },
        j.`gridWidth`.map { x => "gridWidth" -> AxisConfigGridWidthCodec.encode(x) },
        j.`tickCount`.map { x => "tickCount" -> AxisConfigTickCountCodec.encode(x) },
        j.`gridCap`.map { x => "gridCap" -> AxisConfigGridCapCodec.encode(x) },
        j.`labelAngle`.map { x => "labelAngle" -> AxisConfigLabelAngleCodec.encode(x) },
        j.`domainOpacity`.map { x => "domainOpacity" -> AxisConfigDomainOpacityCodec.encode(x) },
        j.`description`.map { x => "description" -> AxisConfigDescriptionCodec.encode(x) },
        j.`titleFont`.map { x => "titleFont" -> AxisConfigTitleFontCodec.encode(x) },
        j.`titleFontStyle`.map { x => "titleFontStyle" -> AxisConfigTitleFontStyleCodec.encode(x) },
        j.`tickDashOffset`.map { x => "tickDashOffset" -> AxisConfigTickDashOffsetCodec.encode(x) },
        j.`labelColor`.map { x => "labelColor" -> AxisConfigLabelColorCodec.encode(x) },
        j.`domainDashOffset`.map { x => "domainDashOffset" -> AxisConfigDomainDashOffsetCodec.encode(x) },
        j.`labelFontWeight`.map { x => "labelFontWeight" -> AxisConfigLabelFontWeightCodec.encode(x) },
        j.`gridDash`.map { x => "gridDash" -> AxisConfigGridDashCodec.encode(x) },
        j.`minExtent`.map { x => "minExtent" -> AxisConfigMinExtentCodec.encode(x) },
        j.`titleLineHeight`.map { x => "titleLineHeight" -> AxisConfigTitleLineHeightCodec.encode(x) },
        j.`labelLineHeight`.map { x => "labelLineHeight" -> AxisConfigLabelLineHeightCodec.encode(x) },
        j.`tickCap`.map { x => "tickCap" -> AxisConfigTickCapCodec.encode(x) },
        j.`titleX`.map { x => "titleX" -> AxisConfigTitleXCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> AxisConfigBandPositionCodec.encode(x) },
        j.`tickExtra`.map { x => "tickExtra" -> Json.toJson(x) },
        j.`grid`.map { x => "grid" -> Json.toJson(x) },
        j.`tickBand`.map { x => "tickBand" -> AxisConfigTickBandCodec.encode(x) },
        j.`titlePadding`.map { x => "titlePadding" -> AxisConfigTitlePaddingCodec.encode(x) },
        j.`tickMinStep`.map { x => "tickMinStep" -> AxisConfigTickMinStepCodec.encode(x) },
        j.`titleY`.map { x => "titleY" -> AxisConfigTitleYCodec.encode(x) },
        j.`labels`.map { x => "labels" -> Json.toJson(x) },
        j.`labelFlush`.map { x => "labelFlush" -> AxisConfigLabelFlushCodec.encode(x) },
        j.`zindex`.map { x => "zindex" -> AxisConfigZindexCodec.encode(x) },
        j.`formatType`.map { x => "formatType" -> Json.toJson(x) },
        j.`labelLimit`.map { x => "labelLimit" -> AxisConfigLabelLimitCodec.encode(x) },
        j.`gridDashOffset`.map { x => "gridDashOffset" -> AxisConfigGridDashOffsetCodec.encode(x) },
        j.`titleAnchor`.map { x => "titleAnchor" -> AxisConfigTitleAnchorCodec.encode(x) },
        j.`titleColor`.map { x => "titleColor" -> AxisConfigTitleColorCodec.encode(x) },
        j.`labelOverlap`.map { x => "labelOverlap" -> AxisConfigLabelOverlapCodec.encode(x) },
        j.`translate`.map { x => "translate" -> AxisConfigTranslateCodec.encode(x) },
        j.`labelFlushOffset`.map { x => "labelFlushOffset" -> AxisConfigLabelFlushOffsetCodec.encode(x) },
        j.`domainWidth`.map { x => "domainWidth" -> AxisConfigDomainWidthCodec.encode(x) },
        j.`tickRound`.map { x => "tickRound" -> Json.toJson(x) },
        j.`labelOffset`.map { x => "labelOffset" -> AxisConfigLabelOffsetCodec.encode(x) },
        j.`ticks`.map { x => "ticks" -> Json.toJson(x) },
        j.`orient`.map { x => "orient" -> AxisConfigOrientCodec.encode(x) },
        j.`domainDash`.map { x => "domainDash" -> AxisConfigDomainDashCodec.encode(x) },
        j.`labelAlign`.map { x => "labelAlign" -> AxisConfigLabelAlignCodec.encode(x) },
        j.`disable`.map { x => "disable" -> Json.toJson(x) },
        j.`values`.map { x => "values" -> AxisConfigValuesCodec.encode(x) },
        j.`position`.map { x => "position" -> AxisConfigPositionCodec.encode(x) },
        j.`titleAngle`.map { x => "titleAngle" -> AxisConfigTitleAngleCodec.encode(x) },
        j.`labelPadding`.map { x => "labelPadding" -> AxisConfigLabelPaddingCodec.encode(x) },
        j.`aria`.map { x => "aria" -> AxisConfigAriaCodec.encode(x) },
        j.`labelExpr`.map { x => "labelExpr" -> Json.toJson(x) },
        j.`tickWidth`.map { x => "tickWidth" -> AxisConfigTickWidthCodec.encode(x) },
        j.`tickOffset`.map { x => "tickOffset" -> AxisConfigTickOffsetCodec.encode(x) },
        j.`maxExtent`.map { x => "maxExtent" -> AxisConfigMaxExtentCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`tickDash`.map { x => "tickDash" -> AxisConfigTickDashCodec.encode(x) },
        j.`labelBound`.map { x => "labelBound" -> AxisConfigLabelBoundCodec.encode(x) },
        j.`gridColor`.map { x => "gridColor" -> AxisConfigGridColorCodec.encode(x) },
        j.`titleLimit`.map { x => "titleLimit" -> AxisConfigTitleLimitCodec.encode(x) },
        j.`labelFont`.map { x => "labelFont" -> AxisConfigLabelFontCodec.encode(x) },
        j.`labelFontStyle`.map { x => "labelFontStyle" -> AxisConfigLabelFontStyleCodec.encode(x) },
        j.`titleOpacity`.map { x => "titleOpacity" -> AxisConfigTitleOpacityCodec.encode(x) },
        j.`titleAlign`.map { x => "titleAlign" -> AxisConfigTitleAlignCodec.encode(x) },
        j.`labelSeparation`.map { x => "labelSeparation" -> AxisConfigLabelSeparationCodec.encode(x) },
        j.`titleBaseline`.map { x => "titleBaseline" -> AxisConfigTitleBaselineCodec.encode(x) },
        j.`tickColor`.map { x => "tickColor" -> AxisConfigTickColorCodec.encode(x) },
        j.`titleFontSize`.map { x => "titleFontSize" -> AxisConfigTitleFontSizeCodec.encode(x) },
        j.`titleFontWeight`.map { x => "titleFontWeight" -> AxisConfigTitleFontWeightCodec.encode(x) },
        j.`tickSize`.map { x => "tickSize" -> AxisConfigTickSizeCodec.encode(x) },
        j.`tickOpacity`.map { x => "tickOpacity" -> AxisConfigTickOpacityCodec.encode(x) },
        j.`labelBaseline`.map { x => "labelBaseline" -> AxisConfigLabelBaselineCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// MarkDefAspect (UnionType)
object MarkDefAspectCodec {
  def decode(j: JsValue): MarkDefAspect =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefAspect] =
    j.asOpt[Boolean].map { MarkDefAspectAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefAspect): JsValue =
    j match {
      case MarkDefAspectAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisLabelColor (UnionType)
object AxisLabelColorCodec {
  def decode(j: JsValue): AxisLabelColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisLabelColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => AxisLabelColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisColorCodec.decodeOpt(j) } } } 
  def encode(j: AxisLabelColor): JsValue =
    j match {
      case AxisLabelColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisColor /* TypeRef */ => ConditionalAxisColorCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelConcatSpecPadding (UnionType)
object TopLevelConcatSpecPaddingCodec {
  def decode(j: JsValue): TopLevelConcatSpecPadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelConcatSpecPadding] =
    PaddingCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TopLevelConcatSpecPadding): JsValue =
    j match {
      case x:Padding /* TypeRef */ => PaddingCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigOpacity (UnionType)
object MarkConfigOpacityCodec {
  def decode(j: JsValue): MarkConfigOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigOpacity] =
    j.asOpt[JsNumber].map { MarkConfigOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigOpacity): JsValue =
    j match {
      case MarkConfigOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SecondaryFieldDefTimeUnit (UnionType)
object SecondaryFieldDefTimeUnitCodec {
  def decode(j: JsValue): SecondaryFieldDefTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SecondaryFieldDefTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SecondaryFieldDefTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateStringFieldDefFormat (UnionType)
object ConditionalPredicateStringFieldDefFormatCodec {
  def decode(j: JsValue): ConditionalPredicateStringFieldDefFormat =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateStringFieldDefFormat] =
    j.asOpt[String].map { ConditionalPredicateStringFieldDefFormatAsString(_) }.orElse {
    DictOfAnyCodec.decodeOpt(j).map { ConditionalPredicateStringFieldDefFormatAsDictOfAny(_) } } 
  def encode(j: ConditionalPredicateStringFieldDefFormat): JsValue =
    j match {
      case ConditionalPredicateStringFieldDefFormatAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case ConditionalPredicateStringFieldDefFormatAsDictOfAny(x) /* Base, MapType */ => DictOfAnyCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigTension (UnionType)
object TickConfigTensionCodec {
  def decode(j: JsValue): TickConfigTension =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigTension] =
    j.asOpt[JsNumber].map { TickConfigTensionAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigTension): JsValue =
    j match {
      case TickConfigTensionAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisStringAsObject2 (StructType)
object ConditionalAxisStringAsObject2Codec {
  def decode(j: JsValue): ConditionalAxisStringAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalAxisStringAsObject2] =
    {
      val `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => ConditionalAxisStringAsObject2ConditionCodec.decodeOpt(x) }
      if(`condition`.isEmpty) { return None }
      val `expr` = (j \ "expr").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`expr`.isEmpty) { return None }
      return Some(ConditionalAxisStringAsObject2(
        `condition` = `condition`.get,
        `expr` = `expr`.get,
      ))
    }

  def encode(j: ConditionalAxisStringAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("condition" -> ConditionalAxisStringAsObject2ConditionCodec.encode(j.`condition`)),
        Some("expr" -> Json.toJson(j.`expr`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AxisConfigLabelLimit (UnionType)
object AxisConfigLabelLimitCodec {
  def decode(j: JsValue): AxisConfigLabelLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigLabelLimit] =
    j.asOpt[JsNumber].map { AxisConfigLabelLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigLabelLimit): JsValue =
    j match {
      case AxisConfigLabelLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetSpecSpec (UnionType)
object FacetSpecSpecCodec {
  def decode(j: JsValue): FacetSpecSpec =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetSpecSpec] =
    LayerSpecCodec.decodeOpt(j).orElse {
    FacetedUnitSpecCodec.decodeOpt(j) } 
  def encode(j: FacetSpecSpec): JsValue =
    j match {
      case x:LayerSpec /* TypeRef */ => LayerSpecCodec.encode(x)
      case x:FacetedUnitSpec /* TypeRef */ => FacetedUnitSpecCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigPadAngle (UnionType)
object MarkConfigPadAngleCodec {
  def decode(j: JsValue): MarkConfigPadAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigPadAngle] =
    j.asOpt[JsNumber].map { MarkConfigPadAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigPadAngle): JsValue =
    j match {
      case MarkConfigPadAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetedEncodingDetail (UnionType)
object FacetedEncodingDetailCodec {
  def decode(j: JsValue): FacetedEncodingDetail =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetedEncodingDetail] =
    FieldDefWithoutScaleCodec.decodeOpt(j).orElse {
    ArrayOfFieldDefWithoutScaleCodec.decodeOpt(j).map { FacetedEncodingDetailAsArrayOfFieldDefWithoutScale(_) } } 
  def encode(j: FacetedEncodingDetail): JsValue =
    j match {
      case x:FieldDefWithoutScale /* TypeRef */ => FieldDefWithoutScaleCodec.encode(x)
      case FacetedEncodingDetailAsArrayOfFieldDefWithoutScale(x) /* Base, ArrayType */ => ArrayOfFieldDefWithoutScaleCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HConcatSpecGenericSpecBounds (EnumType)
object HConcatSpecGenericSpecBoundsCodec {
  def decode(j: JsValue): HConcatSpecGenericSpecBounds =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HConcatSpecGenericSpecBounds] =
    j match {
      case JsString("full") => Some(HConcatSpecGenericSpecBoundsFull)
      case JsString("flush") => Some(HConcatSpecGenericSpecBoundsFlush)
      case _ => None
    }
  def encode(j: HConcatSpecGenericSpecBounds): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// StringFieldDefWithConditionFormat (UnionType)
object StringFieldDefWithConditionFormatCodec {
  def decode(j: JsValue): StringFieldDefWithConditionFormat =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[StringFieldDefWithConditionFormat] =
    j.asOpt[String].map { StringFieldDefWithConditionFormatAsString(_) }.orElse {
    DictOfAnyCodec.decodeOpt(j).map { StringFieldDefWithConditionFormatAsDictOfAny(_) } } 
  def encode(j: StringFieldDefWithConditionFormat): JsValue =
    j match {
      case StringFieldDefWithConditionFormatAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case StringFieldDefWithConditionFormatAsDictOfAny(x) /* Base, MapType */ => DictOfAnyCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionStringFieldDefTextBandPosition (ConstrainedType)
object FieldOrDatumDefWithConditionStringFieldDefTextBandPositionCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionStringFieldDefTextBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionStringFieldDefTextBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { FieldOrDatumDefWithConditionStringFieldDefTextBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: FieldOrDatumDefWithConditionStringFieldDefTextBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterValueDefGradientStringNullExprRef (StructType)
object ConditionalParameterValueDefGradientStringNullExprRefCodec {
  def decode(j: JsValue): ConditionalParameterValueDefGradientStringNullExprRef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalParameterValueDefGradientStringNullExprRef] =
    {
      val `empty` = (j \ "empty").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `param` = (j \ "param").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`param`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => ConditionalParameterValueDefGradientStringNullExprRefValueCodec.decodeOpt(x) }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalParameterValueDefGradientStringNullExprRef(
        `empty` = `empty`,
        `param` = `param`.get,
        `value` = `value`.get,
      ))
    }

  def encode(j: ConditionalParameterValueDefGradientStringNullExprRef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`empty`.map { x => "empty" -> Json.toJson(x) },
        Some("param" -> Json.toJson(j.`param`)),
        Some("value" -> ConditionalParameterValueDefGradientStringNullExprRefValueCodec.encode(j.`value`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AxisConfigTranslate (UnionType)
object AxisConfigTranslateCodec {
  def decode(j: JsValue): AxisConfigTranslate =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTranslate] =
    j.asOpt[JsNumber].map { AxisConfigTranslateAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigTranslate): JsValue =
    j match {
      case AxisConfigTranslateAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigBandWithNestedOffsetPaddingOuter (ConstrainedType)
// see ScaleConfigBandWithNestedOffsetPaddingOuter (UnionType)

////////////////////////////////////////////////////////////////////////
// SortField (StructType)
object SortFieldCodec {
  def decode(j: JsValue): SortField =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SortField] =
    {
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`field`.isEmpty) { return None }
      val `order` = (j \ "order").asOpt[JsValue].flatMap { x => SortOrderCodec.decodeOpt(x).map { Some(_) }.flatten }
      return Some(SortField(
        `field` = `field`.get,
        `order` = `order`,
      ))
    }

  def encode(j: SortField): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("field" -> Json.toJson(j.`field`)),
        j.`order`.map { x => "order" -> SortOrderCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeDashBandPosition (ConstrainedType)
object SharedEncodingStrokeDashBandPositionCodec {
  def decode(j: JsValue): SharedEncodingStrokeDashBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeDashBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingStrokeDashBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingStrokeDashBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ArrayOfTopLevelVConcatSpecParamsElement (ArrayType)
object ArrayOfTopLevelVConcatSpecParamsElementCodec {
  def decode(j: JsValue): Seq[TopLevelVConcatSpecParamsElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[TopLevelVConcatSpecParamsElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      TopLevelVConcatSpecParamsElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[TopLevelVConcatSpecParamsElement]): JsArray =
      JsArray(j.map { x => TopLevelVConcatSpecParamsElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefColorNullExprRefAsObject2 (StructType)
object ConditionalPredicateValueDefColorNullExprRefAsObject2Codec {
  def decode(j: JsValue): ConditionalPredicateValueDefColorNullExprRefAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefColorNullExprRefAsObject2] =
    {
      val `expr` = (j \ "expr").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`expr`.isEmpty) { return None }
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      return Some(ConditionalPredicateValueDefColorNullExprRefAsObject2(
        `expr` = `expr`.get,
        `test` = `test`.get,
      ))
    }

  def encode(j: ConditionalPredicateValueDefColorNullExprRefAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("expr" -> Json.toJson(j.`expr`)),
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AreaConfigTheta2 (UnionType)
object AreaConfigTheta2Codec {
  def decode(j: JsValue): AreaConfigTheta2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigTheta2] =
    j.asOpt[JsNumber].map { AreaConfigTheta2AsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigTheta2): JsValue =
    j match {
      case AreaConfigTheta2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigBlend (UnionType)
object LineConfigBlendCodec {
  def decode(j: JsValue): LineConfigBlend =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigBlend] =
    BlendCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigBlend): JsValue =
    j match {
      case x:Blend /* TypeRef */ => BlendCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Cyclical (EnumType)
object CyclicalCodec {
  def decode(j: JsValue): Cyclical =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Cyclical] =
    j match {
      case JsString("rainbow") => Some(CyclicalRainbow)
      case JsString("sinebow") => Some(CyclicalSinebow)
      case _ => None
    }
  def encode(j: Cyclical): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// BarConfigLineHeight (UnionType)
object BarConfigLineHeightCodec {
  def decode(j: JsValue): BarConfigLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigLineHeight] =
    j.asOpt[JsNumber].map { BarConfigLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigLineHeight): JsValue =
    j match {
      case BarConfigLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfConditionalPredicateValueDefAlignNullExprRef (ArrayType)
object ArrayOfConditionalPredicateValueDefAlignNullExprRefCodec {
  def decode(j: JsValue): Seq[ConditionalPredicateValueDefAlignNullExprRef] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[ConditionalPredicateValueDefAlignNullExprRef]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      ConditionalPredicateValueDefAlignNullExprRefCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[ConditionalPredicateValueDefAlignNullExprRef]): JsArray =
      JsArray(j.map { x => ConditionalPredicateValueDefAlignNullExprRefCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// BarConfigRadius2 (ConstrainedType)
// see BarConfigRadius2 (UnionType)

////////////////////////////////////////////////////////////////////////
// BoxPlotConfigRule (UnionType)
object BoxPlotConfigRuleCodec {
  def decode(j: JsValue): BoxPlotConfigRule =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BoxPlotConfigRule] =
    j.asOpt[Boolean].map { BoxPlotConfigRuleAsBool(_) }.orElse {
    MarkConfigCodec.decodeOpt(j) } 
  def encode(j: BoxPlotConfigRule): JsValue =
    j match {
      case BoxPlotConfigRuleAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:MarkConfig /* TypeRef */ => MarkConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigLabelLimit (UnionType)
object LegendConfigLabelLimitCodec {
  def decode(j: JsValue): LegendConfigLabelLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigLabelLimit] =
    j.asOpt[JsNumber].map { LegendConfigLabelLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigLabelLimit): JsValue =
    j match {
      case LegendConfigLabelLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullValue (UnionType)
object ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullValueCodec {
  def decode(j: JsValue): ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullValue] =
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[String].map { ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullValueAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullValueAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullValue): JsValue =
    j match {
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullValueAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullValueAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelConcatSpecCenter (UnionType)
object TopLevelConcatSpecCenterCodec {
  def decode(j: JsValue): TopLevelConcatSpecCenter =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelConcatSpecCenter] =
    j.asOpt[Boolean].map { TopLevelConcatSpecCenterAsBool(_) }.orElse {
    RowColBooleanCodec.decodeOpt(j) } 
  def encode(j: TopLevelConcatSpecCenter): JsValue =
    j match {
      case TopLevelConcatSpecCenterAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:RowColBoolean /* TypeRef */ => RowColBooleanCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelLayerSpecHeight (UnionType)
object TopLevelLayerSpecHeightCodec {
  def decode(j: JsValue): TopLevelLayerSpecHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelLayerSpecHeight] =
    j.asOpt[JsNumber].map { TopLevelLayerSpecHeightAsNumber(_) }.orElse {
    ContainerCodec.decodeOpt(j).orElse {
    StepCodec.decodeOpt(j) } } 
  def encode(j: TopLevelLayerSpecHeight): JsValue =
    j match {
      case TopLevelLayerSpecHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Container /* TypeRef */ => ContainerCodec.encode(x)
      case x:Step /* TypeRef */ => StepCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisDescription (UnionType)
object AxisDescriptionCodec {
  def decode(j: JsValue): AxisDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisDescription] =
    j.asOpt[String].map { AxisDescriptionAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisDescription): JsValue =
    j match {
      case AxisDescriptionAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigStrokeCap (UnionType)
object TickConfigStrokeCapCodec {
  def decode(j: JsValue): TickConfigStrokeCap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigStrokeCap] =
    StrokeCapCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigStrokeCap): JsValue =
    j match {
      case x:StrokeCap /* TypeRef */ => StrokeCapCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConcatSpecGenericSpecTitle (UnionType)
object ConcatSpecGenericSpecTitleCodec {
  def decode(j: JsValue): ConcatSpecGenericSpecTitle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConcatSpecGenericSpecTitle] =
    TextCodec.decodeOpt(j).orElse {
    TitleParamsCodec.decodeOpt(j) } 
  def encode(j: ConcatSpecGenericSpecTitle): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:TitleParams /* TypeRef */ => TitleParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendStreamBindingLegend (UnionType)
object LegendStreamBindingLegendCodec {
  def decode(j: JsValue): LegendStreamBindingLegend =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendStreamBindingLegend] =
    j.asOpt[String].map { LegendStreamBindingLegendAsString(_) }.orElse {
    StreamCodec.decodeOpt(j) } 
  def encode(j: LegendStreamBindingLegend): JsValue =
    j match {
      case LegendStreamBindingLegendAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:Stream /* TypeRef */ => StreamCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisLabelSeparation (UnionType)
object AxisLabelSeparationCodec {
  def decode(j: JsValue): AxisLabelSeparation =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisLabelSeparation] =
    j.asOpt[JsNumber].map { AxisLabelSeparationAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisLabelSeparation): JsValue =
    j match {
      case AxisLabelSeparationAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject2Background (UnionType)
object TopLevelRepeatSpecAsObject2BackgroundCodec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject2Background =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject2Background] =
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TopLevelRepeatSpecAsObject2Background): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingXDatum (UnionType)
object SharedEncodingXDatumCodec {
  def decode(j: JsValue): SharedEncodingXDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingXDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingXDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// IntervalSelectionConfigType (ConstantType)
object IntervalSelectionConfigTypeCodec {
  def decode(j: JsValue): IntervalSelectionConfigType =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[IntervalSelectionConfigType] =
    j match {
      case JsString("interval") => Some(IntervalSelectionConfigType())
      case _ => None
    }
  def encode(j: IntervalSelectionConfigType): JsValue =
    JsString("interval")
}


////////////////////////////////////////////////////////////////////////
// BarConfigStartAngle (UnionType)
object BarConfigStartAngleCodec {
  def decode(j: JsValue): BarConfigStartAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigStartAngle] =
    j.asOpt[JsNumber].map { BarConfigStartAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigStartAngle): JsValue =
    j match {
      case BarConfigStartAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// StrokeCap (EnumType)
object StrokeCapCodec {
  def decode(j: JsValue): StrokeCap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[StrokeCap] =
    j match {
      case JsString("butt") => Some(StrokeCapButt)
      case JsString("round") => Some(StrokeCapRound)
      case JsString("square") => Some(StrokeCapSquare)
      case _ => None
    }
  def encode(j: StrokeCap): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// BarConfigOpacity (ConstrainedType)
// see BarConfigOpacity (UnionType)

////////////////////////////////////////////////////////////////////////
// TitleConfigOffset (UnionType)
object TitleConfigOffsetCodec {
  def decode(j: JsValue): TitleConfigOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigOffset] =
    j.asOpt[JsNumber].map { TitleConfigOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleConfigOffset): JsValue =
    j match {
      case TitleConfigOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigWidth (UnionType)
object MarkConfigWidthCodec {
  def decode(j: JsValue): MarkConfigWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigWidth] =
    j.asOpt[JsNumber].map { MarkConfigWidthAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigWidth): JsValue =
    j match {
      case MarkConfigWidthAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BinParams (StructType)
object BinParamsCodec {
  def decode(j: JsValue): BinParams =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BinParams] =
    Some(BinParams(
      `anchor` = (j \ "anchor").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `extent` = (j \ "extent").asOpt[JsValue].flatMap { x => BinExtentCodec.decodeOpt(x) },
      `binned` = (j \ "binned").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `maxbins` = (j \ "maxbins").asOpt[JsValue].flatMap { x => BinParamsMaxbinsCodec.decodeOpt(x) },
      `base` = (j \ "base").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `steps` = (j \ "steps").asOpt[JsValue].flatMap { x => BinParamsStepsCodec.decodeOpt(x) },
      `minstep` = (j \ "minstep").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `step` = (j \ "step").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `divide` = (j \ "divide").asOpt[JsValue].flatMap { x => BinParamsDivideCodec.decodeOpt(x) },
      `nice` = (j \ "nice").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
    ))

  def encode(j: BinParams): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`anchor`.map { x => "anchor" -> Json.toJson(x) },
        j.`extent`.map { x => "extent" -> BinExtentCodec.encode(x) },
        j.`binned`.map { x => "binned" -> Json.toJson(x) },
        j.`maxbins`.map { x => "maxbins" -> BinParamsMaxbinsCodec.encode(x) },
        j.`base`.map { x => "base" -> Json.toJson(x) },
        j.`steps`.map { x => "steps" -> BinParamsStepsCodec.encode(x) },
        j.`minstep`.map { x => "minstep" -> Json.toJson(x) },
        j.`step`.map { x => "step" -> Json.toJson(x) },
        j.`divide`.map { x => "divide" -> BinParamsDivideCodec.encode(x) },
        j.`nice`.map { x => "nice" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TopLevelSelectionParameter (StructType)
object TopLevelSelectionParameterCodec {
  def decode(j: JsValue): TopLevelSelectionParameter =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TopLevelSelectionParameter] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`name`.isEmpty) { return None }
      val `bind` = (j \ "bind").asOpt[JsValue].flatMap { x => TopLevelSelectionParameterBindCodec.decodeOpt(x) }
      val `select` = (j \ "select").asOpt[JsValue].flatMap { x => TopLevelSelectionParameterSelectCodec.decodeOpt(x) }
      if(`select`.isEmpty) { return None }
      val `views` = (j \ "views").asOpt[JsValue].flatMap { x => ArrayOfTopLevelSelectionParameterViewsElementCodec.decodeOpt(x) }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => TopLevelSelectionParameterValueCodec.decodeOpt(x) }
      return Some(TopLevelSelectionParameter(
        `name` = `name`.get,
        `bind` = `bind`,
        `select` = `select`.get,
        `views` = `views`,
        `value` = `value`,
      ))
    }

  def encode(j: TopLevelSelectionParameter): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("name" -> Json.toJson(j.`name`)),
        j.`bind`.map { x => "bind" -> TopLevelSelectionParameterBindCodec.encode(x) },
        Some("select" -> TopLevelSelectionParameterSelectCodec.encode(j.`select`)),
        j.`views`.map { x => "views" -> ArrayOfTopLevelSelectionParameterViewsElementCodec.encode(x) },
        j.`value`.map { x => "value" -> TopLevelSelectionParameterValueCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LegendConfigSymbolBaseFillColor (UnionType)
object LegendConfigSymbolBaseFillColorCodec {
  def decode(j: JsValue): LegendConfigSymbolBaseFillColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigSymbolBaseFillColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => LegendConfigSymbolBaseFillColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: LegendConfigSymbolBaseFillColor): JsValue =
    j match {
      case LegendConfigSymbolBaseFillColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RepeatMapping (StructType)
object RepeatMappingCodec {
  def decode(j: JsValue): RepeatMapping =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RepeatMapping] =
    Some(RepeatMapping(
      `column` = (j \ "column").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) },
      `row` = (j \ "row").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) },
    ))

  def encode(j: RepeatMapping): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`column`.map { x => "column" -> ArrayOfStringCodec.encode(x) },
        j.`row`.map { x => "row" -> ArrayOfStringCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// OverlayMarkDefStrokeDash (UnionType)
object OverlayMarkDefStrokeDashCodec {
  def decode(j: JsValue): OverlayMarkDefStrokeDash =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefStrokeDash] =
    ArrayOfNumberCodec.decodeOpt(j).map { OverlayMarkDefStrokeDashAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefStrokeDash): JsValue =
    j match {
      case OverlayMarkDefStrokeDashAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Parity (ConstantType)
object ParityCodec {
  def decode(j: JsValue): Parity =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Parity] =
    j match {
      case JsString("parity") => Some(Parity())
      case _ => None
    }
  def encode(j: Parity): JsValue =
    JsString("parity")
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingFillOpacityCondition (UnionType)
object SharedEncodingFillOpacityConditionCodec {
  def decode(j: JsValue): SharedEncodingFillOpacityCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingFillOpacityCondition] =
    ConditionalValueDefNumberExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefNumberExprRefCodec.decodeOpt(j).map { SharedEncodingFillOpacityConditionAsArrayOfConditionalValueDefNumberExprRef(_) }.orElse {
    ConditionalMarkPropFieldOrDatumDefCodec.decodeOpt(j) } } 
  def encode(j: SharedEncodingFillOpacityCondition): JsValue =
    j match {
      case x:ConditionalValueDefNumberExprRef /* TypeRef */ => ConditionalValueDefNumberExprRefCodec.encode(x)
      case SharedEncodingFillOpacityConditionAsArrayOfConditionalValueDefNumberExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefNumberExprRefCodec.encode(x)
      case x:ConditionalMarkPropFieldOrDatumDef /* TypeRef */ => ConditionalMarkPropFieldOrDatumDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigTheta2 (UnionType)
object RectConfigTheta2Codec {
  def decode(j: JsValue): RectConfigTheta2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigTheta2] =
    j.asOpt[JsNumber].map { RectConfigTheta2AsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigTheta2): JsValue =
    j match {
      case RectConfigTheta2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefPadAngle (UnionType)
object OverlayMarkDefPadAngleCodec {
  def decode(j: JsValue): OverlayMarkDefPadAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefPadAngle] =
    j.asOpt[JsNumber].map { OverlayMarkDefPadAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefPadAngle): JsValue =
    j match {
      case OverlayMarkDefPadAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderConfigTitleFontSize (ConstrainedType)
// see HeaderConfigTitleFontSize (UnionType)

////////////////////////////////////////////////////////////////////////
// SharedEncodingRadius2BandPosition (ConstrainedType)
object SharedEncodingRadius2BandPositionCodec {
  def decode(j: JsValue): SharedEncodingRadius2BandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingRadius2BandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingRadius2BandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingRadius2BandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefCornerRadiusBottomLeft (UnionType)
object OverlayMarkDefCornerRadiusBottomLeftCodec {
  def decode(j: JsValue): OverlayMarkDefCornerRadiusBottomLeft =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefCornerRadiusBottomLeft] =
    j.asOpt[JsNumber].map { OverlayMarkDefCornerRadiusBottomLeftAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefCornerRadiusBottomLeft): JsValue =
    j match {
      case OverlayMarkDefCornerRadiusBottomLeftAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefInterpolate (UnionType)
object MarkDefInterpolateCodec {
  def decode(j: JsValue): MarkDefInterpolate =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefInterpolate] =
    InterpolateCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefInterpolate): JsValue =
    j match {
      case x:Interpolate /* TypeRef */ => InterpolateCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigFontStyle (UnionType)
object AreaConfigFontStyleCodec {
  def decode(j: JsValue): AreaConfigFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigFontStyle] =
    j.asOpt[String].map { AreaConfigFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigFontStyle): JsValue =
    j match {
      case AreaConfigFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefAriaRole (UnionType)
object OverlayMarkDefAriaRoleCodec {
  def decode(j: JsValue): OverlayMarkDefAriaRole =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefAriaRole] =
    j.asOpt[String].map { OverlayMarkDefAriaRoleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefAriaRole): JsValue =
    j match {
      case OverlayMarkDefAriaRoleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigBandSize (ConstrainedType)
object TickConfigBandSizeCodec {
  def decode(j: JsValue): TickConfigBandSize =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TickConfigBandSize] =
    try {
      j.asOpt[JsNumber]
        .map { TickConfigBandSize(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: TickConfigBandSize): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// LegendConfigCornerRadius (UnionType)
object LegendConfigCornerRadiusCodec {
  def decode(j: JsValue): LegendConfigCornerRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigCornerRadius] =
    j.asOpt[JsNumber].map { LegendConfigCornerRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigCornerRadius): JsValue =
    j match {
      case LegendConfigCornerRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefFontWeightNullExprRefAsObject1 (StructType)
object ConditionalPredicateValueDefFontWeightNullExprRefAsObject1Codec {
  def decode(j: JsValue): ConditionalPredicateValueDefFontWeightNullExprRefAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefFontWeightNullExprRefAsObject1] =
    {
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => FontWeightCodec.decodeOpt(x).map { Some(_) }.flatten }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalPredicateValueDefFontWeightNullExprRefAsObject1(
        `test` = `test`.get,
        `value` = `value`,
      ))
    }

  def encode(j: ConditionalPredicateValueDefFontWeightNullExprRefAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
        j.`value`.map { x => "value" -> FontWeightCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// RectConfigLineHeight (UnionType)
object RectConfigLineHeightCodec {
  def decode(j: JsValue): RectConfigLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigLineHeight] =
    j.asOpt[JsNumber].map { RectConfigLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigLineHeight): JsValue =
    j match {
      case RectConfigLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigCornerRadius (UnionType)
object BarConfigCornerRadiusCodec {
  def decode(j: JsValue): BarConfigCornerRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigCornerRadius] =
    j.asOpt[JsNumber].map { BarConfigCornerRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigCornerRadius): JsValue =
    j match {
      case BarConfigCornerRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigEllipsis (UnionType)
object BarConfigEllipsisCodec {
  def decode(j: JsValue): BarConfigEllipsis =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigEllipsis] =
    j.asOpt[String].map { BarConfigEllipsisAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigEllipsis): JsValue =
    j match {
      case BarConfigEllipsisAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefStartAngle (UnionType)
object OverlayMarkDefStartAngleCodec {
  def decode(j: JsValue): OverlayMarkDefStartAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefStartAngle] =
    j.asOpt[JsNumber].map { OverlayMarkDefStartAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefStartAngle): JsValue =
    j match {
      case OverlayMarkDefStartAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigEndAngle (UnionType)
object MarkConfigEndAngleCodec {
  def decode(j: JsValue): MarkConfigEndAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigEndAngle] =
    j.asOpt[JsNumber].map { MarkConfigEndAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigEndAngle): JsValue =
    j match {
      case MarkConfigEndAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewConfigDiscreteHeight (UnionType)
object ViewConfigDiscreteHeightCodec {
  def decode(j: JsValue): ViewConfigDiscreteHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewConfigDiscreteHeight] =
    j.asOpt[JsNumber].map { ViewConfigDiscreteHeightAsNumber(_) }.orElse {
    ViewConfigDiscreteHeightAsObject2Codec.decodeOpt(j) } 
  def encode(j: ViewConfigDiscreteHeight): JsValue =
    j match {
      case ViewConfigDiscreteHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ViewConfigDiscreteHeightAsObject2 /* TypeRef */ => ViewConfigDiscreteHeightAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigRadius2 (UnionType)
object LineConfigRadius2Codec {
  def decode(j: JsValue): LineConfigRadius2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigRadius2] =
    j.asOpt[JsNumber].map { LineConfigRadius2AsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigRadius2): JsValue =
    j match {
      case LineConfigRadius2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefRadius2Offset (UnionType)
object MarkDefRadius2OffsetCodec {
  def decode(j: JsValue): MarkDefRadius2Offset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefRadius2Offset] =
    j.asOpt[JsNumber].map { MarkDefRadius2OffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefRadius2Offset): JsValue =
    j match {
      case MarkDefRadius2OffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefStroke (UnionType)
object OverlayMarkDefStrokeCodec {
  def decode(j: JsValue): OverlayMarkDefStroke =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefStroke] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => OverlayMarkDefStrokeAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: OverlayMarkDefStroke): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case OverlayMarkDefStrokeAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsFontStyle (UnionType)
object TitleParamsFontStyleCodec {
  def decode(j: JsValue): TitleParamsFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsFontStyle] =
    j.asOpt[String].map { TitleParamsFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleParamsFontStyle): JsValue =
    j match {
      case TitleParamsFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingYDatum (UnionType)
object SharedEncodingYDatumCodec {
  def decode(j: JsValue): SharedEncodingYDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingYDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingYDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisLabelBound (UnionType)
object AxisLabelBoundCodec {
  def decode(j: JsValue): AxisLabelBound =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisLabelBound] =
    j.asOpt[JsNumber].map { AxisLabelBoundAsNumber(_) }.orElse {
    j.asOpt[Boolean].map { AxisLabelBoundAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: AxisLabelBound): JsValue =
    j match {
      case AxisLabelBoundAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case AxisLabelBoundAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigLabelFontSizeAsNumber (ConstrainedType)
object AxisConfigLabelFontSizeAsNumberCodec {
  def decode(j: JsValue): AxisConfigLabelFontSizeAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AxisConfigLabelFontSizeAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AxisConfigLabelFontSizeAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AxisConfigLabelFontSizeAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// TitleParams (StructType)
object TitleParamsCodec {
  def decode(j: JsValue): TitleParams =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TitleParams] =
    {
      val `anchor` = (j \ "anchor").asOpt[JsValue].flatMap { x => TitleAnchorCodec.decodeOpt(x) }
      val `subtitle` = (j \ "subtitle").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x) }
      val `subtitleFontSize` = (j \ "subtitleFontSize").asOpt[JsValue].flatMap { x => TitleParamsSubtitleFontSizeCodec.decodeOpt(x) }
      val `dy` = (j \ "dy").asOpt[JsValue].flatMap { x => TitleParamsDyCodec.decodeOpt(x) }
      val `style` = (j \ "style").asOpt[JsValue].flatMap { x => TitleParamsStyleCodec.decodeOpt(x) }
      val `angle` = (j \ "angle").asOpt[JsValue].flatMap { x => TitleParamsAngleCodec.decodeOpt(x) }
      val `align` = (j \ "align").asOpt[JsValue].flatMap { x => AlignCodec.decodeOpt(x) }
      val `fontStyle` = (j \ "fontStyle").asOpt[JsValue].flatMap { x => TitleParamsFontStyleCodec.decodeOpt(x) }
      val `text` = (j \ "text").asOpt[JsValue].flatMap { x => TitleParamsTextCodec.decodeOpt(x) }
      if(`text`.isEmpty) { return None }
      val `frame` = (j \ "frame").asOpt[JsValue].flatMap { x => TitleParamsFrameCodec.decodeOpt(x) }
      val `font` = (j \ "font").asOpt[JsValue].flatMap { x => TitleParamsFontCodec.decodeOpt(x) }
      val `offset` = (j \ "offset").asOpt[JsValue].flatMap { x => TitleParamsOffsetCodec.decodeOpt(x) }
      val `subtitleColor` = (j \ "subtitleColor").asOpt[JsValue].flatMap { x => TitleParamsSubtitleColorCodec.decodeOpt(x) }
      val `aria` = (j \ "aria").asOpt[JsValue].flatMap { x => TitleParamsAriaCodec.decodeOpt(x) }
      val `dx` = (j \ "dx").asOpt[JsValue].flatMap { x => TitleParamsDxCodec.decodeOpt(x) }
      val `subtitleFont` = (j \ "subtitleFont").asOpt[JsValue].flatMap { x => TitleParamsSubtitleFontCodec.decodeOpt(x) }
      val `subtitleLineHeight` = (j \ "subtitleLineHeight").asOpt[JsValue].flatMap { x => TitleParamsSubtitleLineHeightCodec.decodeOpt(x) }
      val `baseline` = (j \ "baseline").asOpt[JsValue].flatMap { x => TextBaselineCodec.decodeOpt(x) }
      val `subtitleFontStyle` = (j \ "subtitleFontStyle").asOpt[JsValue].flatMap { x => TitleParamsSubtitleFontStyleCodec.decodeOpt(x) }
      val `subtitleFontWeight` = (j \ "subtitleFontWeight").asOpt[JsValue].flatMap { x => TitleParamsSubtitleFontWeightCodec.decodeOpt(x) }
      val `color` = (j \ "color").asOpt[JsValue].flatMap { x => TitleParamsColorCodec.decodeOpt(x) }
      val `subtitlePadding` = (j \ "subtitlePadding").asOpt[JsValue].flatMap { x => TitleParamsSubtitlePaddingCodec.decodeOpt(x) }
      val `zindex` = (j \ "zindex").asOpt[JsValue].flatMap { x => TitleParamsZindexCodec.decodeOpt(x) }
      val `lineHeight` = (j \ "lineHeight").asOpt[JsValue].flatMap { x => TitleParamsLineHeightCodec.decodeOpt(x) }
      val `orient` = (j \ "orient").asOpt[JsValue].flatMap { x => TitleParamsOrientCodec.decodeOpt(x) }
      val `fontSize` = (j \ "fontSize").asOpt[JsValue].flatMap { x => TitleParamsFontSizeCodec.decodeOpt(x) }
      val `limit` = (j \ "limit").asOpt[JsValue].flatMap { x => TitleParamsLimitCodec.decodeOpt(x) }
      val `fontWeight` = (j \ "fontWeight").asOpt[JsValue].flatMap { x => TitleParamsFontWeightCodec.decodeOpt(x) }
      return Some(TitleParams(
        `anchor` = `anchor`,
        `subtitle` = `subtitle`,
        `subtitleFontSize` = `subtitleFontSize`,
        `dy` = `dy`,
        `style` = `style`,
        `angle` = `angle`,
        `align` = `align`,
        `fontStyle` = `fontStyle`,
        `text` = `text`.get,
        `frame` = `frame`,
        `font` = `font`,
        `offset` = `offset`,
        `subtitleColor` = `subtitleColor`,
        `aria` = `aria`,
        `dx` = `dx`,
        `subtitleFont` = `subtitleFont`,
        `subtitleLineHeight` = `subtitleLineHeight`,
        `baseline` = `baseline`,
        `subtitleFontStyle` = `subtitleFontStyle`,
        `subtitleFontWeight` = `subtitleFontWeight`,
        `color` = `color`,
        `subtitlePadding` = `subtitlePadding`,
        `zindex` = `zindex`,
        `lineHeight` = `lineHeight`,
        `orient` = `orient`,
        `fontSize` = `fontSize`,
        `limit` = `limit`,
        `fontWeight` = `fontWeight`,
      ))
    }

  def encode(j: TitleParams): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`anchor`.map { x => "anchor" -> TitleAnchorCodec.encode(x) },
        j.`subtitle`.map { x => "subtitle" -> TextCodec.encode(x) },
        j.`subtitleFontSize`.map { x => "subtitleFontSize" -> TitleParamsSubtitleFontSizeCodec.encode(x) },
        j.`dy`.map { x => "dy" -> TitleParamsDyCodec.encode(x) },
        j.`style`.map { x => "style" -> TitleParamsStyleCodec.encode(x) },
        j.`angle`.map { x => "angle" -> TitleParamsAngleCodec.encode(x) },
        j.`align`.map { x => "align" -> AlignCodec.encode(x) },
        j.`fontStyle`.map { x => "fontStyle" -> TitleParamsFontStyleCodec.encode(x) },
        Some("text" -> TitleParamsTextCodec.encode(j.`text`)),
        j.`frame`.map { x => "frame" -> TitleParamsFrameCodec.encode(x) },
        j.`font`.map { x => "font" -> TitleParamsFontCodec.encode(x) },
        j.`offset`.map { x => "offset" -> TitleParamsOffsetCodec.encode(x) },
        j.`subtitleColor`.map { x => "subtitleColor" -> TitleParamsSubtitleColorCodec.encode(x) },
        j.`aria`.map { x => "aria" -> TitleParamsAriaCodec.encode(x) },
        j.`dx`.map { x => "dx" -> TitleParamsDxCodec.encode(x) },
        j.`subtitleFont`.map { x => "subtitleFont" -> TitleParamsSubtitleFontCodec.encode(x) },
        j.`subtitleLineHeight`.map { x => "subtitleLineHeight" -> TitleParamsSubtitleLineHeightCodec.encode(x) },
        j.`baseline`.map { x => "baseline" -> TextBaselineCodec.encode(x) },
        j.`subtitleFontStyle`.map { x => "subtitleFontStyle" -> TitleParamsSubtitleFontStyleCodec.encode(x) },
        j.`subtitleFontWeight`.map { x => "subtitleFontWeight" -> TitleParamsSubtitleFontWeightCodec.encode(x) },
        j.`color`.map { x => "color" -> TitleParamsColorCodec.encode(x) },
        j.`subtitlePadding`.map { x => "subtitlePadding" -> TitleParamsSubtitlePaddingCodec.encode(x) },
        j.`zindex`.map { x => "zindex" -> TitleParamsZindexCodec.encode(x) },
        j.`lineHeight`.map { x => "lineHeight" -> TitleParamsLineHeightCodec.encode(x) },
        j.`orient`.map { x => "orient" -> TitleParamsOrientCodec.encode(x) },
        j.`fontSize`.map { x => "fontSize" -> TitleParamsFontSizeCodec.encode(x) },
        j.`limit`.map { x => "limit" -> TitleParamsLimitCodec.encode(x) },
        j.`fontWeight`.map { x => "fontWeight" -> TitleParamsFontWeightCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingKeyTimeUnit (UnionType)
object SharedEncodingKeyTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingKeyTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingKeyTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingKeyTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SelectionParameterSelect (UnionType)
object SelectionParameterSelectCodec {
  def decode(j: JsValue): SelectionParameterSelect =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SelectionParameterSelect] =
    SelectionTypeCodec.decodeOpt(j).orElse {
    PointSelectionConfigCodec.decodeOpt(j).orElse {
    IntervalSelectionConfigCodec.decodeOpt(j) } } 
  def encode(j: SelectionParameterSelect): JsValue =
    j match {
      case x:SelectionType /* TypeRef */ => SelectionTypeCodec.encode(x)
      case x:PointSelectionConfig /* TypeRef */ => PointSelectionConfigCodec.encode(x)
      case x:IntervalSelectionConfig /* TypeRef */ => IntervalSelectionConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelLayerSpec (StructType)
object TopLevelLayerSpecCodec {
  def decode(j: JsValue): TopLevelLayerSpec =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TopLevelLayerSpec] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `projection` = (j \ "projection").asOpt[JsValue].flatMap { x => ProjectionCodec.decodeOpt(x) }
      val `background` = (j \ "background").asOpt[JsValue].flatMap { x => TopLevelLayerSpecBackgroundCodec.decodeOpt(x) }
      val `description` = (j \ "description").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `data` = (j \ "data").asOpt[JsValue].flatMap { x => DataCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `params` = (j \ "params").asOpt[JsValue].flatMap { x => ArrayOfTopLevelLayerSpecParamsElementCodec.decodeOpt(x) }
      val `height` = (j \ "height").asOpt[JsValue].flatMap { x => TopLevelLayerSpecHeightCodec.decodeOpt(x) }
      val `config` = (j \ "config").asOpt[JsValue].flatMap { x => ConfigCodec.decodeOpt(x) }
      val `encoding` = (j \ "encoding").asOpt[JsValue].flatMap { x => SharedEncodingCodec.decodeOpt(x) }
      val `datasets` = (j \ "datasets").asOpt[JsValue].flatMap { x => DictOfInlineDatasetCodec.decodeOpt(x) }
      val `layer` = (j \ "layer").asOpt[JsValue].flatMap { x => ArrayOfTopLevelLayerSpecLayerElementCodec.decodeOpt(x) }
      if(`layer`.isEmpty) { return None }
      val `usermeta` = (j \ "usermeta").asOpt[JsValue].flatMap { x => DictOfAnyCodec.decodeOpt(x) }
      val `resolve` = (j \ "resolve").asOpt[JsValue].flatMap { x => ResolveCodec.decodeOpt(x) }
      val `padding` = (j \ "padding").asOpt[JsValue].flatMap { x => TopLevelLayerSpecPaddingCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => TopLevelLayerSpecTitleCodec.decodeOpt(x) }
      val `view` = (j \ "view").asOpt[JsValue].flatMap { x => ViewBackgroundCodec.decodeOpt(x) }
      val `$schema` = (j \ "$schema").asOpt[JsValue].flatMap { x => UriCodec.decodeOpt(x) }
      val `autosize` = (j \ "autosize").asOpt[JsValue].flatMap { x => TopLevelLayerSpecAutosizeCodec.decodeOpt(x) }
      val `transform` = (j \ "transform").asOpt[JsValue].flatMap { x => ArrayOfTransformCodec.decodeOpt(x) }
      val `width` = (j \ "width").asOpt[JsValue].flatMap { x => TopLevelLayerSpecWidthCodec.decodeOpt(x) }
      return Some(TopLevelLayerSpec(
        `name` = `name`,
        `projection` = `projection`,
        `background` = `background`,
        `description` = `description`,
        `data` = `data`,
        `params` = `params`,
        `height` = `height`,
        `config` = `config`,
        `encoding` = `encoding`,
        `datasets` = `datasets`,
        `layer` = `layer`.get,
        `usermeta` = `usermeta`,
        `resolve` = `resolve`,
        `padding` = `padding`,
        `title` = `title`,
        `view` = `view`,
        `$schema` = `$schema`,
        `autosize` = `autosize`,
        `transform` = `transform`,
        `width` = `width`,
      ))
    }

  def encode(j: TopLevelLayerSpec): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`projection`.map { x => "projection" -> ProjectionCodec.encode(x) },
        j.`background`.map { x => "background" -> TopLevelLayerSpecBackgroundCodec.encode(x) },
        j.`description`.map { x => "description" -> Json.toJson(x) },
        j.`data`.map { x => "data" -> DataCodec.encode(x) },
        j.`params`.map { x => "params" -> ArrayOfTopLevelLayerSpecParamsElementCodec.encode(x) },
        j.`height`.map { x => "height" -> TopLevelLayerSpecHeightCodec.encode(x) },
        j.`config`.map { x => "config" -> ConfigCodec.encode(x) },
        j.`encoding`.map { x => "encoding" -> SharedEncodingCodec.encode(x) },
        j.`datasets`.map { x => "datasets" -> DictOfInlineDatasetCodec.encode(x) },
        Some("layer" -> ArrayOfTopLevelLayerSpecLayerElementCodec.encode(j.`layer`)),
        j.`usermeta`.map { x => "usermeta" -> DictOfAnyCodec.encode(x) },
        j.`resolve`.map { x => "resolve" -> ResolveCodec.encode(x) },
        j.`padding`.map { x => "padding" -> TopLevelLayerSpecPaddingCodec.encode(x) },
        j.`title`.map { x => "title" -> TopLevelLayerSpecTitleCodec.encode(x) },
        j.`view`.map { x => "view" -> ViewBackgroundCodec.encode(x) },
        j.`$schema`.map { x => "$schema" -> UriCodec.encode(x) },
        j.`autosize`.map { x => "autosize" -> TopLevelLayerSpecAutosizeCodec.encode(x) },
        j.`transform`.map { x => "transform" -> ArrayOfTransformCodec.encode(x) },
        j.`width`.map { x => "width" -> TopLevelLayerSpecWidthCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ScaleBins (UnionType)
object ScaleBinsCodec {
  def decode(j: JsValue): ScaleBins =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleBins] =
    ArrayOfNumberCodec.decodeOpt(j).map { ScaleBinsAsArrayOfNumber(_) }.orElse {
    ScaleBinParamsCodec.decodeOpt(j) } 
  def encode(j: ScaleBins): JsValue =
    j match {
      case ScaleBinsAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ScaleBinParams /* TypeRef */ => ScaleBinParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// StringFieldDefWithConditionBin (UnionType)
object StringFieldDefWithConditionBinCodec {
  def decode(j: JsValue): StringFieldDefWithConditionBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[StringFieldDefWithConditionBin] =
    j.asOpt[Boolean].map { StringFieldDefWithConditionBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    BinnedCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => StringFieldDefWithConditionBinAsNull } } } } 
  def encode(j: StringFieldDefWithConditionBin): JsValue =
    j match {
      case StringFieldDefWithConditionBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case x:Binned /* TypeRef */ => BinnedCodec.encode(x)
      case StringFieldDefWithConditionBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingTextValue (UnionType)
object SharedEncodingTextValueCodec {
  def decode(j: JsValue): SharedEncodingTextValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingTextValue] =
    TextCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingTextValue): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigGradientThickness (UnionType)
object LegendConfigGradientThicknessCodec {
  def decode(j: JsValue): LegendConfigGradientThickness =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigGradientThickness] =
    LegendConfigGradientThicknessAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigGradientThickness): JsValue =
    j match {
      case x:LegendConfigGradientThicknessAsNumber /* TypeRef */ => LegendConfigGradientThicknessAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderLabelLimit (UnionType)
object HeaderLabelLimitCodec {
  def decode(j: JsValue): HeaderLabelLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderLabelLimit] =
    j.asOpt[JsNumber].map { HeaderLabelLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderLabelLimit): JsValue =
    j match {
      case HeaderLabelLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingXErrorBandPosition (ConstrainedType)
object SharedEncodingXErrorBandPositionCodec {
  def decode(j: JsValue): SharedEncodingXErrorBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingXErrorBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingXErrorBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingXErrorBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkConfigAria (UnionType)
object MarkConfigAriaCodec {
  def decode(j: JsValue): MarkConfigAria =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigAria] =
    j.asOpt[Boolean].map { MarkConfigAriaAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigAria): JsValue =
    j match {
      case MarkConfigAriaAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleFieldDefBin (UnionType)
object ScaleFieldDefBinCodec {
  def decode(j: JsValue): ScaleFieldDefBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleFieldDefBin] =
    j.asOpt[Boolean].map { ScaleFieldDefBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ScaleFieldDefBinAsNull } } } 
  def encode(j: ScaleFieldDefBin): JsValue =
    j match {
      case ScaleFieldDefBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case ScaleFieldDefBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncoding (StructType)
object SharedEncodingCodec {
  def decode(j: JsValue): SharedEncoding =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncoding] =
    Some(SharedEncoding(
      `x` = (j \ "x").asOpt[JsValue].flatMap { x => SharedEncodingXCodec.decodeOpt(x) },
      `longitude2` = (j \ "longitude2").asOpt[JsValue].flatMap { x => SharedEncodingLongitude2Codec.decodeOpt(x) },
      `url` = (j \ "url").asOpt[JsValue].flatMap { x => SharedEncodingUrlCodec.decodeOpt(x) },
      `fillOpacity` = (j \ "fillOpacity").asOpt[JsValue].flatMap { x => SharedEncodingFillOpacityCodec.decodeOpt(x) },
      `text` = (j \ "text").asOpt[JsValue].flatMap { x => SharedEncodingTextCodec.decodeOpt(x) },
      `key` = (j \ "key").asOpt[JsValue].flatMap { x => SharedEncodingKeyCodec.decodeOpt(x) },
      `radius2` = (j \ "radius2").asOpt[JsValue].flatMap { x => SharedEncodingRadius2Codec.decodeOpt(x) },
      `yError2` = (j \ "yError2").asOpt[JsValue].flatMap { x => SharedEncodingYError2Codec.decodeOpt(x) },
      `yError` = (j \ "yError").asOpt[JsValue].flatMap { x => SharedEncodingYErrorCodec.decodeOpt(x) },
      `yOffset` = (j \ "yOffset").asOpt[JsValue].flatMap { x => SharedEncodingYOffsetCodec.decodeOpt(x) },
      `xOffset` = (j \ "xOffset").asOpt[JsValue].flatMap { x => SharedEncodingXOffsetCodec.decodeOpt(x) },
      `size` = (j \ "size").asOpt[JsValue].flatMap { x => SharedEncodingSizeCodec.decodeOpt(x) },
      `latitude` = (j \ "latitude").asOpt[JsValue].flatMap { x => SharedEncodingLatitudeCodec.decodeOpt(x) },
      `y` = (j \ "y").asOpt[JsValue].flatMap { x => SharedEncodingYCodec.decodeOpt(x) },
      `strokeOpacity` = (j \ "strokeOpacity").asOpt[JsValue].flatMap { x => SharedEncodingStrokeOpacityCodec.decodeOpt(x) },
      `description` = (j \ "description").asOpt[JsValue].flatMap { x => SharedEncodingDescriptionCodec.decodeOpt(x) },
      `angle` = (j \ "angle").asOpt[JsValue].flatMap { x => SharedEncodingAngleCodec.decodeOpt(x) },
      `stroke` = (j \ "stroke").asOpt[JsValue].flatMap { x => SharedEncodingStrokeCodec.decodeOpt(x) },
      `color` = (j \ "color").asOpt[JsValue].flatMap { x => SharedEncodingColorCodec.decodeOpt(x) },
      `x2` = (j \ "x2").asOpt[JsValue].flatMap { x => SharedEncodingX2Codec.decodeOpt(x) },
      `radius` = (j \ "radius").asOpt[JsValue].flatMap { x => SharedEncodingRadiusCodec.decodeOpt(x) },
      `longitude` = (j \ "longitude").asOpt[JsValue].flatMap { x => SharedEncodingLongitudeCodec.decodeOpt(x) },
      `order` = (j \ "order").asOpt[JsValue].flatMap { x => SharedEncodingOrderCodec.decodeOpt(x) },
      `fill` = (j \ "fill").asOpt[JsValue].flatMap { x => SharedEncodingFillCodec.decodeOpt(x) },
      `theta` = (j \ "theta").asOpt[JsValue].flatMap { x => SharedEncodingThetaCodec.decodeOpt(x) },
      `y2` = (j \ "y2").asOpt[JsValue].flatMap { x => SharedEncodingY2Codec.decodeOpt(x) },
      `xError` = (j \ "xError").asOpt[JsValue].flatMap { x => SharedEncodingXErrorCodec.decodeOpt(x) },
      `tooltip` = (j \ "tooltip").asOpt[JsValue].flatMap { x => SharedEncodingTooltipCodec.decodeOpt(x) },
      `latitude2` = (j \ "latitude2").asOpt[JsValue].flatMap { x => SharedEncodingLatitude2Codec.decodeOpt(x) },
      `detail` = (j \ "detail").asOpt[JsValue].flatMap { x => SharedEncodingDetailCodec.decodeOpt(x) },
      `shape` = (j \ "shape").asOpt[JsValue].flatMap { x => SharedEncodingShapeCodec.decodeOpt(x) },
      `opacity` = (j \ "opacity").asOpt[JsValue].flatMap { x => SharedEncodingOpacityCodec.decodeOpt(x) },
      `href` = (j \ "href").asOpt[JsValue].flatMap { x => SharedEncodingHrefCodec.decodeOpt(x) },
      `strokeDash` = (j \ "strokeDash").asOpt[JsValue].flatMap { x => SharedEncodingStrokeDashCodec.decodeOpt(x) },
      `xError2` = (j \ "xError2").asOpt[JsValue].flatMap { x => SharedEncodingXError2Codec.decodeOpt(x) },
      `strokeWidth` = (j \ "strokeWidth").asOpt[JsValue].flatMap { x => SharedEncodingStrokeWidthCodec.decodeOpt(x) },
      `theta2` = (j \ "theta2").asOpt[JsValue].flatMap { x => SharedEncodingTheta2Codec.decodeOpt(x) },
    ))

  def encode(j: SharedEncoding): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`x`.map { x => "x" -> SharedEncodingXCodec.encode(x) },
        j.`longitude2`.map { x => "longitude2" -> SharedEncodingLongitude2Codec.encode(x) },
        j.`url`.map { x => "url" -> SharedEncodingUrlCodec.encode(x) },
        j.`fillOpacity`.map { x => "fillOpacity" -> SharedEncodingFillOpacityCodec.encode(x) },
        j.`text`.map { x => "text" -> SharedEncodingTextCodec.encode(x) },
        j.`key`.map { x => "key" -> SharedEncodingKeyCodec.encode(x) },
        j.`radius2`.map { x => "radius2" -> SharedEncodingRadius2Codec.encode(x) },
        j.`yError2`.map { x => "yError2" -> SharedEncodingYError2Codec.encode(x) },
        j.`yError`.map { x => "yError" -> SharedEncodingYErrorCodec.encode(x) },
        j.`yOffset`.map { x => "yOffset" -> SharedEncodingYOffsetCodec.encode(x) },
        j.`xOffset`.map { x => "xOffset" -> SharedEncodingXOffsetCodec.encode(x) },
        j.`size`.map { x => "size" -> SharedEncodingSizeCodec.encode(x) },
        j.`latitude`.map { x => "latitude" -> SharedEncodingLatitudeCodec.encode(x) },
        j.`y`.map { x => "y" -> SharedEncodingYCodec.encode(x) },
        j.`strokeOpacity`.map { x => "strokeOpacity" -> SharedEncodingStrokeOpacityCodec.encode(x) },
        j.`description`.map { x => "description" -> SharedEncodingDescriptionCodec.encode(x) },
        j.`angle`.map { x => "angle" -> SharedEncodingAngleCodec.encode(x) },
        j.`stroke`.map { x => "stroke" -> SharedEncodingStrokeCodec.encode(x) },
        j.`color`.map { x => "color" -> SharedEncodingColorCodec.encode(x) },
        j.`x2`.map { x => "x2" -> SharedEncodingX2Codec.encode(x) },
        j.`radius`.map { x => "radius" -> SharedEncodingRadiusCodec.encode(x) },
        j.`longitude`.map { x => "longitude" -> SharedEncodingLongitudeCodec.encode(x) },
        j.`order`.map { x => "order" -> SharedEncodingOrderCodec.encode(x) },
        j.`fill`.map { x => "fill" -> SharedEncodingFillCodec.encode(x) },
        j.`theta`.map { x => "theta" -> SharedEncodingThetaCodec.encode(x) },
        j.`y2`.map { x => "y2" -> SharedEncodingY2Codec.encode(x) },
        j.`xError`.map { x => "xError" -> SharedEncodingXErrorCodec.encode(x) },
        j.`tooltip`.map { x => "tooltip" -> SharedEncodingTooltipCodec.encode(x) },
        j.`latitude2`.map { x => "latitude2" -> SharedEncodingLatitude2Codec.encode(x) },
        j.`detail`.map { x => "detail" -> SharedEncodingDetailCodec.encode(x) },
        j.`shape`.map { x => "shape" -> SharedEncodingShapeCodec.encode(x) },
        j.`opacity`.map { x => "opacity" -> SharedEncodingOpacityCodec.encode(x) },
        j.`href`.map { x => "href" -> SharedEncodingHrefCodec.encode(x) },
        j.`strokeDash`.map { x => "strokeDash" -> SharedEncodingStrokeDashCodec.encode(x) },
        j.`xError2`.map { x => "xError2" -> SharedEncodingXError2Codec.encode(x) },
        j.`strokeWidth`.map { x => "strokeWidth" -> SharedEncodingStrokeWidthCodec.encode(x) },
        j.`theta2`.map { x => "theta2" -> SharedEncodingTheta2Codec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConditionalAxisStringAsObject1 (StructType)
object ConditionalAxisStringAsObject1Codec {
  def decode(j: JsValue): ConditionalAxisStringAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalAxisStringAsObject1] =
    {
      val `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => ConditionalAxisStringAsObject1ConditionCodec.decodeOpt(x) }
      if(`condition`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => ConditionalAxisStringAsObject1ValueCodec.decodeOpt(x) }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalAxisStringAsObject1(
        `condition` = `condition`.get,
        `value` = `value`.get,
      ))
    }

  def encode(j: ConditionalAxisStringAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("condition" -> ConditionalAxisStringAsObject1ConditionCodec.encode(j.`condition`)),
        Some("value" -> ConditionalAxisStringAsObject1ValueCodec.encode(j.`value`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefTextExprRef (StructType)
object ConditionalPredicateValueDefTextExprRefCodec {
  def decode(j: JsValue): ConditionalPredicateValueDefTextExprRef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefTextExprRef] =
    {
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => ConditionalPredicateValueDefTextExprRefValueCodec.decodeOpt(x) }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalPredicateValueDefTextExprRef(
        `test` = `test`.get,
        `value` = `value`.get,
      ))
    }

  def encode(j: ConditionalPredicateValueDefTextExprRef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
        Some("value" -> ConditionalPredicateValueDefTextExprRefValueCodec.encode(j.`value`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// BarConfigOuterRadius (ConstrainedType)
// see BarConfigOuterRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// MarkConfigDy (UnionType)
object MarkConfigDyCodec {
  def decode(j: JsValue): MarkConfigDy =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigDy] =
    j.asOpt[JsNumber].map { MarkConfigDyAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigDy): JsValue =
    j match {
      case MarkConfigDyAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelUnitSpecParamsElement (UnionType)
object TopLevelUnitSpecParamsElementCodec {
  def decode(j: JsValue): TopLevelUnitSpecParamsElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelUnitSpecParamsElement] =
    VariableParameterCodec.decodeOpt(j).orElse {
    SelectionParameterCodec.decodeOpt(j) } 
  def encode(j: TopLevelUnitSpecParamsElement): JsValue =
    j match {
      case x:VariableParameter /* TypeRef */ => VariableParameterCodec.encode(x)
      case x:SelectionParameter /* TypeRef */ => SelectionParameterCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldDefWithoutScaleBandPosition (ConstrainedType)
object FieldDefWithoutScaleBandPositionCodec {
  def decode(j: JsValue): FieldDefWithoutScaleBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldDefWithoutScaleBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { FieldDefWithoutScaleBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: FieldDefWithoutScaleBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ArrayOfTopLevelRepeatSpecAsObject1ParamsElement (ArrayType)
object ArrayOfTopLevelRepeatSpecAsObject1ParamsElementCodec {
  def decode(j: JsValue): Seq[TopLevelRepeatSpecAsObject1ParamsElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[TopLevelRepeatSpecAsObject1ParamsElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      TopLevelRepeatSpecAsObject1ParamsElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[TopLevelRepeatSpecAsObject1ParamsElement]): JsArray =
      JsArray(j.map { x => TopLevelRepeatSpecAsObject1ParamsElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1Bin (UnionType)
object ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1BinCodec {
  def decode(j: JsValue): ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1Bin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1Bin] =
    j.asOpt[Boolean].map { ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1BinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1BinAsNull } } } 
  def encode(j: ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1Bin): JsValue =
    j match {
      case ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1BinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1BinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTickDash (UnionType)
object AxisConfigTickDashCodec {
  def decode(j: JsValue): AxisConfigTickDash =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTickDash] =
    ArrayOfNumberCodec.decodeOpt(j).map { AxisConfigTickDashAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberArrayCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigTickDash): JsValue =
    j match {
      case AxisConfigTickDashAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumberArray /* TypeRef */ => ConditionalAxisNumberArrayCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigLabelBaseline (UnionType)
object LegendConfigLabelBaselineCodec {
  def decode(j: JsValue): LegendConfigLabelBaseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigLabelBaseline] =
    TextBaselineCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigLabelBaseline): JsValue =
    j match {
      case x:TextBaseline /* TypeRef */ => TextBaselineCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Type (EnumType)
object TypeCodec {
  def decode(j: JsValue): Type =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Type] =
    j match {
      case JsString("quantitative") => Some(TypeQuantitative)
      case JsString("ordinal") => Some(TypeOrdinal)
      case JsString("temporal") => Some(TypeTemporal)
      case JsString("nominal") => Some(TypeNominal)
      case JsString("geojson") => Some(TypeGeojson)
      case _ => None
    }
  def encode(j: Type): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// AxisTickSize (UnionType)
object AxisTickSizeCodec {
  def decode(j: JsValue): AxisTickSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTickSize] =
    AxisTickSizeAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisTickSize): JsValue =
    j match {
      case x:AxisTickSizeAsNumber /* TypeRef */ => AxisTickSizeAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetedUnitSpecBounds (EnumType)
object FacetedUnitSpecBoundsCodec {
  def decode(j: JsValue): FacetedUnitSpecBounds =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetedUnitSpecBounds] =
    j match {
      case JsString("full") => Some(FacetedUnitSpecBoundsFull)
      case JsString("flush") => Some(FacetedUnitSpecBoundsFlush)
      case _ => None
    }
  def encode(j: FacetedUnitSpecBounds): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefAlignNullExprRefAsObject2 (StructType)
object ConditionalPredicateValueDefAlignNullExprRefAsObject2Codec {
  def decode(j: JsValue): ConditionalPredicateValueDefAlignNullExprRefAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefAlignNullExprRefAsObject2] =
    {
      val `expr` = (j \ "expr").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`expr`.isEmpty) { return None }
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      return Some(ConditionalPredicateValueDefAlignNullExprRefAsObject2(
        `expr` = `expr`.get,
        `test` = `test`.get,
      ))
    }

  def encode(j: ConditionalPredicateValueDefAlignNullExprRefAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("expr" -> Json.toJson(j.`expr`)),
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingTextFormat (UnionType)
object SharedEncodingTextFormatCodec {
  def decode(j: JsValue): SharedEncodingTextFormat =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingTextFormat] =
    j.asOpt[String].map { SharedEncodingTextFormatAsString(_) }.orElse {
    DictOfAnyCodec.decodeOpt(j).map { SharedEncodingTextFormatAsDictOfAny(_) } } 
  def encode(j: SharedEncodingTextFormat): JsValue =
    j match {
      case SharedEncodingTextFormatAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case SharedEncodingTextFormatAsDictOfAny(x) /* Base, MapType */ => DictOfAnyCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PrimitiveValue (UnionType)
object PrimitiveValueCodec {
  def decode(j: JsValue): PrimitiveValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PrimitiveValue] =
    j.asOpt[JsNumber].map { PrimitiveValueAsNumber(_) }.orElse {
    j.asOpt[String].map { PrimitiveValueAsString(_) }.orElse {
    j.asOpt[Boolean].map { PrimitiveValueAsBool(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => PrimitiveValueAsNull } } } } 
  def encode(j: PrimitiveValue): JsValue =
    j match {
      case PrimitiveValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case PrimitiveValueAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case PrimitiveValueAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case PrimitiveValueAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefFontWeightNullExprRef (UnionType)
object ConditionalPredicateValueDefFontWeightNullExprRefCodec {
  def decode(j: JsValue): ConditionalPredicateValueDefFontWeightNullExprRef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefFontWeightNullExprRef] =
    ConditionalPredicateValueDefFontWeightNullExprRefAsObject1Codec.decodeOpt(j).orElse {
    ConditionalPredicateValueDefFontWeightNullExprRefAsObject2Codec.decodeOpt(j) } 
  def encode(j: ConditionalPredicateValueDefFontWeightNullExprRef): JsValue =
    j match {
      case x:ConditionalPredicateValueDefFontWeightNullExprRefAsObject1 /* TypeRef */ => ConditionalPredicateValueDefFontWeightNullExprRefAsObject1Codec.encode(x)
      case x:ConditionalPredicateValueDefFontWeightNullExprRefAsObject2 /* TypeRef */ => ConditionalPredicateValueDefFontWeightNullExprRefAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeBin (UnionType)
object SharedEncodingStrokeBinCodec {
  def decode(j: JsValue): SharedEncodingStrokeBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeBin] =
    j.asOpt[Boolean].map { SharedEncodingStrokeBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingStrokeBinAsNull } } } 
  def encode(j: SharedEncodingStrokeBin): JsValue =
    j match {
      case SharedEncodingStrokeBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case SharedEncodingStrokeBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingDescriptionFormat (UnionType)
object SharedEncodingDescriptionFormatCodec {
  def decode(j: JsValue): SharedEncodingDescriptionFormat =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingDescriptionFormat] =
    j.asOpt[String].map { SharedEncodingDescriptionFormatAsString(_) }.orElse {
    DictOfAnyCodec.decodeOpt(j).map { SharedEncodingDescriptionFormatAsDictOfAny(_) } } 
  def encode(j: SharedEncodingDescriptionFormat): JsValue =
    j match {
      case SharedEncodingDescriptionFormatAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case SharedEncodingDescriptionFormatAsDictOfAny(x) /* Base, MapType */ => DictOfAnyCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigContinuousPadding (UnionType)
object ScaleConfigContinuousPaddingCodec {
  def decode(j: JsValue): ScaleConfigContinuousPadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleConfigContinuousPadding] =
    j.asOpt[JsNumber].map { ScaleConfigContinuousPaddingAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleConfigContinuousPadding): JsValue =
    j match {
      case ScaleConfigContinuousPaddingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AggregatedFieldDef (StructType)
object AggregatedFieldDefCodec {
  def decode(j: JsValue): AggregatedFieldDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AggregatedFieldDef] =
    {
      val `as` = (j \ "as").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`as`.isEmpty) { return None }
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `op` = (j \ "op").asOpt[JsValue].flatMap { x => AggregateOpCodec.decodeOpt(x) }
      if(`op`.isEmpty) { return None }
      return Some(AggregatedFieldDef(
        `as` = `as`.get,
        `field` = `field`,
        `op` = `op`.get,
      ))
    }

  def encode(j: AggregatedFieldDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("as" -> Json.toJson(j.`as`)),
        j.`field`.map { x => "field" -> Json.toJson(x) },
        Some("op" -> AggregateOpCodec.encode(j.`op`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// OverlayMarkDefRadiusOffset (UnionType)
object OverlayMarkDefRadiusOffsetCodec {
  def decode(j: JsValue): OverlayMarkDefRadiusOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefRadiusOffset] =
    j.asOpt[JsNumber].map { OverlayMarkDefRadiusOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefRadiusOffset): JsValue =
    j match {
      case OverlayMarkDefRadiusOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetedEncodingXError2 (UnionType)
object FacetedEncodingXError2Codec {
  def decode(j: JsValue): FacetedEncodingXError2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetedEncodingXError2] =
    SecondaryFieldDefCodec.decodeOpt(j).orElse {
    ValueDefNumberCodec.decodeOpt(j) } 
  def encode(j: FacetedEncodingXError2): JsValue =
    j match {
      case x:SecondaryFieldDef /* TypeRef */ => SecondaryFieldDefCodec.encode(x)
      case x:ValueDefNumber /* TypeRef */ => ValueDefNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SelectionParameterValue (UnionType)
object SelectionParameterValueCodec {
  def decode(j: JsValue): SelectionParameterValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SelectionParameterValue] =
    SelectionInitCodec.decodeOpt(j).orElse {
    ArrayOfDictOfSelectionInitCodec.decodeOpt(j).map { SelectionParameterValueAsArrayOfDictOfSelectionInit(_) }.orElse {
    DictOfSelectionInitIntervalCodec.decodeOpt(j).map { SelectionParameterValueAsDictOfSelectionInitInterval(_) } } } 
  def encode(j: SelectionParameterValue): JsValue =
    j match {
      case x:SelectionInit /* TypeRef */ => SelectionInitCodec.encode(x)
      case SelectionParameterValueAsArrayOfDictOfSelectionInit(x) /* Base, ArrayType */ => ArrayOfDictOfSelectionInitCodec.encode(x)
      case SelectionParameterValueAsDictOfSelectionInitInterval(x) /* Base, MapType */ => DictOfSelectionInitIntervalCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RowColumnEncodingFieldDefSort (UnionType)
object RowColumnEncodingFieldDefSortCodec {
  def decode(j: JsValue): RowColumnEncodingFieldDefSort =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RowColumnEncodingFieldDefSort] =
    SortArrayCodec.decodeOpt(j).orElse {
    SortOrderCodec.decodeOpt(j).orElse {
    EncodingSortFieldCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => RowColumnEncodingFieldDefSortAsNull } } } } 
  def encode(j: RowColumnEncodingFieldDefSort): JsValue =
    j match {
      case x:SortArray /* TypeRef */ => SortArrayCodec.encode(x)
      case x:SortOrder /* TypeRef */ => SortOrderCodec.encode(x)
      case x:EncodingSortField /* TypeRef */ => EncodingSortFieldCodec.encode(x)
      case RowColumnEncodingFieldDefSortAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// ColorName (EnumType)
object ColorNameCodec {
  def decode(j: JsValue): ColorName =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ColorName] =
    j match {
      case JsString("black") => Some(ColorNameBlack)
      case JsString("silver") => Some(ColorNameSilver)
      case JsString("gray") => Some(ColorNameGray)
      case JsString("white") => Some(ColorNameWhite)
      case JsString("maroon") => Some(ColorNameMaroon)
      case JsString("red") => Some(ColorNameRed)
      case JsString("purple") => Some(ColorNamePurple)
      case JsString("fuchsia") => Some(ColorNameFuchsia)
      case JsString("green") => Some(ColorNameGreen)
      case JsString("lime") => Some(ColorNameLime)
      case JsString("olive") => Some(ColorNameOlive)
      case JsString("yellow") => Some(ColorNameYellow)
      case JsString("navy") => Some(ColorNameNavy)
      case JsString("blue") => Some(ColorNameBlue)
      case JsString("teal") => Some(ColorNameTeal)
      case JsString("aqua") => Some(ColorNameAqua)
      case JsString("orange") => Some(ColorNameOrange)
      case JsString("aliceblue") => Some(ColorNameAliceblue)
      case JsString("antiquewhite") => Some(ColorNameAntiquewhite)
      case JsString("aquamarine") => Some(ColorNameAquamarine)
      case JsString("azure") => Some(ColorNameAzure)
      case JsString("beige") => Some(ColorNameBeige)
      case JsString("bisque") => Some(ColorNameBisque)
      case JsString("blanchedalmond") => Some(ColorNameBlanchedalmond)
      case JsString("blueviolet") => Some(ColorNameBlueviolet)
      case JsString("brown") => Some(ColorNameBrown)
      case JsString("burlywood") => Some(ColorNameBurlywood)
      case JsString("cadetblue") => Some(ColorNameCadetblue)
      case JsString("chartreuse") => Some(ColorNameChartreuse)
      case JsString("chocolate") => Some(ColorNameChocolate)
      case JsString("coral") => Some(ColorNameCoral)
      case JsString("cornflowerblue") => Some(ColorNameCornflowerblue)
      case JsString("cornsilk") => Some(ColorNameCornsilk)
      case JsString("crimson") => Some(ColorNameCrimson)
      case JsString("cyan") => Some(ColorNameCyan)
      case JsString("darkblue") => Some(ColorNameDarkblue)
      case JsString("darkcyan") => Some(ColorNameDarkcyan)
      case JsString("darkgoldenrod") => Some(ColorNameDarkgoldenrod)
      case JsString("darkgray") => Some(ColorNameDarkgray)
      case JsString("darkgreen") => Some(ColorNameDarkgreen)
      case JsString("darkgrey") => Some(ColorNameDarkgrey)
      case JsString("darkkhaki") => Some(ColorNameDarkkhaki)
      case JsString("darkmagenta") => Some(ColorNameDarkmagenta)
      case JsString("darkolivegreen") => Some(ColorNameDarkolivegreen)
      case JsString("darkorange") => Some(ColorNameDarkorange)
      case JsString("darkorchid") => Some(ColorNameDarkorchid)
      case JsString("darkred") => Some(ColorNameDarkred)
      case JsString("darksalmon") => Some(ColorNameDarksalmon)
      case JsString("darkseagreen") => Some(ColorNameDarkseagreen)
      case JsString("darkslateblue") => Some(ColorNameDarkslateblue)
      case JsString("darkslategray") => Some(ColorNameDarkslategray)
      case JsString("darkslategrey") => Some(ColorNameDarkslategrey)
      case JsString("darkturquoise") => Some(ColorNameDarkturquoise)
      case JsString("darkviolet") => Some(ColorNameDarkviolet)
      case JsString("deeppink") => Some(ColorNameDeeppink)
      case JsString("deepskyblue") => Some(ColorNameDeepskyblue)
      case JsString("dimgray") => Some(ColorNameDimgray)
      case JsString("dimgrey") => Some(ColorNameDimgrey)
      case JsString("dodgerblue") => Some(ColorNameDodgerblue)
      case JsString("firebrick") => Some(ColorNameFirebrick)
      case JsString("floralwhite") => Some(ColorNameFloralwhite)
      case JsString("forestgreen") => Some(ColorNameForestgreen)
      case JsString("gainsboro") => Some(ColorNameGainsboro)
      case JsString("ghostwhite") => Some(ColorNameGhostwhite)
      case JsString("gold") => Some(ColorNameGold)
      case JsString("goldenrod") => Some(ColorNameGoldenrod)
      case JsString("greenyellow") => Some(ColorNameGreenyellow)
      case JsString("grey") => Some(ColorNameGrey)
      case JsString("honeydew") => Some(ColorNameHoneydew)
      case JsString("hotpink") => Some(ColorNameHotpink)
      case JsString("indianred") => Some(ColorNameIndianred)
      case JsString("indigo") => Some(ColorNameIndigo)
      case JsString("ivory") => Some(ColorNameIvory)
      case JsString("khaki") => Some(ColorNameKhaki)
      case JsString("lavender") => Some(ColorNameLavender)
      case JsString("lavenderblush") => Some(ColorNameLavenderblush)
      case JsString("lawngreen") => Some(ColorNameLawngreen)
      case JsString("lemonchiffon") => Some(ColorNameLemonchiffon)
      case JsString("lightblue") => Some(ColorNameLightblue)
      case JsString("lightcoral") => Some(ColorNameLightcoral)
      case JsString("lightcyan") => Some(ColorNameLightcyan)
      case JsString("lightgoldenrodyellow") => Some(ColorNameLightgoldenrodyellow)
      case JsString("lightgray") => Some(ColorNameLightgray)
      case JsString("lightgreen") => Some(ColorNameLightgreen)
      case JsString("lightgrey") => Some(ColorNameLightgrey)
      case JsString("lightpink") => Some(ColorNameLightpink)
      case JsString("lightsalmon") => Some(ColorNameLightsalmon)
      case JsString("lightseagreen") => Some(ColorNameLightseagreen)
      case JsString("lightskyblue") => Some(ColorNameLightskyblue)
      case JsString("lightslategray") => Some(ColorNameLightslategray)
      case JsString("lightslategrey") => Some(ColorNameLightslategrey)
      case JsString("lightsteelblue") => Some(ColorNameLightsteelblue)
      case JsString("lightyellow") => Some(ColorNameLightyellow)
      case JsString("limegreen") => Some(ColorNameLimegreen)
      case JsString("linen") => Some(ColorNameLinen)
      case JsString("magenta") => Some(ColorNameMagenta)
      case JsString("mediumaquamarine") => Some(ColorNameMediumaquamarine)
      case JsString("mediumblue") => Some(ColorNameMediumblue)
      case JsString("mediumorchid") => Some(ColorNameMediumorchid)
      case JsString("mediumpurple") => Some(ColorNameMediumpurple)
      case JsString("mediumseagreen") => Some(ColorNameMediumseagreen)
      case JsString("mediumslateblue") => Some(ColorNameMediumslateblue)
      case JsString("mediumspringgreen") => Some(ColorNameMediumspringgreen)
      case JsString("mediumturquoise") => Some(ColorNameMediumturquoise)
      case JsString("mediumvioletred") => Some(ColorNameMediumvioletred)
      case JsString("midnightblue") => Some(ColorNameMidnightblue)
      case JsString("mintcream") => Some(ColorNameMintcream)
      case JsString("mistyrose") => Some(ColorNameMistyrose)
      case JsString("moccasin") => Some(ColorNameMoccasin)
      case JsString("navajowhite") => Some(ColorNameNavajowhite)
      case JsString("oldlace") => Some(ColorNameOldlace)
      case JsString("olivedrab") => Some(ColorNameOlivedrab)
      case JsString("orangered") => Some(ColorNameOrangered)
      case JsString("orchid") => Some(ColorNameOrchid)
      case JsString("palegoldenrod") => Some(ColorNamePalegoldenrod)
      case JsString("palegreen") => Some(ColorNamePalegreen)
      case JsString("paleturquoise") => Some(ColorNamePaleturquoise)
      case JsString("palevioletred") => Some(ColorNamePalevioletred)
      case JsString("papayawhip") => Some(ColorNamePapayawhip)
      case JsString("peachpuff") => Some(ColorNamePeachpuff)
      case JsString("peru") => Some(ColorNamePeru)
      case JsString("pink") => Some(ColorNamePink)
      case JsString("plum") => Some(ColorNamePlum)
      case JsString("powderblue") => Some(ColorNamePowderblue)
      case JsString("rosybrown") => Some(ColorNameRosybrown)
      case JsString("royalblue") => Some(ColorNameRoyalblue)
      case JsString("saddlebrown") => Some(ColorNameSaddlebrown)
      case JsString("salmon") => Some(ColorNameSalmon)
      case JsString("sandybrown") => Some(ColorNameSandybrown)
      case JsString("seagreen") => Some(ColorNameSeagreen)
      case JsString("seashell") => Some(ColorNameSeashell)
      case JsString("sienna") => Some(ColorNameSienna)
      case JsString("skyblue") => Some(ColorNameSkyblue)
      case JsString("slateblue") => Some(ColorNameSlateblue)
      case JsString("slategray") => Some(ColorNameSlategray)
      case JsString("slategrey") => Some(ColorNameSlategrey)
      case JsString("snow") => Some(ColorNameSnow)
      case JsString("springgreen") => Some(ColorNameSpringgreen)
      case JsString("steelblue") => Some(ColorNameSteelblue)
      case JsString("tan") => Some(ColorNameTan)
      case JsString("thistle") => Some(ColorNameThistle)
      case JsString("tomato") => Some(ColorNameTomato)
      case JsString("turquoise") => Some(ColorNameTurquoise)
      case JsString("violet") => Some(ColorNameViolet)
      case JsString("wheat") => Some(ColorNameWheat)
      case JsString("whitesmoke") => Some(ColorNameWhitesmoke)
      case JsString("yellowgreen") => Some(ColorNameYellowgreen)
      case JsString("rebeccapurple") => Some(ColorNameRebeccapurple)
      case _ => None
    }
  def encode(j: ColorName): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// DsvDataFormatType (ConstantType)
object DsvDataFormatTypeCodec {
  def decode(j: JsValue): DsvDataFormatType =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[DsvDataFormatType] =
    j match {
      case JsString("dsv") => Some(DsvDataFormatType())
      case _ => None
    }
  def encode(j: DsvDataFormatType): JsValue =
    JsString("dsv")
}


////////////////////////////////////////////////////////////////////////
// AreaConfigAngle (UnionType)
object AreaConfigAngleCodec {
  def decode(j: JsValue): AreaConfigAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigAngle] =
    AreaConfigAngleAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigAngle): JsValue =
    j match {
      case x:AreaConfigAngleAsNumber /* TypeRef */ => AreaConfigAngleAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigMaxOpacity (ConstrainedType)
object ScaleConfigMaxOpacityCodec {
  def decode(j: JsValue): ScaleConfigMaxOpacity =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ScaleConfigMaxOpacity] =
    try {
      j.asOpt[JsNumber]
        .map { ScaleConfigMaxOpacity(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ScaleConfigMaxOpacity): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ArrayOfConditionalPredicateValueDefTextBaselineNullExprRef (ArrayType)
object ArrayOfConditionalPredicateValueDefTextBaselineNullExprRefCodec {
  def decode(j: JsValue): Seq[ConditionalPredicateValueDefTextBaselineNullExprRef] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[ConditionalPredicateValueDefTextBaselineNullExprRef]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      ConditionalPredicateValueDefTextBaselineNullExprRefCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[ConditionalPredicateValueDefTextBaselineNullExprRef]): JsArray =
      JsArray(j.map { x => ConditionalPredicateValueDefTextBaselineNullExprRefCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// AreaConfigStrokeMiterLimit (UnionType)
object AreaConfigStrokeMiterLimitCodec {
  def decode(j: JsValue): AreaConfigStrokeMiterLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigStrokeMiterLimit] =
    j.asOpt[JsNumber].map { AreaConfigStrokeMiterLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigStrokeMiterLimit): JsValue =
    j match {
      case AreaConfigStrokeMiterLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingYType (UnionType)
object SharedEncodingYTypeCodec {
  def decode(j: JsValue): SharedEncodingYType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingYType] =
    StandardTypeCodec.decodeOpt(j).orElse {
    TypeCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingYType): JsValue =
    j match {
      case x:StandardType /* TypeRef */ => StandardTypeCodec.encode(x)
      case x:Type /* TypeRef */ => TypeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisNumberAsObject1Condition (UnionType)
object ConditionalAxisNumberAsObject1ConditionCodec {
  def decode(j: JsValue): ConditionalAxisNumberAsObject1Condition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisNumberAsObject1Condition] =
    ConditionalPredicateValueDefNumberNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalPredicateValueDefNumberNullExprRefCodec.decodeOpt(j).map { ConditionalAxisNumberAsObject1ConditionAsArrayOfConditionalPredicateValueDefNumberNullExprRef(_) } } 
  def encode(j: ConditionalAxisNumberAsObject1Condition): JsValue =
    j match {
      case x:ConditionalPredicateValueDefNumberNullExprRef /* TypeRef */ => ConditionalPredicateValueDefNumberNullExprRefCodec.encode(x)
      case ConditionalAxisNumberAsObject1ConditionAsArrayOfConditionalPredicateValueDefNumberNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalPredicateValueDefNumberNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LatLongFieldDefBandPosition (ConstrainedType)
object LatLongFieldDefBandPositionCodec {
  def decode(j: JsValue): LatLongFieldDefBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LatLongFieldDefBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { LatLongFieldDefBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: LatLongFieldDefBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// StandardType (EnumType)
object StandardTypeCodec {
  def decode(j: JsValue): StandardType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[StandardType] =
    j match {
      case JsString("quantitative") => Some(StandardTypeQuantitative)
      case JsString("ordinal") => Some(StandardTypeOrdinal)
      case JsString("temporal") => Some(StandardTypeTemporal)
      case JsString("nominal") => Some(StandardTypeNominal)
      case _ => None
    }
  def encode(j: StandardType): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingRadius2Value (UnionType)
object SharedEncodingRadius2ValueCodec {
  def decode(j: JsValue): SharedEncodingRadius2Value =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingRadius2Value] =
    j.asOpt[JsNumber].map { SharedEncodingRadius2ValueAsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingRadius2Value): JsValue =
    j match {
      case SharedEncodingRadius2ValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigCornerRadiusTopLeft (UnionType)
object RectConfigCornerRadiusTopLeftCodec {
  def decode(j: JsValue): RectConfigCornerRadiusTopLeft =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigCornerRadiusTopLeft] =
    j.asOpt[JsNumber].map { RectConfigCornerRadiusTopLeftAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigCornerRadiusTopLeft): JsValue =
    j match {
      case RectConfigCornerRadiusTopLeftAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PointSelectionConfigClear (UnionType)
object PointSelectionConfigClearCodec {
  def decode(j: JsValue): PointSelectionConfigClear =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PointSelectionConfigClear] =
    StreamCodec.decodeOpt(j).orElse {
    j.asOpt[String].map { PointSelectionConfigClearAsString(_) }.orElse {
    j.asOpt[Boolean].map { PointSelectionConfigClearAsBool(_) } } } 
  def encode(j: PointSelectionConfigClear): JsValue =
    j match {
      case x:Stream /* TypeRef */ => StreamCodec.encode(x)
      case PointSelectionConfigClearAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case PointSelectionConfigClearAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelLayerSpecPadding (UnionType)
object TopLevelLayerSpecPaddingCodec {
  def decode(j: JsValue): TopLevelLayerSpecPadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelLayerSpecPadding] =
    PaddingCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TopLevelLayerSpecPadding): JsValue =
    j match {
      case x:Padding /* TypeRef */ => PaddingCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOneOfPredicateOneOf (UnionType)
object FieldOneOfPredicateOneOfCodec {
  def decode(j: JsValue): FieldOneOfPredicateOneOf =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOneOfPredicateOneOf] =
    ArrayOfStringCodec.decodeOpt(j).map { FieldOneOfPredicateOneOfAsArrayOfString(_) }.orElse {
    ArrayOfNumberCodec.decodeOpt(j).map { FieldOneOfPredicateOneOfAsArrayOfNumber(_) }.orElse {
    ArrayOfBoolCodec.decodeOpt(j).map { FieldOneOfPredicateOneOfAsArrayOfBool(_) }.orElse {
    ArrayOfDateTimeCodec.decodeOpt(j).map { FieldOneOfPredicateOneOfAsArrayOfDateTime(_) } } } } 
  def encode(j: FieldOneOfPredicateOneOf): JsValue =
    j match {
      case FieldOneOfPredicateOneOfAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
      case FieldOneOfPredicateOneOfAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case FieldOneOfPredicateOneOfAsArrayOfBool(x) /* Base, ArrayType */ => ArrayOfBoolCodec.encode(x)
      case FieldOneOfPredicateOneOfAsArrayOfDateTime(x) /* Base, ArrayType */ => ArrayOfDateTimeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingX2Datum (UnionType)
object SharedEncodingX2DatumCodec {
  def decode(j: JsValue): SharedEncodingX2Datum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingX2Datum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingX2Datum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigDy (UnionType)
object RectConfigDyCodec {
  def decode(j: JsValue): RectConfigDy =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigDy] =
    j.asOpt[JsNumber].map { RectConfigDyAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigDy): JsValue =
    j match {
      case RectConfigDyAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FlattenTransform (StructType)
object FlattenTransformCodec {
  def decode(j: JsValue): FlattenTransform =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FlattenTransform] =
    {
      val `as` = (j \ "as").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) }
      val `flatten` = (j \ "flatten").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) }
      if(`flatten`.isEmpty) { return None }
      return Some(FlattenTransform(
        `as` = `as`,
        `flatten` = `flatten`.get,
      ))
    }

  def encode(j: FlattenTransform): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`as`.map { x => "as" -> ArrayOfStringCodec.encode(x) },
        Some("flatten" -> ArrayOfStringCodec.encode(j.`flatten`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TickConfigFontSizeAsNumber (ConstrainedType)
object TickConfigFontSizeAsNumberCodec {
  def decode(j: JsValue): TickConfigFontSizeAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TickConfigFontSizeAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { TickConfigFontSizeAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: TickConfigFontSizeAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// LegendConfigGradientOpacity (UnionType)
object LegendConfigGradientOpacityCodec {
  def decode(j: JsValue): LegendConfigGradientOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigGradientOpacity] =
    j.asOpt[JsNumber].map { LegendConfigGradientOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigGradientOpacity): JsValue =
    j match {
      case LegendConfigGradientOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigFillOpacity (UnionType)
object RectConfigFillOpacityCodec {
  def decode(j: JsValue): RectConfigFillOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigFillOpacity] =
    RectConfigFillOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigFillOpacity): JsValue =
    j match {
      case x:RectConfigFillOpacityAsNumber /* TypeRef */ => RectConfigFillOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingOpacityBandPosition (ConstrainedType)
object SharedEncodingOpacityBandPositionCodec {
  def decode(j: JsValue): SharedEncodingOpacityBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingOpacityBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingOpacityBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingOpacityBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// WindowOnlyOp (EnumType)
object WindowOnlyOpCodec {
  def decode(j: JsValue): WindowOnlyOp =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[WindowOnlyOp] =
    j match {
      case JsString("row_number") => Some(WindowOnlyOpRowNumber)
      case JsString("rank") => Some(WindowOnlyOpRank)
      case JsString("dense_rank") => Some(WindowOnlyOpDenseRank)
      case JsString("percent_rank") => Some(WindowOnlyOpPercentRank)
      case JsString("cume_dist") => Some(WindowOnlyOpCumeDist)
      case JsString("ntile") => Some(WindowOnlyOpNtile)
      case JsString("lag") => Some(WindowOnlyOpLag)
      case JsString("lead") => Some(WindowOnlyOpLead)
      case JsString("first_value") => Some(WindowOnlyOpFirstValue)
      case JsString("last_value") => Some(WindowOnlyOpLastValue)
      case JsString("nth_value") => Some(WindowOnlyOpNthValue)
      case _ => None
    }
  def encode(j: WindowOnlyOp): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// OverlayMarkDefAlign (UnionType)
object OverlayMarkDefAlignCodec {
  def decode(j: JsValue): OverlayMarkDefAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefAlign] =
    AlignCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefAlign): JsValue =
    j match {
      case x:Align /* TypeRef */ => AlignCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfDictOfSelectionInit (ArrayType)
object ArrayOfDictOfSelectionInitCodec {
  def decode(j: JsValue): Seq[Map[String,SelectionInit]] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[Map[String,SelectionInit]]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      DictOfSelectionInitCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[Map[String,SelectionInit]]): JsArray =
      JsArray(j.map { x => DictOfSelectionInitCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// TickConfigFont (UnionType)
object TickConfigFontCodec {
  def decode(j: JsValue): TickConfigFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigFont] =
    j.asOpt[String].map { TickConfigFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigFont): JsValue =
    j match {
      case TickConfigFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigAngleAsNumber (ConstrainedType)
object MarkConfigAngleAsNumberCodec {
  def decode(j: JsValue): MarkConfigAngleAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[MarkConfigAngleAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { MarkConfigAngleAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: MarkConfigAngleAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisStringAsObject2Condition (UnionType)
object ConditionalAxisStringAsObject2ConditionCodec {
  def decode(j: JsValue): ConditionalAxisStringAsObject2Condition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisStringAsObject2Condition] =
    ConditionalPredicateValueDefStringNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalPredicateValueDefStringNullExprRefCodec.decodeOpt(j).map { ConditionalAxisStringAsObject2ConditionAsArrayOfConditionalPredicateValueDefStringNullExprRef(_) } } 
  def encode(j: ConditionalAxisStringAsObject2Condition): JsValue =
    j match {
      case x:ConditionalPredicateValueDefStringNullExprRef /* TypeRef */ => ConditionalPredicateValueDefStringNullExprRefCodec.encode(x)
      case ConditionalAxisStringAsObject2ConditionAsArrayOfConditionalPredicateValueDefStringNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalPredicateValueDefStringNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigPointPadding (UnionType)
object ScaleConfigPointPaddingCodec {
  def decode(j: JsValue): ScaleConfigPointPadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleConfigPointPadding] =
    j.asOpt[JsNumber].map { ScaleConfigPointPaddingAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleConfigPointPadding): JsValue =
    j match {
      case ScaleConfigPointPaddingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalValueDefStringExprRef (UnionType)
object ConditionalValueDefStringExprRefCodec {
  def decode(j: JsValue): ConditionalValueDefStringExprRef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalValueDefStringExprRef] =
    ConditionalPredicateValueDefStringExprRefCodec.decodeOpt(j).orElse {
    ConditionalParameterValueDefStringExprRefCodec.decodeOpt(j) } 
  def encode(j: ConditionalValueDefStringExprRef): JsValue =
    j match {
      case x:ConditionalPredicateValueDefStringExprRef /* TypeRef */ => ConditionalPredicateValueDefStringExprRefCodec.encode(x)
      case x:ConditionalParameterValueDefStringExprRef /* TypeRef */ => ConditionalParameterValueDefStringExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigColumnPadding (UnionType)
object LegendConfigColumnPaddingCodec {
  def decode(j: JsValue): LegendConfigColumnPadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigColumnPadding] =
    j.asOpt[JsNumber].map { LegendConfigColumnPaddingAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigColumnPadding): JsValue =
    j match {
      case LegendConfigColumnPaddingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingLatitudeTimeUnit (UnionType)
object SharedEncodingLatitudeTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingLatitudeTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingLatitudeTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingLatitudeTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigStartAngle (UnionType)
object MarkConfigStartAngleCodec {
  def decode(j: JsValue): MarkConfigStartAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigStartAngle] =
    j.asOpt[JsNumber].map { MarkConfigStartAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigStartAngle): JsValue =
    j match {
      case MarkConfigStartAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingText (StructType)
object SharedEncodingTextCodec {
  def decode(j: JsValue): SharedEncodingText =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingText] =
    Some(SharedEncodingText(
      `format` = (j \ "format").asOpt[JsValue].flatMap { x => SharedEncodingTextFormatCodec.decodeOpt(x) },
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingTextDatumCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingTextBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => SharedEncodingTextConditionCodec.decodeOpt(x) },
      `formatType` = (j \ "formatType").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingTextBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingTextValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingTextTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => SharedEncodingTextTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingText): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`format`.map { x => "format" -> SharedEncodingTextFormatCodec.encode(x) },
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingTextDatumCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingTextBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> SharedEncodingTextConditionCodec.encode(x) },
        j.`formatType`.map { x => "formatType" -> Json.toJson(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingTextBinCodec.encode(x) },
        j.`value`.map { x => "value" -> SharedEncodingTextValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingTextTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> SharedEncodingTextTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ValueDefWithConditionMarkPropFieldOrDatumDefNumber (StructType)
object ValueDefWithConditionMarkPropFieldOrDatumDefNumberCodec {
  def decode(j: JsValue): ValueDefWithConditionMarkPropFieldOrDatumDefNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ValueDefWithConditionMarkPropFieldOrDatumDefNumber] =
    Some(ValueDefWithConditionMarkPropFieldOrDatumDefNumber(
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => ValueDefWithConditionMarkPropFieldOrDatumDefNumberConditionCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => ValueDefWithConditionMarkPropFieldOrDatumDefNumberValueCodec.decodeOpt(x) },
    ))

  def encode(j: ValueDefWithConditionMarkPropFieldOrDatumDefNumber): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`condition`.map { x => "condition" -> ValueDefWithConditionMarkPropFieldOrDatumDefNumberConditionCodec.encode(x) },
        j.`value`.map { x => "value" -> ValueDefWithConditionMarkPropFieldOrDatumDefNumberValueCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TickConfigHeight (UnionType)
object TickConfigHeightCodec {
  def decode(j: JsValue): TickConfigHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigHeight] =
    j.asOpt[JsNumber].map { TickConfigHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigHeight): JsValue =
    j match {
      case TickConfigHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// EncodingSortField (StructType)
object EncodingSortFieldCodec {
  def decode(j: JsValue): EncodingSortField =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[EncodingSortField] =
    Some(EncodingSortField(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `op` = (j \ "op").asOpt[JsValue].flatMap { x => NonArgAggregateOpCodec.decodeOpt(x) },
      `order` = (j \ "order").asOpt[JsValue].flatMap { x => SortOrderCodec.decodeOpt(x).map { Some(_) }.flatten },
    ))

  def encode(j: EncodingSortField): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`op`.map { x => "op" -> NonArgAggregateOpCodec.encode(x) },
        j.`order`.map { x => "order" -> SortOrderCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LineConfigAspect (UnionType)
object LineConfigAspectCodec {
  def decode(j: JsValue): LineConfigAspect =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigAspect] =
    j.asOpt[Boolean].map { LineConfigAspectAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigAspect): JsValue =
    j match {
      case LineConfigAspectAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewBackgroundStrokeWidth (UnionType)
object ViewBackgroundStrokeWidthCodec {
  def decode(j: JsValue): ViewBackgroundStrokeWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewBackgroundStrokeWidth] =
    ViewBackgroundStrokeWidthAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ViewBackgroundStrokeWidth): JsValue =
    j match {
      case x:ViewBackgroundStrokeWidthAsNumber /* TypeRef */ => ViewBackgroundStrokeWidthAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigHeight (UnionType)
object MarkConfigHeightCodec {
  def decode(j: JsValue): MarkConfigHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigHeight] =
    j.asOpt[JsNumber].map { MarkConfigHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigHeight): JsValue =
    j match {
      case MarkConfigHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineBottom (ConstantType)
object LineBottomCodec {
  def decode(j: JsValue): LineBottom =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LineBottom] =
    j match {
      case JsString("line-bottom") => Some(LineBottom())
      case _ => None
    }
  def encode(j: LineBottom): JsValue =
    JsString("line-bottom")
}


////////////////////////////////////////////////////////////////////////
// RectConfigBlend (UnionType)
object RectConfigBlendCodec {
  def decode(j: JsValue): RectConfigBlend =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigBlend] =
    BlendCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigBlend): JsValue =
    j match {
      case x:Blend /* TypeRef */ => BlendCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Vector2String (ConstrainedType)
object Vector2StringCodec {
  def decode(j: JsValue): Vector2String =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Vector2String] =
    try {
      ArrayOfStringCodec.decodeOpt(j)
        .map { Vector2String(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: Vector2String): JsValue =
    ArrayOfStringCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingFillDatum (UnionType)
object SharedEncodingFillDatumCodec {
  def decode(j: JsValue): SharedEncodingFillDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingFillDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingFillDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigRadius2 (ConstrainedType)
// see MarkConfigRadius2 (UnionType)

////////////////////////////////////////////////////////////////////////
// MarkDefY (UnionType)
object MarkDefYCodec {
  def decode(j: JsValue): MarkDefY =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefY] =
    j.asOpt[JsNumber].map { MarkDefYAsNumber(_) }.orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: MarkDefY): JsValue =
    j match {
      case MarkDefYAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisNumberArrayAsObject1Condition (UnionType)
object ConditionalAxisNumberArrayAsObject1ConditionCodec {
  def decode(j: JsValue): ConditionalAxisNumberArrayAsObject1Condition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisNumberArrayAsObject1Condition] =
    ConditionalPredicateValueDefNumberNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalPredicateValueDefNumberNullExprRefCodec.decodeOpt(j).map { ConditionalAxisNumberArrayAsObject1ConditionAsArrayOfConditionalPredicateValueDefNumberNullExprRef(_) } } 
  def encode(j: ConditionalAxisNumberArrayAsObject1Condition): JsValue =
    j match {
      case x:ConditionalPredicateValueDefNumberNullExprRef /* TypeRef */ => ConditionalPredicateValueDefNumberNullExprRefCodec.encode(x)
      case ConditionalAxisNumberArrayAsObject1ConditionAsArrayOfConditionalPredicateValueDefNumberNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalPredicateValueDefNumberNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigFillOpacity (UnionType)
object MarkConfigFillOpacityCodec {
  def decode(j: JsValue): MarkConfigFillOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigFillOpacity] =
    MarkConfigFillOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigFillOpacity): JsValue =
    j match {
      case x:MarkConfigFillOpacityAsNumber /* TypeRef */ => MarkConfigFillOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTickCount (UnionType)
object AxisTickCountCodec {
  def decode(j: JsValue): AxisTickCount =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTickCount] =
    j.asOpt[JsNumber].map { AxisTickCountAsNumber(_) }.orElse {
    TimeIntervalCodec.decodeOpt(j).orElse {
    TimeIntervalStepCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: AxisTickCount): JsValue =
    j match {
      case AxisTickCountAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:TimeInterval /* TypeRef */ => TimeIntervalCodec.encode(x)
      case x:TimeIntervalStep /* TypeRef */ => TimeIntervalStepCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigOuterRadius (ConstrainedType)
// see MarkConfigOuterRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// ConditionalParameterMarkPropFieldOrDatumDefAsObject1 (StructType)
object ConditionalParameterMarkPropFieldOrDatumDefAsObject1Codec {
  def decode(j: JsValue): ConditionalParameterMarkPropFieldOrDatumDefAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalParameterMarkPropFieldOrDatumDefAsObject1] =
    {
      val `empty` = (j \ "empty").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) }
      val `param` = (j \ "param").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`param`.isEmpty) { return None }
      val `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => ConditionalParameterMarkPropFieldOrDatumDefAsObject1BandPositionCodec.decodeOpt(x) }
      val `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => ConditionalParameterMarkPropFieldOrDatumDefAsObject1BinCodec.decodeOpt(x) }
      val `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) }
      val `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => ConditionalParameterMarkPropFieldOrDatumDefAsObject1TimeUnitCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) }
      val `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) }
      return Some(ConditionalParameterMarkPropFieldOrDatumDefAsObject1(
        `empty` = `empty`,
        `field` = `field`,
        `param` = `param`.get,
        `scale` = `scale`,
        `legend` = `legend`,
        `bandPosition` = `bandPosition`,
        `bin` = `bin`,
        `aggregate` = `aggregate`,
        `timeUnit` = `timeUnit`,
        `title` = `title`,
        `sort` = `sort`,
        `type` = `type`,
      ))
    }

  def encode(j: ConditionalParameterMarkPropFieldOrDatumDefAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`empty`.map { x => "empty" -> Json.toJson(x) },
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        Some("param" -> Json.toJson(j.`param`)),
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> ConditionalParameterMarkPropFieldOrDatumDefAsObject1BandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> ConditionalParameterMarkPropFieldOrDatumDefAsObject1BinCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> ConditionalParameterMarkPropFieldOrDatumDefAsObject1TimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// BarConfigStrokeJoin (UnionType)
object BarConfigStrokeJoinCodec {
  def decode(j: JsValue): BarConfigStrokeJoin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigStrokeJoin] =
    StrokeJoinCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigStrokeJoin): JsValue =
    j match {
      case x:StrokeJoin /* TypeRef */ => StrokeJoinCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleConfigZindex (UnionType)
object TitleConfigZindexCodec {
  def decode(j: JsValue): TitleConfigZindex =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigZindex] =
    TitleConfigZindexAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleConfigZindex): JsValue =
    j match {
      case x:TitleConfigZindexAsNumber /* TypeRef */ => TitleConfigZindexAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// IntervalSelectionConfigWithoutType (StructType)
object IntervalSelectionConfigWithoutTypeCodec {
  def decode(j: JsValue): IntervalSelectionConfigWithoutType =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[IntervalSelectionConfigWithoutType] =
    Some(IntervalSelectionConfigWithoutType(
      `clear` = (j \ "clear").asOpt[JsValue].flatMap { x => IntervalSelectionConfigWithoutTypeClearCodec.decodeOpt(x) },
      `on` = (j \ "on").asOpt[JsValue].flatMap { x => IntervalSelectionConfigWithoutTypeOnCodec.decodeOpt(x) },
      `resolve` = (j \ "resolve").asOpt[JsValue].flatMap { x => SelectionResolutionCodec.decodeOpt(x) },
      `translate` = (j \ "translate").asOpt[JsValue].flatMap { x => IntervalSelectionConfigWithoutTypeTranslateCodec.decodeOpt(x) },
      `mark` = (j \ "mark").asOpt[JsValue].flatMap { x => BrushConfigCodec.decodeOpt(x) },
      `encodings` = (j \ "encodings").asOpt[JsValue].flatMap { x => ArrayOfSingleDefUnitChannelCodec.decodeOpt(x) },
      `zoom` = (j \ "zoom").asOpt[JsValue].flatMap { x => IntervalSelectionConfigWithoutTypeZoomCodec.decodeOpt(x) },
    ))

  def encode(j: IntervalSelectionConfigWithoutType): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`clear`.map { x => "clear" -> IntervalSelectionConfigWithoutTypeClearCodec.encode(x) },
        j.`on`.map { x => "on" -> IntervalSelectionConfigWithoutTypeOnCodec.encode(x) },
        j.`resolve`.map { x => "resolve" -> SelectionResolutionCodec.encode(x) },
        j.`translate`.map { x => "translate" -> IntervalSelectionConfigWithoutTypeTranslateCodec.encode(x) },
        j.`mark`.map { x => "mark" -> BrushConfigCodec.encode(x) },
        j.`encodings`.map { x => "encodings" -> ArrayOfSingleDefUnitChannelCodec.encode(x) },
        j.`zoom`.map { x => "zoom" -> IntervalSelectionConfigWithoutTypeZoomCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TickConfigBaseline (UnionType)
object TickConfigBaselineCodec {
  def decode(j: JsValue): TickConfigBaseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigBaseline] =
    TextBaselineCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigBaseline): JsValue =
    j match {
      case x:TextBaseline /* TypeRef */ => TextBaselineCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsFont (UnionType)
object TitleParamsFontCodec {
  def decode(j: JsValue): TitleParamsFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsFont] =
    j.asOpt[String].map { TitleParamsFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleParamsFont): JsValue =
    j match {
      case TitleParamsFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionDistance (UnionType)
object ProjectionDistanceCodec {
  def decode(j: JsValue): ProjectionDistance =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionDistance] =
    j.asOpt[JsNumber].map { ProjectionDistanceAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionDistance): JsValue =
    j match {
      case ProjectionDistanceAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingKeyBin (UnionType)
object SharedEncodingKeyBinCodec {
  def decode(j: JsValue): SharedEncodingKeyBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingKeyBin] =
    j.asOpt[Boolean].map { SharedEncodingKeyBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    BinnedCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingKeyBinAsNull } } } } 
  def encode(j: SharedEncodingKeyBin): JsValue =
    j match {
      case SharedEncodingKeyBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case x:Binned /* TypeRef */ => BinnedCodec.encode(x)
      case SharedEncodingKeyBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingDescriptionBandPosition (ConstrainedType)
object SharedEncodingDescriptionBandPositionCodec {
  def decode(j: JsValue): SharedEncodingDescriptionBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingDescriptionBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingDescriptionBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingDescriptionBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTitleFontSize (UnionType)
object AxisConfigTitleFontSizeCodec {
  def decode(j: JsValue): AxisConfigTitleFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTitleFontSize] =
    AxisConfigTitleFontSizeAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigTitleFontSize): JsValue =
    j match {
      case x:AxisConfigTitleFontSizeAsNumber /* TypeRef */ => AxisConfigTitleFontSizeAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigDy (UnionType)
object BarConfigDyCodec {
  def decode(j: JsValue): BarConfigDy =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigDy] =
    j.asOpt[JsNumber].map { BarConfigDyAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigDy): JsValue =
    j match {
      case BarConfigDyAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ErrorBarDefTicks (UnionType)
object ErrorBarDefTicksCodec {
  def decode(j: JsValue): ErrorBarDefTicks =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ErrorBarDefTicks] =
    j.asOpt[Boolean].map { ErrorBarDefTicksAsBool(_) }.orElse {
    MarkConfigCodec.decodeOpt(j) } 
  def encode(j: ErrorBarDefTicks): JsValue =
    j match {
      case ErrorBarDefTicksAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:MarkConfig /* TypeRef */ => MarkConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigDiscreteBandSize (ConstrainedType)
// see RectConfigDiscreteBandSize (UnionType)

////////////////////////////////////////////////////////////////////////
// UnitSpecParamsElement (UnionType)
object UnitSpecParamsElementCodec {
  def decode(j: JsValue): UnitSpecParamsElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[UnitSpecParamsElement] =
    VariableParameterCodec.decodeOpt(j).orElse {
    SelectionParameterCodec.decodeOpt(j) } 
  def encode(j: UnitSpecParamsElement): JsValue =
    j match {
      case x:VariableParameter /* TypeRef */ => VariableParameterCodec.encode(x)
      case x:SelectionParameter /* TypeRef */ => SelectionParameterCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeWidthBin (UnionType)
object SharedEncodingStrokeWidthBinCodec {
  def decode(j: JsValue): SharedEncodingStrokeWidthBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeWidthBin] =
    j.asOpt[Boolean].map { SharedEncodingStrokeWidthBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingStrokeWidthBinAsNull } } } 
  def encode(j: SharedEncodingStrokeWidthBin): JsValue =
    j match {
      case SharedEncodingStrokeWidthBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case SharedEncodingStrokeWidthBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionDatumDefNumber (StructType)
object FieldOrDatumDefWithConditionDatumDefNumberCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionDatumDefNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionDatumDefNumber] =
    Some(FieldOrDatumDefWithConditionDatumDefNumber(
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionDatumDefNumberDatumCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionDatumDefNumberBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionDatumDefNumberConditionCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeCodec.decodeOpt(x) },
    ))

  def encode(j: FieldOrDatumDefWithConditionDatumDefNumber): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`datum`.map { x => "datum" -> FieldOrDatumDefWithConditionDatumDefNumberDatumCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> FieldOrDatumDefWithConditionDatumDefNumberBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> FieldOrDatumDefWithConditionDatumDefNumberConditionCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ErrorBandConfigBand (UnionType)
object ErrorBandConfigBandCodec {
  def decode(j: JsValue): ErrorBandConfigBand =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ErrorBandConfigBand] =
    j.asOpt[Boolean].map { ErrorBandConfigBandAsBool(_) }.orElse {
    MarkConfigCodec.decodeOpt(j) } 
  def encode(j: ErrorBandConfigBand): JsValue =
    j match {
      case ErrorBandConfigBandAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:MarkConfig /* TypeRef */ => MarkConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigStrokeCap (UnionType)
object RectConfigStrokeCapCodec {
  def decode(j: JsValue): RectConfigStrokeCap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigStrokeCap] =
    StrokeCapCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigStrokeCap): JsValue =
    j match {
      case x:StrokeCap /* TypeRef */ => StrokeCapCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LayerRepeatSpec (StructType)
object LayerRepeatSpecCodec {
  def decode(j: JsValue): LayerRepeatSpec =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LayerRepeatSpec] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `center` = (j \ "center").asOpt[JsValue].flatMap { x => LayerRepeatSpecCenterCodec.decodeOpt(x) }
      val `description` = (j \ "description").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `bounds` = (j \ "bounds").asOpt[JsValue].flatMap { x => LayerRepeatSpecBoundsCodec.decodeOpt(x) }
      val `columns` = (j \ "columns").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `resolve` = (j \ "resolve").asOpt[JsValue].flatMap { x => ResolveCodec.decodeOpt(x) }
      val `spec` = (j \ "spec").asOpt[JsValue].flatMap { x => LayerRepeatSpecSpecCodec.decodeOpt(x) }
      if(`spec`.isEmpty) { return None }
      val `align` = (j \ "align").asOpt[JsValue].flatMap { x => LayerRepeatSpecAlignCodec.decodeOpt(x) }
      val `data` = (j \ "data").asOpt[JsValue].flatMap { x => DataCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `repeat` = (j \ "repeat").asOpt[JsValue].flatMap { x => LayerRepeatMappingCodec.decodeOpt(x) }
      if(`repeat`.isEmpty) { return None }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => LayerRepeatSpecTitleCodec.decodeOpt(x) }
      val `spacing` = (j \ "spacing").asOpt[JsValue].flatMap { x => LayerRepeatSpecSpacingCodec.decodeOpt(x) }
      val `transform` = (j \ "transform").asOpt[JsValue].flatMap { x => ArrayOfTransformCodec.decodeOpt(x) }
      return Some(LayerRepeatSpec(
        `name` = `name`,
        `center` = `center`,
        `description` = `description`,
        `bounds` = `bounds`,
        `columns` = `columns`,
        `resolve` = `resolve`,
        `spec` = `spec`.get,
        `align` = `align`,
        `data` = `data`,
        `repeat` = `repeat`.get,
        `title` = `title`,
        `spacing` = `spacing`,
        `transform` = `transform`,
      ))
    }

  def encode(j: LayerRepeatSpec): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`center`.map { x => "center" -> LayerRepeatSpecCenterCodec.encode(x) },
        j.`description`.map { x => "description" -> Json.toJson(x) },
        j.`bounds`.map { x => "bounds" -> LayerRepeatSpecBoundsCodec.encode(x) },
        j.`columns`.map { x => "columns" -> Json.toJson(x) },
        j.`resolve`.map { x => "resolve" -> ResolveCodec.encode(x) },
        Some("spec" -> LayerRepeatSpecSpecCodec.encode(j.`spec`)),
        j.`align`.map { x => "align" -> LayerRepeatSpecAlignCodec.encode(x) },
        j.`data`.map { x => "data" -> DataCodec.encode(x) },
        Some("repeat" -> LayerRepeatMappingCodec.encode(j.`repeat`)),
        j.`title`.map { x => "title" -> LayerRepeatSpecTitleCodec.encode(x) },
        j.`spacing`.map { x => "spacing" -> LayerRepeatSpecSpacingCodec.encode(x) },
        j.`transform`.map { x => "transform" -> ArrayOfTransformCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ArrayOfNonNormalizedSpec (ArrayType)
object ArrayOfNonNormalizedSpecCodec {
  def decode(j: JsValue): Seq[NonNormalizedSpec] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[NonNormalizedSpec]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      NonNormalizedSpecCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[NonNormalizedSpec]): JsArray =
      JsArray(j.map { x => NonNormalizedSpecCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// ArrayOfConditionalValueDefNumber (ArrayType)
object ArrayOfConditionalValueDefNumberCodec {
  def decode(j: JsValue): Seq[ConditionalValueDefNumber] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[ConditionalValueDefNumber]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      ConditionalValueDefNumberCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[ConditionalValueDefNumber]): JsArray =
      JsArray(j.map { x => ConditionalValueDefNumberCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// TitleParamsSubtitleFont (UnionType)
object TitleParamsSubtitleFontCodec {
  def decode(j: JsValue): TitleParamsSubtitleFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsSubtitleFont] =
    j.asOpt[String].map { TitleParamsSubtitleFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleParamsSubtitleFont): JsValue =
    j match {
      case TitleParamsSubtitleFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTickColor (UnionType)
object AxisTickColorCodec {
  def decode(j: JsValue): AxisTickColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTickColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => AxisTickColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisColorCodec.decodeOpt(j) } } } 
  def encode(j: AxisTickColor): JsValue =
    j match {
      case AxisTickColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisColor /* TypeRef */ => ConditionalAxisColorCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewBackgroundOpacity (ConstrainedType)
// see ViewBackgroundOpacity (UnionType)

////////////////////////////////////////////////////////////////////////
// RegressionTransform (StructType)
object RegressionTransformCodec {
  def decode(j: JsValue): RegressionTransform =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RegressionTransform] =
    {
      val `method` = (j \ "method").asOpt[JsValue].flatMap { x => RegressionTransformMethodCodec.decodeOpt(x) }
      val `extent` = (j \ "extent").asOpt[JsValue].flatMap { x => RegressionTransformExtentCodec.decodeOpt(x) }
      val `params` = (j \ "params").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `as` = (j \ "as").asOpt[JsValue].flatMap { x => RegressionTransformAsCodec.decodeOpt(x) }
      val `on` = (j \ "on").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`on`.isEmpty) { return None }
      val `order` = (j \ "order").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `regression` = (j \ "regression").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`regression`.isEmpty) { return None }
      val `groupby` = (j \ "groupby").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) }
      return Some(RegressionTransform(
        `method` = `method`,
        `extent` = `extent`,
        `params` = `params`,
        `as` = `as`,
        `on` = `on`.get,
        `order` = `order`,
        `regression` = `regression`.get,
        `groupby` = `groupby`,
      ))
    }

  def encode(j: RegressionTransform): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`method`.map { x => "method" -> RegressionTransformMethodCodec.encode(x) },
        j.`extent`.map { x => "extent" -> RegressionTransformExtentCodec.encode(x) },
        j.`params`.map { x => "params" -> Json.toJson(x) },
        j.`as`.map { x => "as" -> RegressionTransformAsCodec.encode(x) },
        Some("on" -> Json.toJson(j.`on`)),
        j.`order`.map { x => "order" -> Json.toJson(x) },
        Some("regression" -> Json.toJson(j.`regression`)),
        j.`groupby`.map { x => "groupby" -> ArrayOfStringCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ImputeParamsFrame (ConstrainedType)
object ImputeParamsFrameCodec {
  def decode(j: JsValue): ImputeParamsFrame =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ImputeParamsFrame] =
    try {
      ArrayOfImputeParamsFrameElementCodec.decodeOpt(j)
        .map { ImputeParamsFrame(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ImputeParamsFrame): JsValue =
    ArrayOfImputeParamsFrameElementCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// Categorical (EnumType)
object CategoricalCodec {
  def decode(j: JsValue): Categorical =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Categorical] =
    j match {
      case JsString("accent") => Some(CategoricalAccent)
      case JsString("category10") => Some(CategoricalCategory10)
      case JsString("category20") => Some(CategoricalCategory20)
      case JsString("category20b") => Some(CategoricalCategory20b)
      case JsString("category20c") => Some(CategoricalCategory20c)
      case JsString("dark2") => Some(CategoricalDark2)
      case JsString("paired") => Some(CategoricalPaired)
      case JsString("pastel1") => Some(CategoricalPastel1)
      case JsString("pastel2") => Some(CategoricalPastel2)
      case JsString("set1") => Some(CategoricalSet1)
      case JsString("set2") => Some(CategoricalSet2)
      case JsString("set3") => Some(CategoricalSet3)
      case JsString("tableau10") => Some(CategoricalTableau10)
      case JsString("tableau20") => Some(CategoricalTableau20)
      case _ => None
    }
  def encode(j: Categorical): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// PositionDef (UnionType)
object PositionDefCodec {
  def decode(j: JsValue): PositionDef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PositionDef] =
    PositionFieldDefCodec.decodeOpt(j).orElse {
    PositionDatumDefCodec.decodeOpt(j).orElse {
    PositionValueDefCodec.decodeOpt(j) } } 
  def encode(j: PositionDef): JsValue =
    j match {
      case x:PositionFieldDef /* TypeRef */ => PositionFieldDefCodec.encode(x)
      case x:PositionDatumDef /* TypeRef */ => PositionDatumDefCodec.encode(x)
      case x:PositionValueDef /* TypeRef */ => PositionValueDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigDiscreteBandSize (UnionType)
object RectConfigDiscreteBandSizeCodec {
  def decode(j: JsValue): RectConfigDiscreteBandSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigDiscreteBandSize] =
    j.asOpt[JsNumber].map { RectConfigDiscreteBandSizeAsNumber(_) }.orElse {
    RelativeBandSizeCodec.decodeOpt(j) } 
  def encode(j: RectConfigDiscreteBandSize): JsValue =
    j match {
      case RectConfigDiscreteBandSizeAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:RelativeBandSize /* TypeRef */ => RelativeBandSizeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingYOffsetBandPosition (ConstrainedType)
object SharedEncodingYOffsetBandPositionCodec {
  def decode(j: JsValue): SharedEncodingYOffsetBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingYOffsetBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingYOffsetBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingYOffsetBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ConditionalValueDefGradientStringNullExprRef (UnionType)
object ConditionalValueDefGradientStringNullExprRefCodec {
  def decode(j: JsValue): ConditionalValueDefGradientStringNullExprRef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalValueDefGradientStringNullExprRef] =
    ConditionalPredicateValueDefGradientStringNullExprRefCodec.decodeOpt(j).orElse {
    ConditionalParameterValueDefGradientStringNullExprRefCodec.decodeOpt(j) } 
  def encode(j: ConditionalValueDefGradientStringNullExprRef): JsValue =
    j match {
      case x:ConditionalPredicateValueDefGradientStringNullExprRef /* TypeRef */ => ConditionalPredicateValueDefGradientStringNullExprRefCodec.encode(x)
      case x:ConditionalParameterValueDefGradientStringNullExprRef /* TypeRef */ => ConditionalParameterValueDefGradientStringNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// GraticuleGenerator (StructType)
object GraticuleGeneratorCodec {
  def decode(j: JsValue): GraticuleGenerator =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[GraticuleGenerator] =
    {
      val `graticule` = (j \ "graticule").asOpt[JsValue].flatMap { x => GraticuleGeneratorGraticuleCodec.decodeOpt(x) }
      if(`graticule`.isEmpty) { return None }
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      return Some(GraticuleGenerator(
        `graticule` = `graticule`.get,
        `name` = `name`,
      ))
    }

  def encode(j: GraticuleGenerator): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("graticule" -> GraticuleGeneratorGraticuleCodec.encode(j.`graticule`)),
        j.`name`.map { x => "name" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AxisLabelAngle (UnionType)
object AxisLabelAngleCodec {
  def decode(j: JsValue): AxisLabelAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisLabelAngle] =
    AxisLabelAngleAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisLabelAngle): JsValue =
    j match {
      case x:AxisLabelAngleAsNumber /* TypeRef */ => AxisLabelAngleAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingSizeValue (UnionType)
object SharedEncodingSizeValueCodec {
  def decode(j: JsValue): SharedEncodingSizeValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingSizeValue] =
    j.asOpt[JsNumber].map { SharedEncodingSizeValueAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingSizeValue): JsValue =
    j match {
      case SharedEncodingSizeValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTitleAlign (UnionType)
object AxisTitleAlignCodec {
  def decode(j: JsValue): AxisTitleAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTitleAlign] =
    AlignCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisTitleAlign): JsValue =
    j match {
      case x:Align /* TypeRef */ => AlignCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ErrorBarConfigTicks (UnionType)
object ErrorBarConfigTicksCodec {
  def decode(j: JsValue): ErrorBarConfigTicks =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ErrorBarConfigTicks] =
    j.asOpt[Boolean].map { ErrorBarConfigTicksAsBool(_) }.orElse {
    MarkConfigCodec.decodeOpt(j) } 
  def encode(j: ErrorBarConfigTicks): JsValue =
    j match {
      case ErrorBarConfigTicksAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:MarkConfig /* TypeRef */ => MarkConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingAngleBin (UnionType)
object SharedEncodingAngleBinCodec {
  def decode(j: JsValue): SharedEncodingAngleBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingAngleBin] =
    j.asOpt[Boolean].map { SharedEncodingAngleBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingAngleBinAsNull } } } 
  def encode(j: SharedEncodingAngleBin): JsValue =
    j match {
      case SharedEncodingAngleBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case SharedEncodingAngleBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingColorDatum (UnionType)
object SharedEncodingColorDatumCodec {
  def decode(j: JsValue): SharedEncodingColorDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingColorDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingColorDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigCursor (UnionType)
object MarkConfigCursorCodec {
  def decode(j: JsValue): MarkConfigCursor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigCursor] =
    CursorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigCursor): JsValue =
    j match {
      case x:Cursor /* TypeRef */ => CursorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LoessTransform (StructType)
object LoessTransformCodec {
  def decode(j: JsValue): LoessTransform =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LoessTransform] =
    {
      val `on` = (j \ "on").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`on`.isEmpty) { return None }
      val `bandwidth` = (j \ "bandwidth").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `as` = (j \ "as").asOpt[JsValue].flatMap { x => LoessTransformAsCodec.decodeOpt(x) }
      val `groupby` = (j \ "groupby").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) }
      val `loess` = (j \ "loess").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`loess`.isEmpty) { return None }
      return Some(LoessTransform(
        `on` = `on`.get,
        `bandwidth` = `bandwidth`,
        `as` = `as`,
        `groupby` = `groupby`,
        `loess` = `loess`.get,
      ))
    }

  def encode(j: LoessTransform): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("on" -> Json.toJson(j.`on`)),
        j.`bandwidth`.map { x => "bandwidth" -> Json.toJson(x) },
        j.`as`.map { x => "as" -> LoessTransformAsCodec.encode(x) },
        j.`groupby`.map { x => "groupby" -> ArrayOfStringCodec.encode(x) },
        Some("loess" -> Json.toJson(j.`loess`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// MarkDefWidth (UnionType)
object MarkDefWidthCodec {
  def decode(j: JsValue): MarkDefWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefWidth] =
    j.asOpt[JsNumber].map { MarkDefWidthAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RelativeBandSizeCodec.decodeOpt(j) } } 
  def encode(j: MarkDefWidth): JsValue =
    j match {
      case MarkDefWidthAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RelativeBandSize /* TypeRef */ => RelativeBandSizeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigStroke (UnionType)
object BarConfigStrokeCodec {
  def decode(j: JsValue): BarConfigStroke =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigStroke] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => BarConfigStrokeAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: BarConfigStroke): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case BarConfigStrokeAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisLabelOpacity (UnionType)
object AxisLabelOpacityCodec {
  def decode(j: JsValue): AxisLabelOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisLabelOpacity] =
    j.asOpt[JsNumber].map { AxisLabelOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisLabelOpacity): JsValue =
    j match {
      case AxisLabelOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfFieldDefWithoutScale (ArrayType)
object ArrayOfFieldDefWithoutScaleCodec {
  def decode(j: JsValue): Seq[FieldDefWithoutScale] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[FieldDefWithoutScale]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      FieldDefWithoutScaleCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[FieldDefWithoutScale]): JsArray =
      JsArray(j.map { x => FieldDefWithoutScaleCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// IntervalSelectionConfigWithoutTypeZoom (UnionType)
object IntervalSelectionConfigWithoutTypeZoomCodec {
  def decode(j: JsValue): IntervalSelectionConfigWithoutTypeZoom =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[IntervalSelectionConfigWithoutTypeZoom] =
    j.asOpt[String].map { IntervalSelectionConfigWithoutTypeZoomAsString(_) }.orElse {
    j.asOpt[Boolean].map { IntervalSelectionConfigWithoutTypeZoomAsBool(_) } } 
  def encode(j: IntervalSelectionConfigWithoutTypeZoom): JsValue =
    j match {
      case IntervalSelectionConfigWithoutTypeZoomAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case IntervalSelectionConfigWithoutTypeZoomAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigBandPaddingOuter (ConstrainedType)
// see ScaleConfigBandPaddingOuter (UnionType)

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefAngle (UnionType)
object OverlayMarkDefAngleCodec {
  def decode(j: JsValue): OverlayMarkDefAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefAngle] =
    OverlayMarkDefAngleAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefAngle): JsValue =
    j match {
      case x:OverlayMarkDefAngleAsNumber /* TypeRef */ => OverlayMarkDefAngleAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelVConcatSpecBackground (UnionType)
object TopLevelVConcatSpecBackgroundCodec {
  def decode(j: JsValue): TopLevelVConcatSpecBackground =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelVConcatSpecBackground] =
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TopLevelVConcatSpecBackground): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigLabelFontSize (UnionType)
object AxisConfigLabelFontSizeCodec {
  def decode(j: JsValue): AxisConfigLabelFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigLabelFontSize] =
    AxisConfigLabelFontSizeAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigLabelFontSize): JsValue =
    j match {
      case x:AxisConfigLabelFontSizeAsNumber /* TypeRef */ => AxisConfigLabelFontSizeAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefFontStyle (UnionType)
object MarkDefFontStyleCodec {
  def decode(j: JsValue): MarkDefFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefFontStyle] =
    j.asOpt[String].map { MarkDefFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefFontStyle): JsValue =
    j match {
      case MarkDefFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigAngle (UnionType)
object RectConfigAngleCodec {
  def decode(j: JsValue): RectConfigAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigAngle] =
    RectConfigAngleAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigAngle): JsValue =
    j match {
      case x:RectConfigAngleAsNumber /* TypeRef */ => RectConfigAngleAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeWidthTimeUnit (UnionType)
object SharedEncodingStrokeWidthTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingStrokeWidthTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeWidthTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingStrokeWidthTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BindRadioSelectInput (EnumType)
object BindRadioSelectInputCodec {
  def decode(j: JsValue): BindRadioSelectInput =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BindRadioSelectInput] =
    j match {
      case JsString("radio") => Some(BindRadioSelectInputRadio)
      case JsString("select") => Some(BindRadioSelectInputSelect)
      case _ => None
    }
  def encode(j: BindRadioSelectInput): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// TitleConfig (StructType)
object TitleConfigCodec {
  def decode(j: JsValue): TitleConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TitleConfig] =
    Some(TitleConfig(
      `anchor` = (j \ "anchor").asOpt[JsValue].flatMap { x => TitleConfigAnchorCodec.decodeOpt(x) },
      `subtitleFontSize` = (j \ "subtitleFontSize").asOpt[JsValue].flatMap { x => TitleConfigSubtitleFontSizeCodec.decodeOpt(x) },
      `dy` = (j \ "dy").asOpt[JsValue].flatMap { x => TitleConfigDyCodec.decodeOpt(x) },
      `angle` = (j \ "angle").asOpt[JsValue].flatMap { x => TitleConfigAngleCodec.decodeOpt(x) },
      `align` = (j \ "align").asOpt[JsValue].flatMap { x => AlignCodec.decodeOpt(x) },
      `fontStyle` = (j \ "fontStyle").asOpt[JsValue].flatMap { x => TitleConfigFontStyleCodec.decodeOpt(x) },
      `frame` = (j \ "frame").asOpt[JsValue].flatMap { x => TitleConfigFrameCodec.decodeOpt(x) },
      `font` = (j \ "font").asOpt[JsValue].flatMap { x => TitleConfigFontCodec.decodeOpt(x) },
      `offset` = (j \ "offset").asOpt[JsValue].flatMap { x => TitleConfigOffsetCodec.decodeOpt(x) },
      `subtitleColor` = (j \ "subtitleColor").asOpt[JsValue].flatMap { x => TitleConfigSubtitleColorCodec.decodeOpt(x) },
      `aria` = (j \ "aria").asOpt[JsValue].flatMap { x => TitleConfigAriaCodec.decodeOpt(x) },
      `dx` = (j \ "dx").asOpt[JsValue].flatMap { x => TitleConfigDxCodec.decodeOpt(x) },
      `subtitleFont` = (j \ "subtitleFont").asOpt[JsValue].flatMap { x => TitleConfigSubtitleFontCodec.decodeOpt(x) },
      `subtitleLineHeight` = (j \ "subtitleLineHeight").asOpt[JsValue].flatMap { x => TitleConfigSubtitleLineHeightCodec.decodeOpt(x) },
      `baseline` = (j \ "baseline").asOpt[JsValue].flatMap { x => TextBaselineCodec.decodeOpt(x) },
      `subtitleFontStyle` = (j \ "subtitleFontStyle").asOpt[JsValue].flatMap { x => TitleConfigSubtitleFontStyleCodec.decodeOpt(x) },
      `subtitleFontWeight` = (j \ "subtitleFontWeight").asOpt[JsValue].flatMap { x => TitleConfigSubtitleFontWeightCodec.decodeOpt(x) },
      `color` = (j \ "color").asOpt[JsValue].flatMap { x => TitleConfigColorCodec.decodeOpt(x) },
      `subtitlePadding` = (j \ "subtitlePadding").asOpt[JsValue].flatMap { x => TitleConfigSubtitlePaddingCodec.decodeOpt(x) },
      `zindex` = (j \ "zindex").asOpt[JsValue].flatMap { x => TitleConfigZindexCodec.decodeOpt(x) },
      `lineHeight` = (j \ "lineHeight").asOpt[JsValue].flatMap { x => TitleConfigLineHeightCodec.decodeOpt(x) },
      `orient` = (j \ "orient").asOpt[JsValue].flatMap { x => TitleConfigOrientCodec.decodeOpt(x) },
      `fontSize` = (j \ "fontSize").asOpt[JsValue].flatMap { x => TitleConfigFontSizeCodec.decodeOpt(x) },
      `limit` = (j \ "limit").asOpt[JsValue].flatMap { x => TitleConfigLimitCodec.decodeOpt(x) },
      `fontWeight` = (j \ "fontWeight").asOpt[JsValue].flatMap { x => TitleConfigFontWeightCodec.decodeOpt(x) },
    ))

  def encode(j: TitleConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`anchor`.map { x => "anchor" -> TitleConfigAnchorCodec.encode(x) },
        j.`subtitleFontSize`.map { x => "subtitleFontSize" -> TitleConfigSubtitleFontSizeCodec.encode(x) },
        j.`dy`.map { x => "dy" -> TitleConfigDyCodec.encode(x) },
        j.`angle`.map { x => "angle" -> TitleConfigAngleCodec.encode(x) },
        j.`align`.map { x => "align" -> AlignCodec.encode(x) },
        j.`fontStyle`.map { x => "fontStyle" -> TitleConfigFontStyleCodec.encode(x) },
        j.`frame`.map { x => "frame" -> TitleConfigFrameCodec.encode(x) },
        j.`font`.map { x => "font" -> TitleConfigFontCodec.encode(x) },
        j.`offset`.map { x => "offset" -> TitleConfigOffsetCodec.encode(x) },
        j.`subtitleColor`.map { x => "subtitleColor" -> TitleConfigSubtitleColorCodec.encode(x) },
        j.`aria`.map { x => "aria" -> TitleConfigAriaCodec.encode(x) },
        j.`dx`.map { x => "dx" -> TitleConfigDxCodec.encode(x) },
        j.`subtitleFont`.map { x => "subtitleFont" -> TitleConfigSubtitleFontCodec.encode(x) },
        j.`subtitleLineHeight`.map { x => "subtitleLineHeight" -> TitleConfigSubtitleLineHeightCodec.encode(x) },
        j.`baseline`.map { x => "baseline" -> TextBaselineCodec.encode(x) },
        j.`subtitleFontStyle`.map { x => "subtitleFontStyle" -> TitleConfigSubtitleFontStyleCodec.encode(x) },
        j.`subtitleFontWeight`.map { x => "subtitleFontWeight" -> TitleConfigSubtitleFontWeightCodec.encode(x) },
        j.`color`.map { x => "color" -> TitleConfigColorCodec.encode(x) },
        j.`subtitlePadding`.map { x => "subtitlePadding" -> TitleConfigSubtitlePaddingCodec.encode(x) },
        j.`zindex`.map { x => "zindex" -> TitleConfigZindexCodec.encode(x) },
        j.`lineHeight`.map { x => "lineHeight" -> TitleConfigLineHeightCodec.encode(x) },
        j.`orient`.map { x => "orient" -> TitleConfigOrientCodec.encode(x) },
        j.`fontSize`.map { x => "fontSize" -> TitleConfigFontSizeCodec.encode(x) },
        j.`limit`.map { x => "limit" -> TitleConfigLimitCodec.encode(x) },
        j.`fontWeight`.map { x => "fontWeight" -> TitleConfigFontWeightCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeOpacity (StructType)
object SharedEncodingStrokeOpacityCodec {
  def decode(j: JsValue): SharedEncodingStrokeOpacity =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeOpacity] =
    Some(SharedEncodingStrokeOpacity(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingStrokeOpacityDatumCodec.decodeOpt(x) },
      `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingStrokeOpacityBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => SharedEncodingStrokeOpacityConditionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingStrokeOpacityBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingStrokeOpacityValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingStrokeOpacityTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => SharedEncodingStrokeOpacityTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingStrokeOpacity): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingStrokeOpacityDatumCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingStrokeOpacityBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> SharedEncodingStrokeOpacityConditionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingStrokeOpacityBinCodec.encode(x) },
        j.`value`.map { x => "value" -> SharedEncodingStrokeOpacityValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingStrokeOpacityTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> SharedEncodingStrokeOpacityTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LegendConfigLabelColor (UnionType)
object LegendConfigLabelColorCodec {
  def decode(j: JsValue): LegendConfigLabelColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigLabelColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => LegendConfigLabelColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: LegendConfigLabelColor): JsValue =
    j match {
      case LegendConfigLabelColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingDescriptionCondition (UnionType)
object SharedEncodingDescriptionConditionCodec {
  def decode(j: JsValue): SharedEncodingDescriptionCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingDescriptionCondition] =
    ConditionalValueDefStringExprRefCodec.decodeOpt(j).orElse {
    ConditionalValueDefStringNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefStringExprRefCodec.decodeOpt(j).map { SharedEncodingDescriptionConditionAsArrayOfConditionalValueDefStringExprRef(_) }.orElse {
    ConditionalMarkPropFieldOrDatumDefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefStringNullExprRefCodec.decodeOpt(j).map { SharedEncodingDescriptionConditionAsArrayOfConditionalValueDefStringNullExprRef(_) } } } } } 
  def encode(j: SharedEncodingDescriptionCondition): JsValue =
    j match {
      case x:ConditionalValueDefStringExprRef /* TypeRef */ => ConditionalValueDefStringExprRefCodec.encode(x)
      case x:ConditionalValueDefStringNullExprRef /* TypeRef */ => ConditionalValueDefStringNullExprRefCodec.encode(x)
      case SharedEncodingDescriptionConditionAsArrayOfConditionalValueDefStringExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefStringExprRefCodec.encode(x)
      case x:ConditionalMarkPropFieldOrDatumDef /* TypeRef */ => ConditionalMarkPropFieldOrDatumDefCodec.encode(x)
      case SharedEncodingDescriptionConditionAsArrayOfConditionalValueDefStringNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefStringNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisNumberAsObject2 (StructType)
object ConditionalAxisNumberAsObject2Codec {
  def decode(j: JsValue): ConditionalAxisNumberAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalAxisNumberAsObject2] =
    {
      val `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => ConditionalAxisNumberAsObject2ConditionCodec.decodeOpt(x) }
      if(`condition`.isEmpty) { return None }
      val `expr` = (j \ "expr").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`expr`.isEmpty) { return None }
      return Some(ConditionalAxisNumberAsObject2(
        `condition` = `condition`.get,
        `expr` = `expr`.get,
      ))
    }

  def encode(j: ConditionalAxisNumberAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("condition" -> ConditionalAxisNumberAsObject2ConditionCodec.encode(j.`condition`)),
        Some("expr" -> Json.toJson(j.`expr`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// BoxPlotConfigMedian (UnionType)
object BoxPlotConfigMedianCodec {
  def decode(j: JsValue): BoxPlotConfigMedian =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BoxPlotConfigMedian] =
    j.asOpt[Boolean].map { BoxPlotConfigMedianAsBool(_) }.orElse {
    MarkConfigCodec.decodeOpt(j) } 
  def encode(j: BoxPlotConfigMedian): JsValue =
    j match {
      case BoxPlotConfigMedianAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:MarkConfig /* TypeRef */ => MarkConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigCornerRadiusBottomRight (UnionType)
object LineConfigCornerRadiusBottomRightCodec {
  def decode(j: JsValue): LineConfigCornerRadiusBottomRight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigCornerRadiusBottomRight] =
    j.asOpt[JsNumber].map { LineConfigCornerRadiusBottomRightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigCornerRadiusBottomRight): JsValue =
    j match {
      case LineConfigCornerRadiusBottomRightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Text (UnionType)
object TextCodec {
  def decode(j: JsValue): Text =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Text] =
    j.asOpt[String].map { TextAsString(_) }.orElse {
    ArrayOfStringCodec.decodeOpt(j).map { TextAsArrayOfString(_) } } 
  def encode(j: Text): JsValue =
    j match {
      case TextAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case TextAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingYErrorBandPosition (ConstrainedType)
object SharedEncodingYErrorBandPositionCodec {
  def decode(j: JsValue): SharedEncodingYErrorBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingYErrorBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingYErrorBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingYErrorBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// LayerSpecTitle (UnionType)
object LayerSpecTitleCodec {
  def decode(j: JsValue): LayerSpecTitle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LayerSpecTitle] =
    TextCodec.decodeOpt(j).orElse {
    TitleParamsCodec.decodeOpt(j) } 
  def encode(j: LayerSpecTitle): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:TitleParams /* TypeRef */ => TitleParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTitleBaseline (UnionType)
object AxisConfigTitleBaselineCodec {
  def decode(j: JsValue): AxisConfigTitleBaseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTitleBaseline] =
    TextBaselineCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigTitleBaseline): JsValue =
    j match {
      case x:TextBaseline /* TypeRef */ => TextBaselineCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigSymbolBaseStrokeColor (UnionType)
object LegendConfigSymbolBaseStrokeColorCodec {
  def decode(j: JsValue): LegendConfigSymbolBaseStrokeColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigSymbolBaseStrokeColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => LegendConfigSymbolBaseStrokeColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: LegendConfigSymbolBaseStrokeColor): JsValue =
    j match {
      case LegendConfigSymbolBaseStrokeColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingLatitudeBandPosition (ConstrainedType)
object SharedEncodingLatitudeBandPositionCodec {
  def decode(j: JsValue): SharedEncodingLatitudeBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingLatitudeBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingLatitudeBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingLatitudeBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkConfigTheta2 (UnionType)
object MarkConfigTheta2Codec {
  def decode(j: JsValue): MarkConfigTheta2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigTheta2] =
    j.asOpt[JsNumber].map { MarkConfigTheta2AsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigTheta2): JsValue =
    j match {
      case MarkConfigTheta2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1BandPosition (ConstrainedType)
object ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1BandPositionCodec {
  def decode(j: JsValue): ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1BandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1BandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1BandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1BandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterMarkPropFieldOrDatumDefAsObject1TimeUnit (UnionType)
object ConditionalParameterMarkPropFieldOrDatumDefAsObject1TimeUnitCodec {
  def decode(j: JsValue): ConditionalParameterMarkPropFieldOrDatumDefAsObject1TimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalParameterMarkPropFieldOrDatumDefAsObject1TimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: ConditionalParameterMarkPropFieldOrDatumDefAsObject1TimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ValueDefWithConditionMarkPropFieldOrDatumDefNumberValue (UnionType)
object ValueDefWithConditionMarkPropFieldOrDatumDefNumberValueCodec {
  def decode(j: JsValue): ValueDefWithConditionMarkPropFieldOrDatumDefNumberValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ValueDefWithConditionMarkPropFieldOrDatumDefNumberValue] =
    j.asOpt[JsNumber].map { ValueDefWithConditionMarkPropFieldOrDatumDefNumberValueAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ValueDefWithConditionMarkPropFieldOrDatumDefNumberValue): JsValue =
    j match {
      case ValueDefWithConditionMarkPropFieldOrDatumDefNumberValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelHConcatSpecAutosize (UnionType)
object TopLevelHConcatSpecAutosizeCodec {
  def decode(j: JsValue): TopLevelHConcatSpecAutosize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelHConcatSpecAutosize] =
    AutosizeTypeCodec.decodeOpt(j).orElse {
    AutoSizeParamsCodec.decodeOpt(j) } 
  def encode(j: TopLevelHConcatSpecAutosize): JsValue =
    j match {
      case x:AutosizeType /* TypeRef */ => AutosizeTypeCodec.encode(x)
      case x:AutoSizeParams /* TypeRef */ => AutoSizeParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigStrokeWidthAsNumber (ConstrainedType)
object BarConfigStrokeWidthAsNumberCodec {
  def decode(j: JsValue): BarConfigStrokeWidthAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BarConfigStrokeWidthAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { BarConfigStrokeWidthAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: BarConfigStrokeWidthAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// HeaderConfigTitlePadding (UnionType)
object HeaderConfigTitlePaddingCodec {
  def decode(j: JsValue): HeaderConfigTitlePadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigTitlePadding] =
    j.asOpt[JsNumber].map { HeaderConfigTitlePaddingAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderConfigTitlePadding): JsValue =
    j match {
      case HeaderConfigTitlePaddingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigAspect (UnionType)
object MarkConfigAspectCodec {
  def decode(j: JsValue): MarkConfigAspect =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigAspect] =
    j.asOpt[Boolean].map { MarkConfigAspectAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigAspect): JsValue =
    j match {
      case MarkConfigAspectAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefLineHeight (UnionType)
object OverlayMarkDefLineHeightCodec {
  def decode(j: JsValue): OverlayMarkDefLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefLineHeight] =
    j.asOpt[JsNumber].map { OverlayMarkDefLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefLineHeight): JsValue =
    j match {
      case OverlayMarkDefLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigColor (UnionType)
object MarkConfigColorCodec {
  def decode(j: JsValue): MarkConfigColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigColor] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: MarkConfigColor): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigWidth (UnionType)
object AreaConfigWidthCodec {
  def decode(j: JsValue): AreaConfigWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigWidth] =
    j.asOpt[JsNumber].map { AreaConfigWidthAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigWidth): JsValue =
    j match {
      case AreaConfigWidthAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldDefWithoutScale (StructType)
object FieldDefWithoutScaleCodec {
  def decode(j: JsValue): FieldDefWithoutScale =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldDefWithoutScale] =
    Some(FieldDefWithoutScale(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => FieldDefWithoutScaleBandPositionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => FieldDefWithoutScaleBinCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => FieldDefWithoutScaleTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) },
    ))

  def encode(j: FieldDefWithoutScale): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> FieldDefWithoutScaleBandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> FieldDefWithoutScaleBinCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> FieldDefWithoutScaleTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LineConfigStrokeMiterLimit (UnionType)
object LineConfigStrokeMiterLimitCodec {
  def decode(j: JsValue): LineConfigStrokeMiterLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigStrokeMiterLimit] =
    j.asOpt[JsNumber].map { LineConfigStrokeMiterLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigStrokeMiterLimit): JsValue =
    j match {
      case LineConfigStrokeMiterLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfAggregatedFieldDef (ArrayType)
object ArrayOfAggregatedFieldDefCodec {
  def decode(j: JsValue): Seq[AggregatedFieldDef] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[AggregatedFieldDef]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      AggregatedFieldDefCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[AggregatedFieldDef]): JsArray =
      JsArray(j.map { x => AggregatedFieldDefCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// ErrorBarDefColor (UnionType)
object ErrorBarDefColorCodec {
  def decode(j: JsValue): ErrorBarDefColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ErrorBarDefColor] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: ErrorBarDefColor): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigPoint (UnionType)
object AreaConfigPointCodec {
  def decode(j: JsValue): AreaConfigPoint =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigPoint] =
    j.asOpt[Boolean].map { AreaConfigPointAsBool(_) }.orElse {
    OverlayMarkDefCodec.decodeOpt(j).orElse {
    TransparentCodec.decodeOpt(j) } } 
  def encode(j: AreaConfigPoint): JsValue =
    j match {
      case AreaConfigPointAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:OverlayMarkDef /* TypeRef */ => OverlayMarkDefCodec.encode(x)
      case x:Transparent /* TypeRef */ => TransparentCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Baseline (EnumType)
object BaselineCodec {
  def decode(j: JsValue): Baseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Baseline] =
    j match {
      case JsString("top") => Some(BaselineTop)
      case JsString("middle") => Some(BaselineMiddle)
      case JsString("bottom") => Some(BaselineBottom)
      case _ => None
    }
  def encode(j: Baseline): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// ScalePadding (UnionType)
object ScalePaddingCodec {
  def decode(j: JsValue): ScalePadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScalePadding] =
    j.asOpt[JsNumber].map { ScalePaddingAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScalePadding): JsValue =
    j match {
      case ScalePaddingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTickCount (UnionType)
object AxisConfigTickCountCodec {
  def decode(j: JsValue): AxisConfigTickCount =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTickCount] =
    j.asOpt[JsNumber].map { AxisConfigTickCountAsNumber(_) }.orElse {
    TimeIntervalCodec.decodeOpt(j).orElse {
    TimeIntervalStepCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: AxisConfigTickCount): JsValue =
    j match {
      case AxisConfigTickCountAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:TimeInterval /* TypeRef */ => TimeIntervalCodec.encode(x)
      case x:TimeIntervalStep /* TypeRef */ => TimeIntervalStepCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigFont (UnionType)
object LineConfigFontCodec {
  def decode(j: JsValue): LineConfigFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigFont] =
    j.asOpt[String].map { LineConfigFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigFont): JsValue =
    j match {
      case LineConfigFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// WindowFieldDefOp (UnionType)
object WindowFieldDefOpCodec {
  def decode(j: JsValue): WindowFieldDefOp =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[WindowFieldDefOp] =
    AggregateOpCodec.decodeOpt(j).orElse {
    WindowOnlyOpCodec.decodeOpt(j) } 
  def encode(j: WindowFieldDefOp): JsValue =
    j match {
      case x:AggregateOp /* TypeRef */ => AggregateOpCodec.encode(x)
      case x:WindowOnlyOp /* TypeRef */ => WindowOnlyOpCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigLimit (UnionType)
object MarkConfigLimitCodec {
  def decode(j: JsValue): MarkConfigLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigLimit] =
    j.asOpt[JsNumber].map { MarkConfigLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigLimit): JsValue =
    j match {
      case MarkConfigLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SequentialSingleHue (EnumType)
object SequentialSingleHueCodec {
  def decode(j: JsValue): SequentialSingleHue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SequentialSingleHue] =
    j match {
      case JsString("blues") => Some(SequentialSingleHueBlues)
      case JsString("tealblues") => Some(SequentialSingleHueTealblues)
      case JsString("teals") => Some(SequentialSingleHueTeals)
      case JsString("greens") => Some(SequentialSingleHueGreens)
      case JsString("browns") => Some(SequentialSingleHueBrowns)
      case JsString("greys") => Some(SequentialSingleHueGreys)
      case JsString("purples") => Some(SequentialSingleHuePurples)
      case JsString("warmgreys") => Some(SequentialSingleHueWarmgreys)
      case JsString("reds") => Some(SequentialSingleHueReds)
      case JsString("oranges") => Some(SequentialSingleHueOranges)
      case _ => None
    }
  def encode(j: SequentialSingleHue): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// AggregateOp (EnumType)
object AggregateOpCodec {
  def decode(j: JsValue): AggregateOp =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AggregateOp] =
    j match {
      case JsString("argmax") => Some(AggregateOpArgmax)
      case JsString("argmin") => Some(AggregateOpArgmin)
      case JsString("average") => Some(AggregateOpAverage)
      case JsString("count") => Some(AggregateOpCount)
      case JsString("distinct") => Some(AggregateOpDistinct)
      case JsString("max") => Some(AggregateOpMax)
      case JsString("mean") => Some(AggregateOpMean)
      case JsString("median") => Some(AggregateOpMedian)
      case JsString("min") => Some(AggregateOpMin)
      case JsString("missing") => Some(AggregateOpMissing)
      case JsString("product") => Some(AggregateOpProduct)
      case JsString("q1") => Some(AggregateOpQ1)
      case JsString("q3") => Some(AggregateOpQ3)
      case JsString("ci0") => Some(AggregateOpCi0)
      case JsString("ci1") => Some(AggregateOpCi1)
      case JsString("stderr") => Some(AggregateOpStderr)
      case JsString("stdev") => Some(AggregateOpStdev)
      case JsString("stdevp") => Some(AggregateOpStdevp)
      case JsString("sum") => Some(AggregateOpSum)
      case JsString("valid") => Some(AggregateOpValid)
      case JsString("values") => Some(AggregateOpValues)
      case JsString("variance") => Some(AggregateOpVariance)
      case JsString("variancep") => Some(AggregateOpVariancep)
      case _ => None
    }
  def encode(j: AggregateOp): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// ValueDefWithConditionStringFieldDefTextValue (UnionType)
object ValueDefWithConditionStringFieldDefTextValueCodec {
  def decode(j: JsValue): ValueDefWithConditionStringFieldDefTextValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ValueDefWithConditionStringFieldDefTextValue] =
    TextCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ValueDefWithConditionStringFieldDefTextValue): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// EventStreamAsObject1Source (EnumType)
object EventStreamAsObject1SourceCodec {
  def decode(j: JsValue): EventStreamAsObject1Source =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[EventStreamAsObject1Source] =
    j match {
      case JsString("view") => Some(EventStreamAsObject1SourceView)
      case JsString("scope") => Some(EventStreamAsObject1SourceScope)
      case _ => None
    }
  def encode(j: EventStreamAsObject1Source): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// HeaderTitleFontSize (ConstrainedType)
// see HeaderTitleFontSize (UnionType)

////////////////////////////////////////////////////////////////////////
// TickConfigText (UnionType)
object TickConfigTextCodec {
  def decode(j: JsValue): TickConfigText =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigText] =
    TextCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigText): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigSize (ConstrainedType)
// see RectConfigSize (UnionType)

////////////////////////////////////////////////////////////////////////
// LegendConfigLabelOffsetAsNumber (ConstrainedType)
object LegendConfigLabelOffsetAsNumberCodec {
  def decode(j: JsValue): LegendConfigLabelOffsetAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LegendConfigLabelOffsetAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { LegendConfigLabelOffsetAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: LegendConfigLabelOffsetAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisNumberArrayAsObject2 (StructType)
object ConditionalAxisNumberArrayAsObject2Codec {
  def decode(j: JsValue): ConditionalAxisNumberArrayAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalAxisNumberArrayAsObject2] =
    {
      val `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => ConditionalAxisNumberArrayAsObject2ConditionCodec.decodeOpt(x) }
      if(`condition`.isEmpty) { return None }
      val `expr` = (j \ "expr").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`expr`.isEmpty) { return None }
      return Some(ConditionalAxisNumberArrayAsObject2(
        `condition` = `condition`.get,
        `expr` = `expr`.get,
      ))
    }

  def encode(j: ConditionalAxisNumberArrayAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("condition" -> ConditionalAxisNumberArrayAsObject2ConditionCodec.encode(j.`condition`)),
        Some("expr" -> Json.toJson(j.`expr`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ProjectionConfigSize (UnionType)
object ProjectionConfigSizeCodec {
  def decode(j: JsValue): ProjectionConfigSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigSize] =
    Vector2NumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigSize): JsValue =
    j match {
      case x:Vector2Number /* TypeRef */ => Vector2NumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigTheta (UnionType)
object TickConfigThetaCodec {
  def decode(j: JsValue): TickConfigTheta =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigTheta] =
    j.asOpt[JsNumber].map { TickConfigThetaAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigTheta): JsValue =
    j match {
      case TickConfigThetaAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderLabelLineHeight (UnionType)
object HeaderLabelLineHeightCodec {
  def decode(j: JsValue): HeaderLabelLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderLabelLineHeight] =
    j.asOpt[JsNumber].map { HeaderLabelLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderLabelLineHeight): JsValue =
    j match {
      case HeaderLabelLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigOuterRadius (ConstrainedType)
// see LineConfigOuterRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// LatLongFieldDef (StructType)
object LatLongFieldDefCodec {
  def decode(j: JsValue): LatLongFieldDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LatLongFieldDef] =
    Some(LatLongFieldDef(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => LatLongFieldDefBandPositionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => x.asOpt[JsNull.type].map { _ => JsNull } },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => LatLongFieldDefTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => LatLongFieldDefTypeCodec.decodeOpt(x) },
    ))

  def encode(j: LatLongFieldDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> LatLongFieldDefBandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> Json.toJson(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> LatLongFieldDefTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> LatLongFieldDefTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LineConfigInnerRadius (ConstrainedType)
// see LineConfigInnerRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// AxisDomainCap (UnionType)
object AxisDomainCapCodec {
  def decode(j: JsValue): AxisDomainCap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisDomainCap] =
    StrokeCapCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisDomainCap): JsValue =
    j match {
      case x:StrokeCap /* TypeRef */ => StrokeCapCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingLatitude2BandPosition (ConstrainedType)
object SharedEncodingLatitude2BandPositionCodec {
  def decode(j: JsValue): SharedEncodingLatitude2BandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingLatitude2BandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingLatitude2BandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingLatitude2BandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// TickConfigDx (UnionType)
object TickConfigDxCodec {
  def decode(j: JsValue): TickConfigDx =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigDx] =
    j.asOpt[JsNumber].map { TickConfigDxAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigDx): JsValue =
    j match {
      case TickConfigDxAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigMaxExtent (UnionType)
object AxisConfigMaxExtentCodec {
  def decode(j: JsValue): AxisConfigMaxExtent =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigMaxExtent] =
    j.asOpt[JsNumber].map { AxisConfigMaxExtentAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigMaxExtent): JsValue =
    j match {
      case AxisConfigMaxExtentAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingYOffsetTimeUnit (UnionType)
object SharedEncodingYOffsetTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingYOffsetTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingYOffsetTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingYOffsetTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigOrder (UnionType)
object AreaConfigOrderCodec {
  def decode(j: JsValue): AreaConfigOrder =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigOrder] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => AreaConfigOrderAsNull }.orElse {
    j.asOpt[Boolean].map { AreaConfigOrderAsBool(_) } } 
  def encode(j: AreaConfigOrder): JsValue =
    j match {
      case AreaConfigOrderAsNull /* Global, NullType$ */ => JsNull
      case AreaConfigOrderAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingYStack (UnionType)
object SharedEncodingYStackCodec {
  def decode(j: JsValue): SharedEncodingYStack =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingYStack] =
    StackOffsetCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingYStackAsNull }.orElse {
    j.asOpt[Boolean].map { SharedEncodingYStackAsBool(_) } } } 
  def encode(j: SharedEncodingYStack): JsValue =
    j match {
      case x:StackOffset /* TypeRef */ => StackOffsetCodec.encode(x)
      case SharedEncodingYStackAsNull /* Global, NullType$ */ => JsNull
      case SharedEncodingYStackAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigGradientLabelLimit (UnionType)
object LegendConfigGradientLabelLimitCodec {
  def decode(j: JsValue): LegendConfigGradientLabelLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigGradientLabelLimit] =
    j.asOpt[JsNumber].map { LegendConfigGradientLabelLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigGradientLabelLimit): JsValue =
    j match {
      case LegendConfigGradientLabelLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisLabelAlignAsObject1 (StructType)
object ConditionalAxisLabelAlignAsObject1Codec {
  def decode(j: JsValue): ConditionalAxisLabelAlignAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalAxisLabelAlignAsObject1] =
    {
      val `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => ConditionalAxisLabelAlignAsObject1ConditionCodec.decodeOpt(x) }
      if(`condition`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => AlignCodec.decodeOpt(x).map { Some(_) }.flatten }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalAxisLabelAlignAsObject1(
        `condition` = `condition`.get,
        `value` = `value`,
      ))
    }

  def encode(j: ConditionalAxisLabelAlignAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("condition" -> ConditionalAxisLabelAlignAsObject1ConditionCodec.encode(j.`condition`)),
        j.`value`.map { x => "value" -> AlignCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ScaleScheme (UnionType)
object ScaleSchemeCodec {
  def decode(j: JsValue): ScaleScheme =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleScheme] =
    j.asOpt[String].map { ScaleSchemeAsString(_) }.orElse {
    SchemeParamsCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: ScaleScheme): JsValue =
    j match {
      case ScaleSchemeAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:SchemeParams /* TypeRef */ => SchemeParamsCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Orientation (EnumType)
object OrientationCodec {
  def decode(j: JsValue): Orientation =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Orientation] =
    j match {
      case JsString("horizontal") => Some(OrientationHorizontal)
      case JsString("vertical") => Some(OrientationVertical)
      case _ => None
    }
  def encode(j: Orientation): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// HeaderLabelFont (UnionType)
object HeaderLabelFontCodec {
  def decode(j: JsValue): HeaderLabelFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderLabelFont] =
    j.asOpt[String].map { HeaderLabelFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderLabelFont): JsValue =
    j match {
      case HeaderLabelFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// StringFieldDefBin (UnionType)
object StringFieldDefBinCodec {
  def decode(j: JsValue): StringFieldDefBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[StringFieldDefBin] =
    j.asOpt[Boolean].map { StringFieldDefBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    BinnedCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => StringFieldDefBinAsNull } } } } 
  def encode(j: StringFieldDefBin): JsValue =
    j match {
      case StringFieldDefBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case x:Binned /* TypeRef */ => BinnedCodec.encode(x)
      case StringFieldDefBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigInnerRadius (ConstrainedType)
// see TickConfigInnerRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// Height (ConstantType)
object HeightCodec {
  def decode(j: JsValue): Height =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Height] =
    j match {
      case JsString("height") => Some(Height())
      case _ => None
    }
  def encode(j: Height): JsValue =
    JsString("height")
}


////////////////////////////////////////////////////////////////////////
// LineConfigRadius2 (ConstrainedType)
// see LineConfigRadius2 (UnionType)

////////////////////////////////////////////////////////////////////////
// ViewConfigCornerRadius (UnionType)
object ViewConfigCornerRadiusCodec {
  def decode(j: JsValue): ViewConfigCornerRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewConfigCornerRadius] =
    j.asOpt[JsNumber].map { ViewConfigCornerRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ViewConfigCornerRadius): JsValue =
    j match {
      case ViewConfigCornerRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigFontSize (UnionType)
object RectConfigFontSizeCodec {
  def decode(j: JsValue): RectConfigFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigFontSize] =
    RectConfigFontSizeAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigFontSize): JsValue =
    j match {
      case x:RectConfigFontSizeAsNumber /* TypeRef */ => RectConfigFontSizeAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigDescription (UnionType)
object AxisConfigDescriptionCodec {
  def decode(j: JsValue): AxisConfigDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigDescription] =
    j.asOpt[String].map { AxisConfigDescriptionAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigDescription): JsValue =
    j match {
      case AxisConfigDescriptionAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefTextBaselineNullExprRefAsObject1 (StructType)
object ConditionalPredicateValueDefTextBaselineNullExprRefAsObject1Codec {
  def decode(j: JsValue): ConditionalPredicateValueDefTextBaselineNullExprRefAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefTextBaselineNullExprRefAsObject1] =
    {
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => TextBaselineCodec.decodeOpt(x).map { Some(_) }.flatten }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalPredicateValueDefTextBaselineNullExprRefAsObject1(
        `test` = `test`.get,
        `value` = `value`,
      ))
    }

  def encode(j: ConditionalPredicateValueDefTextBaselineNullExprRefAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
        j.`value`.map { x => "value" -> TextBaselineCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingShapeTimeUnit (UnionType)
object SharedEncodingShapeTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingShapeTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingShapeTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingShapeTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigTitleOpacity (UnionType)
object LegendConfigTitleOpacityCodec {
  def decode(j: JsValue): LegendConfigTitleOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigTitleOpacity] =
    j.asOpt[JsNumber].map { LegendConfigTitleOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigTitleOpacity): JsValue =
    j match {
      case LegendConfigTitleOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigSymbolStrokeWidth (UnionType)
object LegendConfigSymbolStrokeWidthCodec {
  def decode(j: JsValue): LegendConfigSymbolStrokeWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigSymbolStrokeWidth] =
    LegendConfigSymbolStrokeWidthAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigSymbolStrokeWidth): JsValue =
    j match {
      case x:LegendConfigSymbolStrokeWidthAsNumber /* TypeRef */ => LegendConfigSymbolStrokeWidthAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigStrokeWidth (UnionType)
object TickConfigStrokeWidthCodec {
  def decode(j: JsValue): TickConfigStrokeWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigStrokeWidth] =
    TickConfigStrokeWidthAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigStrokeWidth): JsValue =
    j match {
      case x:TickConfigStrokeWidthAsNumber /* TypeRef */ => TickConfigStrokeWidthAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingLongitudeDatum (UnionType)
object SharedEncodingLongitudeDatumCodec {
  def decode(j: JsValue): SharedEncodingLongitudeDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingLongitudeDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingLongitudeDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisGridColor (UnionType)
object AxisGridColorCodec {
  def decode(j: JsValue): AxisGridColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisGridColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => AxisGridColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisColorCodec.decodeOpt(j) } } } 
  def encode(j: AxisGridColor): JsValue =
    j match {
      case AxisGridColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisColor /* TypeRef */ => ConditionalAxisColorCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetEncodingFieldDefBandPosition (ConstrainedType)
object FacetEncodingFieldDefBandPositionCodec {
  def decode(j: JsValue): FacetEncodingFieldDefBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FacetEncodingFieldDefBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { FacetEncodingFieldDefBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: FacetEncodingFieldDefBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// DictOfAny (MapType)
object DictOfAnyCodec {
  def decode(j: JsValue): Map[String,JsValue] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Map[String,JsValue]] =
    j.asOpt[Map[String,JsValue]].map { _.mapValues { x => 
      x.asOpt[JsValue].getOrElse { return None } } }
  def encode(j: Map[String,JsValue]): JsObject =
      JsObject(j.mapValues { x => Json.toJson(x) })
}


////////////////////////////////////////////////////////////////////////
// LatLongDef (UnionType)
object LatLongDefCodec {
  def decode(j: JsValue): LatLongDef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LatLongDef] =
    LatLongFieldDefCodec.decodeOpt(j).orElse {
    DatumDefCodec.decodeOpt(j) } 
  def encode(j: LatLongDef): JsValue =
    j match {
      case x:LatLongFieldDef /* TypeRef */ => LatLongFieldDefCodec.encode(x)
      case x:DatumDef /* TypeRef */ => DatumDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Aggregate (UnionType)
object AggregateCodec {
  def decode(j: JsValue): Aggregate =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Aggregate] =
    NonArgAggregateOpCodec.decodeOpt(j).orElse {
    ArgmaxDefCodec.decodeOpt(j).orElse {
    ArgminDefCodec.decodeOpt(j) } } 
  def encode(j: Aggregate): JsValue =
    j match {
      case x:NonArgAggregateOp /* TypeRef */ => NonArgAggregateOpCodec.encode(x)
      case x:ArgmaxDef /* TypeRef */ => ArgmaxDefCodec.encode(x)
      case x:ArgminDef /* TypeRef */ => ArgminDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigStrokeOpacity (UnionType)
object BarConfigStrokeOpacityCodec {
  def decode(j: JsValue): BarConfigStrokeOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigStrokeOpacity] =
    BarConfigStrokeOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigStrokeOpacity): JsValue =
    j match {
      case x:BarConfigStrokeOpacityAsNumber /* TypeRef */ => BarConfigStrokeOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingSizeBandPosition (ConstrainedType)
object SharedEncodingSizeBandPositionCodec {
  def decode(j: JsValue): SharedEncodingSizeBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingSizeBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingSizeBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingSizeBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkDefCursor (UnionType)
object MarkDefCursorCodec {
  def decode(j: JsValue): MarkDefCursor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefCursor] =
    CursorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefCursor): JsValue =
    j match {
      case x:Cursor /* TypeRef */ => CursorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PointSelectionConfigWithoutTypeOn (UnionType)
object PointSelectionConfigWithoutTypeOnCodec {
  def decode(j: JsValue): PointSelectionConfigWithoutTypeOn =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PointSelectionConfigWithoutTypeOn] =
    StreamCodec.decodeOpt(j).orElse {
    j.asOpt[String].map { PointSelectionConfigWithoutTypeOnAsString(_) } } 
  def encode(j: PointSelectionConfigWithoutTypeOn): JsValue =
    j match {
      case x:Stream /* TypeRef */ => StreamCodec.encode(x)
      case PointSelectionConfigWithoutTypeOnAsString(x) /* Base, StringType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScalePaddingInner (ConstrainedType)
// see ScalePaddingInner (UnionType)

////////////////////////////////////////////////////////////////////////
// ArrayOfScaleRangeAsArrayElement (ArrayType)
object ArrayOfScaleRangeAsArrayElementCodec {
  def decode(j: JsValue): Seq[ScaleRangeAsArrayElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[ScaleRangeAsArrayElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      ScaleRangeAsArrayElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[ScaleRangeAsArrayElement]): JsArray =
      JsArray(j.map { x => ScaleRangeAsArrayElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// MarkConfigAngle (UnionType)
object MarkConfigAngleCodec {
  def decode(j: JsValue): MarkConfigAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigAngle] =
    MarkConfigAngleAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigAngle): JsValue =
    j match {
      case x:MarkConfigAngleAsNumber /* TypeRef */ => MarkConfigAngleAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionStringDatumDefText (StructType)
object FieldOrDatumDefWithConditionStringDatumDefTextCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionStringDatumDefText =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionStringDatumDefText] =
    Some(FieldOrDatumDefWithConditionStringDatumDefText(
      `format` = (j \ "format").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionStringDatumDefTextFormatCodec.decodeOpt(x) },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionStringDatumDefTextDatumCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionStringDatumDefTextBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionStringDatumDefTextConditionCodec.decodeOpt(x) },
      `formatType` = (j \ "formatType").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeCodec.decodeOpt(x) },
    ))

  def encode(j: FieldOrDatumDefWithConditionStringDatumDefText): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`format`.map { x => "format" -> FieldOrDatumDefWithConditionStringDatumDefTextFormatCodec.encode(x) },
        j.`datum`.map { x => "datum" -> FieldOrDatumDefWithConditionStringDatumDefTextDatumCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> FieldOrDatumDefWithConditionStringDatumDefTextBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> FieldOrDatumDefWithConditionStringDatumDefTextConditionCodec.encode(x) },
        j.`formatType`.map { x => "formatType" -> Json.toJson(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AxisConfigOrient (UnionType)
object AxisConfigOrientCodec {
  def decode(j: JsValue): AxisConfigOrient =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigOrient] =
    AxisOrientCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigOrient): JsValue =
    j match {
      case x:AxisOrient /* TypeRef */ => AxisOrientCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsSubtitleFontSizeAsNumber (ConstrainedType)
object TitleParamsSubtitleFontSizeAsNumberCodec {
  def decode(j: JsValue): TitleParamsSubtitleFontSizeAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TitleParamsSubtitleFontSizeAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { TitleParamsSubtitleFontSizeAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: TitleParamsSubtitleFontSizeAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// GradientStop (StructType)
object GradientStopCodec {
  def decode(j: JsValue): GradientStop =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[GradientStop] =
    {
      val `color` = (j \ "color").asOpt[JsValue].flatMap { x => ColorCodec.decodeOpt(x) }
      if(`color`.isEmpty) { return None }
      val `offset` = (j \ "offset").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      if(`offset`.isEmpty) { return None }
      return Some(GradientStop(
        `color` = `color`.get,
        `offset` = `offset`.get,
      ))
    }

  def encode(j: GradientStop): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("color" -> ColorCodec.encode(j.`color`)),
        Some("offset" -> Json.toJson(j.`offset`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LineConfigAngle (UnionType)
object LineConfigAngleCodec {
  def decode(j: JsValue): LineConfigAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigAngle] =
    LineConfigAngleAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigAngle): JsValue =
    j match {
      case x:LineConfigAngleAsNumber /* TypeRef */ => LineConfigAngleAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateMarkPropFieldOrDatumDefAsObject1TimeUnit (UnionType)
object ConditionalPredicateMarkPropFieldOrDatumDefAsObject1TimeUnitCodec {
  def decode(j: JsValue): ConditionalPredicateMarkPropFieldOrDatumDefAsObject1TimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateMarkPropFieldOrDatumDefAsObject1TimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: ConditionalPredicateMarkPropFieldOrDatumDefAsObject1TimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleType (EnumType)
object ScaleTypeCodec {
  def decode(j: JsValue): ScaleType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleType] =
    j match {
      case JsString("linear") => Some(ScaleTypeLinear)
      case JsString("log") => Some(ScaleTypeLog)
      case JsString("pow") => Some(ScaleTypePow)
      case JsString("sqrt") => Some(ScaleTypeSqrt)
      case JsString("symlog") => Some(ScaleTypeSymlog)
      case JsString("identity") => Some(ScaleTypeIdentity)
      case JsString("sequential") => Some(ScaleTypeSequential)
      case JsString("time") => Some(ScaleTypeTime)
      case JsString("utc") => Some(ScaleTypeUtc)
      case JsString("quantile") => Some(ScaleTypeQuantile)
      case JsString("quantize") => Some(ScaleTypeQuantize)
      case JsString("threshold") => Some(ScaleTypeThreshold)
      case JsString("bin-ordinal") => Some(ScaleTypeBinOrdinal)
      case JsString("ordinal") => Some(ScaleTypeOrdinal)
      case JsString("point") => Some(ScaleTypePoint)
      case JsString("band") => Some(ScaleTypeBand)
      case _ => None
    }
  def encode(j: ScaleType): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionDatumDefGradientStringNullCondition (UnionType)
object FieldOrDatumDefWithConditionDatumDefGradientStringNullConditionCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionDatumDefGradientStringNullCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionDatumDefGradientStringNullCondition] =
    ConditionalValueDefGradientStringNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefGradientStringNullExprRefCodec.decodeOpt(j).map { FieldOrDatumDefWithConditionDatumDefGradientStringNullConditionAsArrayOfConditionalValueDefGradientStringNullExprRef(_) } } 
  def encode(j: FieldOrDatumDefWithConditionDatumDefGradientStringNullCondition): JsValue =
    j match {
      case x:ConditionalValueDefGradientStringNullExprRef /* TypeRef */ => ConditionalValueDefGradientStringNullExprRefCodec.encode(x)
      case FieldOrDatumDefWithConditionDatumDefGradientStringNullConditionAsArrayOfConditionalValueDefGradientStringNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefGradientStringNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingTextType (UnionType)
object SharedEncodingTextTypeCodec {
  def decode(j: JsValue): SharedEncodingTextType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingTextType] =
    StandardTypeCodec.decodeOpt(j).orElse {
    TypeCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingTextType): JsValue =
    j match {
      case x:StandardType /* TypeRef */ => StandardTypeCodec.encode(x)
      case x:Type /* TypeRef */ => TypeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTickOffset (UnionType)
object AxisConfigTickOffsetCodec {
  def decode(j: JsValue): AxisConfigTickOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTickOffset] =
    j.asOpt[JsNumber].map { AxisConfigTickOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigTickOffset): JsValue =
    j match {
      case AxisConfigTickOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigTitleFont (UnionType)
object LegendConfigTitleFontCodec {
  def decode(j: JsValue): LegendConfigTitleFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigTitleFont] =
    j.asOpt[String].map { LegendConfigTitleFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigTitleFont): JsValue =
    j match {
      case LegendConfigTitleFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigCornerRadiusBottomRight (UnionType)
object BarConfigCornerRadiusBottomRightCodec {
  def decode(j: JsValue): BarConfigCornerRadiusBottomRight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigCornerRadiusBottomRight] =
    j.asOpt[JsNumber].map { BarConfigCornerRadiusBottomRightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigCornerRadiusBottomRight): JsValue =
    j match {
      case BarConfigCornerRadiusBottomRightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// DomainUnionWithUnionWith (UnionType)
object DomainUnionWithUnionWithCodec {
  def decode(j: JsValue): DomainUnionWithUnionWith =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[DomainUnionWithUnionWith] =
    ArrayOfNumberCodec.decodeOpt(j).map { DomainUnionWithUnionWithAsArrayOfNumber(_) }.orElse {
    ArrayOfStringCodec.decodeOpt(j).map { DomainUnionWithUnionWithAsArrayOfString(_) }.orElse {
    ArrayOfBoolCodec.decodeOpt(j).map { DomainUnionWithUnionWithAsArrayOfBool(_) }.orElse {
    ArrayOfDateTimeCodec.decodeOpt(j).map { DomainUnionWithUnionWithAsArrayOfDateTime(_) } } } } 
  def encode(j: DomainUnionWithUnionWith): JsValue =
    j match {
      case DomainUnionWithUnionWithAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case DomainUnionWithUnionWithAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
      case DomainUnionWithUnionWithAsArrayOfBool(x) /* Base, ArrayType */ => ArrayOfBoolCodec.encode(x)
      case DomainUnionWithUnionWithAsArrayOfDateTime(x) /* Base, ArrayType */ => ArrayOfDateTimeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingTheta2Datum (UnionType)
object SharedEncodingTheta2DatumCodec {
  def decode(j: JsValue): SharedEncodingTheta2Datum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingTheta2Datum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingTheta2Datum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingLongitude2 (StructType)
object SharedEncodingLongitude2Codec {
  def decode(j: JsValue): SharedEncodingLongitude2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingLongitude2] =
    Some(SharedEncodingLongitude2(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingLongitude2DatumCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingLongitude2BandPositionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => x.asOpt[JsNull.type].map { _ => JsNull } },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingLongitude2ValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingLongitude2TimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingLongitude2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingLongitude2DatumCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingLongitude2BandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> Json.toJson(x) },
        j.`value`.map { x => "value" -> SharedEncodingLongitude2ValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingLongitude2TimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TitleConfigLimit (UnionType)
object TitleConfigLimitCodec {
  def decode(j: JsValue): TitleConfigLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigLimit] =
    TitleConfigLimitAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleConfigLimit): JsValue =
    j match {
      case x:TitleConfigLimitAsNumber /* TypeRef */ => TitleConfigLimitAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefStrokeWidth (UnionType)
object MarkDefStrokeWidthCodec {
  def decode(j: JsValue): MarkDefStrokeWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefStrokeWidth] =
    MarkDefStrokeWidthAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefStrokeWidth): JsValue =
    j match {
      case x:MarkDefStrokeWidthAsNumber /* TypeRef */ => MarkDefStrokeWidthAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldGTEPredicate (StructType)
object FieldGTEPredicateCodec {
  def decode(j: JsValue): FieldGTEPredicate =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldGTEPredicate] =
    {
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`field`.isEmpty) { return None }
      val `gte` = (j \ "gte").asOpt[JsValue].flatMap { x => FieldGTEPredicateGteCodec.decodeOpt(x) }
      if(`gte`.isEmpty) { return None }
      val `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => FieldGTEPredicateTimeUnitCodec.decodeOpt(x) }
      return Some(FieldGTEPredicate(
        `field` = `field`.get,
        `gte` = `gte`.get,
        `timeUnit` = `timeUnit`,
      ))
    }

  def encode(j: FieldGTEPredicate): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("field" -> Json.toJson(j.`field`)),
        Some("gte" -> FieldGTEPredicateGteCodec.encode(j.`gte`)),
        j.`timeUnit`.map { x => "timeUnit" -> FieldGTEPredicateTimeUnitCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ArrayOfGradientStop (ArrayType)
object ArrayOfGradientStopCodec {
  def decode(j: JsValue): Seq[GradientStop] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[GradientStop]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      GradientStopCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[GradientStop]): JsArray =
      JsArray(j.map { x => GradientStopCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// PredicateComposition (UnionType)
object PredicateCompositionCodec {
  def decode(j: JsValue): PredicateComposition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PredicateComposition] =
    LogicalNotPredicateCodec.decodeOpt(j).orElse {
    LogicalAndPredicateCodec.decodeOpt(j).orElse {
    LogicalOrPredicateCodec.decodeOpt(j).orElse {
    PredicateCodec.decodeOpt(j) } } } 
  def encode(j: PredicateComposition): JsValue =
    j match {
      case x:LogicalNotPredicate /* TypeRef */ => LogicalNotPredicateCodec.encode(x)
      case x:LogicalAndPredicate /* TypeRef */ => LogicalAndPredicateCodec.encode(x)
      case x:LogicalOrPredicate /* TypeRef */ => LogicalOrPredicateCodec.encode(x)
      case x:Predicate /* TypeRef */ => PredicateCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefDir (UnionType)
object OverlayMarkDefDirCodec {
  def decode(j: JsValue): OverlayMarkDefDir =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefDir] =
    TextDirectionCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefDir): JsValue =
    j match {
      case x:TextDirection /* TypeRef */ => TextDirectionCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterStringFieldDefBandPosition (ConstrainedType)
object ConditionalParameterStringFieldDefBandPositionCodec {
  def decode(j: JsValue): ConditionalParameterStringFieldDefBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalParameterStringFieldDefBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { ConditionalParameterStringFieldDefBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ConditionalParameterStringFieldDefBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// InlineData (StructType)
object InlineDataCodec {
  def decode(j: JsValue): InlineData =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[InlineData] =
    {
      val `format` = (j \ "format").asOpt[JsValue].flatMap { x => DataFormatCodec.decodeOpt(x) }
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `values` = (j \ "values").asOpt[JsValue].flatMap { x => InlineDatasetCodec.decodeOpt(x) }
      if(`values`.isEmpty) { return None }
      return Some(InlineData(
        `format` = `format`,
        `name` = `name`,
        `values` = `values`.get,
      ))
    }

  def encode(j: InlineData): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`format`.map { x => "format" -> DataFormatCodec.encode(x) },
        j.`name`.map { x => "name" -> Json.toJson(x) },
        Some("values" -> InlineDatasetCodec.encode(j.`values`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// BarConfigTension (UnionType)
object BarConfigTensionCodec {
  def decode(j: JsValue): BarConfigTension =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigTension] =
    j.asOpt[JsNumber].map { BarConfigTensionAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigTension): JsValue =
    j match {
      case BarConfigTensionAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeOpacityDatum (UnionType)
object SharedEncodingStrokeOpacityDatumCodec {
  def decode(j: JsValue): SharedEncodingStrokeOpacityDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeOpacityDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingStrokeOpacityDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingUrlCondition (UnionType)
object SharedEncodingUrlConditionCodec {
  def decode(j: JsValue): SharedEncodingUrlCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingUrlCondition] =
    ConditionalValueDefStringExprRefCodec.decodeOpt(j).orElse {
    ConditionalValueDefStringNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefStringExprRefCodec.decodeOpt(j).map { SharedEncodingUrlConditionAsArrayOfConditionalValueDefStringExprRef(_) }.orElse {
    ConditionalMarkPropFieldOrDatumDefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefStringNullExprRefCodec.decodeOpt(j).map { SharedEncodingUrlConditionAsArrayOfConditionalValueDefStringNullExprRef(_) } } } } } 
  def encode(j: SharedEncodingUrlCondition): JsValue =
    j match {
      case x:ConditionalValueDefStringExprRef /* TypeRef */ => ConditionalValueDefStringExprRefCodec.encode(x)
      case x:ConditionalValueDefStringNullExprRef /* TypeRef */ => ConditionalValueDefStringNullExprRefCodec.encode(x)
      case SharedEncodingUrlConditionAsArrayOfConditionalValueDefStringExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefStringExprRefCodec.encode(x)
      case x:ConditionalMarkPropFieldOrDatumDef /* TypeRef */ => ConditionalMarkPropFieldOrDatumDefCodec.encode(x)
      case SharedEncodingUrlConditionAsArrayOfConditionalValueDefStringNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefStringNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfigClipAngle (UnionType)
object ProjectionConfigClipAngleCodec {
  def decode(j: JsValue): ProjectionConfigClipAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigClipAngle] =
    j.asOpt[JsNumber].map { ProjectionConfigClipAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigClipAngle): JsValue =
    j match {
      case ProjectionConfigClipAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigFontWeight (UnionType)
object TickConfigFontWeightCodec {
  def decode(j: JsValue): TickConfigFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisLabelFontWeight (UnionType)
object ConditionalAxisLabelFontWeightCodec {
  def decode(j: JsValue): ConditionalAxisLabelFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisLabelFontWeight] =
    ConditionalAxisLabelFontWeightAsObject1Codec.decodeOpt(j).orElse {
    ConditionalAxisLabelFontWeightAsObject2Codec.decodeOpt(j) } 
  def encode(j: ConditionalAxisLabelFontWeight): JsValue =
    j match {
      case x:ConditionalAxisLabelFontWeightAsObject1 /* TypeRef */ => ConditionalAxisLabelFontWeightAsObject1Codec.encode(x)
      case x:ConditionalAxisLabelFontWeightAsObject2 /* TypeRef */ => ConditionalAxisLabelFontWeightAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfigDistance (UnionType)
object ProjectionConfigDistanceCodec {
  def decode(j: JsValue): ProjectionConfigDistance =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigDistance] =
    j.asOpt[JsNumber].map { ProjectionConfigDistanceAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigDistance): JsValue =
    j match {
      case ProjectionConfigDistanceAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject2Align (UnionType)
object TopLevelRepeatSpecAsObject2AlignCodec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject2Align =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject2Align] =
    LayoutAlignCodec.decodeOpt(j).orElse {
    RowColLayoutAlignCodec.decodeOpt(j) } 
  def encode(j: TopLevelRepeatSpecAsObject2Align): JsValue =
    j match {
      case x:LayoutAlign /* TypeRef */ => LayoutAlignCodec.encode(x)
      case x:RowColLayoutAlign /* TypeRef */ => RowColLayoutAlignCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConstant (UnionType)
object ScaleConstantCodec {
  def decode(j: JsValue): ScaleConstant =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleConstant] =
    j.asOpt[JsNumber].map { ScaleConstantAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleConstant): JsValue =
    j match {
      case ScaleConstantAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScalePaddingInner (UnionType)
object ScalePaddingInnerCodec {
  def decode(j: JsValue): ScalePaddingInner =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScalePaddingInner] =
    j.asOpt[JsNumber].map { ScalePaddingInnerAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScalePaddingInner): JsValue =
    j match {
      case ScalePaddingInnerAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsText (UnionType)
object TitleParamsTextCodec {
  def decode(j: JsValue): TitleParamsText =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsText] =
    TextCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleParamsText): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigCornerRadiusBottomLeft (UnionType)
object BarConfigCornerRadiusBottomLeftCodec {
  def decode(j: JsValue): BarConfigCornerRadiusBottomLeft =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigCornerRadiusBottomLeft] =
    j.asOpt[JsNumber].map { BarConfigCornerRadiusBottomLeftAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigCornerRadiusBottomLeft): JsValue =
    j match {
      case BarConfigCornerRadiusBottomLeftAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfTopLevelRepeatSpecAsObject2ParamsElement (ArrayType)
object ArrayOfTopLevelRepeatSpecAsObject2ParamsElementCodec {
  def decode(j: JsValue): Seq[TopLevelRepeatSpecAsObject2ParamsElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[TopLevelRepeatSpecAsObject2ParamsElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      TopLevelRepeatSpecAsObject2ParamsElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[TopLevelRepeatSpecAsObject2ParamsElement]): JsArray =
      JsArray(j.map { x => TopLevelRepeatSpecAsObject2ParamsElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// Vector2DateTime (ConstrainedType)
object Vector2DateTimeCodec {
  def decode(j: JsValue): Vector2DateTime =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Vector2DateTime] =
    try {
      ArrayOfDateTimeCodec.decodeOpt(j)
        .map { Vector2DateTime(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: Vector2DateTime): JsValue =
    ArrayOfDateTimeCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefDx (UnionType)
object OverlayMarkDefDxCodec {
  def decode(j: JsValue): OverlayMarkDefDx =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefDx] =
    j.asOpt[JsNumber].map { OverlayMarkDefDxAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefDx): JsValue =
    j match {
      case OverlayMarkDefDxAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefY2Offset (UnionType)
object OverlayMarkDefY2OffsetCodec {
  def decode(j: JsValue): OverlayMarkDefY2Offset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefY2Offset] =
    j.asOpt[JsNumber].map { OverlayMarkDefY2OffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefY2Offset): JsValue =
    j match {
      case OverlayMarkDefY2OffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigTheta (ConstrainedType)
// see LineConfigTheta (UnionType)

////////////////////////////////////////////////////////////////////////
// FacetFieldDefSort (UnionType)
object FacetFieldDefSortCodec {
  def decode(j: JsValue): FacetFieldDefSort =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetFieldDefSort] =
    SortArrayCodec.decodeOpt(j).orElse {
    SortOrderCodec.decodeOpt(j).orElse {
    EncodingSortFieldCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => FacetFieldDefSortAsNull } } } } 
  def encode(j: FacetFieldDefSort): JsValue =
    j match {
      case x:SortArray /* TypeRef */ => SortArrayCodec.encode(x)
      case x:SortOrder /* TypeRef */ => SortOrderCodec.encode(x)
      case x:EncodingSortField /* TypeRef */ => EncodingSortFieldCodec.encode(x)
      case FacetFieldDefSortAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterValueDefStringNullExprRef (StructType)
object ConditionalParameterValueDefStringNullExprRefCodec {
  def decode(j: JsValue): ConditionalParameterValueDefStringNullExprRef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalParameterValueDefStringNullExprRef] =
    {
      val `empty` = (j \ "empty").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `param` = (j \ "param").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`param`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => ConditionalParameterValueDefStringNullExprRefValueCodec.decodeOpt(x) }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalParameterValueDefStringNullExprRef(
        `empty` = `empty`,
        `param` = `param`.get,
        `value` = `value`.get,
      ))
    }

  def encode(j: ConditionalParameterValueDefStringNullExprRef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`empty`.map { x => "empty" -> Json.toJson(x) },
        Some("param" -> Json.toJson(j.`param`)),
        Some("value" -> ConditionalParameterValueDefStringNullExprRefValueCodec.encode(j.`value`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ScaleConfigMinSize (ConstrainedType)
object ScaleConfigMinSizeCodec {
  def decode(j: JsValue): ScaleConfigMinSize =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ScaleConfigMinSize] =
    try {
      j.asOpt[JsNumber]
        .map { ScaleConfigMinSize(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ScaleConfigMinSize): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefLimit (UnionType)
object OverlayMarkDefLimitCodec {
  def decode(j: JsValue): OverlayMarkDefLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefLimit] =
    j.asOpt[JsNumber].map { OverlayMarkDefLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefLimit): JsValue =
    j match {
      case OverlayMarkDefLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldLTEPredicateTimeUnit (UnionType)
object FieldLTEPredicateTimeUnitCodec {
  def decode(j: JsValue): FieldLTEPredicateTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldLTEPredicateTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: FieldLTEPredicateTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigX (UnionType)
object AreaConfigXCodec {
  def decode(j: JsValue): AreaConfigX =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigX] =
    j.asOpt[JsNumber].map { AreaConfigXAsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: AreaConfigX): JsValue =
    j match {
      case AreaConfigXAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigBaseline (UnionType)
object RectConfigBaselineCodec {
  def decode(j: JsValue): RectConfigBaseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigBaseline] =
    TextBaselineCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigBaseline): JsValue =
    j match {
      case x:TextBaseline /* TypeRef */ => TextBaselineCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TimeUnitTransform (StructType)
object TimeUnitTransformCodec {
  def decode(j: JsValue): TimeUnitTransform =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TimeUnitTransform] =
    {
      val `as` = (j \ "as").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`as`.isEmpty) { return None }
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`field`.isEmpty) { return None }
      val `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => TimeUnitTransformTimeUnitCodec.decodeOpt(x) }
      if(`timeUnit`.isEmpty) { return None }
      return Some(TimeUnitTransform(
        `as` = `as`.get,
        `field` = `field`.get,
        `timeUnit` = `timeUnit`.get,
      ))
    }

  def encode(j: TimeUnitTransform): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("as" -> Json.toJson(j.`as`)),
        Some("field" -> Json.toJson(j.`field`)),
        Some("timeUnit" -> TimeUnitTransformTimeUnitCodec.encode(j.`timeUnit`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConditionalPredicateMarkPropFieldOrDatumDefAsObject2BandPosition (ConstrainedType)
object ConditionalPredicateMarkPropFieldOrDatumDefAsObject2BandPositionCodec {
  def decode(j: JsValue): ConditionalPredicateMarkPropFieldOrDatumDefAsObject2BandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateMarkPropFieldOrDatumDefAsObject2BandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { ConditionalPredicateMarkPropFieldOrDatumDefAsObject2BandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ConditionalPredicateMarkPropFieldOrDatumDefAsObject2BandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingFillOpacityValue (UnionType)
object SharedEncodingFillOpacityValueCodec {
  def decode(j: JsValue): SharedEncodingFillOpacityValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingFillOpacityValue] =
    j.asOpt[JsNumber].map { SharedEncodingFillOpacityValueAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingFillOpacityValue): JsValue =
    j match {
      case SharedEncodingFillOpacityValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigCornerRadiusTopRight (UnionType)
object LineConfigCornerRadiusTopRightCodec {
  def decode(j: JsValue): LineConfigCornerRadiusTopRight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigCornerRadiusTopRight] =
    j.asOpt[JsNumber].map { LineConfigCornerRadiusTopRightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigCornerRadiusTopRight): JsValue =
    j match {
      case LineConfigCornerRadiusTopRightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigAngle (UnionType)
object TickConfigAngleCodec {
  def decode(j: JsValue): TickConfigAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigAngle] =
    TickConfigAngleAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigAngle): JsValue =
    j match {
      case x:TickConfigAngleAsNumber /* TypeRef */ => TickConfigAngleAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OrderFieldDefBandPosition (ConstrainedType)
object OrderFieldDefBandPositionCodec {
  def decode(j: JsValue): OrderFieldDefBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[OrderFieldDefBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { OrderFieldDefBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: OrderFieldDefBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// RectConfigStrokeOffset (UnionType)
object RectConfigStrokeOffsetCodec {
  def decode(j: JsValue): RectConfigStrokeOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigStrokeOffset] =
    j.asOpt[JsNumber].map { RectConfigStrokeOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigStrokeOffset): JsValue =
    j match {
      case RectConfigStrokeOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelConcatSpecBounds (EnumType)
object TopLevelConcatSpecBoundsCodec {
  def decode(j: JsValue): TopLevelConcatSpecBounds =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelConcatSpecBounds] =
    j match {
      case JsString("full") => Some(TopLevelConcatSpecBoundsFull)
      case JsString("flush") => Some(TopLevelConcatSpecBoundsFlush)
      case _ => None
    }
  def encode(j: TopLevelConcatSpecBounds): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// HeaderConfigLabelFont (UnionType)
object HeaderConfigLabelFontCodec {
  def decode(j: JsValue): HeaderConfigLabelFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigLabelFont] =
    j.asOpt[String].map { HeaderConfigLabelFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderConfigLabelFont): JsValue =
    j match {
      case HeaderConfigLabelFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderConfigLabelFontSize (UnionType)
object HeaderConfigLabelFontSizeCodec {
  def decode(j: JsValue): HeaderConfigLabelFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigLabelFontSize] =
    j.asOpt[JsNumber].map { HeaderConfigLabelFontSizeAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderConfigLabelFontSize): JsValue =
    j match {
      case HeaderConfigLabelFontSizeAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterValueDefNumber (StructType)
object ConditionalParameterValueDefNumberCodec {
  def decode(j: JsValue): ConditionalParameterValueDefNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalParameterValueDefNumber] =
    {
      val `empty` = (j \ "empty").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `param` = (j \ "param").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`param`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalParameterValueDefNumber(
        `empty` = `empty`,
        `param` = `param`.get,
        `value` = `value`.get,
      ))
    }

  def encode(j: ConditionalParameterValueDefNumber): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`empty`.map { x => "empty" -> Json.toJson(x) },
        Some("param" -> Json.toJson(j.`param`)),
        Some("value" -> Json.toJson(j.`value`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AreaConfigStartAngle (UnionType)
object AreaConfigStartAngleCodec {
  def decode(j: JsValue): AreaConfigStartAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigStartAngle] =
    j.asOpt[JsNumber].map { AreaConfigStartAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigStartAngle): JsValue =
    j match {
      case AreaConfigStartAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigRectBandPaddingInner (UnionType)
object ScaleConfigRectBandPaddingInnerCodec {
  def decode(j: JsValue): ScaleConfigRectBandPaddingInner =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleConfigRectBandPaddingInner] =
    j.asOpt[JsNumber].map { ScaleConfigRectBandPaddingInnerAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleConfigRectBandPaddingInner): JsValue =
    j match {
      case ScaleConfigRectBandPaddingInnerAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LocalMultiTimeUnit (EnumType)
object LocalMultiTimeUnitCodec {
  def decode(j: JsValue): LocalMultiTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LocalMultiTimeUnit] =
    j match {
      case JsString("yearquarter") => Some(LocalMultiTimeUnitYearquarter)
      case JsString("yearquartermonth") => Some(LocalMultiTimeUnitYearquartermonth)
      case JsString("yearmonth") => Some(LocalMultiTimeUnitYearmonth)
      case JsString("yearmonthdate") => Some(LocalMultiTimeUnitYearmonthdate)
      case JsString("yearmonthdatehours") => Some(LocalMultiTimeUnitYearmonthdatehours)
      case JsString("yearmonthdatehoursminutes") => Some(LocalMultiTimeUnitYearmonthdatehoursminutes)
      case JsString("yearmonthdatehoursminutesseconds") => Some(LocalMultiTimeUnitYearmonthdatehoursminutesseconds)
      case JsString("yearweek") => Some(LocalMultiTimeUnitYearweek)
      case JsString("yearweekday") => Some(LocalMultiTimeUnitYearweekday)
      case JsString("yearweekdayhours") => Some(LocalMultiTimeUnitYearweekdayhours)
      case JsString("yearweekdayhoursminutes") => Some(LocalMultiTimeUnitYearweekdayhoursminutes)
      case JsString("yearweekdayhoursminutesseconds") => Some(LocalMultiTimeUnitYearweekdayhoursminutesseconds)
      case JsString("yeardayofyear") => Some(LocalMultiTimeUnitYeardayofyear)
      case JsString("quartermonth") => Some(LocalMultiTimeUnitQuartermonth)
      case JsString("monthdate") => Some(LocalMultiTimeUnitMonthdate)
      case JsString("monthdatehours") => Some(LocalMultiTimeUnitMonthdatehours)
      case JsString("monthdatehoursminutes") => Some(LocalMultiTimeUnitMonthdatehoursminutes)
      case JsString("monthdatehoursminutesseconds") => Some(LocalMultiTimeUnitMonthdatehoursminutesseconds)
      case JsString("weekday") => Some(LocalMultiTimeUnitWeekday)
      case JsString("weeksdayhours") => Some(LocalMultiTimeUnitWeeksdayhours)
      case JsString("weekdayhoursminutes") => Some(LocalMultiTimeUnitWeekdayhoursminutes)
      case JsString("weekdayhoursminutesseconds") => Some(LocalMultiTimeUnitWeekdayhoursminutesseconds)
      case JsString("dayhours") => Some(LocalMultiTimeUnitDayhours)
      case JsString("dayhoursminutes") => Some(LocalMultiTimeUnitDayhoursminutes)
      case JsString("dayhoursminutesseconds") => Some(LocalMultiTimeUnitDayhoursminutesseconds)
      case JsString("hoursminutes") => Some(LocalMultiTimeUnitHoursminutes)
      case JsString("hoursminutesseconds") => Some(LocalMultiTimeUnitHoursminutesseconds)
      case JsString("minutesseconds") => Some(LocalMultiTimeUnitMinutesseconds)
      case JsString("secondsmilliseconds") => Some(LocalMultiTimeUnitSecondsmilliseconds)
      case _ => None
    }
  def encode(j: LocalMultiTimeUnit): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// MarkConfigHref (UnionType)
object MarkConfigHrefCodec {
  def decode(j: JsValue): MarkConfigHref =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigHref] =
    UriReferenceCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigHref): JsValue =
    j match {
      case x:UriReference /* TypeRef */ => UriReferenceCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNull (StructType)
object ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullCodec {
  def decode(j: JsValue): ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNull =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNull] =
    Some(ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNull(
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullConditionCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullValueCodec.decodeOpt(x) },
    ))

  def encode(j: ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNull): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`condition`.map { x => "condition" -> ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullConditionCodec.encode(x) },
        j.`value`.map { x => "value" -> ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullValueCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// RectConfigAlign (UnionType)
object RectConfigAlignCodec {
  def decode(j: JsValue): RectConfigAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigAlign] =
    AlignCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigAlign): JsValue =
    j match {
      case x:Align /* TypeRef */ => AlignCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Data (UnionType)
object DataCodec {
  def decode(j: JsValue): Data =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Data] =
    DataSourceCodec.decodeOpt(j).orElse {
    GeneratorCodec.decodeOpt(j) } 
  def encode(j: Data): JsValue =
    j match {
      case x:DataSource /* TypeRef */ => DataSourceCodec.encode(x)
      case x:Generator /* TypeRef */ => GeneratorCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTitleAnchor (UnionType)
object AxisTitleAnchorCodec {
  def decode(j: JsValue): AxisTitleAnchor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTitleAnchor] =
    TitleAnchorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisTitleAnchor): JsValue =
    j match {
      case x:TitleAnchor /* TypeRef */ => TitleAnchorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TimeIntervalStep (StructType)
object TimeIntervalStepCodec {
  def decode(j: JsValue): TimeIntervalStep =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TimeIntervalStep] =
    {
      val `interval` = (j \ "interval").asOpt[JsValue].flatMap { x => TimeIntervalCodec.decodeOpt(x) }
      if(`interval`.isEmpty) { return None }
      val `step` = (j \ "step").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      if(`step`.isEmpty) { return None }
      return Some(TimeIntervalStep(
        `interval` = `interval`.get,
        `step` = `step`.get,
      ))
    }

  def encode(j: TimeIntervalStep): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("interval" -> TimeIntervalCodec.encode(j.`interval`)),
        Some("step" -> Json.toJson(j.`step`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// OverlayMarkDefHref (UnionType)
object OverlayMarkDefHrefCodec {
  def decode(j: JsValue): OverlayMarkDefHref =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefHref] =
    UriReferenceCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefHref): JsValue =
    j match {
      case x:UriReference /* TypeRef */ => UriReferenceCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigTheta (ConstrainedType)
// see BarConfigTheta (UnionType)

////////////////////////////////////////////////////////////////////////
// Locale (StructType)
object LocaleCodec {
  def decode(j: JsValue): Locale =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Locale] =
    Some(Locale(
      `number` = (j \ "number").asOpt[JsValue].flatMap { x => NumberLocaleCodec.decodeOpt(x) },
      `time` = (j \ "time").asOpt[JsValue].flatMap { x => TimeLocaleCodec.decodeOpt(x) },
    ))

  def encode(j: Locale): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`number`.map { x => "number" -> NumberLocaleCodec.encode(x) },
        j.`time`.map { x => "time" -> TimeLocaleCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// BarConfigLimit (UnionType)
object BarConfigLimitCodec {
  def decode(j: JsValue): BarConfigLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigLimit] =
    j.asOpt[JsNumber].map { BarConfigLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigLimit): JsValue =
    j match {
      case BarConfigLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfStringFieldDef (ArrayType)
object ArrayOfStringFieldDefCodec {
  def decode(j: JsValue): Seq[StringFieldDef] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[StringFieldDef]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      StringFieldDefCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[StringFieldDef]): JsArray =
      JsArray(j.map { x => StringFieldDefCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// MarkDefTension (UnionType)
object MarkDefTensionCodec {
  def decode(j: JsValue): MarkDefTension =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefTension] =
    j.asOpt[JsNumber].map { MarkDefTensionAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefTension): JsValue =
    j match {
      case MarkDefTensionAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigFont (UnionType)
object AreaConfigFontCodec {
  def decode(j: JsValue): AreaConfigFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigFont] =
    j.asOpt[String].map { AreaConfigFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigFont): JsValue =
    j match {
      case AreaConfigFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefCornerRadiusEnd (UnionType)
object MarkDefCornerRadiusEndCodec {
  def decode(j: JsValue): MarkDefCornerRadiusEnd =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefCornerRadiusEnd] =
    j.asOpt[JsNumber].map { MarkDefCornerRadiusEndAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefCornerRadiusEnd): JsValue =
    j match {
      case MarkDefCornerRadiusEndAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterValueDefStringNullExprRefValue (UnionType)
object ConditionalParameterValueDefStringNullExprRefValueCodec {
  def decode(j: JsValue): ConditionalParameterValueDefStringNullExprRefValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalParameterValueDefStringNullExprRefValue] =
    j.asOpt[String].map { ConditionalParameterValueDefStringNullExprRefValueAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ConditionalParameterValueDefStringNullExprRefValueAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: ConditionalParameterValueDefStringNullExprRefValue): JsValue =
    j match {
      case ConditionalParameterValueDefStringNullExprRefValueAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case ConditionalParameterValueDefStringNullExprRefValueAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BindDirect (StructType)
object BindDirectCodec {
  def decode(j: JsValue): BindDirect =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BindDirect] =
    {
      val `debounce` = (j \ "debounce").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `element` = (j \ "element").asOpt[JsValue].flatMap { x => BindDirectElementCodec.decodeOpt(x) }
      if(`element`.isEmpty) { return None }
      val `event` = (j \ "event").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      return Some(BindDirect(
        `debounce` = `debounce`,
        `element` = `element`.get,
        `event` = `event`,
      ))
    }

  def encode(j: BindDirect): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`debounce`.map { x => "debounce" -> Json.toJson(x) },
        Some("element" -> BindDirectElementCodec.encode(j.`element`)),
        j.`event`.map { x => "event" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// RangeSchemeAsObject3Scheme (UnionType)
object RangeSchemeAsObject3SchemeCodec {
  def decode(j: JsValue): RangeSchemeAsObject3Scheme =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RangeSchemeAsObject3Scheme] =
    j.asOpt[String].map { RangeSchemeAsObject3SchemeAsString(_) }.orElse {
    ArrayOfStringCodec.decodeOpt(j).map { RangeSchemeAsObject3SchemeAsArrayOfString(_) }.orElse {
    ColorSchemeCodec.decodeOpt(j) } } 
  def encode(j: RangeSchemeAsObject3Scheme): JsValue =
    j match {
      case RangeSchemeAsObject3SchemeAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case RangeSchemeAsObject3SchemeAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
      case x:ColorScheme /* TypeRef */ => ColorSchemeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LabelOverlap (UnionType)
object LabelOverlapCodec {
  def decode(j: JsValue): LabelOverlap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LabelOverlap] =
    j.asOpt[Boolean].map { LabelOverlapAsBool(_) }.orElse {
    ParityCodec.decodeOpt(j).orElse {
    GreedyCodec.decodeOpt(j) } } 
  def encode(j: LabelOverlap): JsValue =
    j match {
      case LabelOverlapAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:Parity /* TypeRef */ => ParityCodec.encode(x)
      case x:Greedy /* TypeRef */ => GreedyCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelUnitSpecBackground (UnionType)
object TopLevelUnitSpecBackgroundCodec {
  def decode(j: JsValue): TopLevelUnitSpecBackground =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelUnitSpecBackground] =
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TopLevelUnitSpecBackground): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// UnitSpec (StructType)
object UnitSpecCodec {
  def decode(j: JsValue): UnitSpec =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[UnitSpec] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `projection` = (j \ "projection").asOpt[JsValue].flatMap { x => ProjectionCodec.decodeOpt(x) }
      val `description` = (j \ "description").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `data` = (j \ "data").asOpt[JsValue].flatMap { x => DataCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `params` = (j \ "params").asOpt[JsValue].flatMap { x => ArrayOfUnitSpecParamsElementCodec.decodeOpt(x) }
      val `encoding` = (j \ "encoding").asOpt[JsValue].flatMap { x => EncodingCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => UnitSpecTitleCodec.decodeOpt(x) }
      val `mark` = (j \ "mark").asOpt[JsValue].flatMap { x => AnyMarkCodec.decodeOpt(x) }
      if(`mark`.isEmpty) { return None }
      val `transform` = (j \ "transform").asOpt[JsValue].flatMap { x => ArrayOfTransformCodec.decodeOpt(x) }
      return Some(UnitSpec(
        `name` = `name`,
        `projection` = `projection`,
        `description` = `description`,
        `data` = `data`,
        `params` = `params`,
        `encoding` = `encoding`,
        `title` = `title`,
        `mark` = `mark`.get,
        `transform` = `transform`,
      ))
    }

  def encode(j: UnitSpec): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`projection`.map { x => "projection" -> ProjectionCodec.encode(x) },
        j.`description`.map { x => "description" -> Json.toJson(x) },
        j.`data`.map { x => "data" -> DataCodec.encode(x) },
        j.`params`.map { x => "params" -> ArrayOfUnitSpecParamsElementCodec.encode(x) },
        j.`encoding`.map { x => "encoding" -> EncodingCodec.encode(x) },
        j.`title`.map { x => "title" -> UnitSpecTitleCodec.encode(x) },
        Some("mark" -> AnyMarkCodec.encode(j.`mark`)),
        j.`transform`.map { x => "transform" -> ArrayOfTransformCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TickConfigOrder (UnionType)
object TickConfigOrderCodec {
  def decode(j: JsValue): TickConfigOrder =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigOrder] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => TickConfigOrderAsNull }.orElse {
    j.asOpt[Boolean].map { TickConfigOrderAsBool(_) } } 
  def encode(j: TickConfigOrder): JsValue =
    j match {
      case TickConfigOrderAsNull /* Global, NullType$ */ => JsNull
      case TickConfigOrderAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionDatumDefStringNullBandPosition (ConstrainedType)
object FieldOrDatumDefWithConditionDatumDefStringNullBandPositionCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionDatumDefStringNullBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionDatumDefStringNullBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { FieldOrDatumDefWithConditionDatumDefStringNullBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: FieldOrDatumDefWithConditionDatumDefStringNullBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AreaConfigTooltip (UnionType)
object AreaConfigTooltipCodec {
  def decode(j: JsValue): AreaConfigTooltip =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigTooltip] =
    j.asOpt[String].map { AreaConfigTooltipAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => AreaConfigTooltipAsNull }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    TooltipContentCodec.decodeOpt(j).orElse {
    j.asOpt[Boolean].map { AreaConfigTooltipAsBool(_) }.orElse {
    j.asOpt[JsNumber].map { AreaConfigTooltipAsNumber(_) } } } } } } 
  def encode(j: AreaConfigTooltip): JsValue =
    j match {
      case AreaConfigTooltipAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case AreaConfigTooltipAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:TooltipContent /* TypeRef */ => TooltipContentCodec.encode(x)
      case AreaConfigTooltipAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case AreaConfigTooltipAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfUnitSpecParamsElement (ArrayType)
object ArrayOfUnitSpecParamsElementCodec {
  def decode(j: JsValue): Seq[UnitSpecParamsElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[UnitSpecParamsElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      UnitSpecParamsElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[UnitSpecParamsElement]): JsArray =
      JsArray(j.map { x => UnitSpecParamsElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// ColorScheme (UnionType)
object ColorSchemeCodec {
  def decode(j: JsValue): ColorScheme =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ColorScheme] =
    CyclicalCodec.decodeOpt(j).orElse {
    SequentialMultiHueCodec.decodeOpt(j).orElse {
    SequentialSingleHueCodec.decodeOpt(j).orElse {
    DivergingCodec.decodeOpt(j).orElse {
    CategoricalCodec.decodeOpt(j) } } } } 
  def encode(j: ColorScheme): JsValue =
    j match {
      case x:Cyclical /* TypeRef */ => CyclicalCodec.encode(x)
      case x:SequentialMultiHue /* TypeRef */ => SequentialMultiHueCodec.encode(x)
      case x:SequentialSingleHue /* TypeRef */ => SequentialSingleHueCodec.encode(x)
      case x:Diverging /* TypeRef */ => DivergingCodec.encode(x)
      case x:Categorical /* TypeRef */ => CategoricalCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefRadius (UnionType)
object OverlayMarkDefRadiusCodec {
  def decode(j: JsValue): OverlayMarkDefRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefRadius] =
    j.asOpt[JsNumber].map { OverlayMarkDefRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefRadius): JsValue =
    j match {
      case OverlayMarkDefRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject1Title (UnionType)
object TopLevelRepeatSpecAsObject1TitleCodec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject1Title =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject1Title] =
    TextCodec.decodeOpt(j).orElse {
    TitleParamsCodec.decodeOpt(j) } 
  def encode(j: TopLevelRepeatSpecAsObject1Title): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:TitleParams /* TypeRef */ => TitleParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// IntervalSelectionConfigTranslate (UnionType)
object IntervalSelectionConfigTranslateCodec {
  def decode(j: JsValue): IntervalSelectionConfigTranslate =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[IntervalSelectionConfigTranslate] =
    j.asOpt[String].map { IntervalSelectionConfigTranslateAsString(_) }.orElse {
    j.asOpt[Boolean].map { IntervalSelectionConfigTranslateAsBool(_) } } 
  def encode(j: IntervalSelectionConfigTranslate): JsValue =
    j match {
      case IntervalSelectionConfigTranslateAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case IntervalSelectionConfigTranslateAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigTooltip (UnionType)
object LineConfigTooltipCodec {
  def decode(j: JsValue): LineConfigTooltip =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigTooltip] =
    j.asOpt[String].map { LineConfigTooltipAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => LineConfigTooltipAsNull }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    TooltipContentCodec.decodeOpt(j).orElse {
    j.asOpt[Boolean].map { LineConfigTooltipAsBool(_) }.orElse {
    j.asOpt[JsNumber].map { LineConfigTooltipAsNumber(_) } } } } } } 
  def encode(j: LineConfigTooltip): JsValue =
    j match {
      case LineConfigTooltipAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case LineConfigTooltipAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:TooltipContent /* TypeRef */ => TooltipContentCodec.encode(x)
      case LineConfigTooltipAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case LineConfigTooltipAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// EncodingXError2 (UnionType)
object EncodingXError2Codec {
  def decode(j: JsValue): EncodingXError2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[EncodingXError2] =
    SecondaryFieldDefCodec.decodeOpt(j).orElse {
    ValueDefNumberCodec.decodeOpt(j) } 
  def encode(j: EncodingXError2): JsValue =
    j match {
      case x:SecondaryFieldDef /* TypeRef */ => SecondaryFieldDefCodec.encode(x)
      case x:ValueDefNumber /* TypeRef */ => ValueDefNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Header (StructType)
object HeaderCodec {
  def decode(j: JsValue): Header =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Header] =
    Some(Header(
      `labelAngle` = (j \ "labelAngle").asOpt[JsValue].flatMap { x => HeaderLabelAngleCodec.decodeOpt(x) },
      `labelColor` = (j \ "labelColor").asOpt[JsValue].flatMap { x => HeaderLabelColorCodec.decodeOpt(x) },
      `labelFontWeight` = (j \ "labelFontWeight").asOpt[JsValue].flatMap { x => HeaderLabelFontWeightCodec.decodeOpt(x) },
      `titlePadding` = (j \ "titlePadding").asOpt[JsValue].flatMap { x => HeaderTitlePaddingCodec.decodeOpt(x) },
      `labels` = (j \ "labels").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `labelExpr` = (j \ "labelExpr").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `titleBaseline` = (j \ "titleBaseline").asOpt[JsValue].flatMap { x => HeaderTitleBaselineCodec.decodeOpt(x) },
      `labelBaseline` = (j \ "labelBaseline").asOpt[JsValue].flatMap { x => HeaderLabelBaselineCodec.decodeOpt(x) },
      `labelFontSize` = (j \ "labelFontSize").asOpt[JsValue].flatMap { x => HeaderLabelFontSizeCodec.decodeOpt(x) },
      `format` = (j \ "format").asOpt[JsValue].flatMap { x => HeaderFormatCodec.decodeOpt(x) },
      `titleFont` = (j \ "titleFont").asOpt[JsValue].flatMap { x => HeaderTitleFontCodec.decodeOpt(x) },
      `titleFontStyle` = (j \ "titleFontStyle").asOpt[JsValue].flatMap { x => HeaderTitleFontStyleCodec.decodeOpt(x) },
      `titleLineHeight` = (j \ "titleLineHeight").asOpt[JsValue].flatMap { x => HeaderTitleLineHeightCodec.decodeOpt(x) },
      `labelLineHeight` = (j \ "labelLineHeight").asOpt[JsValue].flatMap { x => HeaderLabelLineHeightCodec.decodeOpt(x) },
      `formatType` = (j \ "formatType").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `labelLimit` = (j \ "labelLimit").asOpt[JsValue].flatMap { x => HeaderLabelLimitCodec.decodeOpt(x) },
      `titleAnchor` = (j \ "titleAnchor").asOpt[JsValue].flatMap { x => TitleAnchorCodec.decodeOpt(x) },
      `titleColor` = (j \ "titleColor").asOpt[JsValue].flatMap { x => HeaderTitleColorCodec.decodeOpt(x) },
      `orient` = (j \ "orient").asOpt[JsValue].flatMap { x => OrientCodec.decodeOpt(x) },
      `titleOrient` = (j \ "titleOrient").asOpt[JsValue].flatMap { x => OrientCodec.decodeOpt(x) },
      `labelAlign` = (j \ "labelAlign").asOpt[JsValue].flatMap { x => HeaderLabelAlignCodec.decodeOpt(x) },
      `labelOrient` = (j \ "labelOrient").asOpt[JsValue].flatMap { x => OrientCodec.decodeOpt(x) },
      `titleAngle` = (j \ "titleAngle").asOpt[JsValue].flatMap { x => HeaderTitleAngleCodec.decodeOpt(x) },
      `labelPadding` = (j \ "labelPadding").asOpt[JsValue].flatMap { x => HeaderLabelPaddingCodec.decodeOpt(x) },
      `labelFont` = (j \ "labelFont").asOpt[JsValue].flatMap { x => HeaderLabelFontCodec.decodeOpt(x) },
      `labelAnchor` = (j \ "labelAnchor").asOpt[JsValue].flatMap { x => TitleAnchorCodec.decodeOpt(x) },
      `titleLimit` = (j \ "titleLimit").asOpt[JsValue].flatMap { x => HeaderTitleLimitCodec.decodeOpt(x) },
      `labelFontStyle` = (j \ "labelFontStyle").asOpt[JsValue].flatMap { x => HeaderLabelFontStyleCodec.decodeOpt(x) },
      `titleAlign` = (j \ "titleAlign").asOpt[JsValue].flatMap { x => HeaderTitleAlignCodec.decodeOpt(x) },
      `titleFontSize` = (j \ "titleFontSize").asOpt[JsValue].flatMap { x => HeaderTitleFontSizeCodec.decodeOpt(x) },
      `titleFontWeight` = (j \ "titleFontWeight").asOpt[JsValue].flatMap { x => HeaderTitleFontWeightCodec.decodeOpt(x) },
    ))

  def encode(j: Header): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`labelAngle`.map { x => "labelAngle" -> HeaderLabelAngleCodec.encode(x) },
        j.`labelColor`.map { x => "labelColor" -> HeaderLabelColorCodec.encode(x) },
        j.`labelFontWeight`.map { x => "labelFontWeight" -> HeaderLabelFontWeightCodec.encode(x) },
        j.`titlePadding`.map { x => "titlePadding" -> HeaderTitlePaddingCodec.encode(x) },
        j.`labels`.map { x => "labels" -> Json.toJson(x) },
        j.`labelExpr`.map { x => "labelExpr" -> Json.toJson(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`titleBaseline`.map { x => "titleBaseline" -> HeaderTitleBaselineCodec.encode(x) },
        j.`labelBaseline`.map { x => "labelBaseline" -> HeaderLabelBaselineCodec.encode(x) },
        j.`labelFontSize`.map { x => "labelFontSize" -> HeaderLabelFontSizeCodec.encode(x) },
        j.`format`.map { x => "format" -> HeaderFormatCodec.encode(x) },
        j.`titleFont`.map { x => "titleFont" -> HeaderTitleFontCodec.encode(x) },
        j.`titleFontStyle`.map { x => "titleFontStyle" -> HeaderTitleFontStyleCodec.encode(x) },
        j.`titleLineHeight`.map { x => "titleLineHeight" -> HeaderTitleLineHeightCodec.encode(x) },
        j.`labelLineHeight`.map { x => "labelLineHeight" -> HeaderLabelLineHeightCodec.encode(x) },
        j.`formatType`.map { x => "formatType" -> Json.toJson(x) },
        j.`labelLimit`.map { x => "labelLimit" -> HeaderLabelLimitCodec.encode(x) },
        j.`titleAnchor`.map { x => "titleAnchor" -> TitleAnchorCodec.encode(x) },
        j.`titleColor`.map { x => "titleColor" -> HeaderTitleColorCodec.encode(x) },
        j.`orient`.map { x => "orient" -> OrientCodec.encode(x) },
        j.`titleOrient`.map { x => "titleOrient" -> OrientCodec.encode(x) },
        j.`labelAlign`.map { x => "labelAlign" -> HeaderLabelAlignCodec.encode(x) },
        j.`labelOrient`.map { x => "labelOrient" -> OrientCodec.encode(x) },
        j.`titleAngle`.map { x => "titleAngle" -> HeaderTitleAngleCodec.encode(x) },
        j.`labelPadding`.map { x => "labelPadding" -> HeaderLabelPaddingCodec.encode(x) },
        j.`labelFont`.map { x => "labelFont" -> HeaderLabelFontCodec.encode(x) },
        j.`labelAnchor`.map { x => "labelAnchor" -> TitleAnchorCodec.encode(x) },
        j.`titleLimit`.map { x => "titleLimit" -> HeaderTitleLimitCodec.encode(x) },
        j.`labelFontStyle`.map { x => "labelFontStyle" -> HeaderLabelFontStyleCodec.encode(x) },
        j.`titleAlign`.map { x => "titleAlign" -> HeaderTitleAlignCodec.encode(x) },
        j.`titleFontSize`.map { x => "titleFontSize" -> HeaderTitleFontSizeCodec.encode(x) },
        j.`titleFontWeight`.map { x => "titleFontWeight" -> HeaderTitleFontWeightCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConditionalParameterValueDefTextExprRef (StructType)
object ConditionalParameterValueDefTextExprRefCodec {
  def decode(j: JsValue): ConditionalParameterValueDefTextExprRef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalParameterValueDefTextExprRef] =
    {
      val `empty` = (j \ "empty").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `param` = (j \ "param").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`param`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => ConditionalParameterValueDefTextExprRefValueCodec.decodeOpt(x) }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalParameterValueDefTextExprRef(
        `empty` = `empty`,
        `param` = `param`.get,
        `value` = `value`.get,
      ))
    }

  def encode(j: ConditionalParameterValueDefTextExprRef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`empty`.map { x => "empty" -> Json.toJson(x) },
        Some("param" -> Json.toJson(j.`param`)),
        Some("value" -> ConditionalParameterValueDefTextExprRefValueCodec.encode(j.`value`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// MarkConfigTheta (UnionType)
object MarkConfigThetaCodec {
  def decode(j: JsValue): MarkConfigTheta =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigTheta] =
    j.asOpt[JsNumber].map { MarkConfigThetaAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigTheta): JsValue =
    j match {
      case MarkConfigThetaAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefLineHeight (UnionType)
object MarkDefLineHeightCodec {
  def decode(j: JsValue): MarkDefLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefLineHeight] =
    j.asOpt[JsNumber].map { MarkDefLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefLineHeight): JsValue =
    j match {
      case MarkDefLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// IntervalSelectionConfigZoom (UnionType)
object IntervalSelectionConfigZoomCodec {
  def decode(j: JsValue): IntervalSelectionConfigZoom =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[IntervalSelectionConfigZoom] =
    j.asOpt[String].map { IntervalSelectionConfigZoomAsString(_) }.orElse {
    j.asOpt[Boolean].map { IntervalSelectionConfigZoomAsBool(_) } } 
  def encode(j: IntervalSelectionConfigZoom): JsValue =
    j match {
      case IntervalSelectionConfigZoomAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case IntervalSelectionConfigZoomAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PositionFieldDefBase (StructType)
object PositionFieldDefBaseCodec {
  def decode(j: JsValue): PositionFieldDefBase =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[PositionFieldDefBase] =
    Some(PositionFieldDefBase(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => PositionFieldDefBaseBandPositionCodec.decodeOpt(x) },
      `stack` = (j \ "stack").asOpt[JsValue].flatMap { x => PositionFieldDefBaseStackCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => PositionFieldDefBaseBinCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => PositionFieldDefBaseTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) },
    ))

  def encode(j: PositionFieldDefBase): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> PositionFieldDefBaseBandPositionCodec.encode(x) },
        j.`stack`.map { x => "stack" -> PositionFieldDefBaseStackCodec.encode(x) },
        j.`bin`.map { x => "bin" -> PositionFieldDefBaseBinCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> PositionFieldDefBaseTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// UnitSpecWithFrameHeight (UnionType)
object UnitSpecWithFrameHeightCodec {
  def decode(j: JsValue): UnitSpecWithFrameHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[UnitSpecWithFrameHeight] =
    j.asOpt[JsNumber].map { UnitSpecWithFrameHeightAsNumber(_) }.orElse {
    ContainerCodec.decodeOpt(j).orElse {
    StepCodec.decodeOpt(j) } } 
  def encode(j: UnitSpecWithFrameHeight): JsValue =
    j match {
      case UnitSpecWithFrameHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Container /* TypeRef */ => ContainerCodec.encode(x)
      case x:Step /* TypeRef */ => StepCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigEllipsis (UnionType)
object AreaConfigEllipsisCodec {
  def decode(j: JsValue): AreaConfigEllipsis =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigEllipsis] =
    j.asOpt[String].map { AreaConfigEllipsisAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigEllipsis): JsValue =
    j match {
      case AreaConfigEllipsisAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PositionDatumDefDatum (UnionType)
object PositionDatumDefDatumCodec {
  def decode(j: JsValue): PositionDatumDefDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PositionDatumDefDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: PositionDatumDefDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LookupSelection (StructType)
object LookupSelectionCodec {
  def decode(j: JsValue): LookupSelection =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LookupSelection] =
    {
      val `fields` = (j \ "fields").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) }
      val `key` = (j \ "key").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`key`.isEmpty) { return None }
      val `param` = (j \ "param").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`param`.isEmpty) { return None }
      return Some(LookupSelection(
        `fields` = `fields`,
        `key` = `key`.get,
        `param` = `param`.get,
      ))
    }

  def encode(j: LookupSelection): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`fields`.map { x => "fields" -> ArrayOfStringCodec.encode(x) },
        Some("key" -> Json.toJson(j.`key`)),
        Some("param" -> Json.toJson(j.`param`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// NumericMarkPropDef (UnionType)
object NumericMarkPropDefCodec {
  def decode(j: JsValue): NumericMarkPropDef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[NumericMarkPropDef] =
    FieldOrDatumDefWithConditionMarkPropFieldDefNumberCodec.decodeOpt(j).orElse {
    FieldOrDatumDefWithConditionDatumDefNumberCodec.decodeOpt(j).orElse {
    ValueDefWithConditionMarkPropFieldOrDatumDefNumberCodec.decodeOpt(j) } } 
  def encode(j: NumericMarkPropDef): JsValue =
    j match {
      case x:FieldOrDatumDefWithConditionMarkPropFieldDefNumber /* TypeRef */ => FieldOrDatumDefWithConditionMarkPropFieldDefNumberCodec.encode(x)
      case x:FieldOrDatumDefWithConditionDatumDefNumber /* TypeRef */ => FieldOrDatumDefWithConditionDatumDefNumberCodec.encode(x)
      case x:ValueDefWithConditionMarkPropFieldOrDatumDefNumber /* TypeRef */ => ValueDefWithConditionMarkPropFieldOrDatumDefNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfScaleDomainAsArrayElement (ArrayType)
object ArrayOfScaleDomainAsArrayElementCodec {
  def decode(j: JsValue): Seq[ScaleDomainAsArrayElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[ScaleDomainAsArrayElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      ScaleDomainAsArrayElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[ScaleDomainAsArrayElement]): JsArray =
      JsArray(j.map { x => ScaleDomainAsArrayElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// MarkConfigUrl (UnionType)
object MarkConfigUrlCodec {
  def decode(j: JsValue): MarkConfigUrl =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigUrl] =
    UriReferenceCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigUrl): JsValue =
    j match {
      case x:UriReference /* TypeRef */ => UriReferenceCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelLayerSpecWidth (UnionType)
object TopLevelLayerSpecWidthCodec {
  def decode(j: JsValue): TopLevelLayerSpecWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelLayerSpecWidth] =
    j.asOpt[JsNumber].map { TopLevelLayerSpecWidthAsNumber(_) }.orElse {
    ContainerCodec.decodeOpt(j).orElse {
    StepCodec.decodeOpt(j) } } 
  def encode(j: TopLevelLayerSpecWidth): JsValue =
    j match {
      case TopLevelLayerSpecWidthAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Container /* TypeRef */ => ContainerCodec.encode(x)
      case x:Step /* TypeRef */ => StepCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigWidth (UnionType)
object LineConfigWidthCodec {
  def decode(j: JsValue): LineConfigWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigWidth] =
    j.asOpt[JsNumber].map { LineConfigWidthAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigWidth): JsValue =
    j match {
      case LineConfigWidthAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigLabelFontSizeAsNumber (ConstrainedType)
object LegendConfigLabelFontSizeAsNumberCodec {
  def decode(j: JsValue): LegendConfigLabelFontSizeAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LegendConfigLabelFontSizeAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { LegendConfigLabelFontSizeAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: LegendConfigLabelFontSizeAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// DictOfInlineDataset (MapType)
object DictOfInlineDatasetCodec {
  def decode(j: JsValue): Map[String,InlineDataset] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Map[String,InlineDataset]] =
    j.asOpt[Map[String,JsValue]].map { _.mapValues { x => 
      InlineDatasetCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Map[String,InlineDataset]): JsObject =
      JsObject(j.mapValues { x => InlineDatasetCodec.encode(x) })
}


////////////////////////////////////////////////////////////////////////
// Vector7String (ConstrainedType)
object Vector7StringCodec {
  def decode(j: JsValue): Vector7String =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Vector7String] =
    try {
      ArrayOfStringCodec.decodeOpt(j)
        .map { Vector7String(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: Vector7String): JsValue =
    ArrayOfStringCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// BarConfigInnerRadius (ConstrainedType)
// see BarConfigInnerRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// AxisDomainOpacity (UnionType)
object AxisDomainOpacityCodec {
  def decode(j: JsValue): AxisDomainOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisDomainOpacity] =
    j.asOpt[JsNumber].map { AxisDomainOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisDomainOpacity): JsValue =
    j match {
      case AxisDomainOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigAngleAsNumber (ConstrainedType)
object RectConfigAngleAsNumberCodec {
  def decode(j: JsValue): RectConfigAngleAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RectConfigAngleAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { RectConfigAngleAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: RectConfigAngleAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// TitleConfigSubtitleFontSizeAsNumber (ConstrainedType)
object TitleConfigSubtitleFontSizeAsNumberCodec {
  def decode(j: JsValue): TitleConfigSubtitleFontSizeAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TitleConfigSubtitleFontSizeAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { TitleConfigSubtitleFontSizeAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: TitleConfigSubtitleFontSizeAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterMarkPropFieldOrDatumDef (UnionType)
object ConditionalParameterMarkPropFieldOrDatumDefCodec {
  def decode(j: JsValue): ConditionalParameterMarkPropFieldOrDatumDef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalParameterMarkPropFieldOrDatumDef] =
    ConditionalParameterMarkPropFieldOrDatumDefAsObject1Codec.decodeOpt(j).orElse {
    ConditionalParameterMarkPropFieldOrDatumDefAsObject2Codec.decodeOpt(j) } 
  def encode(j: ConditionalParameterMarkPropFieldOrDatumDef): JsValue =
    j match {
      case x:ConditionalParameterMarkPropFieldOrDatumDefAsObject1 /* TypeRef */ => ConditionalParameterMarkPropFieldOrDatumDefAsObject1Codec.encode(x)
      case x:ConditionalParameterMarkPropFieldOrDatumDefAsObject2 /* TypeRef */ => ConditionalParameterMarkPropFieldOrDatumDefAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetEncodingFieldDefTimeUnit (UnionType)
object FacetEncodingFieldDefTimeUnitCodec {
  def decode(j: JsValue): FacetEncodingFieldDefTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetEncodingFieldDefTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: FacetEncodingFieldDefTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendBinding (UnionType)
object LegendBindingCodec {
  def decode(j: JsValue): LegendBinding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendBinding] =
    LegendCodec.decodeOpt(j).orElse {
    LegendStreamBindingCodec.decodeOpt(j) } 
  def encode(j: LegendBinding): JsValue =
    j match {
      case x:Legend /* TypeRef */ => LegendCodec.encode(x)
      case x:LegendStreamBinding /* TypeRef */ => LegendStreamBindingCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// EventStreamAsObject2Filter (UnionType)
object EventStreamAsObject2FilterCodec {
  def decode(j: JsValue): EventStreamAsObject2Filter =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[EventStreamAsObject2Filter] =
    j.asOpt[String].map { EventStreamAsObject2FilterAsString(_) }.orElse {
    ArrayOfStringCodec.decodeOpt(j).map { EventStreamAsObject2FilterAsArrayOfString(_) } } 
  def encode(j: EventStreamAsObject2Filter): JsValue =
    j match {
      case EventStreamAsObject2FilterAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case EventStreamAsObject2FilterAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigAlign (UnionType)
object LineConfigAlignCodec {
  def decode(j: JsValue): LineConfigAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigAlign] =
    AlignCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigAlign): JsValue =
    j match {
      case x:Align /* TypeRef */ => AlignCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisLabelFontWeightAsObject2Condition (UnionType)
object ConditionalAxisLabelFontWeightAsObject2ConditionCodec {
  def decode(j: JsValue): ConditionalAxisLabelFontWeightAsObject2Condition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisLabelFontWeightAsObject2Condition] =
    ConditionalPredicateValueDefFontWeightNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalPredicateValueDefFontWeightNullExprRefCodec.decodeOpt(j).map { ConditionalAxisLabelFontWeightAsObject2ConditionAsArrayOfConditionalPredicateValueDefFontWeightNullExprRef(_) } } 
  def encode(j: ConditionalAxisLabelFontWeightAsObject2Condition): JsValue =
    j match {
      case x:ConditionalPredicateValueDefFontWeightNullExprRef /* TypeRef */ => ConditionalPredicateValueDefFontWeightNullExprRefCodec.encode(x)
      case ConditionalAxisLabelFontWeightAsObject2ConditionAsArrayOfConditionalPredicateValueDefFontWeightNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalPredicateValueDefFontWeightNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfig (StructType)
object BarConfigCodec {
  def decode(j: JsValue): BarConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BarConfig] =
    Some(BarConfig(
      `continuousBandSize` = (j \ "continuousBandSize").asOpt[JsValue].flatMap { x => BarConfigContinuousBandSizeCodec.decodeOpt(x) },
      `cornerRadiusBottomRight` = (j \ "cornerRadiusBottomRight").asOpt[JsValue].flatMap { x => BarConfigCornerRadiusBottomRightCodec.decodeOpt(x) },
      `fillOpacity` = (j \ "fillOpacity").asOpt[JsValue].flatMap { x => BarConfigFillOpacityCodec.decodeOpt(x) },
      `strokeMiterLimit` = (j \ "strokeMiterLimit").asOpt[JsValue].flatMap { x => BarConfigStrokeMiterLimitCodec.decodeOpt(x) },
      `dir` = (j \ "dir").asOpt[JsValue].flatMap { x => BarConfigDirCodec.decodeOpt(x) },
      `tooltip` = (j \ "tooltip").asOpt[JsValue].flatMap { x => BarConfigTooltipCodec.decodeOpt(x) },
      `timeUnitBandPosition` = (j \ "timeUnitBandPosition").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `cornerRadiusTopRight` = (j \ "cornerRadiusTopRight").asOpt[JsValue].flatMap { x => BarConfigCornerRadiusTopRightCodec.decodeOpt(x) },
      `outerRadius` = (j \ "outerRadius").asOpt[JsValue].flatMap { x => BarConfigOuterRadiusCodec.decodeOpt(x) },
      `x` = (j \ "x").asOpt[JsValue].flatMap { x => BarConfigXCodec.decodeOpt(x) },
      `dy` = (j \ "dy").asOpt[JsValue].flatMap { x => BarConfigDyCodec.decodeOpt(x) },
      `size` = (j \ "size").asOpt[JsValue].flatMap { x => BarConfigSizeCodec.decodeOpt(x) },
      `smooth` = (j \ "smooth").asOpt[JsValue].flatMap { x => BarConfigSmoothCodec.decodeOpt(x) },
      `url` = (j \ "url").asOpt[JsValue].flatMap { x => BarConfigUrlCodec.decodeOpt(x) },
      `y` = (j \ "y").asOpt[JsValue].flatMap { x => BarConfigYCodec.decodeOpt(x) },
      `strokeOpacity` = (j \ "strokeOpacity").asOpt[JsValue].flatMap { x => BarConfigStrokeOpacityCodec.decodeOpt(x) },
      `ellipsis` = (j \ "ellipsis").asOpt[JsValue].flatMap { x => BarConfigEllipsisCodec.decodeOpt(x) },
      `description` = (j \ "description").asOpt[JsValue].flatMap { x => BarConfigDescriptionCodec.decodeOpt(x) },
      `angle` = (j \ "angle").asOpt[JsValue].flatMap { x => BarConfigAngleCodec.decodeOpt(x) },
      `lineBreak` = (j \ "lineBreak").asOpt[JsValue].flatMap { x => BarConfigLineBreakCodec.decodeOpt(x) },
      `tension` = (j \ "tension").asOpt[JsValue].flatMap { x => BarConfigTensionCodec.decodeOpt(x) },
      `cornerRadiusTopLeft` = (j \ "cornerRadiusTopLeft").asOpt[JsValue].flatMap { x => BarConfigCornerRadiusTopLeftCodec.decodeOpt(x) },
      `stroke` = (j \ "stroke").asOpt[JsValue].flatMap { x => BarConfigStrokeCodec.decodeOpt(x) },
      `strokeDashOffset` = (j \ "strokeDashOffset").asOpt[JsValue].flatMap { x => BarConfigStrokeDashOffsetCodec.decodeOpt(x) },
      `align` = (j \ "align").asOpt[JsValue].flatMap { x => BarConfigAlignCodec.decodeOpt(x) },
      `ariaRole` = (j \ "ariaRole").asOpt[JsValue].flatMap { x => BarConfigAriaRoleCodec.decodeOpt(x) },
      `strokeCap` = (j \ "strokeCap").asOpt[JsValue].flatMap { x => BarConfigStrokeCapCodec.decodeOpt(x) },
      `endAngle` = (j \ "endAngle").asOpt[JsValue].flatMap { x => BarConfigEndAngleCodec.decodeOpt(x) },
      `strokeJoin` = (j \ "strokeJoin").asOpt[JsValue].flatMap { x => BarConfigStrokeJoinCodec.decodeOpt(x) },
      `baseline` = (j \ "baseline").asOpt[JsValue].flatMap { x => BarConfigBaselineCodec.decodeOpt(x) },
      `ariaRoleDescription` = (j \ "ariaRoleDescription").asOpt[JsValue].flatMap { x => BarConfigAriaRoleDescriptionCodec.decodeOpt(x) },
      `aspect` = (j \ "aspect").asOpt[JsValue].flatMap { x => BarConfigAspectCodec.decodeOpt(x) },
      `height` = (j \ "height").asOpt[JsValue].flatMap { x => BarConfigHeightCodec.decodeOpt(x) },
      `fontStyle` = (j \ "fontStyle").asOpt[JsValue].flatMap { x => BarConfigFontStyleCodec.decodeOpt(x) },
      `text` = (j \ "text").asOpt[JsValue].flatMap { x => BarConfigTextCodec.decodeOpt(x) },
      `binSpacing` = (j \ "binSpacing").asOpt[JsValue].flatMap { x => BarConfigBinSpacingCodec.decodeOpt(x) },
      `cornerRadius` = (j \ "cornerRadius").asOpt[JsValue].flatMap { x => BarConfigCornerRadiusCodec.decodeOpt(x) },
      `color` = (j \ "color").asOpt[JsValue].flatMap { x => BarConfigColorCodec.decodeOpt(x) },
      `x2` = (j \ "x2").asOpt[JsValue].flatMap { x => BarConfigX2Codec.decodeOpt(x) },
      `padAngle` = (j \ "padAngle").asOpt[JsValue].flatMap { x => BarConfigPadAngleCodec.decodeOpt(x) },
      `cursor` = (j \ "cursor").asOpt[JsValue].flatMap { x => BarConfigCursorCodec.decodeOpt(x) },
      `radius` = (j \ "radius").asOpt[JsValue].flatMap { x => BarConfigRadiusCodec.decodeOpt(x) },
      `timeUnitBandSize` = (j \ "timeUnitBandSize").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `startAngle` = (j \ "startAngle").asOpt[JsValue].flatMap { x => BarConfigStartAngleCodec.decodeOpt(x) },
      `font` = (j \ "font").asOpt[JsValue].flatMap { x => BarConfigFontCodec.decodeOpt(x) },
      `radius2` = (j \ "radius2").asOpt[JsValue].flatMap { x => BarConfigRadius2Codec.decodeOpt(x) },
      `invalid` = (j \ "invalid").asOpt[JsValue].flatMap { x => BarConfigInvalidCodec.decodeOpt(x) },
      `lineHeight` = (j \ "lineHeight").asOpt[JsValue].flatMap { x => BarConfigLineHeightCodec.decodeOpt(x) },
      `order` = (j \ "order").asOpt[JsValue].flatMap { x => BarConfigOrderCodec.decodeOpt(x) },
      `fill` = (j \ "fill").asOpt[JsValue].flatMap { x => BarConfigFillCodec.decodeOpt(x) },
      `interpolate` = (j \ "interpolate").asOpt[JsValue].flatMap { x => BarConfigInterpolateCodec.decodeOpt(x) },
      `theta` = (j \ "theta").asOpt[JsValue].flatMap { x => BarConfigThetaCodec.decodeOpt(x) },
      `innerRadius` = (j \ "innerRadius").asOpt[JsValue].flatMap { x => BarConfigInnerRadiusCodec.decodeOpt(x) },
      `fontSize` = (j \ "fontSize").asOpt[JsValue].flatMap { x => BarConfigFontSizeCodec.decodeOpt(x) },
      `y2` = (j \ "y2").asOpt[JsValue].flatMap { x => BarConfigY2Codec.decodeOpt(x) },
      `orient` = (j \ "orient").asOpt[JsValue].flatMap { x => OrientationCodec.decodeOpt(x) },
      `discreteBandSize` = (j \ "discreteBandSize").asOpt[JsValue].flatMap { x => BarConfigDiscreteBandSizeCodec.decodeOpt(x) },
      `shape` = (j \ "shape").asOpt[JsValue].flatMap { x => BarConfigShapeCodec.decodeOpt(x) },
      `aria` = (j \ "aria").asOpt[JsValue].flatMap { x => BarConfigAriaCodec.decodeOpt(x) },
      `opacity` = (j \ "opacity").asOpt[JsValue].flatMap { x => BarConfigOpacityCodec.decodeOpt(x) },
      `dx` = (j \ "dx").asOpt[JsValue].flatMap { x => BarConfigDxCodec.decodeOpt(x) },
      `cornerRadiusEnd` = (j \ "cornerRadiusEnd").asOpt[JsValue].flatMap { x => BarConfigCornerRadiusEndCodec.decodeOpt(x) },
      `cornerRadiusBottomLeft` = (j \ "cornerRadiusBottomLeft").asOpt[JsValue].flatMap { x => BarConfigCornerRadiusBottomLeftCodec.decodeOpt(x) },
      `href` = (j \ "href").asOpt[JsValue].flatMap { x => BarConfigHrefCodec.decodeOpt(x) },
      `strokeDash` = (j \ "strokeDash").asOpt[JsValue].flatMap { x => BarConfigStrokeDashCodec.decodeOpt(x) },
      `strokeOffset` = (j \ "strokeOffset").asOpt[JsValue].flatMap { x => BarConfigStrokeOffsetCodec.decodeOpt(x) },
      `limit` = (j \ "limit").asOpt[JsValue].flatMap { x => BarConfigLimitCodec.decodeOpt(x) },
      `width` = (j \ "width").asOpt[JsValue].flatMap { x => BarConfigWidthCodec.decodeOpt(x) },
      `fontWeight` = (j \ "fontWeight").asOpt[JsValue].flatMap { x => BarConfigFontWeightCodec.decodeOpt(x) },
      `filled` = (j \ "filled").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `blend` = (j \ "blend").asOpt[JsValue].flatMap { x => BarConfigBlendCodec.decodeOpt(x) },
      `strokeWidth` = (j \ "strokeWidth").asOpt[JsValue].flatMap { x => BarConfigStrokeWidthCodec.decodeOpt(x) },
      `theta2` = (j \ "theta2").asOpt[JsValue].flatMap { x => BarConfigTheta2Codec.decodeOpt(x) },
    ))

  def encode(j: BarConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`continuousBandSize`.map { x => "continuousBandSize" -> BarConfigContinuousBandSizeCodec.encode(x) },
        j.`cornerRadiusBottomRight`.map { x => "cornerRadiusBottomRight" -> BarConfigCornerRadiusBottomRightCodec.encode(x) },
        j.`fillOpacity`.map { x => "fillOpacity" -> BarConfigFillOpacityCodec.encode(x) },
        j.`strokeMiterLimit`.map { x => "strokeMiterLimit" -> BarConfigStrokeMiterLimitCodec.encode(x) },
        j.`dir`.map { x => "dir" -> BarConfigDirCodec.encode(x) },
        j.`tooltip`.map { x => "tooltip" -> BarConfigTooltipCodec.encode(x) },
        j.`timeUnitBandPosition`.map { x => "timeUnitBandPosition" -> Json.toJson(x) },
        j.`cornerRadiusTopRight`.map { x => "cornerRadiusTopRight" -> BarConfigCornerRadiusTopRightCodec.encode(x) },
        j.`outerRadius`.map { x => "outerRadius" -> BarConfigOuterRadiusCodec.encode(x) },
        j.`x`.map { x => "x" -> BarConfigXCodec.encode(x) },
        j.`dy`.map { x => "dy" -> BarConfigDyCodec.encode(x) },
        j.`size`.map { x => "size" -> BarConfigSizeCodec.encode(x) },
        j.`smooth`.map { x => "smooth" -> BarConfigSmoothCodec.encode(x) },
        j.`url`.map { x => "url" -> BarConfigUrlCodec.encode(x) },
        j.`y`.map { x => "y" -> BarConfigYCodec.encode(x) },
        j.`strokeOpacity`.map { x => "strokeOpacity" -> BarConfigStrokeOpacityCodec.encode(x) },
        j.`ellipsis`.map { x => "ellipsis" -> BarConfigEllipsisCodec.encode(x) },
        j.`description`.map { x => "description" -> BarConfigDescriptionCodec.encode(x) },
        j.`angle`.map { x => "angle" -> BarConfigAngleCodec.encode(x) },
        j.`lineBreak`.map { x => "lineBreak" -> BarConfigLineBreakCodec.encode(x) },
        j.`tension`.map { x => "tension" -> BarConfigTensionCodec.encode(x) },
        j.`cornerRadiusTopLeft`.map { x => "cornerRadiusTopLeft" -> BarConfigCornerRadiusTopLeftCodec.encode(x) },
        j.`stroke`.map { x => "stroke" -> BarConfigStrokeCodec.encode(x) },
        j.`strokeDashOffset`.map { x => "strokeDashOffset" -> BarConfigStrokeDashOffsetCodec.encode(x) },
        j.`align`.map { x => "align" -> BarConfigAlignCodec.encode(x) },
        j.`ariaRole`.map { x => "ariaRole" -> BarConfigAriaRoleCodec.encode(x) },
        j.`strokeCap`.map { x => "strokeCap" -> BarConfigStrokeCapCodec.encode(x) },
        j.`endAngle`.map { x => "endAngle" -> BarConfigEndAngleCodec.encode(x) },
        j.`strokeJoin`.map { x => "strokeJoin" -> BarConfigStrokeJoinCodec.encode(x) },
        j.`baseline`.map { x => "baseline" -> BarConfigBaselineCodec.encode(x) },
        j.`ariaRoleDescription`.map { x => "ariaRoleDescription" -> BarConfigAriaRoleDescriptionCodec.encode(x) },
        j.`aspect`.map { x => "aspect" -> BarConfigAspectCodec.encode(x) },
        j.`height`.map { x => "height" -> BarConfigHeightCodec.encode(x) },
        j.`fontStyle`.map { x => "fontStyle" -> BarConfigFontStyleCodec.encode(x) },
        j.`text`.map { x => "text" -> BarConfigTextCodec.encode(x) },
        j.`binSpacing`.map { x => "binSpacing" -> BarConfigBinSpacingCodec.encode(x) },
        j.`cornerRadius`.map { x => "cornerRadius" -> BarConfigCornerRadiusCodec.encode(x) },
        j.`color`.map { x => "color" -> BarConfigColorCodec.encode(x) },
        j.`x2`.map { x => "x2" -> BarConfigX2Codec.encode(x) },
        j.`padAngle`.map { x => "padAngle" -> BarConfigPadAngleCodec.encode(x) },
        j.`cursor`.map { x => "cursor" -> BarConfigCursorCodec.encode(x) },
        j.`radius`.map { x => "radius" -> BarConfigRadiusCodec.encode(x) },
        j.`timeUnitBandSize`.map { x => "timeUnitBandSize" -> Json.toJson(x) },
        j.`startAngle`.map { x => "startAngle" -> BarConfigStartAngleCodec.encode(x) },
        j.`font`.map { x => "font" -> BarConfigFontCodec.encode(x) },
        j.`radius2`.map { x => "radius2" -> BarConfigRadius2Codec.encode(x) },
        j.`invalid`.map { x => "invalid" -> BarConfigInvalidCodec.encode(x) },
        j.`lineHeight`.map { x => "lineHeight" -> BarConfigLineHeightCodec.encode(x) },
        j.`order`.map { x => "order" -> BarConfigOrderCodec.encode(x) },
        j.`fill`.map { x => "fill" -> BarConfigFillCodec.encode(x) },
        j.`interpolate`.map { x => "interpolate" -> BarConfigInterpolateCodec.encode(x) },
        j.`theta`.map { x => "theta" -> BarConfigThetaCodec.encode(x) },
        j.`innerRadius`.map { x => "innerRadius" -> BarConfigInnerRadiusCodec.encode(x) },
        j.`fontSize`.map { x => "fontSize" -> BarConfigFontSizeCodec.encode(x) },
        j.`y2`.map { x => "y2" -> BarConfigY2Codec.encode(x) },
        j.`orient`.map { x => "orient" -> OrientationCodec.encode(x) },
        j.`discreteBandSize`.map { x => "discreteBandSize" -> BarConfigDiscreteBandSizeCodec.encode(x) },
        j.`shape`.map { x => "shape" -> BarConfigShapeCodec.encode(x) },
        j.`aria`.map { x => "aria" -> BarConfigAriaCodec.encode(x) },
        j.`opacity`.map { x => "opacity" -> BarConfigOpacityCodec.encode(x) },
        j.`dx`.map { x => "dx" -> BarConfigDxCodec.encode(x) },
        j.`cornerRadiusEnd`.map { x => "cornerRadiusEnd" -> BarConfigCornerRadiusEndCodec.encode(x) },
        j.`cornerRadiusBottomLeft`.map { x => "cornerRadiusBottomLeft" -> BarConfigCornerRadiusBottomLeftCodec.encode(x) },
        j.`href`.map { x => "href" -> BarConfigHrefCodec.encode(x) },
        j.`strokeDash`.map { x => "strokeDash" -> BarConfigStrokeDashCodec.encode(x) },
        j.`strokeOffset`.map { x => "strokeOffset" -> BarConfigStrokeOffsetCodec.encode(x) },
        j.`limit`.map { x => "limit" -> BarConfigLimitCodec.encode(x) },
        j.`width`.map { x => "width" -> BarConfigWidthCodec.encode(x) },
        j.`fontWeight`.map { x => "fontWeight" -> BarConfigFontWeightCodec.encode(x) },
        j.`filled`.map { x => "filled" -> Json.toJson(x) },
        j.`blend`.map { x => "blend" -> BarConfigBlendCodec.encode(x) },
        j.`strokeWidth`.map { x => "strokeWidth" -> BarConfigStrokeWidthCodec.encode(x) },
        j.`theta2`.map { x => "theta2" -> BarConfigTheta2Codec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// MarkConfigY (UnionType)
object MarkConfigYCodec {
  def decode(j: JsValue): MarkConfigY =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigY] =
    j.asOpt[JsNumber].map { MarkConfigYAsNumber(_) }.orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: MarkConfigY): JsValue =
    j match {
      case MarkConfigYAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingFillBandPosition (ConstrainedType)
object SharedEncodingFillBandPositionCodec {
  def decode(j: JsValue): SharedEncodingFillBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingFillBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingFillBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingFillBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkDefX2 (UnionType)
object MarkDefX2Codec {
  def decode(j: JsValue): MarkDefX2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefX2] =
    j.asOpt[JsNumber].map { MarkDefX2AsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: MarkDefX2): JsValue =
    j match {
      case MarkDefX2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigInvalid (EnumType)
object MarkConfigInvalidCodec {
  def decode(j: JsValue): MarkConfigInvalid =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigInvalid] =
    j match {
      case JsString("filter") => Some(MarkConfigInvalidFilter)
      case JsNull => Some(MarkConfigInvalidUndefined)
      case _ => None
    }
  def encode(j: MarkConfigInvalid): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// LegendConfig (StructType)
object LegendConfigCodec {
  def decode(j: JsValue): LegendConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LegendConfig] =
    Some(LegendConfig(
      `gradientVerticalMinLength` = (j \ "gradientVerticalMinLength").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `labelFontWeight` = (j \ "labelFontWeight").asOpt[JsValue].flatMap { x => LegendConfigLabelFontWeightCodec.decodeOpt(x) },
      `columnPadding` = (j \ "columnPadding").asOpt[JsValue].flatMap { x => LegendConfigColumnPaddingCodec.decodeOpt(x) },
      `symbolOpacity` = (j \ "symbolOpacity").asOpt[JsValue].flatMap { x => LegendConfigSymbolOpacityCodec.decodeOpt(x) },
      `labelOffset` = (j \ "labelOffset").asOpt[JsValue].flatMap { x => LegendConfigLabelOffsetCodec.decodeOpt(x) },
      `labelFontSize` = (j \ "labelFontSize").asOpt[JsValue].flatMap { x => LegendConfigLabelFontSizeCodec.decodeOpt(x) },
      `gridAlign` = (j \ "gridAlign").asOpt[JsValue].flatMap { x => LegendConfigGridAlignCodec.decodeOpt(x) },
      `symbolStrokeWidth` = (j \ "symbolStrokeWidth").asOpt[JsValue].flatMap { x => LegendConfigSymbolStrokeWidthCodec.decodeOpt(x) },
      `labelOpacity` = (j \ "labelOpacity").asOpt[JsValue].flatMap { x => LegendConfigLabelOpacityCodec.decodeOpt(x) },
      `gradientStrokeColor` = (j \ "gradientStrokeColor").asOpt[JsValue].flatMap { x => LegendConfigGradientStrokeColorCodec.decodeOpt(x) },
      `symbolFillColor` = (j \ "symbolFillColor").asOpt[JsValue].flatMap { x => LegendConfigSymbolFillColorCodec.decodeOpt(x) },
      `tickCount` = (j \ "tickCount").asOpt[JsValue].flatMap { x => LegendConfigTickCountCodec.decodeOpt(x) },
      `gradientHorizontalMaxLength` = (j \ "gradientHorizontalMaxLength").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `description` = (j \ "description").asOpt[JsValue].flatMap { x => LegendConfigDescriptionCodec.decodeOpt(x) },
      `titleFont` = (j \ "titleFont").asOpt[JsValue].flatMap { x => LegendConfigTitleFontCodec.decodeOpt(x) },
      `legendX` = (j \ "legendX").asOpt[JsValue].flatMap { x => LegendConfigLegendXCodec.decodeOpt(x) },
      `titleFontStyle` = (j \ "titleFontStyle").asOpt[JsValue].flatMap { x => LegendConfigTitleFontStyleCodec.decodeOpt(x) },
      `gradientLength` = (j \ "gradientLength").asOpt[JsValue].flatMap { x => LegendConfigGradientLengthCodec.decodeOpt(x) },
      `labelColor` = (j \ "labelColor").asOpt[JsValue].flatMap { x => LegendConfigLabelColorCodec.decodeOpt(x) },
      `clipHeight` = (j \ "clipHeight").asOpt[JsValue].flatMap { x => LegendConfigClipHeightCodec.decodeOpt(x) },
      `titleLineHeight` = (j \ "titleLineHeight").asOpt[JsValue].flatMap { x => LegendConfigTitleLineHeightCodec.decodeOpt(x) },
      `direction` = (j \ "direction").asOpt[JsValue].flatMap { x => OrientationCodec.decodeOpt(x) },
      `cornerRadius` = (j \ "cornerRadius").asOpt[JsValue].flatMap { x => LegendConfigCornerRadiusCodec.decodeOpt(x) },
      `gradientStrokeWidth` = (j \ "gradientStrokeWidth").asOpt[JsValue].flatMap { x => LegendConfigGradientStrokeWidthCodec.decodeOpt(x) },
      `symbolStrokeColor` = (j \ "symbolStrokeColor").asOpt[JsValue].flatMap { x => LegendConfigSymbolStrokeColorCodec.decodeOpt(x) },
      `gradientDirection` = (j \ "gradientDirection").asOpt[JsValue].flatMap { x => LegendConfigGradientDirectionCodec.decodeOpt(x) },
      `symbolBaseFillColor` = (j \ "symbolBaseFillColor").asOpt[JsValue].flatMap { x => LegendConfigSymbolBaseFillColorCodec.decodeOpt(x) },
      `gradientThickness` = (j \ "gradientThickness").asOpt[JsValue].flatMap { x => LegendConfigGradientThicknessCodec.decodeOpt(x) },
      `titlePadding` = (j \ "titlePadding").asOpt[JsValue].flatMap { x => LegendConfigTitlePaddingCodec.decodeOpt(x) },
      `rowPadding` = (j \ "rowPadding").asOpt[JsValue].flatMap { x => LegendConfigRowPaddingCodec.decodeOpt(x) },
      `gradientVerticalMaxLength` = (j \ "gradientVerticalMaxLength").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `gradientHorizontalMinLength` = (j \ "gradientHorizontalMinLength").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `offset` = (j \ "offset").asOpt[JsValue].flatMap { x => LegendConfigOffsetCodec.decodeOpt(x) },
      `symbolDash` = (j \ "symbolDash").asOpt[JsValue].flatMap { x => LegendConfigSymbolDashCodec.decodeOpt(x) },
      `symbolBaseStrokeColor` = (j \ "symbolBaseStrokeColor").asOpt[JsValue].flatMap { x => LegendConfigSymbolBaseStrokeColorCodec.decodeOpt(x) },
      `zindex` = (j \ "zindex").asOpt[JsValue].flatMap { x => LegendConfigZindexCodec.decodeOpt(x) },
      `symbolOffset` = (j \ "symbolOffset").asOpt[JsValue].flatMap { x => LegendConfigSymbolOffsetCodec.decodeOpt(x) },
      `labelLimit` = (j \ "labelLimit").asOpt[JsValue].flatMap { x => LegendConfigLabelLimitCodec.decodeOpt(x) },
      `titleAnchor` = (j \ "titleAnchor").asOpt[JsValue].flatMap { x => LegendConfigTitleAnchorCodec.decodeOpt(x) },
      `titleColor` = (j \ "titleColor").asOpt[JsValue].flatMap { x => LegendConfigTitleColorCodec.decodeOpt(x) },
      `columns` = (j \ "columns").asOpt[JsValue].flatMap { x => LegendConfigColumnsCodec.decodeOpt(x) },
      `labelOverlap` = (j \ "labelOverlap").asOpt[JsValue].flatMap { x => LegendConfigLabelOverlapCodec.decodeOpt(x) },
      `symbolDirection` = (j \ "symbolDirection").asOpt[JsValue].flatMap { x => LegendConfigSymbolDirectionCodec.decodeOpt(x) },
      `symbolType` = (j \ "symbolType").asOpt[JsValue].flatMap { x => LegendConfigSymbolTypeCodec.decodeOpt(x) },
      `symbolSize` = (j \ "symbolSize").asOpt[JsValue].flatMap { x => LegendConfigSymbolSizeCodec.decodeOpt(x) },
      `orient` = (j \ "orient").asOpt[JsValue].flatMap { x => LegendOrientCodec.decodeOpt(x) },
      `gradientLabelLimit` = (j \ "gradientLabelLimit").asOpt[JsValue].flatMap { x => LegendConfigGradientLabelLimitCodec.decodeOpt(x) },
      `titleOrient` = (j \ "titleOrient").asOpt[JsValue].flatMap { x => LegendConfigTitleOrientCodec.decodeOpt(x) },
      `labelAlign` = (j \ "labelAlign").asOpt[JsValue].flatMap { x => LegendConfigLabelAlignCodec.decodeOpt(x) },
      `disable` = (j \ "disable").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `unselectedOpacity` = (j \ "unselectedOpacity").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `labelPadding` = (j \ "labelPadding").asOpt[JsValue].flatMap { x => LegendConfigLabelPaddingCodec.decodeOpt(x) },
      `aria` = (j \ "aria").asOpt[JsValue].flatMap { x => LegendConfigAriaCodec.decodeOpt(x) },
      `padding` = (j \ "padding").asOpt[JsValue].flatMap { x => LegendConfigPaddingCodec.decodeOpt(x) },
      `layout` = (j \ "layout").asOpt[JsValue].flatMap { x => ExprRefCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => x.asOpt[JsNull.type].map { _ => JsNull } },
      `symbolLimit` = (j \ "symbolLimit").asOpt[JsValue].flatMap { x => LegendConfigSymbolLimitCodec.decodeOpt(x) },
      `titleLimit` = (j \ "titleLimit").asOpt[JsValue].flatMap { x => LegendConfigTitleLimitCodec.decodeOpt(x) },
      `strokeDash` = (j \ "strokeDash").asOpt[JsValue].flatMap { x => LegendConfigStrokeDashCodec.decodeOpt(x) },
      `labelFont` = (j \ "labelFont").asOpt[JsValue].flatMap { x => LegendConfigLabelFontCodec.decodeOpt(x) },
      `symbolDashOffset` = (j \ "symbolDashOffset").asOpt[JsValue].flatMap { x => LegendConfigSymbolDashOffsetCodec.decodeOpt(x) },
      `labelFontStyle` = (j \ "labelFontStyle").asOpt[JsValue].flatMap { x => LegendConfigLabelFontStyleCodec.decodeOpt(x) },
      `titleOpacity` = (j \ "titleOpacity").asOpt[JsValue].flatMap { x => LegendConfigTitleOpacityCodec.decodeOpt(x) },
      `titleAlign` = (j \ "titleAlign").asOpt[JsValue].flatMap { x => LegendConfigTitleAlignCodec.decodeOpt(x) },
      `labelSeparation` = (j \ "labelSeparation").asOpt[JsValue].flatMap { x => LegendConfigLabelSeparationCodec.decodeOpt(x) },
      `strokeColor` = (j \ "strokeColor").asOpt[JsValue].flatMap { x => LegendConfigStrokeColorCodec.decodeOpt(x) },
      `gradientOpacity` = (j \ "gradientOpacity").asOpt[JsValue].flatMap { x => LegendConfigGradientOpacityCodec.decodeOpt(x) },
      `titleBaseline` = (j \ "titleBaseline").asOpt[JsValue].flatMap { x => LegendConfigTitleBaselineCodec.decodeOpt(x) },
      `legendY` = (j \ "legendY").asOpt[JsValue].flatMap { x => LegendConfigLegendYCodec.decodeOpt(x) },
      `strokeWidth` = (j \ "strokeWidth").asOpt[JsValue].flatMap { x => LegendConfigStrokeWidthCodec.decodeOpt(x) },
      `titleFontSize` = (j \ "titleFontSize").asOpt[JsValue].flatMap { x => LegendConfigTitleFontSizeCodec.decodeOpt(x) },
      `gradientLabelOffset` = (j \ "gradientLabelOffset").asOpt[JsValue].flatMap { x => LegendConfigGradientLabelOffsetCodec.decodeOpt(x) },
      `titleFontWeight` = (j \ "titleFontWeight").asOpt[JsValue].flatMap { x => LegendConfigTitleFontWeightCodec.decodeOpt(x) },
      `labelBaseline` = (j \ "labelBaseline").asOpt[JsValue].flatMap { x => LegendConfigLabelBaselineCodec.decodeOpt(x) },
      `fillColor` = (j \ "fillColor").asOpt[JsValue].flatMap { x => LegendConfigFillColorCodec.decodeOpt(x) },
    ))

  def encode(j: LegendConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`gradientVerticalMinLength`.map { x => "gradientVerticalMinLength" -> Json.toJson(x) },
        j.`labelFontWeight`.map { x => "labelFontWeight" -> LegendConfigLabelFontWeightCodec.encode(x) },
        j.`columnPadding`.map { x => "columnPadding" -> LegendConfigColumnPaddingCodec.encode(x) },
        j.`symbolOpacity`.map { x => "symbolOpacity" -> LegendConfigSymbolOpacityCodec.encode(x) },
        j.`labelOffset`.map { x => "labelOffset" -> LegendConfigLabelOffsetCodec.encode(x) },
        j.`labelFontSize`.map { x => "labelFontSize" -> LegendConfigLabelFontSizeCodec.encode(x) },
        j.`gridAlign`.map { x => "gridAlign" -> LegendConfigGridAlignCodec.encode(x) },
        j.`symbolStrokeWidth`.map { x => "symbolStrokeWidth" -> LegendConfigSymbolStrokeWidthCodec.encode(x) },
        j.`labelOpacity`.map { x => "labelOpacity" -> LegendConfigLabelOpacityCodec.encode(x) },
        j.`gradientStrokeColor`.map { x => "gradientStrokeColor" -> LegendConfigGradientStrokeColorCodec.encode(x) },
        j.`symbolFillColor`.map { x => "symbolFillColor" -> LegendConfigSymbolFillColorCodec.encode(x) },
        j.`tickCount`.map { x => "tickCount" -> LegendConfigTickCountCodec.encode(x) },
        j.`gradientHorizontalMaxLength`.map { x => "gradientHorizontalMaxLength" -> Json.toJson(x) },
        j.`description`.map { x => "description" -> LegendConfigDescriptionCodec.encode(x) },
        j.`titleFont`.map { x => "titleFont" -> LegendConfigTitleFontCodec.encode(x) },
        j.`legendX`.map { x => "legendX" -> LegendConfigLegendXCodec.encode(x) },
        j.`titleFontStyle`.map { x => "titleFontStyle" -> LegendConfigTitleFontStyleCodec.encode(x) },
        j.`gradientLength`.map { x => "gradientLength" -> LegendConfigGradientLengthCodec.encode(x) },
        j.`labelColor`.map { x => "labelColor" -> LegendConfigLabelColorCodec.encode(x) },
        j.`clipHeight`.map { x => "clipHeight" -> LegendConfigClipHeightCodec.encode(x) },
        j.`titleLineHeight`.map { x => "titleLineHeight" -> LegendConfigTitleLineHeightCodec.encode(x) },
        j.`direction`.map { x => "direction" -> OrientationCodec.encode(x) },
        j.`cornerRadius`.map { x => "cornerRadius" -> LegendConfigCornerRadiusCodec.encode(x) },
        j.`gradientStrokeWidth`.map { x => "gradientStrokeWidth" -> LegendConfigGradientStrokeWidthCodec.encode(x) },
        j.`symbolStrokeColor`.map { x => "symbolStrokeColor" -> LegendConfigSymbolStrokeColorCodec.encode(x) },
        j.`gradientDirection`.map { x => "gradientDirection" -> LegendConfigGradientDirectionCodec.encode(x) },
        j.`symbolBaseFillColor`.map { x => "symbolBaseFillColor" -> LegendConfigSymbolBaseFillColorCodec.encode(x) },
        j.`gradientThickness`.map { x => "gradientThickness" -> LegendConfigGradientThicknessCodec.encode(x) },
        j.`titlePadding`.map { x => "titlePadding" -> LegendConfigTitlePaddingCodec.encode(x) },
        j.`rowPadding`.map { x => "rowPadding" -> LegendConfigRowPaddingCodec.encode(x) },
        j.`gradientVerticalMaxLength`.map { x => "gradientVerticalMaxLength" -> Json.toJson(x) },
        j.`gradientHorizontalMinLength`.map { x => "gradientHorizontalMinLength" -> Json.toJson(x) },
        j.`offset`.map { x => "offset" -> LegendConfigOffsetCodec.encode(x) },
        j.`symbolDash`.map { x => "symbolDash" -> LegendConfigSymbolDashCodec.encode(x) },
        j.`symbolBaseStrokeColor`.map { x => "symbolBaseStrokeColor" -> LegendConfigSymbolBaseStrokeColorCodec.encode(x) },
        j.`zindex`.map { x => "zindex" -> LegendConfigZindexCodec.encode(x) },
        j.`symbolOffset`.map { x => "symbolOffset" -> LegendConfigSymbolOffsetCodec.encode(x) },
        j.`labelLimit`.map { x => "labelLimit" -> LegendConfigLabelLimitCodec.encode(x) },
        j.`titleAnchor`.map { x => "titleAnchor" -> LegendConfigTitleAnchorCodec.encode(x) },
        j.`titleColor`.map { x => "titleColor" -> LegendConfigTitleColorCodec.encode(x) },
        j.`columns`.map { x => "columns" -> LegendConfigColumnsCodec.encode(x) },
        j.`labelOverlap`.map { x => "labelOverlap" -> LegendConfigLabelOverlapCodec.encode(x) },
        j.`symbolDirection`.map { x => "symbolDirection" -> LegendConfigSymbolDirectionCodec.encode(x) },
        j.`symbolType`.map { x => "symbolType" -> LegendConfigSymbolTypeCodec.encode(x) },
        j.`symbolSize`.map { x => "symbolSize" -> LegendConfigSymbolSizeCodec.encode(x) },
        j.`orient`.map { x => "orient" -> LegendOrientCodec.encode(x) },
        j.`gradientLabelLimit`.map { x => "gradientLabelLimit" -> LegendConfigGradientLabelLimitCodec.encode(x) },
        j.`titleOrient`.map { x => "titleOrient" -> LegendConfigTitleOrientCodec.encode(x) },
        j.`labelAlign`.map { x => "labelAlign" -> LegendConfigLabelAlignCodec.encode(x) },
        j.`disable`.map { x => "disable" -> Json.toJson(x) },
        j.`unselectedOpacity`.map { x => "unselectedOpacity" -> Json.toJson(x) },
        j.`labelPadding`.map { x => "labelPadding" -> LegendConfigLabelPaddingCodec.encode(x) },
        j.`aria`.map { x => "aria" -> LegendConfigAriaCodec.encode(x) },
        j.`padding`.map { x => "padding" -> LegendConfigPaddingCodec.encode(x) },
        j.`layout`.map { x => "layout" -> ExprRefCodec.encode(x) },
        j.`title`.map { x => "title" -> Json.toJson(x) },
        j.`symbolLimit`.map { x => "symbolLimit" -> LegendConfigSymbolLimitCodec.encode(x) },
        j.`titleLimit`.map { x => "titleLimit" -> LegendConfigTitleLimitCodec.encode(x) },
        j.`strokeDash`.map { x => "strokeDash" -> LegendConfigStrokeDashCodec.encode(x) },
        j.`labelFont`.map { x => "labelFont" -> LegendConfigLabelFontCodec.encode(x) },
        j.`symbolDashOffset`.map { x => "symbolDashOffset" -> LegendConfigSymbolDashOffsetCodec.encode(x) },
        j.`labelFontStyle`.map { x => "labelFontStyle" -> LegendConfigLabelFontStyleCodec.encode(x) },
        j.`titleOpacity`.map { x => "titleOpacity" -> LegendConfigTitleOpacityCodec.encode(x) },
        j.`titleAlign`.map { x => "titleAlign" -> LegendConfigTitleAlignCodec.encode(x) },
        j.`labelSeparation`.map { x => "labelSeparation" -> LegendConfigLabelSeparationCodec.encode(x) },
        j.`strokeColor`.map { x => "strokeColor" -> LegendConfigStrokeColorCodec.encode(x) },
        j.`gradientOpacity`.map { x => "gradientOpacity" -> LegendConfigGradientOpacityCodec.encode(x) },
        j.`titleBaseline`.map { x => "titleBaseline" -> LegendConfigTitleBaselineCodec.encode(x) },
        j.`legendY`.map { x => "legendY" -> LegendConfigLegendYCodec.encode(x) },
        j.`strokeWidth`.map { x => "strokeWidth" -> LegendConfigStrokeWidthCodec.encode(x) },
        j.`titleFontSize`.map { x => "titleFontSize" -> LegendConfigTitleFontSizeCodec.encode(x) },
        j.`gradientLabelOffset`.map { x => "gradientLabelOffset" -> LegendConfigGradientLabelOffsetCodec.encode(x) },
        j.`titleFontWeight`.map { x => "titleFontWeight" -> LegendConfigTitleFontWeightCodec.encode(x) },
        j.`labelBaseline`.map { x => "labelBaseline" -> LegendConfigLabelBaselineCodec.encode(x) },
        j.`fillColor`.map { x => "fillColor" -> LegendConfigFillColorCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TimeUnitTransformTimeUnit (UnionType)
object TimeUnitTransformTimeUnitCodec {
  def decode(j: JsValue): TimeUnitTransformTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TimeUnitTransformTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: TimeUnitTransformTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigQuantileCount (ConstrainedType)
object ScaleConfigQuantileCountCodec {
  def decode(j: JsValue): ScaleConfigQuantileCount =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ScaleConfigQuantileCount] =
    try {
      j.asOpt[JsNumber]
        .map { ScaleConfigQuantileCount(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ScaleConfigQuantileCount): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// HeaderConfigTitleFontStyle (UnionType)
object HeaderConfigTitleFontStyleCodec {
  def decode(j: JsValue): HeaderConfigTitleFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigTitleFontStyle] =
    j.asOpt[String].map { HeaderConfigTitleFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderConfigTitleFontStyle): JsValue =
    j match {
      case HeaderConfigTitleFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigLineBreak (UnionType)
object AreaConfigLineBreakCodec {
  def decode(j: JsValue): AreaConfigLineBreak =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigLineBreak] =
    j.asOpt[String].map { AreaConfigLineBreakAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigLineBreak): JsValue =
    j match {
      case AreaConfigLineBreakAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefRadius (ConstrainedType)
// see OverlayMarkDefRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// AxisConfigMinExtent (UnionType)
object AxisConfigMinExtentCodec {
  def decode(j: JsValue): AxisConfigMinExtent =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigMinExtent] =
    j.asOpt[JsNumber].map { AxisConfigMinExtentAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigMinExtent): JsValue =
    j match {
      case AxisConfigMinExtentAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionStringDatumDefTextFormat (UnionType)
object FieldOrDatumDefWithConditionStringDatumDefTextFormatCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionStringDatumDefTextFormat =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionStringDatumDefTextFormat] =
    j.asOpt[String].map { FieldOrDatumDefWithConditionStringDatumDefTextFormatAsString(_) }.orElse {
    DictOfAnyCodec.decodeOpt(j).map { FieldOrDatumDefWithConditionStringDatumDefTextFormatAsDictOfAny(_) } } 
  def encode(j: FieldOrDatumDefWithConditionStringDatumDefTextFormat): JsValue =
    j match {
      case FieldOrDatumDefWithConditionStringDatumDefTextFormatAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case FieldOrDatumDefWithConditionStringDatumDefTextFormatAsDictOfAny(x) /* Base, MapType */ => DictOfAnyCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigInnerRadius (UnionType)
object MarkConfigInnerRadiusCodec {
  def decode(j: JsValue): MarkConfigInnerRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigInnerRadius] =
    j.asOpt[JsNumber].map { MarkConfigInnerRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigInnerRadius): JsValue =
    j match {
      case MarkConfigInnerRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsStyle (UnionType)
object TitleParamsStyleCodec {
  def decode(j: JsValue): TitleParamsStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsStyle] =
    j.asOpt[String].map { TitleParamsStyleAsString(_) }.orElse {
    ArrayOfStringCodec.decodeOpt(j).map { TitleParamsStyleAsArrayOfString(_) } } 
  def encode(j: TitleParamsStyle): JsValue =
    j match {
      case TitleParamsStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case TitleParamsStyleAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingRadiusStack (UnionType)
object SharedEncodingRadiusStackCodec {
  def decode(j: JsValue): SharedEncodingRadiusStack =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingRadiusStack] =
    StackOffsetCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingRadiusStackAsNull }.orElse {
    j.asOpt[Boolean].map { SharedEncodingRadiusStackAsBool(_) } } } 
  def encode(j: SharedEncodingRadiusStack): JsValue =
    j match {
      case x:StackOffset /* TypeRef */ => StackOffsetCodec.encode(x)
      case SharedEncodingRadiusStackAsNull /* Global, NullType$ */ => JsNull
      case SharedEncodingRadiusStackAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SecondaryFieldDef (StructType)
object SecondaryFieldDefCodec {
  def decode(j: JsValue): SecondaryFieldDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SecondaryFieldDef] =
    Some(SecondaryFieldDef(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SecondaryFieldDefBandPositionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => x.asOpt[JsNull.type].map { _ => JsNull } },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SecondaryFieldDefTimeUnitCodec.decodeOpt(x) },
    ))

  def encode(j: SecondaryFieldDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SecondaryFieldDefBandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> Json.toJson(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SecondaryFieldDefTimeUnitCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AxisConfigLabelOverlap (UnionType)
object AxisConfigLabelOverlapCodec {
  def decode(j: JsValue): AxisConfigLabelOverlap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigLabelOverlap] =
    LabelOverlapCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigLabelOverlap): JsValue =
    j match {
      case x:LabelOverlap /* TypeRef */ => LabelOverlapCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigBlend (UnionType)
object TickConfigBlendCodec {
  def decode(j: JsValue): TickConfigBlend =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigBlend] =
    BlendCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigBlend): JsValue =
    j match {
      case x:Blend /* TypeRef */ => BlendCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigMinFontSize (ConstrainedType)
object ScaleConfigMinFontSizeCodec {
  def decode(j: JsValue): ScaleConfigMinFontSize =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ScaleConfigMinFontSize] =
    try {
      j.asOpt[JsNumber]
        .map { ScaleConfigMinFontSize(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ScaleConfigMinFontSize): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// LegendConfigSymbolStrokeColor (UnionType)
object LegendConfigSymbolStrokeColorCodec {
  def decode(j: JsValue): LegendConfigSymbolStrokeColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigSymbolStrokeColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => LegendConfigSymbolStrokeColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: LegendConfigSymbolStrokeColor): JsValue =
    j match {
      case LegendConfigSymbolStrokeColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTranslate (UnionType)
object AxisTranslateCodec {
  def decode(j: JsValue): AxisTranslate =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTranslate] =
    j.asOpt[JsNumber].map { AxisTranslateAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisTranslate): JsValue =
    j match {
      case AxisTranslateAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigHref (UnionType)
object BarConfigHrefCodec {
  def decode(j: JsValue): BarConfigHref =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigHref] =
    UriReferenceCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigHref): JsValue =
    j match {
      case x:UriReference /* TypeRef */ => UriReferenceCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefStrokeOpacityAsNumber (ConstrainedType)
object MarkDefStrokeOpacityAsNumberCodec {
  def decode(j: JsValue): MarkDefStrokeOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[MarkDefStrokeOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { MarkDefStrokeOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: MarkDefStrokeOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// TitleParamsAngle (UnionType)
object TitleParamsAngleCodec {
  def decode(j: JsValue): TitleParamsAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsAngle] =
    j.asOpt[JsNumber].map { TitleParamsAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleParamsAngle): JsValue =
    j match {
      case TitleParamsAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewConfigStrokeCap (UnionType)
object ViewConfigStrokeCapCodec {
  def decode(j: JsValue): ViewConfigStrokeCap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewConfigStrokeCap] =
    StrokeCapCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ViewConfigStrokeCap): JsValue =
    j match {
      case x:StrokeCap /* TypeRef */ => StrokeCapCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTickCount (ConstrainedType)
// see AxisConfigTickCount (UnionType)

////////////////////////////////////////////////////////////////////////
// MarkConfigCornerRadiusBottomLeft (UnionType)
object MarkConfigCornerRadiusBottomLeftCodec {
  def decode(j: JsValue): MarkConfigCornerRadiusBottomLeft =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigCornerRadiusBottomLeft] =
    j.asOpt[JsNumber].map { MarkConfigCornerRadiusBottomLeftAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigCornerRadiusBottomLeft): JsValue =
    j match {
      case MarkConfigCornerRadiusBottomLeftAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigStrokeOpacityAsNumber (ConstrainedType)
object LineConfigStrokeOpacityAsNumberCodec {
  def decode(j: JsValue): LineConfigStrokeOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LineConfigStrokeOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { LineConfigStrokeOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: LineConfigStrokeOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigRectBandPaddingInner (ConstrainedType)
// see ScaleConfigRectBandPaddingInner (UnionType)

////////////////////////////////////////////////////////////////////////
// TitleOrient (EnumType)
object TitleOrientCodec {
  def decode(j: JsValue): TitleOrient =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleOrient] =
    j match {
      case JsString("none") => Some(TitleOrientNone)
      case JsString("left") => Some(TitleOrientLeft)
      case JsString("right") => Some(TitleOrientRight)
      case JsString("top") => Some(TitleOrientTop)
      case JsString("bottom") => Some(TitleOrientBottom)
      case _ => None
    }
  def encode(j: TitleOrient): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// FacetedUnitSpecAlign (UnionType)
object FacetedUnitSpecAlignCodec {
  def decode(j: JsValue): FacetedUnitSpecAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetedUnitSpecAlign] =
    LayoutAlignCodec.decodeOpt(j).orElse {
    RowColLayoutAlignCodec.decodeOpt(j) } 
  def encode(j: FacetedUnitSpecAlign): JsValue =
    j match {
      case x:LayoutAlign /* TypeRef */ => LayoutAlignCodec.encode(x)
      case x:RowColLayoutAlign /* TypeRef */ => RowColLayoutAlignCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleConfigFrame (UnionType)
object TitleConfigFrameCodec {
  def decode(j: JsValue): TitleConfigFrame =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigFrame] =
    TitleFrameCodec.decodeOpt(j).orElse {
    j.asOpt[String].map { TitleConfigFrameAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: TitleConfigFrame): JsValue =
    j match {
      case x:TitleFrame /* TypeRef */ => TitleFrameCodec.encode(x)
      case TitleConfigFrameAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PositionDatumDefBaseBandPosition (ConstrainedType)
object PositionDatumDefBaseBandPositionCodec {
  def decode(j: JsValue): PositionDatumDefBaseBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[PositionDatumDefBaseBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { PositionDatumDefBaseBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: PositionDatumDefBaseBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ProjectionReflectX (UnionType)
object ProjectionReflectXCodec {
  def decode(j: JsValue): ProjectionReflectX =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionReflectX] =
    j.asOpt[Boolean].map { ProjectionReflectXAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionReflectX): JsValue =
    j match {
      case ProjectionReflectXAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTitleOpacity (UnionType)
object AxisConfigTitleOpacityCodec {
  def decode(j: JsValue): AxisConfigTitleOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTitleOpacity] =
    j.asOpt[JsNumber].map { AxisConfigTitleOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigTitleOpacity): JsValue =
    j match {
      case AxisConfigTitleOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigAriaRoleDescription (UnionType)
object AreaConfigAriaRoleDescriptionCodec {
  def decode(j: JsValue): AreaConfigAriaRoleDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigAriaRoleDescription] =
    j.asOpt[String].map { AreaConfigAriaRoleDescriptionAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigAriaRoleDescription): JsValue =
    j match {
      case AreaConfigAriaRoleDescriptionAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// UtcMultiTimeUnit (EnumType)
object UtcMultiTimeUnitCodec {
  def decode(j: JsValue): UtcMultiTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[UtcMultiTimeUnit] =
    j match {
      case JsString("utcyearquarter") => Some(UtcMultiTimeUnitUtcyearquarter)
      case JsString("utcyearquartermonth") => Some(UtcMultiTimeUnitUtcyearquartermonth)
      case JsString("utcyearmonth") => Some(UtcMultiTimeUnitUtcyearmonth)
      case JsString("utcyearmonthdate") => Some(UtcMultiTimeUnitUtcyearmonthdate)
      case JsString("utcyearmonthdatehours") => Some(UtcMultiTimeUnitUtcyearmonthdatehours)
      case JsString("utcyearmonthdatehoursminutes") => Some(UtcMultiTimeUnitUtcyearmonthdatehoursminutes)
      case JsString("utcyearmonthdatehoursminutesseconds") => Some(UtcMultiTimeUnitUtcyearmonthdatehoursminutesseconds)
      case JsString("utcyearweek") => Some(UtcMultiTimeUnitUtcyearweek)
      case JsString("utcyearweekday") => Some(UtcMultiTimeUnitUtcyearweekday)
      case JsString("utcyearweekdayhours") => Some(UtcMultiTimeUnitUtcyearweekdayhours)
      case JsString("utcyearweekdayhoursminutes") => Some(UtcMultiTimeUnitUtcyearweekdayhoursminutes)
      case JsString("utcyearweekdayhoursminutesseconds") => Some(UtcMultiTimeUnitUtcyearweekdayhoursminutesseconds)
      case JsString("utcyeardayofyear") => Some(UtcMultiTimeUnitUtcyeardayofyear)
      case JsString("utcquartermonth") => Some(UtcMultiTimeUnitUtcquartermonth)
      case JsString("utcmonthdate") => Some(UtcMultiTimeUnitUtcmonthdate)
      case JsString("utcmonthdatehours") => Some(UtcMultiTimeUnitUtcmonthdatehours)
      case JsString("utcmonthdatehoursminutes") => Some(UtcMultiTimeUnitUtcmonthdatehoursminutes)
      case JsString("utcmonthdatehoursminutesseconds") => Some(UtcMultiTimeUnitUtcmonthdatehoursminutesseconds)
      case JsString("utcweekday") => Some(UtcMultiTimeUnitUtcweekday)
      case JsString("utcweeksdayhours") => Some(UtcMultiTimeUnitUtcweeksdayhours)
      case JsString("utcweekdayhoursminutes") => Some(UtcMultiTimeUnitUtcweekdayhoursminutes)
      case JsString("utcweekdayhoursminutesseconds") => Some(UtcMultiTimeUnitUtcweekdayhoursminutesseconds)
      case JsString("utcdayhours") => Some(UtcMultiTimeUnitUtcdayhours)
      case JsString("utcdayhoursminutes") => Some(UtcMultiTimeUnitUtcdayhoursminutes)
      case JsString("utcdayhoursminutesseconds") => Some(UtcMultiTimeUnitUtcdayhoursminutesseconds)
      case JsString("utchoursminutes") => Some(UtcMultiTimeUnitUtchoursminutes)
      case JsString("utchoursminutesseconds") => Some(UtcMultiTimeUnitUtchoursminutesseconds)
      case JsString("utcminutesseconds") => Some(UtcMultiTimeUnitUtcminutesseconds)
      case JsString("utcsecondsmilliseconds") => Some(UtcMultiTimeUnitUtcsecondsmilliseconds)
      case _ => None
    }
  def encode(j: UtcMultiTimeUnit): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// ScaleConfigMinStrokeWidth (ConstrainedType)
object ScaleConfigMinStrokeWidthCodec {
  def decode(j: JsValue): ScaleConfigMinStrokeWidth =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ScaleConfigMinStrokeWidth] =
    try {
      j.asOpt[JsNumber]
        .map { ScaleConfigMinStrokeWidth(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ScaleConfigMinStrokeWidth): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// TitleConfigFontSizeAsNumber (ConstrainedType)
object TitleConfigFontSizeAsNumberCodec {
  def decode(j: JsValue): TitleConfigFontSizeAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TitleConfigFontSizeAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { TitleConfigFontSizeAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: TitleConfigFontSizeAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// RowColumnEncodingFieldDefBin (UnionType)
object RowColumnEncodingFieldDefBinCodec {
  def decode(j: JsValue): RowColumnEncodingFieldDefBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RowColumnEncodingFieldDefBin] =
    j.asOpt[Boolean].map { RowColumnEncodingFieldDefBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => RowColumnEncodingFieldDefBinAsNull } } } 
  def encode(j: RowColumnEncodingFieldDefBin): JsValue =
    j match {
      case RowColumnEncodingFieldDefBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case RowColumnEncodingFieldDefBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigDir (UnionType)
object LineConfigDirCodec {
  def decode(j: JsValue): LineConfigDir =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigDir] =
    TextDirectionCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigDir): JsValue =
    j match {
      case x:TextDirection /* TypeRef */ => TextDirectionCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetSpec (StructType)
object FacetSpecCodec {
  def decode(j: JsValue): FacetSpec =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FacetSpec] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `center` = (j \ "center").asOpt[JsValue].flatMap { x => FacetSpecCenterCodec.decodeOpt(x) }
      val `description` = (j \ "description").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `bounds` = (j \ "bounds").asOpt[JsValue].flatMap { x => FacetSpecBoundsCodec.decodeOpt(x) }
      val `columns` = (j \ "columns").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `resolve` = (j \ "resolve").asOpt[JsValue].flatMap { x => ResolveCodec.decodeOpt(x) }
      val `spec` = (j \ "spec").asOpt[JsValue].flatMap { x => FacetSpecSpecCodec.decodeOpt(x) }
      if(`spec`.isEmpty) { return None }
      val `facet` = (j \ "facet").asOpt[JsValue].flatMap { x => FacetSpecFacetCodec.decodeOpt(x) }
      if(`facet`.isEmpty) { return None }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => FacetSpecTitleCodec.decodeOpt(x) }
      val `align` = (j \ "align").asOpt[JsValue].flatMap { x => FacetSpecAlignCodec.decodeOpt(x) }
      val `data` = (j \ "data").asOpt[JsValue].flatMap { x => DataCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `spacing` = (j \ "spacing").asOpt[JsValue].flatMap { x => FacetSpecSpacingCodec.decodeOpt(x) }
      val `transform` = (j \ "transform").asOpt[JsValue].flatMap { x => ArrayOfTransformCodec.decodeOpt(x) }
      return Some(FacetSpec(
        `name` = `name`,
        `center` = `center`,
        `description` = `description`,
        `bounds` = `bounds`,
        `columns` = `columns`,
        `resolve` = `resolve`,
        `spec` = `spec`.get,
        `facet` = `facet`.get,
        `title` = `title`,
        `align` = `align`,
        `data` = `data`,
        `spacing` = `spacing`,
        `transform` = `transform`,
      ))
    }

  def encode(j: FacetSpec): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`center`.map { x => "center" -> FacetSpecCenterCodec.encode(x) },
        j.`description`.map { x => "description" -> Json.toJson(x) },
        j.`bounds`.map { x => "bounds" -> FacetSpecBoundsCodec.encode(x) },
        j.`columns`.map { x => "columns" -> Json.toJson(x) },
        j.`resolve`.map { x => "resolve" -> ResolveCodec.encode(x) },
        Some("spec" -> FacetSpecSpecCodec.encode(j.`spec`)),
        Some("facet" -> FacetSpecFacetCodec.encode(j.`facet`)),
        j.`title`.map { x => "title" -> FacetSpecTitleCodec.encode(x) },
        j.`align`.map { x => "align" -> FacetSpecAlignCodec.encode(x) },
        j.`data`.map { x => "data" -> DataCodec.encode(x) },
        j.`spacing`.map { x => "spacing" -> FacetSpecSpacingCodec.encode(x) },
        j.`transform`.map { x => "transform" -> ArrayOfTransformCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LegendConfigGradientThicknessAsNumber (ConstrainedType)
object LegendConfigGradientThicknessAsNumberCodec {
  def decode(j: JsValue): LegendConfigGradientThicknessAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LegendConfigGradientThicknessAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { LegendConfigGradientThicknessAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: LegendConfigGradientThicknessAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// TickConfigInnerRadius (UnionType)
object TickConfigInnerRadiusCodec {
  def decode(j: JsValue): TickConfigInnerRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigInnerRadius] =
    j.asOpt[JsNumber].map { TickConfigInnerRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigInnerRadius): JsValue =
    j match {
      case TickConfigInnerRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingFillOpacity (StructType)
object SharedEncodingFillOpacityCodec {
  def decode(j: JsValue): SharedEncodingFillOpacity =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingFillOpacity] =
    Some(SharedEncodingFillOpacity(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingFillOpacityDatumCodec.decodeOpt(x) },
      `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingFillOpacityBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => SharedEncodingFillOpacityConditionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingFillOpacityBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingFillOpacityValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingFillOpacityTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => SharedEncodingFillOpacityTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingFillOpacity): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingFillOpacityDatumCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingFillOpacityBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> SharedEncodingFillOpacityConditionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingFillOpacityBinCodec.encode(x) },
        j.`value`.map { x => "value" -> SharedEncodingFillOpacityValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingFillOpacityTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> SharedEncodingFillOpacityTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TickConfigCornerRadiusTopRight (UnionType)
object TickConfigCornerRadiusTopRightCodec {
  def decode(j: JsValue): TickConfigCornerRadiusTopRight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigCornerRadiusTopRight] =
    j.asOpt[JsNumber].map { TickConfigCornerRadiusTopRightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigCornerRadiusTopRight): JsValue =
    j match {
      case TickConfigCornerRadiusTopRightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigGridAlign (UnionType)
object LegendConfigGridAlignCodec {
  def decode(j: JsValue): LegendConfigGridAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigGridAlign] =
    LayoutAlignCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigGridAlign): JsValue =
    j match {
      case x:LayoutAlign /* TypeRef */ => LayoutAlignCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigShape (UnionType)
object TickConfigShapeCodec {
  def decode(j: JsValue): TickConfigShape =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigShape] =
    j.asOpt[String].map { TickConfigShapeAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigShape): JsValue =
    j match {
      case TickConfigShapeAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// DensityTransform (StructType)
object DensityTransformCodec {
  def decode(j: JsValue): DensityTransform =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[DensityTransform] =
    {
      val `cumulative` = (j \ "cumulative").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `density` = (j \ "density").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`density`.isEmpty) { return None }
      val `groupby` = (j \ "groupby").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) }
      val `minsteps` = (j \ "minsteps").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `extent` = (j \ "extent").asOpt[JsValue].flatMap { x => DensityTransformExtentCodec.decodeOpt(x) }
      val `maxsteps` = (j \ "maxsteps").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `bandwidth` = (j \ "bandwidth").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `as` = (j \ "as").asOpt[JsValue].flatMap { x => DensityTransformAsCodec.decodeOpt(x) }
      val `counts` = (j \ "counts").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `steps` = (j \ "steps").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      return Some(DensityTransform(
        `cumulative` = `cumulative`,
        `density` = `density`.get,
        `groupby` = `groupby`,
        `minsteps` = `minsteps`,
        `extent` = `extent`,
        `maxsteps` = `maxsteps`,
        `bandwidth` = `bandwidth`,
        `as` = `as`,
        `counts` = `counts`,
        `steps` = `steps`,
      ))
    }

  def encode(j: DensityTransform): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`cumulative`.map { x => "cumulative" -> Json.toJson(x) },
        Some("density" -> Json.toJson(j.`density`)),
        j.`groupby`.map { x => "groupby" -> ArrayOfStringCodec.encode(x) },
        j.`minsteps`.map { x => "minsteps" -> Json.toJson(x) },
        j.`extent`.map { x => "extent" -> DensityTransformExtentCodec.encode(x) },
        j.`maxsteps`.map { x => "maxsteps" -> Json.toJson(x) },
        j.`bandwidth`.map { x => "bandwidth" -> Json.toJson(x) },
        j.`as`.map { x => "as" -> DensityTransformAsCodec.encode(x) },
        j.`counts`.map { x => "counts" -> Json.toJson(x) },
        j.`steps`.map { x => "steps" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingColorType (UnionType)
object SharedEncodingColorTypeCodec {
  def decode(j: JsValue): SharedEncodingColorType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingColorType] =
    StandardTypeCodec.decodeOpt(j).orElse {
    TypeCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingColorType): JsValue =
    j match {
      case x:StandardType /* TypeRef */ => StandardTypeCodec.encode(x)
      case x:Type /* TypeRef */ => TypeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderLabelFontSize (ConstrainedType)
// see HeaderLabelFontSize (UnionType)

////////////////////////////////////////////////////////////////////////
// AxisTitleX (UnionType)
object AxisTitleXCodec {
  def decode(j: JsValue): AxisTitleX =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTitleX] =
    j.asOpt[JsNumber].map { AxisTitleXAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisTitleX): JsValue =
    j match {
      case AxisTitleXAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetFieldDef (StructType)
object FacetFieldDefCodec {
  def decode(j: JsValue): FacetFieldDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FacetFieldDef] =
    Some(FacetFieldDef(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => FacetFieldDefBandPositionCodec.decodeOpt(x) },
      `header` = (j \ "header").asOpt[JsValue].flatMap { x => HeaderCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => FacetFieldDefBinCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => FacetFieldDefTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => FacetFieldDefSortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) },
    ))

  def encode(j: FacetFieldDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> FacetFieldDefBandPositionCodec.encode(x) },
        j.`header`.map { x => "header" -> HeaderCodec.encode(x) },
        j.`bin`.map { x => "bin" -> FacetFieldDefBinCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> FacetFieldDefTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> FacetFieldDefSortCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ViewConfigDiscreteWidth (UnionType)
object ViewConfigDiscreteWidthCodec {
  def decode(j: JsValue): ViewConfigDiscreteWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewConfigDiscreteWidth] =
    j.asOpt[JsNumber].map { ViewConfigDiscreteWidthAsNumber(_) }.orElse {
    ViewConfigDiscreteWidthAsObject2Codec.decodeOpt(j) } 
  def encode(j: ViewConfigDiscreteWidth): JsValue =
    j match {
      case ViewConfigDiscreteWidthAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ViewConfigDiscreteWidthAsObject2 /* TypeRef */ => ViewConfigDiscreteWidthAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LayerRepeatSpecAlign (UnionType)
object LayerRepeatSpecAlignCodec {
  def decode(j: JsValue): LayerRepeatSpecAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LayerRepeatSpecAlign] =
    LayoutAlignCodec.decodeOpt(j).orElse {
    RowColLayoutAlignCodec.decodeOpt(j) } 
  def encode(j: LayerRepeatSpecAlign): JsValue =
    j match {
      case x:LayoutAlign /* TypeRef */ => LayoutAlignCodec.encode(x)
      case x:RowColLayoutAlign /* TypeRef */ => RowColLayoutAlignCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigAria (UnionType)
object AxisConfigAriaCodec {
  def decode(j: JsValue): AxisConfigAria =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigAria] =
    j.asOpt[Boolean].map { AxisConfigAriaAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigAria): JsValue =
    j match {
      case AxisConfigAriaAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsSubtitleLineHeight (UnionType)
object TitleParamsSubtitleLineHeightCodec {
  def decode(j: JsValue): TitleParamsSubtitleLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsSubtitleLineHeight] =
    j.asOpt[JsNumber].map { TitleParamsSubtitleLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleParamsSubtitleLineHeight): JsValue =
    j match {
      case TitleParamsSubtitleLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Vector2Vector2Number (ConstrainedType)
object Vector2Vector2NumberCodec {
  def decode(j: JsValue): Vector2Vector2Number =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Vector2Vector2Number] =
    try {
      ArrayOfVector2NumberCodec.decodeOpt(j)
        .map { Vector2Vector2Number(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: Vector2Vector2Number): JsValue =
    ArrayOfVector2NumberCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingDescription (StructType)
object SharedEncodingDescriptionCodec {
  def decode(j: JsValue): SharedEncodingDescription =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingDescription] =
    Some(SharedEncodingDescription(
      `format` = (j \ "format").asOpt[JsValue].flatMap { x => SharedEncodingDescriptionFormatCodec.decodeOpt(x) },
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingDescriptionBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => SharedEncodingDescriptionConditionCodec.decodeOpt(x) },
      `formatType` = (j \ "formatType").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingDescriptionBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingDescriptionValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingDescriptionTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingDescription): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`format`.map { x => "format" -> SharedEncodingDescriptionFormatCodec.encode(x) },
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingDescriptionBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> SharedEncodingDescriptionConditionCodec.encode(x) },
        j.`formatType`.map { x => "formatType" -> Json.toJson(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingDescriptionBinCodec.encode(x) },
        j.`value`.map { x => "value" -> SharedEncodingDescriptionValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingDescriptionTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// BarConfigSmooth (UnionType)
object BarConfigSmoothCodec {
  def decode(j: JsValue): BarConfigSmooth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigSmooth] =
    j.asOpt[Boolean].map { BarConfigSmoothAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigSmooth): JsValue =
    j match {
      case BarConfigSmoothAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalMarkPropFieldOrDatumDefTypeForShape (UnionType)
object ConditionalMarkPropFieldOrDatumDefTypeForShapeCodec {
  def decode(j: JsValue): ConditionalMarkPropFieldOrDatumDefTypeForShape =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalMarkPropFieldOrDatumDefTypeForShape] =
    ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeCodec.decodeOpt(j).orElse {
    ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeCodec.decodeOpt(j) } 
  def encode(j: ConditionalMarkPropFieldOrDatumDefTypeForShape): JsValue =
    j match {
      case x:ConditionalPredicateMarkPropFieldOrDatumDefTypeForShape /* TypeRef */ => ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeCodec.encode(x)
      case x:ConditionalParameterMarkPropFieldOrDatumDefTypeForShape /* TypeRef */ => ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterMarkPropFieldOrDatumDefAsObject2 (StructType)
object ConditionalParameterMarkPropFieldOrDatumDefAsObject2Codec {
  def decode(j: JsValue): ConditionalParameterMarkPropFieldOrDatumDefAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalParameterMarkPropFieldOrDatumDefAsObject2] =
    {
      val `empty` = (j \ "empty").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `param` = (j \ "param").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`param`.isEmpty) { return None }
      val `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => ConditionalParameterMarkPropFieldOrDatumDefAsObject2DatumCodec.decodeOpt(x) }
      val `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => ConditionalParameterMarkPropFieldOrDatumDefAsObject2BandPositionCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeCodec.decodeOpt(x) }
      return Some(ConditionalParameterMarkPropFieldOrDatumDefAsObject2(
        `empty` = `empty`,
        `param` = `param`.get,
        `scale` = `scale`,
        `datum` = `datum`,
        `legend` = `legend`,
        `bandPosition` = `bandPosition`,
        `title` = `title`,
        `type` = `type`,
      ))
    }

  def encode(j: ConditionalParameterMarkPropFieldOrDatumDefAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`empty`.map { x => "empty" -> Json.toJson(x) },
        Some("param" -> Json.toJson(j.`param`)),
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> ConditionalParameterMarkPropFieldOrDatumDefAsObject2DatumCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> ConditionalParameterMarkPropFieldOrDatumDefAsObject2BandPositionCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// OverlayMarkDefStrokeDashOffset (UnionType)
object OverlayMarkDefStrokeDashOffsetCodec {
  def decode(j: JsValue): OverlayMarkDefStrokeDashOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefStrokeDashOffset] =
    j.asOpt[JsNumber].map { OverlayMarkDefStrokeDashOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefStrokeDashOffset): JsValue =
    j match {
      case OverlayMarkDefStrokeDashOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ValueDefNumber (StructType)
object ValueDefNumberCodec {
  def decode(j: JsValue): ValueDefNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ValueDefNumber] =
    {
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      if(`value`.isEmpty) { return None }
      return Some(ValueDefNumber(
        `value` = `value`.get,
      ))
    }

  def encode(j: ValueDefNumber): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("value" -> Json.toJson(j.`value`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TopLevelUnitSpecCenter (UnionType)
object TopLevelUnitSpecCenterCodec {
  def decode(j: JsValue): TopLevelUnitSpecCenter =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelUnitSpecCenter] =
    j.asOpt[Boolean].map { TopLevelUnitSpecCenterAsBool(_) }.orElse {
    RowColBooleanCodec.decodeOpt(j) } 
  def encode(j: TopLevelUnitSpecCenter): JsValue =
    j match {
      case TopLevelUnitSpecCenterAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:RowColBoolean /* TypeRef */ => RowColBooleanCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingTheta2TimeUnit (UnionType)
object SharedEncodingTheta2TimeUnitCodec {
  def decode(j: JsValue): SharedEncodingTheta2TimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingTheta2TimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingTheta2TimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Month (ConstrainedType)
object MonthCodec {
  def decode(j: JsValue): Month =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Month] =
    try {
      j.asOpt[JsNumber]
        .map { Month(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: Month): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullBandPosition (ConstrainedType)
object FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullBandPositionCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefNumberExprRef (StructType)
object ConditionalPredicateValueDefNumberExprRefCodec {
  def decode(j: JsValue): ConditionalPredicateValueDefNumberExprRef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefNumberExprRef] =
    {
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => ConditionalPredicateValueDefNumberExprRefValueCodec.decodeOpt(x) }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalPredicateValueDefNumberExprRef(
        `test` = `test`.get,
        `value` = `value`.get,
      ))
    }

  def encode(j: ConditionalPredicateValueDefNumberExprRef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
        Some("value" -> ConditionalPredicateValueDefNumberExprRefValueCodec.encode(j.`value`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AreaConfigRadius (UnionType)
object AreaConfigRadiusCodec {
  def decode(j: JsValue): AreaConfigRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigRadius] =
    j.asOpt[JsNumber].map { AreaConfigRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigRadius): JsValue =
    j match {
      case AreaConfigRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// StringFieldDefTimeUnit (UnionType)
object StringFieldDefTimeUnitCodec {
  def decode(j: JsValue): StringFieldDefTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[StringFieldDefTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: StringFieldDefTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfPredicateComposition (ArrayType)
object ArrayOfPredicateCompositionCodec {
  def decode(j: JsValue): Seq[PredicateComposition] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[PredicateComposition]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      PredicateCompositionCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[PredicateComposition]): JsArray =
      JsArray(j.map { x => PredicateCompositionCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// TickConfigStrokeWidthAsNumber (ConstrainedType)
object TickConfigStrokeWidthAsNumberCodec {
  def decode(j: JsValue): TickConfigStrokeWidthAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TickConfigStrokeWidthAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { TickConfigStrokeWidthAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: TickConfigStrokeWidthAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefAlignNullExprRefAsObject1 (StructType)
object ConditionalPredicateValueDefAlignNullExprRefAsObject1Codec {
  def decode(j: JsValue): ConditionalPredicateValueDefAlignNullExprRefAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefAlignNullExprRefAsObject1] =
    {
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => AlignCodec.decodeOpt(x).map { Some(_) }.flatten }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalPredicateValueDefAlignNullExprRefAsObject1(
        `test` = `test`.get,
        `value` = `value`,
      ))
    }

  def encode(j: ConditionalPredicateValueDefAlignNullExprRefAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
        j.`value`.map { x => "value" -> AlignCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// BarConfigCursor (UnionType)
object BarConfigCursorCodec {
  def decode(j: JsValue): BarConfigCursor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigCursor] =
    CursorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigCursor): JsValue =
    j match {
      case x:Cursor /* TypeRef */ => CursorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigTickCount (UnionType)
object LegendConfigTickCountCodec {
  def decode(j: JsValue): LegendConfigTickCount =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigTickCount] =
    TickCountCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigTickCount): JsValue =
    j match {
      case x:TickCount /* TypeRef */ => TickCountCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetSpecAlign (UnionType)
object FacetSpecAlignCodec {
  def decode(j: JsValue): FacetSpecAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetSpecAlign] =
    LayoutAlignCodec.decodeOpt(j).orElse {
    RowColLayoutAlignCodec.decodeOpt(j) } 
  def encode(j: FacetSpecAlign): JsValue =
    j match {
      case x:LayoutAlign /* TypeRef */ => LayoutAlignCodec.encode(x)
      case x:RowColLayoutAlign /* TypeRef */ => RowColLayoutAlignCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// DateTimeMinutes (ConstrainedType)
object DateTimeMinutesCodec {
  def decode(j: JsValue): DateTimeMinutes =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[DateTimeMinutes] =
    try {
      j.asOpt[JsNumber]
        .map { DateTimeMinutes(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: DateTimeMinutes): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// FacetFieldDefBandPosition (ConstrainedType)
object FacetFieldDefBandPositionCodec {
  def decode(j: JsValue): FacetFieldDefBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FacetFieldDefBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { FacetFieldDefBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: FacetFieldDefBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AreaConfigTheta (UnionType)
object AreaConfigThetaCodec {
  def decode(j: JsValue): AreaConfigTheta =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigTheta] =
    j.asOpt[JsNumber].map { AreaConfigThetaAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigTheta): JsValue =
    j match {
      case AreaConfigThetaAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfLayerSpecLayerElement (ArrayType)
object ArrayOfLayerSpecLayerElementCodec {
  def decode(j: JsValue): Seq[LayerSpecLayerElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[LayerSpecLayerElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      LayerSpecLayerElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[LayerSpecLayerElement]): JsArray =
      JsArray(j.map { x => LayerSpecLayerElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// MarkDefStrokeDashOffset (UnionType)
object MarkDefStrokeDashOffsetCodec {
  def decode(j: JsValue): MarkDefStrokeDashOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefStrokeDashOffset] =
    j.asOpt[JsNumber].map { MarkDefStrokeDashOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefStrokeDashOffset): JsValue =
    j match {
      case MarkDefStrokeDashOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject2Spacing (UnionType)
object TopLevelRepeatSpecAsObject2SpacingCodec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject2Spacing =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject2Spacing] =
    j.asOpt[JsNumber].map { TopLevelRepeatSpecAsObject2SpacingAsNumber(_) }.orElse {
    RowColNumberCodec.decodeOpt(j) } 
  def encode(j: TopLevelRepeatSpecAsObject2Spacing): JsValue =
    j match {
      case TopLevelRepeatSpecAsObject2SpacingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:RowColNumber /* TypeRef */ => RowColNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LocalSingleTimeUnit (EnumType)
object LocalSingleTimeUnitCodec {
  def decode(j: JsValue): LocalSingleTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LocalSingleTimeUnit] =
    j match {
      case JsString("year") => Some(LocalSingleTimeUnitYear)
      case JsString("quarter") => Some(LocalSingleTimeUnitQuarter)
      case JsString("month") => Some(LocalSingleTimeUnitMonth)
      case JsString("week") => Some(LocalSingleTimeUnitWeek)
      case JsString("day") => Some(LocalSingleTimeUnitDay)
      case JsString("dayofyear") => Some(LocalSingleTimeUnitDayofyear)
      case JsString("date") => Some(LocalSingleTimeUnitDate)
      case JsString("hours") => Some(LocalSingleTimeUnitHours)
      case JsString("minutes") => Some(LocalSingleTimeUnitMinutes)
      case JsString("seconds") => Some(LocalSingleTimeUnitSeconds)
      case JsString("milliseconds") => Some(LocalSingleTimeUnitMilliseconds)
      case _ => None
    }
  def encode(j: LocalSingleTimeUnit): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// TickConfigAriaRole (UnionType)
object TickConfigAriaRoleCodec {
  def decode(j: JsValue): TickConfigAriaRole =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigAriaRole] =
    j.asOpt[String].map { TickConfigAriaRoleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigAriaRole): JsValue =
    j match {
      case TickConfigAriaRoleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfSortField (ArrayType)
object ArrayOfSortFieldCodec {
  def decode(j: JsValue): Seq[SortField] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[SortField]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      SortFieldCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[SortField]): JsArray =
      JsArray(j.map { x => SortFieldCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// TickConfigStrokeOpacityAsNumber (ConstrainedType)
object TickConfigStrokeOpacityAsNumberCodec {
  def decode(j: JsValue): TickConfigStrokeOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TickConfigStrokeOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { TickConfigStrokeOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: TickConfigStrokeOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// Scale (StructType)
object ScaleCodec {
  def decode(j: JsValue): Scale =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Scale] =
    Some(Scale(
      `rangeMin` = (j \ "rangeMin").asOpt[JsValue].flatMap { x => ScaleRangeMinCodec.decodeOpt(x) },
      `paddingOuter` = (j \ "paddingOuter").asOpt[JsValue].flatMap { x => ScalePaddingOuterCodec.decodeOpt(x) },
      `domainMin` = (j \ "domainMin").asOpt[JsValue].flatMap { x => ScaleDomainMinCodec.decodeOpt(x) },
      `round` = (j \ "round").asOpt[JsValue].flatMap { x => ScaleRoundCodec.decodeOpt(x) },
      `padding` = (j \ "padding").asOpt[JsValue].flatMap { x => ScalePaddingCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => ScaleTypeCodec.decodeOpt(x) },
      `bins` = (j \ "bins").asOpt[JsValue].flatMap { x => ScaleBinsCodec.decodeOpt(x) },
      `domainMid` = (j \ "domainMid").asOpt[JsValue].flatMap { x => ScaleDomainMidCodec.decodeOpt(x) },
      `rangeMax` = (j \ "rangeMax").asOpt[JsValue].flatMap { x => ScaleRangeMaxCodec.decodeOpt(x) },
      `constant` = (j \ "constant").asOpt[JsValue].flatMap { x => ScaleConstantCodec.decodeOpt(x) },
      `zero` = (j \ "zero").asOpt[JsValue].flatMap { x => ScaleZeroCodec.decodeOpt(x) },
      `domainMax` = (j \ "domainMax").asOpt[JsValue].flatMap { x => ScaleDomainMaxCodec.decodeOpt(x) },
      `align` = (j \ "align").asOpt[JsValue].flatMap { x => ScaleAlignCodec.decodeOpt(x) },
      `domain` = (j \ "domain").asOpt[JsValue].flatMap { x => ScaleDomainCodec.decodeOpt(x) },
      `nice` = (j \ "nice").asOpt[JsValue].flatMap { x => ScaleNiceCodec.decodeOpt(x) },
      `clamp` = (j \ "clamp").asOpt[JsValue].flatMap { x => ScaleClampCodec.decodeOpt(x) },
      `paddingInner` = (j \ "paddingInner").asOpt[JsValue].flatMap { x => ScalePaddingInnerCodec.decodeOpt(x) },
      `exponent` = (j \ "exponent").asOpt[JsValue].flatMap { x => ScaleExponentCodec.decodeOpt(x) },
      `base` = (j \ "base").asOpt[JsValue].flatMap { x => ScaleBaseCodec.decodeOpt(x) },
      `reverse` = (j \ "reverse").asOpt[JsValue].flatMap { x => ScaleReverseCodec.decodeOpt(x) },
      `scheme` = (j \ "scheme").asOpt[JsValue].flatMap { x => ScaleSchemeCodec.decodeOpt(x) },
      `interpolate` = (j \ "interpolate").asOpt[JsValue].flatMap { x => ScaleInterpolateCodec.decodeOpt(x) },
      `range` = (j \ "range").asOpt[JsValue].flatMap { x => ScaleRangeCodec.decodeOpt(x) },
    ))

  def encode(j: Scale): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`rangeMin`.map { x => "rangeMin" -> ScaleRangeMinCodec.encode(x) },
        j.`paddingOuter`.map { x => "paddingOuter" -> ScalePaddingOuterCodec.encode(x) },
        j.`domainMin`.map { x => "domainMin" -> ScaleDomainMinCodec.encode(x) },
        j.`round`.map { x => "round" -> ScaleRoundCodec.encode(x) },
        j.`padding`.map { x => "padding" -> ScalePaddingCodec.encode(x) },
        j.`type`.map { x => "type" -> ScaleTypeCodec.encode(x) },
        j.`bins`.map { x => "bins" -> ScaleBinsCodec.encode(x) },
        j.`domainMid`.map { x => "domainMid" -> ScaleDomainMidCodec.encode(x) },
        j.`rangeMax`.map { x => "rangeMax" -> ScaleRangeMaxCodec.encode(x) },
        j.`constant`.map { x => "constant" -> ScaleConstantCodec.encode(x) },
        j.`zero`.map { x => "zero" -> ScaleZeroCodec.encode(x) },
        j.`domainMax`.map { x => "domainMax" -> ScaleDomainMaxCodec.encode(x) },
        j.`align`.map { x => "align" -> ScaleAlignCodec.encode(x) },
        j.`domain`.map { x => "domain" -> ScaleDomainCodec.encode(x) },
        j.`nice`.map { x => "nice" -> ScaleNiceCodec.encode(x) },
        j.`clamp`.map { x => "clamp" -> ScaleClampCodec.encode(x) },
        j.`paddingInner`.map { x => "paddingInner" -> ScalePaddingInnerCodec.encode(x) },
        j.`exponent`.map { x => "exponent" -> ScaleExponentCodec.encode(x) },
        j.`base`.map { x => "base" -> ScaleBaseCodec.encode(x) },
        j.`reverse`.map { x => "reverse" -> ScaleReverseCodec.encode(x) },
        j.`scheme`.map { x => "scheme" -> ScaleSchemeCodec.encode(x) },
        j.`interpolate`.map { x => "interpolate" -> ScaleInterpolateCodec.encode(x) },
        j.`range`.map { x => "range" -> ScaleRangeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ArgmaxDef (StructType)
object ArgmaxDefCodec {
  def decode(j: JsValue): ArgmaxDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ArgmaxDef] =
    {
      val `argmax` = (j \ "argmax").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`argmax`.isEmpty) { return None }
      return Some(ArgmaxDef(
        `argmax` = `argmax`.get,
      ))
    }

  def encode(j: ArgmaxDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("argmax" -> Json.toJson(j.`argmax`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AxisLabelFlushOffset (UnionType)
object AxisLabelFlushOffsetCodec {
  def decode(j: JsValue): AxisLabelFlushOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisLabelFlushOffset] =
    j.asOpt[JsNumber].map { AxisLabelFlushOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisLabelFlushOffset): JsValue =
    j match {
      case AxisLabelFlushOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ValueDefWithConditionMarkPropFieldOrDatumDefNumberCondition (UnionType)
object ValueDefWithConditionMarkPropFieldOrDatumDefNumberConditionCodec {
  def decode(j: JsValue): ValueDefWithConditionMarkPropFieldOrDatumDefNumberCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ValueDefWithConditionMarkPropFieldOrDatumDefNumberCondition] =
    ConditionalMarkPropFieldOrDatumDefCodec.decodeOpt(j).orElse {
    ConditionalValueDefNumberExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefNumberExprRefCodec.decodeOpt(j).map { ValueDefWithConditionMarkPropFieldOrDatumDefNumberConditionAsArrayOfConditionalValueDefNumberExprRef(_) } } } 
  def encode(j: ValueDefWithConditionMarkPropFieldOrDatumDefNumberCondition): JsValue =
    j match {
      case x:ConditionalMarkPropFieldOrDatumDef /* TypeRef */ => ConditionalMarkPropFieldOrDatumDefCodec.encode(x)
      case x:ConditionalValueDefNumberExprRef /* TypeRef */ => ConditionalValueDefNumberExprRefCodec.encode(x)
      case ValueDefWithConditionMarkPropFieldOrDatumDefNumberConditionAsArrayOfConditionalValueDefNumberExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefNumberExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TimeLocale (StructType)
object TimeLocaleCodec {
  def decode(j: JsValue): TimeLocale =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TimeLocale] =
    {
      val `shortMonths` = (j \ "shortMonths").asOpt[JsValue].flatMap { x => Vector12StringCodec.decodeOpt(x) }
      if(`shortMonths`.isEmpty) { return None }
      val `periods` = (j \ "periods").asOpt[JsValue].flatMap { x => Vector2StringCodec.decodeOpt(x) }
      if(`periods`.isEmpty) { return None }
      val `dateTime` = (j \ "dateTime").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`dateTime`.isEmpty) { return None }
      val `date` = (j \ "date").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`date`.isEmpty) { return None }
      val `time` = (j \ "time").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`time`.isEmpty) { return None }
      val `shortDays` = (j \ "shortDays").asOpt[JsValue].flatMap { x => Vector7StringCodec.decodeOpt(x) }
      if(`shortDays`.isEmpty) { return None }
      val `months` = (j \ "months").asOpt[JsValue].flatMap { x => Vector12StringCodec.decodeOpt(x) }
      if(`months`.isEmpty) { return None }
      val `days` = (j \ "days").asOpt[JsValue].flatMap { x => Vector7StringCodec.decodeOpt(x) }
      if(`days`.isEmpty) { return None }
      return Some(TimeLocale(
        `shortMonths` = `shortMonths`.get,
        `periods` = `periods`.get,
        `dateTime` = `dateTime`.get,
        `date` = `date`.get,
        `time` = `time`.get,
        `shortDays` = `shortDays`.get,
        `months` = `months`.get,
        `days` = `days`.get,
      ))
    }

  def encode(j: TimeLocale): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("shortMonths" -> Vector12StringCodec.encode(j.`shortMonths`)),
        Some("periods" -> Vector2StringCodec.encode(j.`periods`)),
        Some("dateTime" -> Json.toJson(j.`dateTime`)),
        Some("date" -> Json.toJson(j.`date`)),
        Some("time" -> Json.toJson(j.`time`)),
        Some("shortDays" -> Vector7StringCodec.encode(j.`shortDays`)),
        Some("months" -> Vector12StringCodec.encode(j.`months`)),
        Some("days" -> Vector7StringCodec.encode(j.`days`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1TimeUnit (UnionType)
object ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1TimeUnitCodec {
  def decode(j: JsValue): ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1TimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1TimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1TimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Transparent (ConstantType)
object TransparentCodec {
  def decode(j: JsValue): Transparent =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Transparent] =
    j match {
      case JsString("transparent") => Some(Transparent())
      case _ => None
    }
  def encode(j: Transparent): JsValue =
    JsString("transparent")
}


////////////////////////////////////////////////////////////////////////
// PositionFieldDefStack (UnionType)
object PositionFieldDefStackCodec {
  def decode(j: JsValue): PositionFieldDefStack =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PositionFieldDefStack] =
    StackOffsetCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => PositionFieldDefStackAsNull }.orElse {
    j.asOpt[Boolean].map { PositionFieldDefStackAsBool(_) } } } 
  def encode(j: PositionFieldDefStack): JsValue =
    j match {
      case x:StackOffset /* TypeRef */ => StackOffsetCodec.encode(x)
      case PositionFieldDefStackAsNull /* Global, NullType$ */ => JsNull
      case PositionFieldDefStackAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefTextBaselineNullExprRefAsObject2 (StructType)
object ConditionalPredicateValueDefTextBaselineNullExprRefAsObject2Codec {
  def decode(j: JsValue): ConditionalPredicateValueDefTextBaselineNullExprRefAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefTextBaselineNullExprRefAsObject2] =
    {
      val `expr` = (j \ "expr").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`expr`.isEmpty) { return None }
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      return Some(ConditionalPredicateValueDefTextBaselineNullExprRefAsObject2(
        `expr` = `expr`.get,
        `test` = `test`.get,
      ))
    }

  def encode(j: ConditionalPredicateValueDefTextBaselineNullExprRefAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("expr" -> Json.toJson(j.`expr`)),
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// NonLayerRepeatSpecCenter (UnionType)
object NonLayerRepeatSpecCenterCodec {
  def decode(j: JsValue): NonLayerRepeatSpecCenter =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[NonLayerRepeatSpecCenter] =
    j.asOpt[Boolean].map { NonLayerRepeatSpecCenterAsBool(_) }.orElse {
    RowColBooleanCodec.decodeOpt(j) } 
  def encode(j: NonLayerRepeatSpecCenter): JsValue =
    j match {
      case NonLayerRepeatSpecCenterAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:RowColBoolean /* TypeRef */ => RowColBooleanCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigStartAngle (UnionType)
object TickConfigStartAngleCodec {
  def decode(j: JsValue): TickConfigStartAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigStartAngle] =
    j.asOpt[JsNumber].map { TickConfigStartAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigStartAngle): JsValue =
    j match {
      case TickConfigStartAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsOffset (UnionType)
object TitleParamsOffsetCodec {
  def decode(j: JsValue): TitleParamsOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsOffset] =
    j.asOpt[JsNumber].map { TitleParamsOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleParamsOffset): JsValue =
    j match {
      case TitleParamsOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisLabelFontStyleAsObject1 (StructType)
object ConditionalAxisLabelFontStyleAsObject1Codec {
  def decode(j: JsValue): ConditionalAxisLabelFontStyleAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalAxisLabelFontStyleAsObject1] =
    {
      val `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => ConditionalAxisLabelFontStyleAsObject1ConditionCodec.decodeOpt(x) }
      if(`condition`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => x.asOpt[String].map { Some(_) }.flatten }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalAxisLabelFontStyleAsObject1(
        `condition` = `condition`.get,
        `value` = `value`,
      ))
    }

  def encode(j: ConditionalAxisLabelFontStyleAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("condition" -> ConditionalAxisLabelFontStyleAsObject1ConditionCodec.encode(j.`condition`)),
        j.`value`.map { x => "value" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AxisConfigGridDashOffset (UnionType)
object AxisConfigGridDashOffsetCodec {
  def decode(j: JsValue): AxisConfigGridDashOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigGridDashOffset] =
    j.asOpt[JsNumber].map { AxisConfigGridDashOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigGridDashOffset): JsValue =
    j match {
      case AxisConfigGridDashOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// StringValueDefWithConditionValue (UnionType)
object StringValueDefWithConditionValueCodec {
  def decode(j: JsValue): StringValueDefWithConditionValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[StringValueDefWithConditionValue] =
    j.asOpt[String].map { StringValueDefWithConditionValueAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => StringValueDefWithConditionValueAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: StringValueDefWithConditionValue): JsValue =
    j match {
      case StringValueDefWithConditionValueAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case StringValueDefWithConditionValueAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// VConcatSpecGenericSpecBounds (EnumType)
object VConcatSpecGenericSpecBoundsCodec {
  def decode(j: JsValue): VConcatSpecGenericSpecBounds =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[VConcatSpecGenericSpecBounds] =
    j match {
      case JsString("full") => Some(VConcatSpecGenericSpecBoundsFull)
      case JsString("flush") => Some(VConcatSpecGenericSpecBoundsFlush)
      case _ => None
    }
  def encode(j: VConcatSpecGenericSpecBounds): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// Config (StructType)
object ConfigCodec {
  def decode(j: JsValue): Config =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Config] =
    Some(Config(
      `axisTemporal` = (j \ "axisTemporal").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `rect` = (j \ "rect").asOpt[JsValue].flatMap { x => RectConfigCodec.decodeOpt(x) },
      `mark` = (j \ "mark").asOpt[JsValue].flatMap { x => MarkConfigCodec.decodeOpt(x) },
      `axisYQuantitative` = (j \ "axisYQuantitative").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `view` = (j \ "view").asOpt[JsValue].flatMap { x => ViewConfigCodec.decodeOpt(x) },
      `boxplot` = (j \ "boxplot").asOpt[JsValue].flatMap { x => BoxPlotConfigCodec.decodeOpt(x) },
      `axisXPoint` = (j \ "axisXPoint").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `area` = (j \ "area").asOpt[JsValue].flatMap { x => AreaConfigCodec.decodeOpt(x) },
      `axisBand` = (j \ "axisBand").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `point` = (j \ "point").asOpt[JsValue].flatMap { x => MarkConfigCodec.decodeOpt(x) },
      `fieldTitle` = (j \ "fieldTitle").asOpt[JsValue].flatMap { x => ConfigFieldTitleCodec.decodeOpt(x) },
      `circle` = (j \ "circle").asOpt[JsValue].flatMap { x => MarkConfigCodec.decodeOpt(x) },
      `projection` = (j \ "projection").asOpt[JsValue].flatMap { x => ProjectionConfigCodec.decodeOpt(x) },
      `style` = (j \ "style").asOpt[JsValue].flatMap { x => StyleConfigIndexCodec.decodeOpt(x) },
      `line` = (j \ "line").asOpt[JsValue].flatMap { x => LineConfigCodec.decodeOpt(x) },
      `background` = (j \ "background").asOpt[JsValue].flatMap { x => ConfigBackgroundCodec.decodeOpt(x) },
      `image` = (j \ "image").asOpt[JsValue].flatMap { x => RectConfigCodec.decodeOpt(x) },
      `headerFacet` = (j \ "headerFacet").asOpt[JsValue].flatMap { x => HeaderConfigCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleConfigCodec.decodeOpt(x) },
      `lineBreak` = (j \ "lineBreak").asOpt[JsValue].flatMap { x => ConfigLineBreakCodec.decodeOpt(x) },
      `customFormatTypes` = (j \ "customFormatTypes").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `trail` = (j \ "trail").asOpt[JsValue].flatMap { x => LineConfigCodec.decodeOpt(x) },
      `axisPoint` = (j \ "axisPoint").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `headerColumn` = (j \ "headerColumn").asOpt[JsValue].flatMap { x => HeaderConfigCodec.decodeOpt(x) },
      `params` = (j \ "params").asOpt[JsValue].flatMap { x => ArrayOfConfigParamsElementCodec.decodeOpt(x) },
      `concat` = (j \ "concat").asOpt[JsValue].flatMap { x => CompositionConfigCodec.decodeOpt(x) },
      `axisDiscrete` = (j \ "axisDiscrete").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `axisRight` = (j \ "axisRight").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `rule` = (j \ "rule").asOpt[JsValue].flatMap { x => MarkConfigCodec.decodeOpt(x) },
      `errorband` = (j \ "errorband").asOpt[JsValue].flatMap { x => ErrorBandConfigCodec.decodeOpt(x) },
      `text` = (j \ "text").asOpt[JsValue].flatMap { x => MarkConfigCodec.decodeOpt(x) },
      `axisXTemporal` = (j \ "axisXTemporal").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendConfigCodec.decodeOpt(x) },
      `tick` = (j \ "tick").asOpt[JsValue].flatMap { x => TickConfigCodec.decodeOpt(x) },
      `geoshape` = (j \ "geoshape").asOpt[JsValue].flatMap { x => MarkConfigCodec.decodeOpt(x) },
      `axisXDiscrete` = (j \ "axisXDiscrete").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `countTitle` = (j \ "countTitle").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `square` = (j \ "square").asOpt[JsValue].flatMap { x => MarkConfigCodec.decodeOpt(x) },
      `locale` = (j \ "locale").asOpt[JsValue].flatMap { x => LocaleCodec.decodeOpt(x) },
      `errorbar` = (j \ "errorbar").asOpt[JsValue].flatMap { x => ErrorBarConfigCodec.decodeOpt(x) },
      `axisX` = (j \ "axisX").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `arc` = (j \ "arc").asOpt[JsValue].flatMap { x => RectConfigCodec.decodeOpt(x) },
      `font` = (j \ "font").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `axisYBand` = (j \ "axisYBand").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `axisTop` = (j \ "axisTop").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `axisQuantitative` = (j \ "axisQuantitative").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `axisXQuantitative` = (j \ "axisXQuantitative").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `range` = (j \ "range").asOpt[JsValue].flatMap { x => RangeConfigCodec.decodeOpt(x) },
      `selection` = (j \ "selection").asOpt[JsValue].flatMap { x => SelectionConfigCodec.decodeOpt(x) },
      `axisYPoint` = (j \ "axisYPoint").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `headerRow` = (j \ "headerRow").asOpt[JsValue].flatMap { x => HeaderConfigCodec.decodeOpt(x) },
      `axisBottom` = (j \ "axisBottom").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `axisYDiscrete` = (j \ "axisYDiscrete").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `axisYTemporal` = (j \ "axisYTemporal").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `axisLeft` = (j \ "axisLeft").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `bar` = (j \ "bar").asOpt[JsValue].flatMap { x => BarConfigCodec.decodeOpt(x) },
      `axisY` = (j \ "axisY").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `timeFormat` = (j \ "timeFormat").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `header` = (j \ "header").asOpt[JsValue].flatMap { x => HeaderConfigCodec.decodeOpt(x) },
      `facet` = (j \ "facet").asOpt[JsValue].flatMap { x => CompositionConfigCodec.decodeOpt(x) },
      `aria` = (j \ "aria").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `padding` = (j \ "padding").asOpt[JsValue].flatMap { x => ConfigPaddingCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TitleConfigCodec.decodeOpt(x) },
      `axis` = (j \ "axis").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `autosize` = (j \ "autosize").asOpt[JsValue].flatMap { x => ConfigAutosizeCodec.decodeOpt(x) },
      `axisXBand` = (j \ "axisXBand").asOpt[JsValue].flatMap { x => AxisConfigCodec.decodeOpt(x) },
      `numberFormat` = (j \ "numberFormat").asOpt[JsValue].flatMap { x => x.asOpt[String] },
    ))

  def encode(j: Config): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`axisTemporal`.map { x => "axisTemporal" -> AxisConfigCodec.encode(x) },
        j.`rect`.map { x => "rect" -> RectConfigCodec.encode(x) },
        j.`mark`.map { x => "mark" -> MarkConfigCodec.encode(x) },
        j.`axisYQuantitative`.map { x => "axisYQuantitative" -> AxisConfigCodec.encode(x) },
        j.`view`.map { x => "view" -> ViewConfigCodec.encode(x) },
        j.`boxplot`.map { x => "boxplot" -> BoxPlotConfigCodec.encode(x) },
        j.`axisXPoint`.map { x => "axisXPoint" -> AxisConfigCodec.encode(x) },
        j.`area`.map { x => "area" -> AreaConfigCodec.encode(x) },
        j.`axisBand`.map { x => "axisBand" -> AxisConfigCodec.encode(x) },
        j.`point`.map { x => "point" -> MarkConfigCodec.encode(x) },
        j.`fieldTitle`.map { x => "fieldTitle" -> ConfigFieldTitleCodec.encode(x) },
        j.`circle`.map { x => "circle" -> MarkConfigCodec.encode(x) },
        j.`projection`.map { x => "projection" -> ProjectionConfigCodec.encode(x) },
        j.`style`.map { x => "style" -> StyleConfigIndexCodec.encode(x) },
        j.`line`.map { x => "line" -> LineConfigCodec.encode(x) },
        j.`background`.map { x => "background" -> ConfigBackgroundCodec.encode(x) },
        j.`image`.map { x => "image" -> RectConfigCodec.encode(x) },
        j.`headerFacet`.map { x => "headerFacet" -> HeaderConfigCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleConfigCodec.encode(x) },
        j.`lineBreak`.map { x => "lineBreak" -> ConfigLineBreakCodec.encode(x) },
        j.`customFormatTypes`.map { x => "customFormatTypes" -> Json.toJson(x) },
        j.`trail`.map { x => "trail" -> LineConfigCodec.encode(x) },
        j.`axisPoint`.map { x => "axisPoint" -> AxisConfigCodec.encode(x) },
        j.`headerColumn`.map { x => "headerColumn" -> HeaderConfigCodec.encode(x) },
        j.`params`.map { x => "params" -> ArrayOfConfigParamsElementCodec.encode(x) },
        j.`concat`.map { x => "concat" -> CompositionConfigCodec.encode(x) },
        j.`axisDiscrete`.map { x => "axisDiscrete" -> AxisConfigCodec.encode(x) },
        j.`axisRight`.map { x => "axisRight" -> AxisConfigCodec.encode(x) },
        j.`rule`.map { x => "rule" -> MarkConfigCodec.encode(x) },
        j.`errorband`.map { x => "errorband" -> ErrorBandConfigCodec.encode(x) },
        j.`text`.map { x => "text" -> MarkConfigCodec.encode(x) },
        j.`axisXTemporal`.map { x => "axisXTemporal" -> AxisConfigCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendConfigCodec.encode(x) },
        j.`tick`.map { x => "tick" -> TickConfigCodec.encode(x) },
        j.`geoshape`.map { x => "geoshape" -> MarkConfigCodec.encode(x) },
        j.`axisXDiscrete`.map { x => "axisXDiscrete" -> AxisConfigCodec.encode(x) },
        j.`countTitle`.map { x => "countTitle" -> Json.toJson(x) },
        j.`square`.map { x => "square" -> MarkConfigCodec.encode(x) },
        j.`locale`.map { x => "locale" -> LocaleCodec.encode(x) },
        j.`errorbar`.map { x => "errorbar" -> ErrorBarConfigCodec.encode(x) },
        j.`axisX`.map { x => "axisX" -> AxisConfigCodec.encode(x) },
        j.`arc`.map { x => "arc" -> RectConfigCodec.encode(x) },
        j.`font`.map { x => "font" -> Json.toJson(x) },
        j.`axisYBand`.map { x => "axisYBand" -> AxisConfigCodec.encode(x) },
        j.`axisTop`.map { x => "axisTop" -> AxisConfigCodec.encode(x) },
        j.`axisQuantitative`.map { x => "axisQuantitative" -> AxisConfigCodec.encode(x) },
        j.`axisXQuantitative`.map { x => "axisXQuantitative" -> AxisConfigCodec.encode(x) },
        j.`range`.map { x => "range" -> RangeConfigCodec.encode(x) },
        j.`selection`.map { x => "selection" -> SelectionConfigCodec.encode(x) },
        j.`axisYPoint`.map { x => "axisYPoint" -> AxisConfigCodec.encode(x) },
        j.`headerRow`.map { x => "headerRow" -> HeaderConfigCodec.encode(x) },
        j.`axisBottom`.map { x => "axisBottom" -> AxisConfigCodec.encode(x) },
        j.`axisYDiscrete`.map { x => "axisYDiscrete" -> AxisConfigCodec.encode(x) },
        j.`axisYTemporal`.map { x => "axisYTemporal" -> AxisConfigCodec.encode(x) },
        j.`axisLeft`.map { x => "axisLeft" -> AxisConfigCodec.encode(x) },
        j.`bar`.map { x => "bar" -> BarConfigCodec.encode(x) },
        j.`axisY`.map { x => "axisY" -> AxisConfigCodec.encode(x) },
        j.`timeFormat`.map { x => "timeFormat" -> Json.toJson(x) },
        j.`header`.map { x => "header" -> HeaderConfigCodec.encode(x) },
        j.`facet`.map { x => "facet" -> CompositionConfigCodec.encode(x) },
        j.`aria`.map { x => "aria" -> Json.toJson(x) },
        j.`padding`.map { x => "padding" -> ConfigPaddingCodec.encode(x) },
        j.`title`.map { x => "title" -> TitleConfigCodec.encode(x) },
        j.`axis`.map { x => "axis" -> AxisConfigCodec.encode(x) },
        j.`autosize`.map { x => "autosize" -> ConfigAutosizeCodec.encode(x) },
        j.`axisXBand`.map { x => "axisXBand" -> AxisConfigCodec.encode(x) },
        j.`numberFormat`.map { x => "numberFormat" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// BarConfigStrokeCap (UnionType)
object BarConfigStrokeCapCodec {
  def decode(j: JsValue): BarConfigStrokeCap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigStrokeCap] =
    StrokeCapCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigStrokeCap): JsValue =
    j match {
      case x:StrokeCap /* TypeRef */ => StrokeCapCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ImputeTransformFrameElement (UnionType)
object ImputeTransformFrameElementCodec {
  def decode(j: JsValue): ImputeTransformFrameElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ImputeTransformFrameElement] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ImputeTransformFrameElementAsNull }.orElse {
    j.asOpt[JsNumber].map { ImputeTransformFrameElementAsNumber(_) } } 
  def encode(j: ImputeTransformFrameElement): JsValue =
    j match {
      case ImputeTransformFrameElementAsNull /* Global, NullType$ */ => JsNull
      case ImputeTransformFrameElementAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeValue (UnionType)
object SharedEncodingStrokeValueCodec {
  def decode(j: JsValue): SharedEncodingStrokeValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeValue] =
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[String].map { SharedEncodingStrokeValueAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingStrokeValueAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingStrokeValue): JsValue =
    j match {
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case SharedEncodingStrokeValueAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case SharedEncodingStrokeValueAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleDomain (UnionType)
object ScaleDomainCodec {
  def decode(j: JsValue): ScaleDomain =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleDomain] =
    ArrayOfScaleDomainAsArrayElementCodec.decodeOpt(j).map { ScaleDomainAsArrayOfScaleDomainAsArrayElement(_) }.orElse {
    DomainUnionWithCodec.decodeOpt(j).orElse {
    UnaggregatedCodec.decodeOpt(j).orElse {
    ParameterExtentCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } } } 
  def encode(j: ScaleDomain): JsValue =
    j match {
      case ScaleDomainAsArrayOfScaleDomainAsArrayElement(x) /* Base, ArrayType */ => ArrayOfScaleDomainAsArrayElementCodec.encode(x)
      case x:DomainUnionWith /* TypeRef */ => DomainUnionWithCodec.encode(x)
      case x:Unaggregated /* TypeRef */ => UnaggregatedCodec.encode(x)
      case x:ParameterExtent /* TypeRef */ => ParameterExtentCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewBackgroundFill (UnionType)
object ViewBackgroundFillCodec {
  def decode(j: JsValue): ViewBackgroundFill =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewBackgroundFill] =
    ColorCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ViewBackgroundFillAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: ViewBackgroundFill): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case ViewBackgroundFillAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfig (StructType)
object AreaConfigCodec {
  def decode(j: JsValue): AreaConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AreaConfig] =
    Some(AreaConfig(
      `point` = (j \ "point").asOpt[JsValue].flatMap { x => AreaConfigPointCodec.decodeOpt(x) },
      `cornerRadiusBottomRight` = (j \ "cornerRadiusBottomRight").asOpt[JsValue].flatMap { x => AreaConfigCornerRadiusBottomRightCodec.decodeOpt(x) },
      `fillOpacity` = (j \ "fillOpacity").asOpt[JsValue].flatMap { x => AreaConfigFillOpacityCodec.decodeOpt(x) },
      `strokeMiterLimit` = (j \ "strokeMiterLimit").asOpt[JsValue].flatMap { x => AreaConfigStrokeMiterLimitCodec.decodeOpt(x) },
      `dir` = (j \ "dir").asOpt[JsValue].flatMap { x => AreaConfigDirCodec.decodeOpt(x) },
      `tooltip` = (j \ "tooltip").asOpt[JsValue].flatMap { x => AreaConfigTooltipCodec.decodeOpt(x) },
      `timeUnitBandPosition` = (j \ "timeUnitBandPosition").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `cornerRadiusTopRight` = (j \ "cornerRadiusTopRight").asOpt[JsValue].flatMap { x => AreaConfigCornerRadiusTopRightCodec.decodeOpt(x) },
      `outerRadius` = (j \ "outerRadius").asOpt[JsValue].flatMap { x => AreaConfigOuterRadiusCodec.decodeOpt(x) },
      `x` = (j \ "x").asOpt[JsValue].flatMap { x => AreaConfigXCodec.decodeOpt(x) },
      `dy` = (j \ "dy").asOpt[JsValue].flatMap { x => AreaConfigDyCodec.decodeOpt(x) },
      `size` = (j \ "size").asOpt[JsValue].flatMap { x => AreaConfigSizeCodec.decodeOpt(x) },
      `smooth` = (j \ "smooth").asOpt[JsValue].flatMap { x => AreaConfigSmoothCodec.decodeOpt(x) },
      `url` = (j \ "url").asOpt[JsValue].flatMap { x => AreaConfigUrlCodec.decodeOpt(x) },
      `y` = (j \ "y").asOpt[JsValue].flatMap { x => AreaConfigYCodec.decodeOpt(x) },
      `line` = (j \ "line").asOpt[JsValue].flatMap { x => AreaConfigLineCodec.decodeOpt(x) },
      `strokeOpacity` = (j \ "strokeOpacity").asOpt[JsValue].flatMap { x => AreaConfigStrokeOpacityCodec.decodeOpt(x) },
      `ellipsis` = (j \ "ellipsis").asOpt[JsValue].flatMap { x => AreaConfigEllipsisCodec.decodeOpt(x) },
      `description` = (j \ "description").asOpt[JsValue].flatMap { x => AreaConfigDescriptionCodec.decodeOpt(x) },
      `angle` = (j \ "angle").asOpt[JsValue].flatMap { x => AreaConfigAngleCodec.decodeOpt(x) },
      `lineBreak` = (j \ "lineBreak").asOpt[JsValue].flatMap { x => AreaConfigLineBreakCodec.decodeOpt(x) },
      `tension` = (j \ "tension").asOpt[JsValue].flatMap { x => AreaConfigTensionCodec.decodeOpt(x) },
      `cornerRadiusTopLeft` = (j \ "cornerRadiusTopLeft").asOpt[JsValue].flatMap { x => AreaConfigCornerRadiusTopLeftCodec.decodeOpt(x) },
      `stroke` = (j \ "stroke").asOpt[JsValue].flatMap { x => AreaConfigStrokeCodec.decodeOpt(x) },
      `strokeDashOffset` = (j \ "strokeDashOffset").asOpt[JsValue].flatMap { x => AreaConfigStrokeDashOffsetCodec.decodeOpt(x) },
      `align` = (j \ "align").asOpt[JsValue].flatMap { x => AreaConfigAlignCodec.decodeOpt(x) },
      `ariaRole` = (j \ "ariaRole").asOpt[JsValue].flatMap { x => AreaConfigAriaRoleCodec.decodeOpt(x) },
      `strokeCap` = (j \ "strokeCap").asOpt[JsValue].flatMap { x => AreaConfigStrokeCapCodec.decodeOpt(x) },
      `endAngle` = (j \ "endAngle").asOpt[JsValue].flatMap { x => AreaConfigEndAngleCodec.decodeOpt(x) },
      `strokeJoin` = (j \ "strokeJoin").asOpt[JsValue].flatMap { x => AreaConfigStrokeJoinCodec.decodeOpt(x) },
      `baseline` = (j \ "baseline").asOpt[JsValue].flatMap { x => AreaConfigBaselineCodec.decodeOpt(x) },
      `ariaRoleDescription` = (j \ "ariaRoleDescription").asOpt[JsValue].flatMap { x => AreaConfigAriaRoleDescriptionCodec.decodeOpt(x) },
      `aspect` = (j \ "aspect").asOpt[JsValue].flatMap { x => AreaConfigAspectCodec.decodeOpt(x) },
      `height` = (j \ "height").asOpt[JsValue].flatMap { x => AreaConfigHeightCodec.decodeOpt(x) },
      `fontStyle` = (j \ "fontStyle").asOpt[JsValue].flatMap { x => AreaConfigFontStyleCodec.decodeOpt(x) },
      `text` = (j \ "text").asOpt[JsValue].flatMap { x => AreaConfigTextCodec.decodeOpt(x) },
      `cornerRadius` = (j \ "cornerRadius").asOpt[JsValue].flatMap { x => AreaConfigCornerRadiusCodec.decodeOpt(x) },
      `color` = (j \ "color").asOpt[JsValue].flatMap { x => AreaConfigColorCodec.decodeOpt(x) },
      `x2` = (j \ "x2").asOpt[JsValue].flatMap { x => AreaConfigX2Codec.decodeOpt(x) },
      `padAngle` = (j \ "padAngle").asOpt[JsValue].flatMap { x => AreaConfigPadAngleCodec.decodeOpt(x) },
      `cursor` = (j \ "cursor").asOpt[JsValue].flatMap { x => AreaConfigCursorCodec.decodeOpt(x) },
      `radius` = (j \ "radius").asOpt[JsValue].flatMap { x => AreaConfigRadiusCodec.decodeOpt(x) },
      `timeUnitBandSize` = (j \ "timeUnitBandSize").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `startAngle` = (j \ "startAngle").asOpt[JsValue].flatMap { x => AreaConfigStartAngleCodec.decodeOpt(x) },
      `font` = (j \ "font").asOpt[JsValue].flatMap { x => AreaConfigFontCodec.decodeOpt(x) },
      `radius2` = (j \ "radius2").asOpt[JsValue].flatMap { x => AreaConfigRadius2Codec.decodeOpt(x) },
      `invalid` = (j \ "invalid").asOpt[JsValue].flatMap { x => AreaConfigInvalidCodec.decodeOpt(x) },
      `lineHeight` = (j \ "lineHeight").asOpt[JsValue].flatMap { x => AreaConfigLineHeightCodec.decodeOpt(x) },
      `order` = (j \ "order").asOpt[JsValue].flatMap { x => AreaConfigOrderCodec.decodeOpt(x) },
      `fill` = (j \ "fill").asOpt[JsValue].flatMap { x => AreaConfigFillCodec.decodeOpt(x) },
      `interpolate` = (j \ "interpolate").asOpt[JsValue].flatMap { x => AreaConfigInterpolateCodec.decodeOpt(x) },
      `theta` = (j \ "theta").asOpt[JsValue].flatMap { x => AreaConfigThetaCodec.decodeOpt(x) },
      `orient` = (j \ "orient").asOpt[JsValue].flatMap { x => OrientationCodec.decodeOpt(x) },
      `innerRadius` = (j \ "innerRadius").asOpt[JsValue].flatMap { x => AreaConfigInnerRadiusCodec.decodeOpt(x) },
      `fontSize` = (j \ "fontSize").asOpt[JsValue].flatMap { x => AreaConfigFontSizeCodec.decodeOpt(x) },
      `y2` = (j \ "y2").asOpt[JsValue].flatMap { x => AreaConfigY2Codec.decodeOpt(x) },
      `shape` = (j \ "shape").asOpt[JsValue].flatMap { x => AreaConfigShapeCodec.decodeOpt(x) },
      `aria` = (j \ "aria").asOpt[JsValue].flatMap { x => AreaConfigAriaCodec.decodeOpt(x) },
      `opacity` = (j \ "opacity").asOpt[JsValue].flatMap { x => AreaConfigOpacityCodec.decodeOpt(x) },
      `dx` = (j \ "dx").asOpt[JsValue].flatMap { x => AreaConfigDxCodec.decodeOpt(x) },
      `cornerRadiusBottomLeft` = (j \ "cornerRadiusBottomLeft").asOpt[JsValue].flatMap { x => AreaConfigCornerRadiusBottomLeftCodec.decodeOpt(x) },
      `href` = (j \ "href").asOpt[JsValue].flatMap { x => AreaConfigHrefCodec.decodeOpt(x) },
      `strokeDash` = (j \ "strokeDash").asOpt[JsValue].flatMap { x => AreaConfigStrokeDashCodec.decodeOpt(x) },
      `strokeOffset` = (j \ "strokeOffset").asOpt[JsValue].flatMap { x => AreaConfigStrokeOffsetCodec.decodeOpt(x) },
      `limit` = (j \ "limit").asOpt[JsValue].flatMap { x => AreaConfigLimitCodec.decodeOpt(x) },
      `width` = (j \ "width").asOpt[JsValue].flatMap { x => AreaConfigWidthCodec.decodeOpt(x) },
      `fontWeight` = (j \ "fontWeight").asOpt[JsValue].flatMap { x => AreaConfigFontWeightCodec.decodeOpt(x) },
      `filled` = (j \ "filled").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `blend` = (j \ "blend").asOpt[JsValue].flatMap { x => AreaConfigBlendCodec.decodeOpt(x) },
      `strokeWidth` = (j \ "strokeWidth").asOpt[JsValue].flatMap { x => AreaConfigStrokeWidthCodec.decodeOpt(x) },
      `theta2` = (j \ "theta2").asOpt[JsValue].flatMap { x => AreaConfigTheta2Codec.decodeOpt(x) },
    ))

  def encode(j: AreaConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`point`.map { x => "point" -> AreaConfigPointCodec.encode(x) },
        j.`cornerRadiusBottomRight`.map { x => "cornerRadiusBottomRight" -> AreaConfigCornerRadiusBottomRightCodec.encode(x) },
        j.`fillOpacity`.map { x => "fillOpacity" -> AreaConfigFillOpacityCodec.encode(x) },
        j.`strokeMiterLimit`.map { x => "strokeMiterLimit" -> AreaConfigStrokeMiterLimitCodec.encode(x) },
        j.`dir`.map { x => "dir" -> AreaConfigDirCodec.encode(x) },
        j.`tooltip`.map { x => "tooltip" -> AreaConfigTooltipCodec.encode(x) },
        j.`timeUnitBandPosition`.map { x => "timeUnitBandPosition" -> Json.toJson(x) },
        j.`cornerRadiusTopRight`.map { x => "cornerRadiusTopRight" -> AreaConfigCornerRadiusTopRightCodec.encode(x) },
        j.`outerRadius`.map { x => "outerRadius" -> AreaConfigOuterRadiusCodec.encode(x) },
        j.`x`.map { x => "x" -> AreaConfigXCodec.encode(x) },
        j.`dy`.map { x => "dy" -> AreaConfigDyCodec.encode(x) },
        j.`size`.map { x => "size" -> AreaConfigSizeCodec.encode(x) },
        j.`smooth`.map { x => "smooth" -> AreaConfigSmoothCodec.encode(x) },
        j.`url`.map { x => "url" -> AreaConfigUrlCodec.encode(x) },
        j.`y`.map { x => "y" -> AreaConfigYCodec.encode(x) },
        j.`line`.map { x => "line" -> AreaConfigLineCodec.encode(x) },
        j.`strokeOpacity`.map { x => "strokeOpacity" -> AreaConfigStrokeOpacityCodec.encode(x) },
        j.`ellipsis`.map { x => "ellipsis" -> AreaConfigEllipsisCodec.encode(x) },
        j.`description`.map { x => "description" -> AreaConfigDescriptionCodec.encode(x) },
        j.`angle`.map { x => "angle" -> AreaConfigAngleCodec.encode(x) },
        j.`lineBreak`.map { x => "lineBreak" -> AreaConfigLineBreakCodec.encode(x) },
        j.`tension`.map { x => "tension" -> AreaConfigTensionCodec.encode(x) },
        j.`cornerRadiusTopLeft`.map { x => "cornerRadiusTopLeft" -> AreaConfigCornerRadiusTopLeftCodec.encode(x) },
        j.`stroke`.map { x => "stroke" -> AreaConfigStrokeCodec.encode(x) },
        j.`strokeDashOffset`.map { x => "strokeDashOffset" -> AreaConfigStrokeDashOffsetCodec.encode(x) },
        j.`align`.map { x => "align" -> AreaConfigAlignCodec.encode(x) },
        j.`ariaRole`.map { x => "ariaRole" -> AreaConfigAriaRoleCodec.encode(x) },
        j.`strokeCap`.map { x => "strokeCap" -> AreaConfigStrokeCapCodec.encode(x) },
        j.`endAngle`.map { x => "endAngle" -> AreaConfigEndAngleCodec.encode(x) },
        j.`strokeJoin`.map { x => "strokeJoin" -> AreaConfigStrokeJoinCodec.encode(x) },
        j.`baseline`.map { x => "baseline" -> AreaConfigBaselineCodec.encode(x) },
        j.`ariaRoleDescription`.map { x => "ariaRoleDescription" -> AreaConfigAriaRoleDescriptionCodec.encode(x) },
        j.`aspect`.map { x => "aspect" -> AreaConfigAspectCodec.encode(x) },
        j.`height`.map { x => "height" -> AreaConfigHeightCodec.encode(x) },
        j.`fontStyle`.map { x => "fontStyle" -> AreaConfigFontStyleCodec.encode(x) },
        j.`text`.map { x => "text" -> AreaConfigTextCodec.encode(x) },
        j.`cornerRadius`.map { x => "cornerRadius" -> AreaConfigCornerRadiusCodec.encode(x) },
        j.`color`.map { x => "color" -> AreaConfigColorCodec.encode(x) },
        j.`x2`.map { x => "x2" -> AreaConfigX2Codec.encode(x) },
        j.`padAngle`.map { x => "padAngle" -> AreaConfigPadAngleCodec.encode(x) },
        j.`cursor`.map { x => "cursor" -> AreaConfigCursorCodec.encode(x) },
        j.`radius`.map { x => "radius" -> AreaConfigRadiusCodec.encode(x) },
        j.`timeUnitBandSize`.map { x => "timeUnitBandSize" -> Json.toJson(x) },
        j.`startAngle`.map { x => "startAngle" -> AreaConfigStartAngleCodec.encode(x) },
        j.`font`.map { x => "font" -> AreaConfigFontCodec.encode(x) },
        j.`radius2`.map { x => "radius2" -> AreaConfigRadius2Codec.encode(x) },
        j.`invalid`.map { x => "invalid" -> AreaConfigInvalidCodec.encode(x) },
        j.`lineHeight`.map { x => "lineHeight" -> AreaConfigLineHeightCodec.encode(x) },
        j.`order`.map { x => "order" -> AreaConfigOrderCodec.encode(x) },
        j.`fill`.map { x => "fill" -> AreaConfigFillCodec.encode(x) },
        j.`interpolate`.map { x => "interpolate" -> AreaConfigInterpolateCodec.encode(x) },
        j.`theta`.map { x => "theta" -> AreaConfigThetaCodec.encode(x) },
        j.`orient`.map { x => "orient" -> OrientationCodec.encode(x) },
        j.`innerRadius`.map { x => "innerRadius" -> AreaConfigInnerRadiusCodec.encode(x) },
        j.`fontSize`.map { x => "fontSize" -> AreaConfigFontSizeCodec.encode(x) },
        j.`y2`.map { x => "y2" -> AreaConfigY2Codec.encode(x) },
        j.`shape`.map { x => "shape" -> AreaConfigShapeCodec.encode(x) },
        j.`aria`.map { x => "aria" -> AreaConfigAriaCodec.encode(x) },
        j.`opacity`.map { x => "opacity" -> AreaConfigOpacityCodec.encode(x) },
        j.`dx`.map { x => "dx" -> AreaConfigDxCodec.encode(x) },
        j.`cornerRadiusBottomLeft`.map { x => "cornerRadiusBottomLeft" -> AreaConfigCornerRadiusBottomLeftCodec.encode(x) },
        j.`href`.map { x => "href" -> AreaConfigHrefCodec.encode(x) },
        j.`strokeDash`.map { x => "strokeDash" -> AreaConfigStrokeDashCodec.encode(x) },
        j.`strokeOffset`.map { x => "strokeOffset" -> AreaConfigStrokeOffsetCodec.encode(x) },
        j.`limit`.map { x => "limit" -> AreaConfigLimitCodec.encode(x) },
        j.`width`.map { x => "width" -> AreaConfigWidthCodec.encode(x) },
        j.`fontWeight`.map { x => "fontWeight" -> AreaConfigFontWeightCodec.encode(x) },
        j.`filled`.map { x => "filled" -> Json.toJson(x) },
        j.`blend`.map { x => "blend" -> AreaConfigBlendCodec.encode(x) },
        j.`strokeWidth`.map { x => "strokeWidth" -> AreaConfigStrokeWidthCodec.encode(x) },
        j.`theta2`.map { x => "theta2" -> AreaConfigTheta2Codec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ProjectionSpacing (UnionType)
object ProjectionSpacingCodec {
  def decode(j: JsValue): ProjectionSpacing =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionSpacing] =
    j.asOpt[JsNumber].map { ProjectionSpacingAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionSpacing): JsValue =
    j match {
      case ProjectionSpacingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PointSelectionConfigToggle (UnionType)
object PointSelectionConfigToggleCodec {
  def decode(j: JsValue): PointSelectionConfigToggle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PointSelectionConfigToggle] =
    j.asOpt[String].map { PointSelectionConfigToggleAsString(_) }.orElse {
    j.asOpt[Boolean].map { PointSelectionConfigToggleAsBool(_) } } 
  def encode(j: PointSelectionConfigToggle): JsValue =
    j match {
      case PointSelectionConfigToggleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case PointSelectionConfigToggleAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// NonLayerRepeatSpecAlign (UnionType)
object NonLayerRepeatSpecAlignCodec {
  def decode(j: JsValue): NonLayerRepeatSpecAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[NonLayerRepeatSpecAlign] =
    LayoutAlignCodec.decodeOpt(j).orElse {
    RowColLayoutAlignCodec.decodeOpt(j) } 
  def encode(j: NonLayerRepeatSpecAlign): JsValue =
    j match {
      case x:LayoutAlign /* TypeRef */ => LayoutAlignCodec.encode(x)
      case x:RowColLayoutAlign /* TypeRef */ => RowColLayoutAlignCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigX2 (UnionType)
object LineConfigX2Codec {
  def decode(j: JsValue): LineConfigX2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigX2] =
    j.asOpt[JsNumber].map { LineConfigX2AsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: LineConfigX2): JsValue =
    j match {
      case LineConfigX2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// CsvDataFormat (StructType)
object CsvDataFormatCodec {
  def decode(j: JsValue): CsvDataFormat =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[CsvDataFormat] =
    Some(CsvDataFormat(
      `parse` = (j \ "parse").asOpt[JsValue].flatMap { x => DictOfParseValueCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => CsvDataFormatTypeCodec.decodeOpt(x) },
    ))

  def encode(j: CsvDataFormat): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`parse`.map { x => "parse" -> DictOfParseValueCodec.encode(x) },
        j.`type`.map { x => "type" -> CsvDataFormatTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ViewConfigStrokeOpacityAsNumber (ConstrainedType)
object ViewConfigStrokeOpacityAsNumberCodec {
  def decode(j: JsValue): ViewConfigStrokeOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ViewConfigStrokeOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { ViewConfigStrokeOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ViewConfigStrokeOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkConfigSize (ConstrainedType)
// see MarkConfigSize (UnionType)

////////////////////////////////////////////////////////////////////////
// SharedEncodingOpacityTimeUnit (UnionType)
object SharedEncodingOpacityTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingOpacityTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingOpacityTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingOpacityTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeDashTimeUnit (UnionType)
object SharedEncodingStrokeDashTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingStrokeDashTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeDashTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingStrokeDashTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateStringFieldDefBin (UnionType)
object ConditionalPredicateStringFieldDefBinCodec {
  def decode(j: JsValue): ConditionalPredicateStringFieldDefBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateStringFieldDefBin] =
    j.asOpt[Boolean].map { ConditionalPredicateStringFieldDefBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    BinnedCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ConditionalPredicateStringFieldDefBinAsNull } } } } 
  def encode(j: ConditionalPredicateStringFieldDefBin): JsValue =
    j match {
      case ConditionalPredicateStringFieldDefBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case x:Binned /* TypeRef */ => BinnedCodec.encode(x)
      case ConditionalPredicateStringFieldDefBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelHConcatSpecBackground (UnionType)
object TopLevelHConcatSpecBackgroundCodec {
  def decode(j: JsValue): TopLevelHConcatSpecBackground =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelHConcatSpecBackground] =
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TopLevelHConcatSpecBackground): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BindRange (StructType)
object BindRangeCodec {
  def decode(j: JsValue): BindRange =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BindRange] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `step` = (j \ "step").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `min` = (j \ "min").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `element` = (j \ "element").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `max` = (j \ "max").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `input` = (j \ "input").asOpt[JsValue].flatMap { x => BindRangeInputCodec.decodeOpt(x) }
      if(`input`.isEmpty) { return None }
      val `debounce` = (j \ "debounce").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      return Some(BindRange(
        `name` = `name`,
        `step` = `step`,
        `min` = `min`,
        `element` = `element`,
        `max` = `max`,
        `input` = `input`.get,
        `debounce` = `debounce`,
      ))
    }

  def encode(j: BindRange): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`step`.map { x => "step" -> Json.toJson(x) },
        j.`min`.map { x => "min" -> Json.toJson(x) },
        j.`element`.map { x => "element" -> Json.toJson(x) },
        j.`max`.map { x => "max" -> Json.toJson(x) },
        Some("input" -> BindRangeInputCodec.encode(j.`input`)),
        j.`debounce`.map { x => "debounce" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1 (StructType)
object ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1Codec {
  def decode(j: JsValue): ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1] =
    {
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) }
      val `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1BandPositionCodec.decodeOpt(x) }
      val `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1BinCodec.decodeOpt(x) }
      val `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) }
      val `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1TimeUnitCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) }
      val `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeForShapeCodec.decodeOpt(x) }
      return Some(ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1(
        `test` = `test`.get,
        `field` = `field`,
        `scale` = `scale`,
        `legend` = `legend`,
        `bandPosition` = `bandPosition`,
        `bin` = `bin`,
        `aggregate` = `aggregate`,
        `timeUnit` = `timeUnit`,
        `title` = `title`,
        `sort` = `sort`,
        `type` = `type`,
      ))
    }

  def encode(j: ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1BandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1BinCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1TimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeForShapeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingXTimeUnit (UnionType)
object SharedEncodingXTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingXTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingXTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingXTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisNumberAsObject2Condition (UnionType)
object ConditionalAxisNumberAsObject2ConditionCodec {
  def decode(j: JsValue): ConditionalAxisNumberAsObject2Condition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisNumberAsObject2Condition] =
    ConditionalPredicateValueDefNumberNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalPredicateValueDefNumberNullExprRefCodec.decodeOpt(j).map { ConditionalAxisNumberAsObject2ConditionAsArrayOfConditionalPredicateValueDefNumberNullExprRef(_) } } 
  def encode(j: ConditionalAxisNumberAsObject2Condition): JsValue =
    j match {
      case x:ConditionalPredicateValueDefNumberNullExprRef /* TypeRef */ => ConditionalPredicateValueDefNumberNullExprRefCodec.encode(x)
      case ConditionalAxisNumberAsObject2ConditionAsArrayOfConditionalPredicateValueDefNumberNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalPredicateValueDefNumberNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigBlend (UnionType)
object MarkConfigBlendCodec {
  def decode(j: JsValue): MarkConfigBlend =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigBlend] =
    BlendCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigBlend): JsValue =
    j match {
      case x:Blend /* TypeRef */ => BlendCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfigParallel (UnionType)
object ProjectionConfigParallelCodec {
  def decode(j: JsValue): ProjectionConfigParallel =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigParallel] =
    j.asOpt[JsNumber].map { ProjectionConfigParallelAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigParallel): JsValue =
    j match {
      case ProjectionConfigParallelAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Padding (ConstrainedType)
// see Padding (UnionType)

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefStrokeCap (UnionType)
object OverlayMarkDefStrokeCapCodec {
  def decode(j: JsValue): OverlayMarkDefStrokeCap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefStrokeCap] =
    StrokeCapCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefStrokeCap): JsValue =
    j match {
      case x:StrokeCap /* TypeRef */ => StrokeCapCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigMinOpacity (ConstrainedType)
object ScaleConfigMinOpacityCodec {
  def decode(j: JsValue): ScaleConfigMinOpacity =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ScaleConfigMinOpacity] =
    try {
      j.asOpt[JsNumber]
        .map { ScaleConfigMinOpacity(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ScaleConfigMinOpacity): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkDefSmooth (UnionType)
object MarkDefSmoothCodec {
  def decode(j: JsValue): MarkDefSmooth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefSmooth] =
    j.asOpt[Boolean].map { MarkDefSmoothAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefSmooth): JsValue =
    j match {
      case MarkDefSmoothAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ImputeParams (StructType)
object ImputeParamsCodec {
  def decode(j: JsValue): ImputeParams =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ImputeParams] =
    Some(ImputeParams(
      `frame` = (j \ "frame").asOpt[JsValue].flatMap { x => ImputeParamsFrameCodec.decodeOpt(x) },
      `keyvals` = (j \ "keyvals").asOpt[JsValue].flatMap { x => ImputeParamsKeyvalsCodec.decodeOpt(x) },
      `method` = (j \ "method").asOpt[JsValue].flatMap { x => ImputeMethodCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => x.asOpt[JsValue] },
    ))

  def encode(j: ImputeParams): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`frame`.map { x => "frame" -> ImputeParamsFrameCodec.encode(x) },
        j.`keyvals`.map { x => "keyvals" -> ImputeParamsKeyvalsCodec.encode(x) },
        j.`method`.map { x => "method" -> ImputeMethodCodec.encode(x) },
        j.`value`.map { x => "value" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// RectConfigFillOpacityAsNumber (ConstrainedType)
object RectConfigFillOpacityAsNumberCodec {
  def decode(j: JsValue): RectConfigFillOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RectConfigFillOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { RectConfigFillOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: RectConfigFillOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// BinTransform (StructType)
object BinTransformCodec {
  def decode(j: JsValue): BinTransform =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BinTransform] =
    {
      val `as` = (j \ "as").asOpt[JsValue].flatMap { x => BinTransformAsCodec.decodeOpt(x) }
      if(`as`.isEmpty) { return None }
      val `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => BinTransformBinCodec.decodeOpt(x) }
      if(`bin`.isEmpty) { return None }
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`field`.isEmpty) { return None }
      return Some(BinTransform(
        `as` = `as`.get,
        `bin` = `bin`.get,
        `field` = `field`.get,
      ))
    }

  def encode(j: BinTransform): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("as" -> BinTransformAsCodec.encode(j.`as`)),
        Some("bin" -> BinTransformBinCodec.encode(j.`bin`)),
        Some("field" -> Json.toJson(j.`field`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LayerSpecHeight (UnionType)
object LayerSpecHeightCodec {
  def decode(j: JsValue): LayerSpecHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LayerSpecHeight] =
    j.asOpt[JsNumber].map { LayerSpecHeightAsNumber(_) }.orElse {
    ContainerCodec.decodeOpt(j).orElse {
    StepCodec.decodeOpt(j) } } 
  def encode(j: LayerSpecHeight): JsValue =
    j match {
      case LayerSpecHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Container /* TypeRef */ => ContainerCodec.encode(x)
      case x:Step /* TypeRef */ => StepCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewBackgroundOpacity (UnionType)
object ViewBackgroundOpacityCodec {
  def decode(j: JsValue): ViewBackgroundOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewBackgroundOpacity] =
    j.asOpt[JsNumber].map { ViewBackgroundOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ViewBackgroundOpacity): JsValue =
    j match {
      case ViewBackgroundOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefOuterRadius (UnionType)
object MarkDefOuterRadiusCodec {
  def decode(j: JsValue): MarkDefOuterRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefOuterRadius] =
    j.asOpt[JsNumber].map { MarkDefOuterRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefOuterRadius): JsValue =
    j match {
      case MarkDefOuterRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigMaxFontSize (ConstrainedType)
object ScaleConfigMaxFontSizeCodec {
  def decode(j: JsValue): ScaleConfigMaxFontSize =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ScaleConfigMaxFontSize] =
    try {
      j.asOpt[JsNumber]
        .map { ScaleConfigMaxFontSize(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ScaleConfigMaxFontSize): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// FieldDefWithoutScaleTimeUnit (UnionType)
object FieldDefWithoutScaleTimeUnitCodec {
  def decode(j: JsValue): FieldDefWithoutScaleTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldDefWithoutScaleTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: FieldDefWithoutScaleTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ErrorBarConfig (StructType)
object ErrorBarConfigCodec {
  def decode(j: JsValue): ErrorBarConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ErrorBarConfig] =
    Some(ErrorBarConfig(
      `size` = (j \ "size").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `extent` = (j \ "extent").asOpt[JsValue].flatMap { x => ErrorBarExtentCodec.decodeOpt(x) },
      `rule` = (j \ "rule").asOpt[JsValue].flatMap { x => ErrorBarConfigRuleCodec.decodeOpt(x) },
      `thickness` = (j \ "thickness").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `ticks` = (j \ "ticks").asOpt[JsValue].flatMap { x => ErrorBarConfigTicksCodec.decodeOpt(x) },
    ))

  def encode(j: ErrorBarConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`size`.map { x => "size" -> Json.toJson(x) },
        j.`extent`.map { x => "extent" -> ErrorBarExtentCodec.encode(x) },
        j.`rule`.map { x => "rule" -> ErrorBarConfigRuleCodec.encode(x) },
        j.`thickness`.map { x => "thickness" -> Json.toJson(x) },
        j.`ticks`.map { x => "ticks" -> ErrorBarConfigTicksCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ArrayOfJoinAggregateFieldDef (ArrayType)
object ArrayOfJoinAggregateFieldDefCodec {
  def decode(j: JsValue): Seq[JoinAggregateFieldDef] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[JoinAggregateFieldDef]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      JoinAggregateFieldDefCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[JoinAggregateFieldDef]): JsArray =
      JsArray(j.map { x => JoinAggregateFieldDefCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// MarkDefStrokeWidthAsNumber (ConstrainedType)
object MarkDefStrokeWidthAsNumberCodec {
  def decode(j: JsValue): MarkDefStrokeWidthAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[MarkDefStrokeWidthAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { MarkDefStrokeWidthAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: MarkDefStrokeWidthAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigOffsetBandPaddingOuter (UnionType)
object ScaleConfigOffsetBandPaddingOuterCodec {
  def decode(j: JsValue): ScaleConfigOffsetBandPaddingOuter =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleConfigOffsetBandPaddingOuter] =
    j.asOpt[JsNumber].map { ScaleConfigOffsetBandPaddingOuterAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleConfigOffsetBandPaddingOuter): JsValue =
    j match {
      case ScaleConfigOffsetBandPaddingOuterAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject2Bounds (EnumType)
object TopLevelRepeatSpecAsObject2BoundsCodec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject2Bounds =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject2Bounds] =
    j match {
      case JsString("full") => Some(TopLevelRepeatSpecAsObject2BoundsFull)
      case JsString("flush") => Some(TopLevelRepeatSpecAsObject2BoundsFlush)
      case _ => None
    }
  def encode(j: TopLevelRepeatSpecAsObject2Bounds): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// HeaderConfigTitleLimit (UnionType)
object HeaderConfigTitleLimitCodec {
  def decode(j: JsValue): HeaderConfigTitleLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigTitleLimit] =
    j.asOpt[JsNumber].map { HeaderConfigTitleLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderConfigTitleLimit): JsValue =
    j match {
      case HeaderConfigTitleLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsDy (UnionType)
object TitleParamsDyCodec {
  def decode(j: JsValue): TitleParamsDy =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsDy] =
    j.asOpt[JsNumber].map { TitleParamsDyAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleParamsDy): JsValue =
    j match {
      case TitleParamsDyAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetEncodingFieldDefBounds (EnumType)
object FacetEncodingFieldDefBoundsCodec {
  def decode(j: JsValue): FacetEncodingFieldDefBounds =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetEncodingFieldDefBounds] =
    j match {
      case JsString("full") => Some(FacetEncodingFieldDefBoundsFull)
      case JsString("flush") => Some(FacetEncodingFieldDefBoundsFlush)
      case _ => None
    }
  def encode(j: FacetEncodingFieldDefBounds): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// AxisTitleLimit (UnionType)
object AxisTitleLimitCodec {
  def decode(j: JsValue): AxisTitleLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTitleLimit] =
    AxisTitleLimitAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisTitleLimit): JsValue =
    j match {
      case x:AxisTitleLimitAsNumber /* TypeRef */ => AxisTitleLimitAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScalePaddingOuter (ConstrainedType)
// see ScalePaddingOuter (UnionType)

////////////////////////////////////////////////////////////////////////
// ProjectionExtent (UnionType)
object ProjectionExtentCodec {
  def decode(j: JsValue): ProjectionExtent =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionExtent] =
    Vector2Vector2NumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionExtent): JsValue =
    j match {
      case x:Vector2Vector2Number /* TypeRef */ => Vector2Vector2NumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldGTEPredicateTimeUnit (UnionType)
object FieldGTEPredicateTimeUnitCodec {
  def decode(j: JsValue): FieldGTEPredicateTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldGTEPredicateTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: FieldGTEPredicateTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigOrder (UnionType)
object MarkConfigOrderCodec {
  def decode(j: JsValue): MarkConfigOrder =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigOrder] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => MarkConfigOrderAsNull }.orElse {
    j.asOpt[Boolean].map { MarkConfigOrderAsBool(_) } } 
  def encode(j: MarkConfigOrder): JsValue =
    j match {
      case MarkConfigOrderAsNull /* Global, NullType$ */ => JsNull
      case MarkConfigOrderAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2BandPosition (ConstrainedType)
object ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2BandPositionCodec {
  def decode(j: JsValue): ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2BandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2BandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2BandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2BandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefCornerRadiusBottomRight (UnionType)
object OverlayMarkDefCornerRadiusBottomRightCodec {
  def decode(j: JsValue): OverlayMarkDefCornerRadiusBottomRight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefCornerRadiusBottomRight] =
    j.asOpt[JsNumber].map { OverlayMarkDefCornerRadiusBottomRightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefCornerRadiusBottomRight): JsValue =
    j match {
      case OverlayMarkDefCornerRadiusBottomRightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigQuantizeCount (ConstrainedType)
object ScaleConfigQuantizeCountCodec {
  def decode(j: JsValue): ScaleConfigQuantizeCount =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ScaleConfigQuantizeCount] =
    try {
      j.asOpt[JsNumber]
        .map { ScaleConfigQuantizeCount(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ScaleConfigQuantizeCount): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AxisConfigLabelColor (UnionType)
object AxisConfigLabelColorCodec {
  def decode(j: JsValue): AxisConfigLabelColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigLabelColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => AxisConfigLabelColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisColorCodec.decodeOpt(j) } } } 
  def encode(j: AxisConfigLabelColor): JsValue =
    j match {
      case AxisConfigLabelColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisColor /* TypeRef */ => ConditionalAxisColorCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LookupTransform (StructType)
object LookupTransformCodec {
  def decode(j: JsValue): LookupTransform =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LookupTransform] =
    {
      val `as` = (j \ "as").asOpt[JsValue].flatMap { x => LookupTransformAsCodec.decodeOpt(x) }
      val `default` = (j \ "default").asOpt[JsValue].flatMap { x => x.asOpt[JsValue] }
      val `from` = (j \ "from").asOpt[JsValue].flatMap { x => LookupTransformFromCodec.decodeOpt(x) }
      if(`from`.isEmpty) { return None }
      val `lookup` = (j \ "lookup").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`lookup`.isEmpty) { return None }
      return Some(LookupTransform(
        `as` = `as`,
        `default` = `default`,
        `from` = `from`.get,
        `lookup` = `lookup`.get,
      ))
    }

  def encode(j: LookupTransform): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`as`.map { x => "as" -> LookupTransformAsCodec.encode(x) },
        j.`default`.map { x => "default" -> Json.toJson(x) },
        Some("from" -> LookupTransformFromCodec.encode(j.`from`)),
        Some("lookup" -> Json.toJson(j.`lookup`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LineConfigSize (UnionType)
object LineConfigSizeCodec {
  def decode(j: JsValue): LineConfigSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigSize] =
    j.asOpt[JsNumber].map { LineConfigSizeAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigSize): JsValue =
    j match {
      case LineConfigSizeAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldRange (StructType)
object FieldRangeCodec {
  def decode(j: JsValue): FieldRange =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldRange] =
    {
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`field`.isEmpty) { return None }
      return Some(FieldRange(
        `field` = `field`.get,
      ))
    }

  def encode(j: FieldRange): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("field" -> Json.toJson(j.`field`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingYErrorTimeUnit (UnionType)
object SharedEncodingYErrorTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingYErrorTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingYErrorTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingYErrorTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionPointRadius (UnionType)
object ProjectionPointRadiusCodec {
  def decode(j: JsValue): ProjectionPointRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionPointRadius] =
    j.asOpt[JsNumber].map { ProjectionPointRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionPointRadius): JsValue =
    j match {
      case ProjectionPointRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingTextDatum (UnionType)
object SharedEncodingTextDatumCodec {
  def decode(j: JsValue): SharedEncodingTextDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingTextDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingTextDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RangeConfig (StructType)
object RangeConfigCodec {
  def decode(j: JsValue): RangeConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RangeConfig] =
    Some(RangeConfig(
      `diverging` = (j \ "diverging").asOpt[JsValue].flatMap { x => RangeConfigDivergingCodec.decodeOpt(x) },
      `symbol` = (j \ "symbol").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) },
      `ordinal` = (j \ "ordinal").asOpt[JsValue].flatMap { x => RangeConfigOrdinalCodec.decodeOpt(x) },
      `category` = (j \ "category").asOpt[JsValue].flatMap { x => RangeConfigCategoryCodec.decodeOpt(x) },
      `ramp` = (j \ "ramp").asOpt[JsValue].flatMap { x => RangeConfigRampCodec.decodeOpt(x) },
      `heatmap` = (j \ "heatmap").asOpt[JsValue].flatMap { x => RangeConfigHeatmapCodec.decodeOpt(x) },
    optionalFields = j.as[Map[String, JsValue]].toSeq.filterNot {
        x => RangeConfig.definedFields(x._1)
      }.flatMap { case (name, value) =>
        RangeConfigOptionalCodec.decodeOpt(value).map { name -> _ }
      }.toMap
    ))

  def encode(j: RangeConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`diverging`.map { x => "diverging" -> RangeConfigDivergingCodec.encode(x) },
        j.`symbol`.map { x => "symbol" -> ArrayOfStringCodec.encode(x) },
        j.`ordinal`.map { x => "ordinal" -> RangeConfigOrdinalCodec.encode(x) },
        j.`category`.map { x => "category" -> RangeConfigCategoryCodec.encode(x) },
        j.`ramp`.map { x => "ramp" -> RangeConfigRampCodec.encode(x) },
        j.`heatmap`.map { x => "heatmap" -> RangeConfigHeatmapCodec.encode(x) },
      ).flatten.toMap
      ++j.optionalFields.mapValues { x => RangeConfigOptionalCodec.encode(x) }
    )
}


////////////////////////////////////////////////////////////////////////
// MarkDefX2Offset (UnionType)
object MarkDefX2OffsetCodec {
  def decode(j: JsValue): MarkDefX2Offset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefX2Offset] =
    j.asOpt[JsNumber].map { MarkDefX2OffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefX2Offset): JsValue =
    j match {
      case MarkDefX2OffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingAngleTimeUnit (UnionType)
object SharedEncodingAngleTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingAngleTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingAngleTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingAngleTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelHConcatSpecPadding (UnionType)
object TopLevelHConcatSpecPaddingCodec {
  def decode(j: JsValue): TopLevelHConcatSpecPadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelHConcatSpecPadding] =
    PaddingCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TopLevelHConcatSpecPadding): JsValue =
    j match {
      case x:Padding /* TypeRef */ => PaddingCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigDomainCap (UnionType)
object AxisConfigDomainCapCodec {
  def decode(j: JsValue): AxisConfigDomainCap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigDomainCap] =
    StrokeCapCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigDomainCap): JsValue =
    j match {
      case x:StrokeCap /* TypeRef */ => StrokeCapCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefPadAngle (UnionType)
object MarkDefPadAngleCodec {
  def decode(j: JsValue): MarkDefPadAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefPadAngle] =
    j.asOpt[JsNumber].map { MarkDefPadAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefPadAngle): JsValue =
    j match {
      case MarkDefPadAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigZindex (UnionType)
object LegendConfigZindexCodec {
  def decode(j: JsValue): LegendConfigZindex =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigZindex] =
    LegendConfigZindexAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigZindex): JsValue =
    j match {
      case x:LegendConfigZindexAsNumber /* TypeRef */ => LegendConfigZindexAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigCursor (UnionType)
object LineConfigCursorCodec {
  def decode(j: JsValue): LineConfigCursor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigCursor] =
    CursorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigCursor): JsValue =
    j match {
      case x:Cursor /* TypeRef */ => CursorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsSubtitleFontWeight (UnionType)
object TitleParamsSubtitleFontWeightCodec {
  def decode(j: JsValue): TitleParamsSubtitleFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsSubtitleFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleParamsSubtitleFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigCornerRadius (UnionType)
object MarkConfigCornerRadiusCodec {
  def decode(j: JsValue): MarkConfigCornerRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigCornerRadius] =
    j.asOpt[JsNumber].map { MarkConfigCornerRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigCornerRadius): JsValue =
    j match {
      case MarkConfigCornerRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisLabelFontWeightAsObject1Condition (UnionType)
object ConditionalAxisLabelFontWeightAsObject1ConditionCodec {
  def decode(j: JsValue): ConditionalAxisLabelFontWeightAsObject1Condition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisLabelFontWeightAsObject1Condition] =
    ConditionalPredicateValueDefFontWeightNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalPredicateValueDefFontWeightNullExprRefCodec.decodeOpt(j).map { ConditionalAxisLabelFontWeightAsObject1ConditionAsArrayOfConditionalPredicateValueDefFontWeightNullExprRef(_) } } 
  def encode(j: ConditionalAxisLabelFontWeightAsObject1Condition): JsValue =
    j match {
      case x:ConditionalPredicateValueDefFontWeightNullExprRef /* TypeRef */ => ConditionalPredicateValueDefFontWeightNullExprRefCodec.encode(x)
      case ConditionalAxisLabelFontWeightAsObject1ConditionAsArrayOfConditionalPredicateValueDefFontWeightNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalPredicateValueDefFontWeightNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeDashBin (UnionType)
object SharedEncodingStrokeDashBinCodec {
  def decode(j: JsValue): SharedEncodingStrokeDashBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeDashBin] =
    j.asOpt[Boolean].map { SharedEncodingStrokeDashBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingStrokeDashBinAsNull } } } 
  def encode(j: SharedEncodingStrokeDashBin): JsValue =
    j match {
      case SharedEncodingStrokeDashBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case SharedEncodingStrokeDashBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// IntervalSelectionConfig (StructType)
object IntervalSelectionConfigCodec {
  def decode(j: JsValue): IntervalSelectionConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[IntervalSelectionConfig] =
    {
      val `clear` = (j \ "clear").asOpt[JsValue].flatMap { x => IntervalSelectionConfigClearCodec.decodeOpt(x) }
      val `on` = (j \ "on").asOpt[JsValue].flatMap { x => IntervalSelectionConfigOnCodec.decodeOpt(x) }
      val `resolve` = (j \ "resolve").asOpt[JsValue].flatMap { x => SelectionResolutionCodec.decodeOpt(x) }
      val `translate` = (j \ "translate").asOpt[JsValue].flatMap { x => IntervalSelectionConfigTranslateCodec.decodeOpt(x) }
      val `type` = (j \ "type").asOpt[JsValue].flatMap { x => IntervalSelectionConfigTypeCodec.decodeOpt(x) }
      if(`type`.isEmpty) { return None }
      val `mark` = (j \ "mark").asOpt[JsValue].flatMap { x => BrushConfigCodec.decodeOpt(x) }
      val `encodings` = (j \ "encodings").asOpt[JsValue].flatMap { x => ArrayOfSingleDefUnitChannelCodec.decodeOpt(x) }
      val `zoom` = (j \ "zoom").asOpt[JsValue].flatMap { x => IntervalSelectionConfigZoomCodec.decodeOpt(x) }
      return Some(IntervalSelectionConfig(
        `clear` = `clear`,
        `on` = `on`,
        `resolve` = `resolve`,
        `translate` = `translate`,
        `type` = `type`.get,
        `mark` = `mark`,
        `encodings` = `encodings`,
        `zoom` = `zoom`,
      ))
    }

  def encode(j: IntervalSelectionConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`clear`.map { x => "clear" -> IntervalSelectionConfigClearCodec.encode(x) },
        j.`on`.map { x => "on" -> IntervalSelectionConfigOnCodec.encode(x) },
        j.`resolve`.map { x => "resolve" -> SelectionResolutionCodec.encode(x) },
        j.`translate`.map { x => "translate" -> IntervalSelectionConfigTranslateCodec.encode(x) },
        Some("type" -> IntervalSelectionConfigTypeCodec.encode(j.`type`)),
        j.`mark`.map { x => "mark" -> BrushConfigCodec.encode(x) },
        j.`encodings`.map { x => "encodings" -> ArrayOfSingleDefUnitChannelCodec.encode(x) },
        j.`zoom`.map { x => "zoom" -> IntervalSelectionConfigZoomCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AreaConfigCornerRadiusBottomRight (UnionType)
object AreaConfigCornerRadiusBottomRightCodec {
  def decode(j: JsValue): AreaConfigCornerRadiusBottomRight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigCornerRadiusBottomRight] =
    j.asOpt[JsNumber].map { AreaConfigCornerRadiusBottomRightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigCornerRadiusBottomRight): JsValue =
    j match {
      case AreaConfigCornerRadiusBottomRightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// DataFormat (UnionType)
object DataFormatCodec {
  def decode(j: JsValue): DataFormat =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[DataFormat] =
    CsvDataFormatCodec.decodeOpt(j).orElse {
    DsvDataFormatCodec.decodeOpt(j).orElse {
    JsonDataFormatCodec.decodeOpt(j).orElse {
    TopoDataFormatCodec.decodeOpt(j) } } } 
  def encode(j: DataFormat): JsValue =
    j match {
      case x:CsvDataFormat /* TypeRef */ => CsvDataFormatCodec.encode(x)
      case x:DsvDataFormat /* TypeRef */ => DsvDataFormatCodec.encode(x)
      case x:JsonDataFormat /* TypeRef */ => JsonDataFormatCodec.encode(x)
      case x:TopoDataFormat /* TypeRef */ => TopoDataFormatCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefXOffset (UnionType)
object MarkDefXOffsetCodec {
  def decode(j: JsValue): MarkDefXOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefXOffset] =
    j.asOpt[JsNumber].map { MarkDefXOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefXOffset): JsValue =
    j match {
      case MarkDefXOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ErrorBarDef (StructType)
object ErrorBarDefCodec {
  def decode(j: JsValue): ErrorBarDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ErrorBarDef] =
    {
      val `size` = (j \ "size").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `extent` = (j \ "extent").asOpt[JsValue].flatMap { x => ErrorBarExtentCodec.decodeOpt(x) }
      val `rule` = (j \ "rule").asOpt[JsValue].flatMap { x => ErrorBarDefRuleCodec.decodeOpt(x) }
      val `color` = (j \ "color").asOpt[JsValue].flatMap { x => ErrorBarDefColorCodec.decodeOpt(x) }
      val `thickness` = (j \ "thickness").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `ticks` = (j \ "ticks").asOpt[JsValue].flatMap { x => ErrorBarDefTicksCodec.decodeOpt(x) }
      val `orient` = (j \ "orient").asOpt[JsValue].flatMap { x => OrientationCodec.decodeOpt(x) }
      val `opacity` = (j \ "opacity").asOpt[JsValue].flatMap { x => ErrorBarDefOpacityCodec.decodeOpt(x) }
      val `type` = (j \ "type").asOpt[JsValue].flatMap { x => ErrorBarCodec.decodeOpt(x) }
      if(`type`.isEmpty) { return None }
      val `clip` = (j \ "clip").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      return Some(ErrorBarDef(
        `size` = `size`,
        `extent` = `extent`,
        `rule` = `rule`,
        `color` = `color`,
        `thickness` = `thickness`,
        `ticks` = `ticks`,
        `orient` = `orient`,
        `opacity` = `opacity`,
        `type` = `type`.get,
        `clip` = `clip`,
      ))
    }

  def encode(j: ErrorBarDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`size`.map { x => "size" -> Json.toJson(x) },
        j.`extent`.map { x => "extent" -> ErrorBarExtentCodec.encode(x) },
        j.`rule`.map { x => "rule" -> ErrorBarDefRuleCodec.encode(x) },
        j.`color`.map { x => "color" -> ErrorBarDefColorCodec.encode(x) },
        j.`thickness`.map { x => "thickness" -> Json.toJson(x) },
        j.`ticks`.map { x => "ticks" -> ErrorBarDefTicksCodec.encode(x) },
        j.`orient`.map { x => "orient" -> OrientationCodec.encode(x) },
        j.`opacity`.map { x => "opacity" -> ErrorBarDefOpacityCodec.encode(x) },
        Some("type" -> ErrorBarCodec.encode(j.`type`)),
        j.`clip`.map { x => "clip" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// RectConfigFontSizeAsNumber (ConstrainedType)
object RectConfigFontSizeAsNumberCodec {
  def decode(j: JsValue): RectConfigFontSizeAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RectConfigFontSizeAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { RectConfigFontSizeAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: RectConfigFontSizeAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// RectConfigStrokeJoin (UnionType)
object RectConfigStrokeJoinCodec {
  def decode(j: JsValue): RectConfigStrokeJoin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigStrokeJoin] =
    StrokeJoinCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigStrokeJoin): JsValue =
    j match {
      case x:StrokeJoin /* TypeRef */ => StrokeJoinCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefDir (UnionType)
object MarkDefDirCodec {
  def decode(j: JsValue): MarkDefDir =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefDir] =
    TextDirectionCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefDir): JsValue =
    j match {
      case x:TextDirection /* TypeRef */ => TextDirectionCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigStroke (UnionType)
object TickConfigStrokeCodec {
  def decode(j: JsValue): TickConfigStroke =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigStroke] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => TickConfigStrokeAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: TickConfigStroke): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case TickConfigStrokeAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LayerRepeatSpecSpec (UnionType)
object LayerRepeatSpecSpecCodec {
  def decode(j: JsValue): LayerRepeatSpecSpec =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LayerRepeatSpecSpec] =
    LayerSpecCodec.decodeOpt(j).orElse {
    UnitSpecCodec.decodeOpt(j) } 
  def encode(j: LayerRepeatSpecSpec): JsValue =
    j match {
      case x:LayerSpec /* TypeRef */ => LayerSpecCodec.encode(x)
      case x:UnitSpec /* TypeRef */ => UnitSpecCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefDescription (UnionType)
object OverlayMarkDefDescriptionCodec {
  def decode(j: JsValue): OverlayMarkDefDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefDescription] =
    j.asOpt[String].map { OverlayMarkDefDescriptionAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefDescription): JsValue =
    j match {
      case OverlayMarkDefDescriptionAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateMarkPropFieldOrDatumDefAsObject1Bin (UnionType)
object ConditionalPredicateMarkPropFieldOrDatumDefAsObject1BinCodec {
  def decode(j: JsValue): ConditionalPredicateMarkPropFieldOrDatumDefAsObject1Bin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateMarkPropFieldOrDatumDefAsObject1Bin] =
    j.asOpt[Boolean].map { ConditionalPredicateMarkPropFieldOrDatumDefAsObject1BinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ConditionalPredicateMarkPropFieldOrDatumDefAsObject1BinAsNull } } } 
  def encode(j: ConditionalPredicateMarkPropFieldOrDatumDefAsObject1Bin): JsValue =
    j match {
      case ConditionalPredicateMarkPropFieldOrDatumDefAsObject1BinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case ConditionalPredicateMarkPropFieldOrDatumDefAsObject1BinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject1ParamsElement (UnionType)
object TopLevelRepeatSpecAsObject1ParamsElementCodec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject1ParamsElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject1ParamsElement] =
    VariableParameterCodec.decodeOpt(j).orElse {
    TopLevelSelectionParameterCodec.decodeOpt(j) } 
  def encode(j: TopLevelRepeatSpecAsObject1ParamsElement): JsValue =
    j match {
      case x:VariableParameter /* TypeRef */ => VariableParameterCodec.encode(x)
      case x:TopLevelSelectionParameter /* TypeRef */ => TopLevelSelectionParameterCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewConfigDiscreteWidthAsObject2 (StructType)
object ViewConfigDiscreteWidthAsObject2Codec {
  def decode(j: JsValue): ViewConfigDiscreteWidthAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ViewConfigDiscreteWidthAsObject2] =
    {
      val `step` = (j \ "step").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      if(`step`.isEmpty) { return None }
      return Some(ViewConfigDiscreteWidthAsObject2(
        `step` = `step`.get,
      ))
    }

  def encode(j: ViewConfigDiscreteWidthAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("step" -> Json.toJson(j.`step`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ScaleDatumDefDatum (UnionType)
object ScaleDatumDefDatumCodec {
  def decode(j: JsValue): ScaleDatumDefDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleDatumDefDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: ScaleDatumDefDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderLabelFontWeight (UnionType)
object HeaderLabelFontWeightCodec {
  def decode(j: JsValue): HeaderLabelFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderLabelFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderLabelFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TooltipContentContent (EnumType)
object TooltipContentContentCodec {
  def decode(j: JsValue): TooltipContentContent =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TooltipContentContent] =
    j match {
      case JsString("encoding") => Some(TooltipContentContentEncoding)
      case JsString("data") => Some(TooltipContentContentData)
      case _ => None
    }
  def encode(j: TooltipContentContent): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// LineConfigInterpolate (UnionType)
object LineConfigInterpolateCodec {
  def decode(j: JsValue): LineConfigInterpolate =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigInterpolate] =
    InterpolateCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigInterpolate): JsValue =
    j match {
      case x:Interpolate /* TypeRef */ => InterpolateCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNull (StructType)
object FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNull =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNull] =
    Some(FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNull(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullConditionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullBinCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeForShapeCodec.decodeOpt(x) },
    ))

  def encode(j: FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNull): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullConditionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullBinCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeForShapeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingAngleDatum (UnionType)
object SharedEncodingAngleDatumCodec {
  def decode(j: JsValue): SharedEncodingAngleDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingAngleDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingAngleDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ImputeTransformKeyvals (UnionType)
object ImputeTransformKeyvalsCodec {
  def decode(j: JsValue): ImputeTransformKeyvals =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ImputeTransformKeyvals] =
    ArrayOfAnyCodec.decodeOpt(j).map { ImputeTransformKeyvalsAsArrayOfAny(_) }.orElse {
    ImputeSequenceCodec.decodeOpt(j) } 
  def encode(j: ImputeTransformKeyvals): JsValue =
    j match {
      case ImputeTransformKeyvalsAsArrayOfAny(x) /* Base, ArrayType */ => ArrayOfAnyCodec.encode(x)
      case x:ImputeSequence /* TypeRef */ => ImputeSequenceCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigFillOpacityAsNumber (ConstrainedType)
object TickConfigFillOpacityAsNumberCodec {
  def decode(j: JsValue): TickConfigFillOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TickConfigFillOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { TickConfigFillOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: TickConfigFillOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkConfigDescription (UnionType)
object MarkConfigDescriptionCodec {
  def decode(j: JsValue): MarkConfigDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigDescription] =
    j.asOpt[String].map { MarkConfigDescriptionAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigDescription): JsValue =
    j match {
      case MarkConfigDescriptionAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigFontWeight (UnionType)
object LineConfigFontWeightCodec {
  def decode(j: JsValue): LineConfigFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigBlend (UnionType)
object BarConfigBlendCodec {
  def decode(j: JsValue): BarConfigBlend =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigBlend] =
    BlendCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigBlend): JsValue =
    j match {
      case x:Blend /* TypeRef */ => BlendCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldValidPredicateTimeUnit (UnionType)
object FieldValidPredicateTimeUnitCodec {
  def decode(j: JsValue): FieldValidPredicateTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldValidPredicateTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: FieldValidPredicateTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingHrefBandPosition (ConstrainedType)
object SharedEncodingHrefBandPositionCodec {
  def decode(j: JsValue): SharedEncodingHrefBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingHrefBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingHrefBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingHrefBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// InlineDataset (UnionType)
object InlineDatasetCodec {
  def decode(j: JsValue): InlineDataset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[InlineDataset] =
    j.asOpt[String].map { InlineDatasetAsString(_) }.orElse {
    j.asOpt[JsObject].map { _ => Json.obj() }.map { _ => InlineDatasetAsEmptyObject }.orElse {
    ArrayOfNumberCodec.decodeOpt(j).map { InlineDatasetAsArrayOfNumber(_) }.orElse {
    ArrayOfBoolCodec.decodeOpt(j).map { InlineDatasetAsArrayOfBool(_) }.orElse {
    ArrayOfEmptyObjectCodec.decodeOpt(j).map { InlineDatasetAsArrayOfEmptyObject(_) }.orElse {
    ArrayOfStringCodec.decodeOpt(j).map { InlineDatasetAsArrayOfString(_) } } } } } } 
  def encode(j: InlineDataset): JsValue =
    j match {
      case InlineDatasetAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case InlineDatasetAsEmptyObject /* Global, EmptyObject$ */ => Json.obj()
      case InlineDatasetAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case InlineDatasetAsArrayOfBool(x) /* Base, ArrayType */ => ArrayOfBoolCodec.encode(x)
      case InlineDatasetAsArrayOfEmptyObject(x) /* Base, ArrayType */ => ArrayOfEmptyObjectCodec.encode(x)
      case InlineDatasetAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingRadiusBin (UnionType)
object SharedEncodingRadiusBinCodec {
  def decode(j: JsValue): SharedEncodingRadiusBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingRadiusBin] =
    j.asOpt[Boolean].map { SharedEncodingRadiusBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    BinnedCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingRadiusBinAsNull } } } } 
  def encode(j: SharedEncodingRadiusBin): JsValue =
    j match {
      case SharedEncodingRadiusBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case x:Binned /* TypeRef */ => BinnedCodec.encode(x)
      case SharedEncodingRadiusBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigLimit (UnionType)
object TickConfigLimitCodec {
  def decode(j: JsValue): TickConfigLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigLimit] =
    j.asOpt[JsNumber].map { TickConfigLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigLimit): JsValue =
    j match {
      case TickConfigLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigFill (UnionType)
object TickConfigFillCodec {
  def decode(j: JsValue): TickConfigFill =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigFill] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => TickConfigFillAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: TickConfigFill): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case TickConfigFillAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigLegendY (UnionType)
object LegendConfigLegendYCodec {
  def decode(j: JsValue): LegendConfigLegendY =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigLegendY] =
    j.asOpt[JsNumber].map { LegendConfigLegendYAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigLegendY): JsValue =
    j match {
      case LegendConfigLegendYAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigY2 (UnionType)
object BarConfigY2Codec {
  def decode(j: JsValue): BarConfigY2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigY2] =
    j.asOpt[JsNumber].map { BarConfigY2AsNumber(_) }.orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: BarConfigY2): JsValue =
    j match {
      case BarConfigY2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewConfigStrokeWidthAsNumber (ConstrainedType)
object ViewConfigStrokeWidthAsNumberCodec {
  def decode(j: JsValue): ViewConfigStrokeWidthAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ViewConfigStrokeWidthAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { ViewConfigStrokeWidthAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ViewConfigStrokeWidthAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingFillCondition (UnionType)
object SharedEncodingFillConditionCodec {
  def decode(j: JsValue): SharedEncodingFillCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingFillCondition] =
    ConditionalValueDefGradientStringNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefGradientStringNullExprRefCodec.decodeOpt(j).map { SharedEncodingFillConditionAsArrayOfConditionalValueDefGradientStringNullExprRef(_) }.orElse {
    ConditionalMarkPropFieldOrDatumDefCodec.decodeOpt(j) } } 
  def encode(j: SharedEncodingFillCondition): JsValue =
    j match {
      case x:ConditionalValueDefGradientStringNullExprRef /* TypeRef */ => ConditionalValueDefGradientStringNullExprRefCodec.encode(x)
      case SharedEncodingFillConditionAsArrayOfConditionalValueDefGradientStringNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefGradientStringNullExprRefCodec.encode(x)
      case x:ConditionalMarkPropFieldOrDatumDef /* TypeRef */ => ConditionalMarkPropFieldOrDatumDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefTension (UnionType)
object OverlayMarkDefTensionCodec {
  def decode(j: JsValue): OverlayMarkDefTension =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefTension] =
    j.asOpt[JsNumber].map { OverlayMarkDefTensionAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefTension): JsValue =
    j match {
      case OverlayMarkDefTensionAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewConfigStrokeDashOffset (UnionType)
object ViewConfigStrokeDashOffsetCodec {
  def decode(j: JsValue): ViewConfigStrokeDashOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewConfigStrokeDashOffset] =
    j.asOpt[JsNumber].map { ViewConfigStrokeDashOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ViewConfigStrokeDashOffset): JsValue =
    j match {
      case ViewConfigStrokeDashOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterValueDefStringExprRef (StructType)
object ConditionalParameterValueDefStringExprRefCodec {
  def decode(j: JsValue): ConditionalParameterValueDefStringExprRef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalParameterValueDefStringExprRef] =
    {
      val `empty` = (j \ "empty").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `param` = (j \ "param").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`param`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => ConditionalParameterValueDefStringExprRefValueCodec.decodeOpt(x) }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalParameterValueDefStringExprRef(
        `empty` = `empty`,
        `param` = `param`.get,
        `value` = `value`.get,
      ))
    }

  def encode(j: ConditionalParameterValueDefStringExprRef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`empty`.map { x => "empty" -> Json.toJson(x) },
        Some("param" -> Json.toJson(j.`param`)),
        Some("value" -> ConditionalParameterValueDefStringExprRefValueCodec.encode(j.`value`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// MarkConfigAriaRoleDescription (UnionType)
object MarkConfigAriaRoleDescriptionCodec {
  def decode(j: JsValue): MarkConfigAriaRoleDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigAriaRoleDescription] =
    j.asOpt[String].map { MarkConfigAriaRoleDescriptionAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigAriaRoleDescription): JsValue =
    j match {
      case MarkConfigAriaRoleDescriptionAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeDash (StructType)
object SharedEncodingStrokeDashCodec {
  def decode(j: JsValue): SharedEncodingStrokeDash =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeDash] =
    Some(SharedEncodingStrokeDash(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingStrokeDashDatumCodec.decodeOpt(x) },
      `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingStrokeDashBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => SharedEncodingStrokeDashConditionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingStrokeDashBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingStrokeDashValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingStrokeDashTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => SharedEncodingStrokeDashTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingStrokeDash): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingStrokeDashDatumCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingStrokeDashBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> SharedEncodingStrokeDashConditionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingStrokeDashBinCodec.encode(x) },
        j.`value`.map { x => "value" -> SharedEncodingStrokeDashValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingStrokeDashTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> SharedEncodingStrokeDashTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ArrayOfTopLevelHConcatSpecParamsElement (ArrayType)
object ArrayOfTopLevelHConcatSpecParamsElementCodec {
  def decode(j: JsValue): Seq[TopLevelHConcatSpecParamsElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[TopLevelHConcatSpecParamsElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      TopLevelHConcatSpecParamsElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[TopLevelHConcatSpecParamsElement]): JsArray =
      JsArray(j.map { x => TopLevelHConcatSpecParamsElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// FoldTransform (StructType)
object FoldTransformCodec {
  def decode(j: JsValue): FoldTransform =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FoldTransform] =
    {
      val `as` = (j \ "as").asOpt[JsValue].flatMap { x => FoldTransformAsCodec.decodeOpt(x) }
      val `fold` = (j \ "fold").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) }
      if(`fold`.isEmpty) { return None }
      return Some(FoldTransform(
        `as` = `as`,
        `fold` = `fold`.get,
      ))
    }

  def encode(j: FoldTransform): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`as`.map { x => "as" -> FoldTransformAsCodec.encode(x) },
        Some("fold" -> ArrayOfStringCodec.encode(j.`fold`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// HeaderConfigTitleFontWeight (UnionType)
object HeaderConfigTitleFontWeightCodec {
  def decode(j: JsValue): HeaderConfigTitleFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigTitleFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderConfigTitleFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfigRatio (UnionType)
object ProjectionConfigRatioCodec {
  def decode(j: JsValue): ProjectionConfigRatio =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigRatio] =
    j.asOpt[JsNumber].map { ProjectionConfigRatioAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigRatio): JsValue =
    j match {
      case ProjectionConfigRatioAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefY2 (UnionType)
object OverlayMarkDefY2Codec {
  def decode(j: JsValue): OverlayMarkDefY2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefY2] =
    j.asOpt[JsNumber].map { OverlayMarkDefY2AsNumber(_) }.orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: OverlayMarkDefY2): JsValue =
    j match {
      case OverlayMarkDefY2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigFontSize (UnionType)
object AreaConfigFontSizeCodec {
  def decode(j: JsValue): AreaConfigFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigFontSize] =
    AreaConfigFontSizeAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigFontSize): JsValue =
    j match {
      case x:AreaConfigFontSizeAsNumber /* TypeRef */ => AreaConfigFontSizeAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigLabelFontSize (UnionType)
object LegendConfigLabelFontSizeCodec {
  def decode(j: JsValue): LegendConfigLabelFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigLabelFontSize] =
    LegendConfigLabelFontSizeAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigLabelFontSize): JsValue =
    j match {
      case x:LegendConfigLabelFontSizeAsNumber /* TypeRef */ => LegendConfigLabelFontSizeAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewConfigFillOpacity (UnionType)
object ViewConfigFillOpacityCodec {
  def decode(j: JsValue): ViewConfigFillOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewConfigFillOpacity] =
    ViewConfigFillOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ViewConfigFillOpacity): JsValue =
    j match {
      case x:ViewConfigFillOpacityAsNumber /* TypeRef */ => ViewConfigFillOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ErrorBandConfigTension (ConstrainedType)
object ErrorBandConfigTensionCodec {
  def decode(j: JsValue): ErrorBandConfigTension =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ErrorBandConfigTension] =
    try {
      j.asOpt[JsNumber]
        .map { ErrorBandConfigTension(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ErrorBandConfigTension): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// JsonDataFormatType (ConstantType)
object JsonDataFormatTypeCodec {
  def decode(j: JsValue): JsonDataFormatType =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[JsonDataFormatType] =
    j match {
      case JsString("json") => Some(JsonDataFormatType())
      case _ => None
    }
  def encode(j: JsonDataFormatType): JsValue =
    JsString("json")
}


////////////////////////////////////////////////////////////////////////
// HeaderConfigTitleAlign (UnionType)
object HeaderConfigTitleAlignCodec {
  def decode(j: JsValue): HeaderConfigTitleAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigTitleAlign] =
    AlignCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderConfigTitleAlign): JsValue =
    j match {
      case x:Align /* TypeRef */ => AlignCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderTitleAlign (UnionType)
object HeaderTitleAlignCodec {
  def decode(j: JsValue): HeaderTitleAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderTitleAlign] =
    AlignCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderTitleAlign): JsValue =
    j match {
      case x:Align /* TypeRef */ => AlignCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleBase (UnionType)
object ScaleBaseCodec {
  def decode(j: JsValue): ScaleBase =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleBase] =
    j.asOpt[JsNumber].map { ScaleBaseAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleBase): JsValue =
    j match {
      case ScaleBaseAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigTitleLineHeight (UnionType)
object LegendConfigTitleLineHeightCodec {
  def decode(j: JsValue): LegendConfigTitleLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigTitleLineHeight] =
    j.asOpt[JsNumber].map { LegendConfigTitleLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigTitleLineHeight): JsValue =
    j match {
      case LegendConfigTitleLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewBackgroundStrokeCap (UnionType)
object ViewBackgroundStrokeCapCodec {
  def decode(j: JsValue): ViewBackgroundStrokeCap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewBackgroundStrokeCap] =
    StrokeCapCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ViewBackgroundStrokeCap): JsValue =
    j match {
      case x:StrokeCap /* TypeRef */ => StrokeCapCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderLabelPadding (UnionType)
object HeaderLabelPaddingCodec {
  def decode(j: JsValue): HeaderLabelPadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderLabelPadding] =
    j.asOpt[JsNumber].map { HeaderLabelPaddingAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderLabelPadding): JsValue =
    j match {
      case HeaderLabelPaddingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfWindowTransformFrameElement (ArrayType)
object ArrayOfWindowTransformFrameElementCodec {
  def decode(j: JsValue): Seq[WindowTransformFrameElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[WindowTransformFrameElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      WindowTransformFrameElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[WindowTransformFrameElement]): JsArray =
      JsArray(j.map { x => WindowTransformFrameElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// ErrorBandDefColor (UnionType)
object ErrorBandDefColorCodec {
  def decode(j: JsValue): ErrorBandDefColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ErrorBandDefColor] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: ErrorBandDefColor): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigFontSize (UnionType)
object TickConfigFontSizeCodec {
  def decode(j: JsValue): TickConfigFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigFontSize] =
    TickConfigFontSizeAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigFontSize): JsValue =
    j match {
      case x:TickConfigFontSizeAsNumber /* TypeRef */ => TickConfigFontSizeAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewBackgroundStyle (UnionType)
object ViewBackgroundStyleCodec {
  def decode(j: JsValue): ViewBackgroundStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewBackgroundStyle] =
    j.asOpt[String].map { ViewBackgroundStyleAsString(_) }.orElse {
    ArrayOfStringCodec.decodeOpt(j).map { ViewBackgroundStyleAsArrayOfString(_) } } 
  def encode(j: ViewBackgroundStyle): JsValue =
    j match {
      case ViewBackgroundStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case ViewBackgroundStyleAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigDir (UnionType)
object RectConfigDirCodec {
  def decode(j: JsValue): RectConfigDir =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigDir] =
    TextDirectionCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigDir): JsValue =
    j match {
      case x:TextDirection /* TypeRef */ => TextDirectionCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigRadius (ConstrainedType)
// see TickConfigRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// AxisConfigLabelOffset (UnionType)
object AxisConfigLabelOffsetCodec {
  def decode(j: JsValue): AxisConfigLabelOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigLabelOffset] =
    j.asOpt[JsNumber].map { AxisConfigLabelOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigLabelOffset): JsValue =
    j match {
      case AxisConfigLabelOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTickBand (UnionType)
object AxisTickBandCodec {
  def decode(j: JsValue): AxisTickBand =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTickBand] =
    AxisTickBandAsStringCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisTickBand): JsValue =
    j match {
      case x:AxisTickBandAsString /* TypeRef */ => AxisTickBandAsStringCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject2Autosize (UnionType)
object TopLevelRepeatSpecAsObject2AutosizeCodec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject2Autosize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject2Autosize] =
    AutosizeTypeCodec.decodeOpt(j).orElse {
    AutoSizeParamsCodec.decodeOpt(j) } 
  def encode(j: TopLevelRepeatSpecAsObject2Autosize): JsValue =
    j match {
      case x:AutosizeType /* TypeRef */ => AutosizeTypeCodec.encode(x)
      case x:AutoSizeParams /* TypeRef */ => AutoSizeParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderLabelAngle (ConstrainedType)
object HeaderLabelAngleCodec {
  def decode(j: JsValue): HeaderLabelAngle =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[HeaderLabelAngle] =
    try {
      j.asOpt[JsNumber]
        .map { HeaderLabelAngle(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: HeaderLabelAngle): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefX (UnionType)
object OverlayMarkDefXCodec {
  def decode(j: JsValue): OverlayMarkDefX =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefX] =
    j.asOpt[JsNumber].map { OverlayMarkDefXAsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: OverlayMarkDefX): JsValue =
    j match {
      case OverlayMarkDefXAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ErrorBarExtent (EnumType)
object ErrorBarExtentCodec {
  def decode(j: JsValue): ErrorBarExtent =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ErrorBarExtent] =
    j match {
      case JsString("ci") => Some(ErrorBarExtentCi)
      case JsString("iqr") => Some(ErrorBarExtentIqr)
      case JsString("stderr") => Some(ErrorBarExtentStderr)
      case JsString("stdev") => Some(ErrorBarExtentStdev)
      case _ => None
    }
  def encode(j: ErrorBarExtent): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingYError2 (StructType)
object SharedEncodingYError2Codec {
  def decode(j: JsValue): SharedEncodingYError2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingYError2] =
    Some(SharedEncodingYError2(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingYError2BandPositionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => x.asOpt[JsNull.type].map { _ => JsNull } },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingYError2TimeUnitCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingYError2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingYError2BandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> Json.toJson(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`value`.map { x => "value" -> Json.toJson(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingYError2TimeUnitCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingUrlValue (UnionType)
object SharedEncodingUrlValueCodec {
  def decode(j: JsValue): SharedEncodingUrlValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingUrlValue] =
    j.asOpt[String].map { SharedEncodingUrlValueAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingUrlValueAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: SharedEncodingUrlValue): JsValue =
    j match {
      case SharedEncodingUrlValueAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case SharedEncodingUrlValueAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigDomainDashOffset (UnionType)
object AxisConfigDomainDashOffsetCodec {
  def decode(j: JsValue): AxisConfigDomainDashOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigDomainDashOffset] =
    j.asOpt[JsNumber].map { AxisConfigDomainDashOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigDomainDashOffset): JsValue =
    j match {
      case AxisConfigDomainDashOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScalePadding (ConstrainedType)
// see ScalePadding (UnionType)

////////////////////////////////////////////////////////////////////////
// Fit (UnionType)
object FitCodec {
  def decode(j: JsValue): Fit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Fit] =
    j.asOpt[JsValue].map { FitAsAny(_) }.orElse {
    ArrayOfAnyCodec.decodeOpt(j).map { FitAsArrayOfAny(_) } } 
  def encode(j: Fit): JsValue =
    j match {
      case FitAsAny(x) /* Base, AnyType$ */ => Json.toJson(x)
      case FitAsArrayOfAny(x) /* Base, ArrayType */ => ArrayOfAnyCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BinParamsSteps (ConstrainedType)
object BinParamsStepsCodec {
  def decode(j: JsValue): BinParamsSteps =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BinParamsSteps] =
    try {
      ArrayOfNumberCodec.decodeOpt(j)
        .map { BinParamsSteps(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: BinParamsSteps): JsValue =
    ArrayOfNumberCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// TitleConfigOrient (UnionType)
object TitleConfigOrientCodec {
  def decode(j: JsValue): TitleConfigOrient =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigOrient] =
    TitleOrientCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleConfigOrient): JsValue =
    j match {
      case x:TitleOrient /* TypeRef */ => TitleOrientCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsLimit (UnionType)
object TitleParamsLimitCodec {
  def decode(j: JsValue): TitleParamsLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsLimit] =
    TitleParamsLimitAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleParamsLimit): JsValue =
    j match {
      case x:TitleParamsLimitAsNumber /* TypeRef */ => TitleParamsLimitAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfRangeRawElement (ArrayType)
object ArrayOfRangeRawElementCodec {
  def decode(j: JsValue): Seq[RangeRawElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[RangeRawElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      RangeRawElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[RangeRawElement]): JsArray =
      JsArray(j.map { x => RangeRawElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// MarkDefAngleAsNumber (ConstrainedType)
object MarkDefAngleAsNumberCodec {
  def decode(j: JsValue): MarkDefAngleAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[MarkDefAngleAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { MarkDefAngleAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: MarkDefAngleAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AxisTitleColor (UnionType)
object AxisTitleColorCodec {
  def decode(j: JsValue): AxisTitleColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTitleColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => AxisTitleColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: AxisTitleColor): JsValue =
    j match {
      case AxisTitleColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OrderValueDef (StructType)
object OrderValueDefCodec {
  def decode(j: JsValue): OrderValueDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[OrderValueDef] =
    {
      val `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => OrderValueDefConditionCodec.decodeOpt(x) }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => OrderValueDefValueCodec.decodeOpt(x) }
      if(`value`.isEmpty) { return None }
      return Some(OrderValueDef(
        `condition` = `condition`,
        `value` = `value`.get,
      ))
    }

  def encode(j: OrderValueDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`condition`.map { x => "condition" -> OrderValueDefConditionCodec.encode(x) },
        Some("value" -> OrderValueDefValueCodec.encode(j.`value`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AxisLabelOffset (UnionType)
object AxisLabelOffsetCodec {
  def decode(j: JsValue): AxisLabelOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisLabelOffset] =
    j.asOpt[JsNumber].map { AxisLabelOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisLabelOffset): JsValue =
    j match {
      case AxisLabelOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigLabelFont (UnionType)
object AxisConfigLabelFontCodec {
  def decode(j: JsValue): AxisConfigLabelFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigLabelFont] =
    j.asOpt[String].map { AxisConfigLabelFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisStringCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigLabelFont): JsValue =
    j match {
      case AxisConfigLabelFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisString /* TypeRef */ => ConditionalAxisStringCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// StringFieldDefBandPosition (ConstrainedType)
object StringFieldDefBandPositionCodec {
  def decode(j: JsValue): StringFieldDefBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[StringFieldDefBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { StringFieldDefBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: StringFieldDefBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// BarConfigPadAngle (UnionType)
object BarConfigPadAngleCodec {
  def decode(j: JsValue): BarConfigPadAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigPadAngle] =
    j.asOpt[JsNumber].map { BarConfigPadAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigPadAngle): JsValue =
    j match {
      case BarConfigPadAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefAngleAsNumber (ConstrainedType)
object OverlayMarkDefAngleAsNumberCodec {
  def decode(j: JsValue): OverlayMarkDefAngleAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[OverlayMarkDefAngleAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { OverlayMarkDefAngleAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: OverlayMarkDefAngleAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// BinParamsMaxbins (ConstrainedType)
object BinParamsMaxbinsCodec {
  def decode(j: JsValue): BinParamsMaxbins =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BinParamsMaxbins] =
    try {
      j.asOpt[JsNumber]
        .map { BinParamsMaxbins(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: BinParamsMaxbins): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingThetaBandPosition (ConstrainedType)
object SharedEncodingThetaBandPositionCodec {
  def decode(j: JsValue): SharedEncodingThetaBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingThetaBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingThetaBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingThetaBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingAngle (StructType)
object SharedEncodingAngleCodec {
  def decode(j: JsValue): SharedEncodingAngle =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingAngle] =
    Some(SharedEncodingAngle(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingAngleDatumCodec.decodeOpt(x) },
      `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingAngleBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => SharedEncodingAngleConditionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingAngleBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingAngleValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingAngleTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => SharedEncodingAngleTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingAngle): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingAngleDatumCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingAngleBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> SharedEncodingAngleConditionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingAngleBinCodec.encode(x) },
        j.`value`.map { x => "value" -> SharedEncodingAngleValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingAngleTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> SharedEncodingAngleTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// MarkConfigY2 (UnionType)
object MarkConfigY2Codec {
  def decode(j: JsValue): MarkConfigY2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigY2] =
    j.asOpt[JsNumber].map { MarkConfigY2AsNumber(_) }.orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: MarkConfigY2): JsValue =
    j match {
      case MarkConfigY2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigPadAngle (UnionType)
object RectConfigPadAngleCodec {
  def decode(j: JsValue): RectConfigPadAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigPadAngle] =
    j.asOpt[JsNumber].map { RectConfigPadAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigPadAngle): JsValue =
    j match {
      case RectConfigPadAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterMarkPropFieldOrDatumDefTypeForShape (UnionType)
object ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeCodec {
  def decode(j: JsValue): ConditionalParameterMarkPropFieldOrDatumDefTypeForShape =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalParameterMarkPropFieldOrDatumDefTypeForShape] =
    ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1Codec.decodeOpt(j).orElse {
    ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2Codec.decodeOpt(j) } 
  def encode(j: ConditionalParameterMarkPropFieldOrDatumDefTypeForShape): JsValue =
    j match {
      case x:ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1 /* TypeRef */ => ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1Codec.encode(x)
      case x:ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2 /* TypeRef */ => ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigCornerRadiusTopLeft (UnionType)
object TickConfigCornerRadiusTopLeftCodec {
  def decode(j: JsValue): TickConfigCornerRadiusTopLeft =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigCornerRadiusTopLeft] =
    j.asOpt[JsNumber].map { TickConfigCornerRadiusTopLeftAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigCornerRadiusTopLeft): JsValue =
    j match {
      case TickConfigCornerRadiusTopLeftAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HConcatSpecGenericSpecTitle (UnionType)
object HConcatSpecGenericSpecTitleCodec {
  def decode(j: JsValue): HConcatSpecGenericSpecTitle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HConcatSpecGenericSpecTitle] =
    TextCodec.decodeOpt(j).orElse {
    TitleParamsCodec.decodeOpt(j) } 
  def encode(j: HConcatSpecGenericSpecTitle): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:TitleParams /* TypeRef */ => TitleParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetEncodingFieldDefBin (UnionType)
object FacetEncodingFieldDefBinCodec {
  def decode(j: JsValue): FacetEncodingFieldDefBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetEncodingFieldDefBin] =
    j.asOpt[Boolean].map { FacetEncodingFieldDefBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => FacetEncodingFieldDefBinAsNull } } } 
  def encode(j: FacetEncodingFieldDefBin): JsValue =
    j match {
      case FacetEncodingFieldDefBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case FacetEncodingFieldDefBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderConfigTitleBaseline (UnionType)
object HeaderConfigTitleBaselineCodec {
  def decode(j: JsValue): HeaderConfigTitleBaseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigTitleBaseline] =
    TextBaselineCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderConfigTitleBaseline): JsValue =
    j match {
      case x:TextBaseline /* TypeRef */ => TextBaselineCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigFontSize (UnionType)
object BarConfigFontSizeCodec {
  def decode(j: JsValue): BarConfigFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigFontSize] =
    BarConfigFontSizeAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigFontSize): JsValue =
    j match {
      case x:BarConfigFontSizeAsNumber /* TypeRef */ => BarConfigFontSizeAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingTooltip (UnionType)
object SharedEncodingTooltipCodec {
  def decode(j: JsValue): SharedEncodingTooltip =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingTooltip] =
    StringFieldDefWithConditionCodec.decodeOpt(j).orElse {
    StringValueDefWithConditionCodec.decodeOpt(j).orElse {
    ArrayOfStringFieldDefCodec.decodeOpt(j).map { SharedEncodingTooltipAsArrayOfStringFieldDef(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingTooltipAsNull } } } } 
  def encode(j: SharedEncodingTooltip): JsValue =
    j match {
      case x:StringFieldDefWithCondition /* TypeRef */ => StringFieldDefWithConditionCodec.encode(x)
      case x:StringValueDefWithCondition /* TypeRef */ => StringValueDefWithConditionCodec.encode(x)
      case SharedEncodingTooltipAsArrayOfStringFieldDef(x) /* Base, ArrayType */ => ArrayOfStringFieldDefCodec.encode(x)
      case SharedEncodingTooltipAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// WindowEventType (UnionType)
object WindowEventTypeCodec {
  def decode(j: JsValue): WindowEventType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[WindowEventType] =
    EventTypeCodec.decodeOpt(j).orElse {
    j.asOpt[String].map { WindowEventTypeAsString(_) } } 
  def encode(j: WindowEventType): JsValue =
    j match {
      case x:EventType /* TypeRef */ => EventTypeCodec.encode(x)
      case WindowEventTypeAsString(x) /* Base, StringType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldRangePredicateRange (UnionType)
object FieldRangePredicateRangeCodec {
  def decode(j: JsValue): FieldRangePredicateRange =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldRangePredicateRange] =
    ArrayOfFieldRangePredicateRangeAsArrayElementCodec.decodeOpt(j).map { FieldRangePredicateRangeAsArrayOfFieldRangePredicateRangeAsArrayElement(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: FieldRangePredicateRange): JsValue =
    j match {
      case FieldRangePredicateRangeAsArrayOfFieldRangePredicateRangeAsArrayElement(x) /* Base, ArrayType */ => ArrayOfFieldRangePredicateRangeAsArrayElementCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigOrder (UnionType)
object RectConfigOrderCodec {
  def decode(j: JsValue): RectConfigOrder =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigOrder] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => RectConfigOrderAsNull }.orElse {
    j.asOpt[Boolean].map { RectConfigOrderAsBool(_) } } 
  def encode(j: RectConfigOrder): JsValue =
    j match {
      case RectConfigOrderAsNull /* Global, NullType$ */ => JsNull
      case RectConfigOrderAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderTitleFont (UnionType)
object HeaderTitleFontCodec {
  def decode(j: JsValue): HeaderTitleFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderTitleFont] =
    j.asOpt[String].map { HeaderTitleFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderTitleFont): JsValue =
    j match {
      case HeaderTitleFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingShapeCondition (UnionType)
object SharedEncodingShapeConditionCodec {
  def decode(j: JsValue): SharedEncodingShapeCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingShapeCondition] =
    ConditionalValueDefStringNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefStringNullExprRefCodec.decodeOpt(j).map { SharedEncodingShapeConditionAsArrayOfConditionalValueDefStringNullExprRef(_) }.orElse {
    ConditionalMarkPropFieldOrDatumDefTypeForShapeCodec.decodeOpt(j) } } 
  def encode(j: SharedEncodingShapeCondition): JsValue =
    j match {
      case x:ConditionalValueDefStringNullExprRef /* TypeRef */ => ConditionalValueDefStringNullExprRefCodec.encode(x)
      case SharedEncodingShapeConditionAsArrayOfConditionalValueDefStringNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefStringNullExprRefCodec.encode(x)
      case x:ConditionalMarkPropFieldOrDatumDefTypeForShape /* TypeRef */ => ConditionalMarkPropFieldOrDatumDefTypeForShapeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigGridDash (UnionType)
object AxisConfigGridDashCodec {
  def decode(j: JsValue): AxisConfigGridDash =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigGridDash] =
    ArrayOfNumberCodec.decodeOpt(j).map { AxisConfigGridDashAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberArrayCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigGridDash): JsValue =
    j match {
      case AxisConfigGridDashAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumberArray /* TypeRef */ => ConditionalAxisNumberArrayCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// DictOfParseValue (MapType)
object DictOfParseValueCodec {
  def decode(j: JsValue): Map[String,ParseValue] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Map[String,ParseValue]] =
    j.asOpt[Map[String,JsValue]].map { _.mapValues { x => 
      ParseValueCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Map[String,ParseValue]): JsObject =
      JsObject(j.mapValues { x => ParseValueCodec.encode(x) })
}


////////////////////////////////////////////////////////////////////////
// AxisGridWidth (UnionType)
object AxisGridWidthCodec {
  def decode(j: JsValue): AxisGridWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisGridWidth] =
    AxisGridWidthAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisGridWidth): JsValue =
    j match {
      case x:AxisGridWidthAsNumber /* TypeRef */ => AxisGridWidthAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsSubtitleFontSize (UnionType)
object TitleParamsSubtitleFontSizeCodec {
  def decode(j: JsValue): TitleParamsSubtitleFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsSubtitleFontSize] =
    TitleParamsSubtitleFontSizeAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleParamsSubtitleFontSize): JsValue =
    j match {
      case x:TitleParamsSubtitleFontSizeAsNumber /* TypeRef */ => TitleParamsSubtitleFontSizeAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigLineBreak (UnionType)
object MarkConfigLineBreakCodec {
  def decode(j: JsValue): MarkConfigLineBreak =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigLineBreak] =
    j.asOpt[String].map { MarkConfigLineBreakAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigLineBreak): JsValue =
    j match {
      case MarkConfigLineBreakAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BoxPlotConfigTicks (UnionType)
object BoxPlotConfigTicksCodec {
  def decode(j: JsValue): BoxPlotConfigTicks =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BoxPlotConfigTicks] =
    j.asOpt[Boolean].map { BoxPlotConfigTicksAsBool(_) }.orElse {
    MarkConfigCodec.decodeOpt(j) } 
  def encode(j: BoxPlotConfigTicks): JsValue =
    j match {
      case BoxPlotConfigTicksAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:MarkConfig /* TypeRef */ => MarkConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingTextCondition (UnionType)
object SharedEncodingTextConditionCodec {
  def decode(j: JsValue): SharedEncodingTextCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingTextCondition] =
    ConditionalValueDefTextExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefTextExprRefCodec.decodeOpt(j).map { SharedEncodingTextConditionAsArrayOfConditionalValueDefTextExprRef(_) }.orElse {
    ConditionalStringFieldDefCodec.decodeOpt(j) } } 
  def encode(j: SharedEncodingTextCondition): JsValue =
    j match {
      case x:ConditionalValueDefTextExprRef /* TypeRef */ => ConditionalValueDefTextExprRefCodec.encode(x)
      case SharedEncodingTextConditionAsArrayOfConditionalValueDefTextExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefTextExprRefCodec.encode(x)
      case x:ConditionalStringFieldDef /* TypeRef */ => ConditionalStringFieldDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleInterpolateParams (StructType)
object ScaleInterpolateParamsCodec {
  def decode(j: JsValue): ScaleInterpolateParams =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ScaleInterpolateParams] =
    {
      val `gamma` = (j \ "gamma").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `type` = (j \ "type").asOpt[JsValue].flatMap { x => ScaleInterpolateParamsTypeCodec.decodeOpt(x) }
      if(`type`.isEmpty) { return None }
      return Some(ScaleInterpolateParams(
        `gamma` = `gamma`,
        `type` = `type`.get,
      ))
    }

  def encode(j: ScaleInterpolateParams): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`gamma`.map { x => "gamma" -> Json.toJson(x) },
        Some("type" -> ScaleInterpolateParamsTypeCodec.encode(j.`type`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// RectConfigText (UnionType)
object RectConfigTextCodec {
  def decode(j: JsValue): RectConfigText =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigText] =
    TextCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigText): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SequentialMultiHue (EnumType)
object SequentialMultiHueCodec {
  def decode(j: JsValue): SequentialMultiHue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SequentialMultiHue] =
    j match {
      case JsString("turbo") => Some(SequentialMultiHueTurbo)
      case JsString("viridis") => Some(SequentialMultiHueViridis)
      case JsString("inferno") => Some(SequentialMultiHueInferno)
      case JsString("magma") => Some(SequentialMultiHueMagma)
      case JsString("plasma") => Some(SequentialMultiHuePlasma)
      case JsString("cividis") => Some(SequentialMultiHueCividis)
      case JsString("bluegreen") => Some(SequentialMultiHueBluegreen)
      case JsString("bluegreen-3") => Some(SequentialMultiHueBluegreen3)
      case JsString("bluegreen-4") => Some(SequentialMultiHueBluegreen4)
      case JsString("bluegreen-5") => Some(SequentialMultiHueBluegreen5)
      case JsString("bluegreen-6") => Some(SequentialMultiHueBluegreen6)
      case JsString("bluegreen-7") => Some(SequentialMultiHueBluegreen7)
      case JsString("bluegreen-8") => Some(SequentialMultiHueBluegreen8)
      case JsString("bluegreen-9") => Some(SequentialMultiHueBluegreen9)
      case JsString("bluepurple") => Some(SequentialMultiHueBluepurple)
      case JsString("bluepurple-3") => Some(SequentialMultiHueBluepurple3)
      case JsString("bluepurple-4") => Some(SequentialMultiHueBluepurple4)
      case JsString("bluepurple-5") => Some(SequentialMultiHueBluepurple5)
      case JsString("bluepurple-6") => Some(SequentialMultiHueBluepurple6)
      case JsString("bluepurple-7") => Some(SequentialMultiHueBluepurple7)
      case JsString("bluepurple-8") => Some(SequentialMultiHueBluepurple8)
      case JsString("bluepurple-9") => Some(SequentialMultiHueBluepurple9)
      case JsString("goldgreen") => Some(SequentialMultiHueGoldgreen)
      case JsString("goldgreen-3") => Some(SequentialMultiHueGoldgreen3)
      case JsString("goldgreen-4") => Some(SequentialMultiHueGoldgreen4)
      case JsString("goldgreen-5") => Some(SequentialMultiHueGoldgreen5)
      case JsString("goldgreen-6") => Some(SequentialMultiHueGoldgreen6)
      case JsString("goldgreen-7") => Some(SequentialMultiHueGoldgreen7)
      case JsString("goldgreen-8") => Some(SequentialMultiHueGoldgreen8)
      case JsString("goldgreen-9") => Some(SequentialMultiHueGoldgreen9)
      case JsString("goldorange") => Some(SequentialMultiHueGoldorange)
      case JsString("goldorange-3") => Some(SequentialMultiHueGoldorange3)
      case JsString("goldorange-4") => Some(SequentialMultiHueGoldorange4)
      case JsString("goldorange-5") => Some(SequentialMultiHueGoldorange5)
      case JsString("goldorange-6") => Some(SequentialMultiHueGoldorange6)
      case JsString("goldorange-7") => Some(SequentialMultiHueGoldorange7)
      case JsString("goldorange-8") => Some(SequentialMultiHueGoldorange8)
      case JsString("goldorange-9") => Some(SequentialMultiHueGoldorange9)
      case JsString("goldred") => Some(SequentialMultiHueGoldred)
      case JsString("goldred-3") => Some(SequentialMultiHueGoldred3)
      case JsString("goldred-4") => Some(SequentialMultiHueGoldred4)
      case JsString("goldred-5") => Some(SequentialMultiHueGoldred5)
      case JsString("goldred-6") => Some(SequentialMultiHueGoldred6)
      case JsString("goldred-7") => Some(SequentialMultiHueGoldred7)
      case JsString("goldred-8") => Some(SequentialMultiHueGoldred8)
      case JsString("goldred-9") => Some(SequentialMultiHueGoldred9)
      case JsString("greenblue") => Some(SequentialMultiHueGreenblue)
      case JsString("greenblue-3") => Some(SequentialMultiHueGreenblue3)
      case JsString("greenblue-4") => Some(SequentialMultiHueGreenblue4)
      case JsString("greenblue-5") => Some(SequentialMultiHueGreenblue5)
      case JsString("greenblue-6") => Some(SequentialMultiHueGreenblue6)
      case JsString("greenblue-7") => Some(SequentialMultiHueGreenblue7)
      case JsString("greenblue-8") => Some(SequentialMultiHueGreenblue8)
      case JsString("greenblue-9") => Some(SequentialMultiHueGreenblue9)
      case JsString("orangered") => Some(SequentialMultiHueOrangered)
      case JsString("orangered-3") => Some(SequentialMultiHueOrangered3)
      case JsString("orangered-4") => Some(SequentialMultiHueOrangered4)
      case JsString("orangered-5") => Some(SequentialMultiHueOrangered5)
      case JsString("orangered-6") => Some(SequentialMultiHueOrangered6)
      case JsString("orangered-7") => Some(SequentialMultiHueOrangered7)
      case JsString("orangered-8") => Some(SequentialMultiHueOrangered8)
      case JsString("orangered-9") => Some(SequentialMultiHueOrangered9)
      case JsString("purplebluegreen") => Some(SequentialMultiHuePurplebluegreen)
      case JsString("purplebluegreen-3") => Some(SequentialMultiHuePurplebluegreen3)
      case JsString("purplebluegreen-4") => Some(SequentialMultiHuePurplebluegreen4)
      case JsString("purplebluegreen-5") => Some(SequentialMultiHuePurplebluegreen5)
      case JsString("purplebluegreen-6") => Some(SequentialMultiHuePurplebluegreen6)
      case JsString("purplebluegreen-7") => Some(SequentialMultiHuePurplebluegreen7)
      case JsString("purplebluegreen-8") => Some(SequentialMultiHuePurplebluegreen8)
      case JsString("purplebluegreen-9") => Some(SequentialMultiHuePurplebluegreen9)
      case JsString("purpleblue") => Some(SequentialMultiHuePurpleblue)
      case JsString("purpleblue-3") => Some(SequentialMultiHuePurpleblue3)
      case JsString("purpleblue-4") => Some(SequentialMultiHuePurpleblue4)
      case JsString("purpleblue-5") => Some(SequentialMultiHuePurpleblue5)
      case JsString("purpleblue-6") => Some(SequentialMultiHuePurpleblue6)
      case JsString("purpleblue-7") => Some(SequentialMultiHuePurpleblue7)
      case JsString("purpleblue-8") => Some(SequentialMultiHuePurpleblue8)
      case JsString("purpleblue-9") => Some(SequentialMultiHuePurpleblue9)
      case JsString("purplered") => Some(SequentialMultiHuePurplered)
      case JsString("purplered-3") => Some(SequentialMultiHuePurplered3)
      case JsString("purplered-4") => Some(SequentialMultiHuePurplered4)
      case JsString("purplered-5") => Some(SequentialMultiHuePurplered5)
      case JsString("purplered-6") => Some(SequentialMultiHuePurplered6)
      case JsString("purplered-7") => Some(SequentialMultiHuePurplered7)
      case JsString("purplered-8") => Some(SequentialMultiHuePurplered8)
      case JsString("purplered-9") => Some(SequentialMultiHuePurplered9)
      case JsString("redpurple") => Some(SequentialMultiHueRedpurple)
      case JsString("redpurple-3") => Some(SequentialMultiHueRedpurple3)
      case JsString("redpurple-4") => Some(SequentialMultiHueRedpurple4)
      case JsString("redpurple-5") => Some(SequentialMultiHueRedpurple5)
      case JsString("redpurple-6") => Some(SequentialMultiHueRedpurple6)
      case JsString("redpurple-7") => Some(SequentialMultiHueRedpurple7)
      case JsString("redpurple-8") => Some(SequentialMultiHueRedpurple8)
      case JsString("redpurple-9") => Some(SequentialMultiHueRedpurple9)
      case JsString("yellowgreenblue") => Some(SequentialMultiHueYellowgreenblue)
      case JsString("yellowgreenblue-3") => Some(SequentialMultiHueYellowgreenblue3)
      case JsString("yellowgreenblue-4") => Some(SequentialMultiHueYellowgreenblue4)
      case JsString("yellowgreenblue-5") => Some(SequentialMultiHueYellowgreenblue5)
      case JsString("yellowgreenblue-6") => Some(SequentialMultiHueYellowgreenblue6)
      case JsString("yellowgreenblue-7") => Some(SequentialMultiHueYellowgreenblue7)
      case JsString("yellowgreenblue-8") => Some(SequentialMultiHueYellowgreenblue8)
      case JsString("yellowgreenblue-9") => Some(SequentialMultiHueYellowgreenblue9)
      case JsString("yellowgreen") => Some(SequentialMultiHueYellowgreen)
      case JsString("yellowgreen-3") => Some(SequentialMultiHueYellowgreen3)
      case JsString("yellowgreen-4") => Some(SequentialMultiHueYellowgreen4)
      case JsString("yellowgreen-5") => Some(SequentialMultiHueYellowgreen5)
      case JsString("yellowgreen-6") => Some(SequentialMultiHueYellowgreen6)
      case JsString("yellowgreen-7") => Some(SequentialMultiHueYellowgreen7)
      case JsString("yellowgreen-8") => Some(SequentialMultiHueYellowgreen8)
      case JsString("yellowgreen-9") => Some(SequentialMultiHueYellowgreen9)
      case JsString("yelloworangebrown") => Some(SequentialMultiHueYelloworangebrown)
      case JsString("yelloworangebrown-3") => Some(SequentialMultiHueYelloworangebrown3)
      case JsString("yelloworangebrown-4") => Some(SequentialMultiHueYelloworangebrown4)
      case JsString("yelloworangebrown-5") => Some(SequentialMultiHueYelloworangebrown5)
      case JsString("yelloworangebrown-6") => Some(SequentialMultiHueYelloworangebrown6)
      case JsString("yelloworangebrown-7") => Some(SequentialMultiHueYelloworangebrown7)
      case JsString("yelloworangebrown-8") => Some(SequentialMultiHueYelloworangebrown8)
      case JsString("yelloworangebrown-9") => Some(SequentialMultiHueYelloworangebrown9)
      case JsString("yelloworangered") => Some(SequentialMultiHueYelloworangered)
      case JsString("yelloworangered-3") => Some(SequentialMultiHueYelloworangered3)
      case JsString("yelloworangered-4") => Some(SequentialMultiHueYelloworangered4)
      case JsString("yelloworangered-5") => Some(SequentialMultiHueYelloworangered5)
      case JsString("yelloworangered-6") => Some(SequentialMultiHueYelloworangered6)
      case JsString("yelloworangered-7") => Some(SequentialMultiHueYelloworangered7)
      case JsString("yelloworangered-8") => Some(SequentialMultiHueYelloworangered8)
      case JsString("yelloworangered-9") => Some(SequentialMultiHueYelloworangered9)
      case JsString("darkblue") => Some(SequentialMultiHueDarkblue)
      case JsString("darkblue-3") => Some(SequentialMultiHueDarkblue3)
      case JsString("darkblue-4") => Some(SequentialMultiHueDarkblue4)
      case JsString("darkblue-5") => Some(SequentialMultiHueDarkblue5)
      case JsString("darkblue-6") => Some(SequentialMultiHueDarkblue6)
      case JsString("darkblue-7") => Some(SequentialMultiHueDarkblue7)
      case JsString("darkblue-8") => Some(SequentialMultiHueDarkblue8)
      case JsString("darkblue-9") => Some(SequentialMultiHueDarkblue9)
      case JsString("darkgold") => Some(SequentialMultiHueDarkgold)
      case JsString("darkgold-3") => Some(SequentialMultiHueDarkgold3)
      case JsString("darkgold-4") => Some(SequentialMultiHueDarkgold4)
      case JsString("darkgold-5") => Some(SequentialMultiHueDarkgold5)
      case JsString("darkgold-6") => Some(SequentialMultiHueDarkgold6)
      case JsString("darkgold-7") => Some(SequentialMultiHueDarkgold7)
      case JsString("darkgold-8") => Some(SequentialMultiHueDarkgold8)
      case JsString("darkgold-9") => Some(SequentialMultiHueDarkgold9)
      case JsString("darkgreen") => Some(SequentialMultiHueDarkgreen)
      case JsString("darkgreen-3") => Some(SequentialMultiHueDarkgreen3)
      case JsString("darkgreen-4") => Some(SequentialMultiHueDarkgreen4)
      case JsString("darkgreen-5") => Some(SequentialMultiHueDarkgreen5)
      case JsString("darkgreen-6") => Some(SequentialMultiHueDarkgreen6)
      case JsString("darkgreen-7") => Some(SequentialMultiHueDarkgreen7)
      case JsString("darkgreen-8") => Some(SequentialMultiHueDarkgreen8)
      case JsString("darkgreen-9") => Some(SequentialMultiHueDarkgreen9)
      case JsString("darkmulti") => Some(SequentialMultiHueDarkmulti)
      case JsString("darkmulti-3") => Some(SequentialMultiHueDarkmulti3)
      case JsString("darkmulti-4") => Some(SequentialMultiHueDarkmulti4)
      case JsString("darkmulti-5") => Some(SequentialMultiHueDarkmulti5)
      case JsString("darkmulti-6") => Some(SequentialMultiHueDarkmulti6)
      case JsString("darkmulti-7") => Some(SequentialMultiHueDarkmulti7)
      case JsString("darkmulti-8") => Some(SequentialMultiHueDarkmulti8)
      case JsString("darkmulti-9") => Some(SequentialMultiHueDarkmulti9)
      case JsString("darkred") => Some(SequentialMultiHueDarkred)
      case JsString("darkred-3") => Some(SequentialMultiHueDarkred3)
      case JsString("darkred-4") => Some(SequentialMultiHueDarkred4)
      case JsString("darkred-5") => Some(SequentialMultiHueDarkred5)
      case JsString("darkred-6") => Some(SequentialMultiHueDarkred6)
      case JsString("darkred-7") => Some(SequentialMultiHueDarkred7)
      case JsString("darkred-8") => Some(SequentialMultiHueDarkred8)
      case JsString("darkred-9") => Some(SequentialMultiHueDarkred9)
      case JsString("lightgreyred") => Some(SequentialMultiHueLightgreyred)
      case JsString("lightgreyred-3") => Some(SequentialMultiHueLightgreyred3)
      case JsString("lightgreyred-4") => Some(SequentialMultiHueLightgreyred4)
      case JsString("lightgreyred-5") => Some(SequentialMultiHueLightgreyred5)
      case JsString("lightgreyred-6") => Some(SequentialMultiHueLightgreyred6)
      case JsString("lightgreyred-7") => Some(SequentialMultiHueLightgreyred7)
      case JsString("lightgreyred-8") => Some(SequentialMultiHueLightgreyred8)
      case JsString("lightgreyred-9") => Some(SequentialMultiHueLightgreyred9)
      case JsString("lightgreyteal") => Some(SequentialMultiHueLightgreyteal)
      case JsString("lightgreyteal-3") => Some(SequentialMultiHueLightgreyteal3)
      case JsString("lightgreyteal-4") => Some(SequentialMultiHueLightgreyteal4)
      case JsString("lightgreyteal-5") => Some(SequentialMultiHueLightgreyteal5)
      case JsString("lightgreyteal-6") => Some(SequentialMultiHueLightgreyteal6)
      case JsString("lightgreyteal-7") => Some(SequentialMultiHueLightgreyteal7)
      case JsString("lightgreyteal-8") => Some(SequentialMultiHueLightgreyteal8)
      case JsString("lightgreyteal-9") => Some(SequentialMultiHueLightgreyteal9)
      case JsString("lightmulti") => Some(SequentialMultiHueLightmulti)
      case JsString("lightmulti-3") => Some(SequentialMultiHueLightmulti3)
      case JsString("lightmulti-4") => Some(SequentialMultiHueLightmulti4)
      case JsString("lightmulti-5") => Some(SequentialMultiHueLightmulti5)
      case JsString("lightmulti-6") => Some(SequentialMultiHueLightmulti6)
      case JsString("lightmulti-7") => Some(SequentialMultiHueLightmulti7)
      case JsString("lightmulti-8") => Some(SequentialMultiHueLightmulti8)
      case JsString("lightmulti-9") => Some(SequentialMultiHueLightmulti9)
      case JsString("lightorange") => Some(SequentialMultiHueLightorange)
      case JsString("lightorange-3") => Some(SequentialMultiHueLightorange3)
      case JsString("lightorange-4") => Some(SequentialMultiHueLightorange4)
      case JsString("lightorange-5") => Some(SequentialMultiHueLightorange5)
      case JsString("lightorange-6") => Some(SequentialMultiHueLightorange6)
      case JsString("lightorange-7") => Some(SequentialMultiHueLightorange7)
      case JsString("lightorange-8") => Some(SequentialMultiHueLightorange8)
      case JsString("lightorange-9") => Some(SequentialMultiHueLightorange9)
      case JsString("lighttealblue") => Some(SequentialMultiHueLighttealblue)
      case JsString("lighttealblue-3") => Some(SequentialMultiHueLighttealblue3)
      case JsString("lighttealblue-4") => Some(SequentialMultiHueLighttealblue4)
      case JsString("lighttealblue-5") => Some(SequentialMultiHueLighttealblue5)
      case JsString("lighttealblue-6") => Some(SequentialMultiHueLighttealblue6)
      case JsString("lighttealblue-7") => Some(SequentialMultiHueLighttealblue7)
      case JsString("lighttealblue-8") => Some(SequentialMultiHueLighttealblue8)
      case JsString("lighttealblue-9") => Some(SequentialMultiHueLighttealblue9)
      case _ => None
    }
  def encode(j: SequentialMultiHue): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// TickConfigStrokeOffset (UnionType)
object TickConfigStrokeOffsetCodec {
  def decode(j: JsValue): TickConfigStrokeOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigStrokeOffset] =
    j.asOpt[JsNumber].map { TickConfigStrokeOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigStrokeOffset): JsValue =
    j match {
      case TickConfigStrokeOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisColorAsObject1Condition (UnionType)
object ConditionalAxisColorAsObject1ConditionCodec {
  def decode(j: JsValue): ConditionalAxisColorAsObject1Condition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisColorAsObject1Condition] =
    ConditionalPredicateValueDefColorNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalPredicateValueDefColorNullExprRefCodec.decodeOpt(j).map { ConditionalAxisColorAsObject1ConditionAsArrayOfConditionalPredicateValueDefColorNullExprRef(_) } } 
  def encode(j: ConditionalAxisColorAsObject1Condition): JsValue =
    j match {
      case x:ConditionalPredicateValueDefColorNullExprRef /* TypeRef */ => ConditionalPredicateValueDefColorNullExprRefCodec.encode(x)
      case ConditionalAxisColorAsObject1ConditionAsArrayOfConditionalPredicateValueDefColorNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalPredicateValueDefColorNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeDashDatum (UnionType)
object SharedEncodingStrokeDashDatumCodec {
  def decode(j: JsValue): SharedEncodingStrokeDashDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeDashDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingStrokeDashDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsAria (UnionType)
object TitleParamsAriaCodec {
  def decode(j: JsValue): TitleParamsAria =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsAria] =
    j.asOpt[Boolean].map { TitleParamsAriaAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleParamsAria): JsValue =
    j match {
      case TitleParamsAriaAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TextBaseline (UnionType)
object TextBaselineCodec {
  def decode(j: JsValue): TextBaseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TextBaseline] =
    AlphabeticCodec.decodeOpt(j).orElse {
    BaselineCodec.decodeOpt(j).orElse {
    LineTopCodec.decodeOpt(j).orElse {
    LineBottomCodec.decodeOpt(j) } } } 
  def encode(j: TextBaseline): JsValue =
    j match {
      case x:Alphabetic /* TypeRef */ => AlphabeticCodec.encode(x)
      case x:Baseline /* TypeRef */ => BaselineCodec.encode(x)
      case x:LineTop /* TypeRef */ => LineTopCodec.encode(x)
      case x:LineBottom /* TypeRef */ => LineBottomCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SortOrder (EnumType)
object SortOrderCodec {
  def decode(j: JsValue): SortOrder =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SortOrder] =
    j match {
      case JsString("ascending") => Some(SortOrderAscending)
      case JsString("descending") => Some(SortOrderDescending)
      case _ => None
    }
  def encode(j: SortOrder): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// BarConfigAlign (UnionType)
object BarConfigAlignCodec {
  def decode(j: JsValue): BarConfigAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigAlign] =
    AlignCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigAlign): JsValue =
    j match {
      case x:Align /* TypeRef */ => AlignCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNull (StructType)
object ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullCodec {
  def decode(j: JsValue): ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNull =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNull] =
    Some(ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNull(
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullConditionCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullValueCodec.decodeOpt(x) },
    ))

  def encode(j: ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNull): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`condition`.map { x => "condition" -> ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullConditionCodec.encode(x) },
        j.`value`.map { x => "value" -> ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullValueCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LayerSpecLayerElement (UnionType)
object LayerSpecLayerElementCodec {
  def decode(j: JsValue): LayerSpecLayerElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LayerSpecLayerElement] =
    LayerSpecCodec.decodeOpt(j).orElse {
    UnitSpecCodec.decodeOpt(j) } 
  def encode(j: LayerSpecLayerElement): JsValue =
    j match {
      case x:LayerSpec /* TypeRef */ => LayerSpecCodec.encode(x)
      case x:UnitSpec /* TypeRef */ => UnitSpecCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigStrokeJoin (UnionType)
object AreaConfigStrokeJoinCodec {
  def decode(j: JsValue): AreaConfigStrokeJoin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigStrokeJoin] =
    StrokeJoinCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigStrokeJoin): JsValue =
    j match {
      case x:StrokeJoin /* TypeRef */ => StrokeJoinCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTickMinStep (UnionType)
object AxisTickMinStepCodec {
  def decode(j: JsValue): AxisTickMinStep =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTickMinStep] =
    j.asOpt[JsNumber].map { AxisTickMinStepAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisTickMinStep): JsValue =
    j match {
      case AxisTickMinStepAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTickDashOffset (UnionType)
object AxisConfigTickDashOffsetCodec {
  def decode(j: JsValue): AxisConfigTickDashOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTickDashOffset] =
    j.asOpt[JsNumber].map { AxisConfigTickDashOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigTickDashOffset): JsValue =
    j match {
      case AxisConfigTickDashOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelConcatSpecSpacing (UnionType)
object TopLevelConcatSpecSpacingCodec {
  def decode(j: JsValue): TopLevelConcatSpecSpacing =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelConcatSpecSpacing] =
    j.asOpt[JsNumber].map { TopLevelConcatSpecSpacingAsNumber(_) }.orElse {
    RowColNumberCodec.decodeOpt(j) } 
  def encode(j: TopLevelConcatSpecSpacing): JsValue =
    j match {
      case TopLevelConcatSpecSpacingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:RowColNumber /* TypeRef */ => RowColNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionMarkPropFieldDefNumberBandPosition (ConstrainedType)
object FieldOrDatumDefWithConditionMarkPropFieldDefNumberBandPositionCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionMarkPropFieldDefNumberBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionMarkPropFieldDefNumberBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { FieldOrDatumDefWithConditionMarkPropFieldDefNumberBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: FieldOrDatumDefWithConditionMarkPropFieldDefNumberBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ScaleDomainMid (UnionType)
object ScaleDomainMidCodec {
  def decode(j: JsValue): ScaleDomainMid =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleDomainMid] =
    j.asOpt[JsNumber].map { ScaleDomainMidAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleDomainMid): JsValue =
    j match {
      case ScaleDomainMidAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigSmooth (UnionType)
object TickConfigSmoothCodec {
  def decode(j: JsValue): TickConfigSmooth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigSmooth] =
    j.asOpt[Boolean].map { TickConfigSmoothAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigSmooth): JsValue =
    j match {
      case TickConfigSmoothAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderConfig (StructType)
object HeaderConfigCodec {
  def decode(j: JsValue): HeaderConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[HeaderConfig] =
    Some(HeaderConfig(
      `labelAngle` = (j \ "labelAngle").asOpt[JsValue].flatMap { x => HeaderConfigLabelAngleCodec.decodeOpt(x) },
      `labelColor` = (j \ "labelColor").asOpt[JsValue].flatMap { x => HeaderConfigLabelColorCodec.decodeOpt(x) },
      `labelFontWeight` = (j \ "labelFontWeight").asOpt[JsValue].flatMap { x => HeaderConfigLabelFontWeightCodec.decodeOpt(x) },
      `titlePadding` = (j \ "titlePadding").asOpt[JsValue].flatMap { x => HeaderConfigTitlePaddingCodec.decodeOpt(x) },
      `labels` = (j \ "labels").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `labelExpr` = (j \ "labelExpr").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => x.asOpt[JsNull.type].map { _ => JsNull } },
      `titleBaseline` = (j \ "titleBaseline").asOpt[JsValue].flatMap { x => HeaderConfigTitleBaselineCodec.decodeOpt(x) },
      `labelBaseline` = (j \ "labelBaseline").asOpt[JsValue].flatMap { x => HeaderConfigLabelBaselineCodec.decodeOpt(x) },
      `labelFontSize` = (j \ "labelFontSize").asOpt[JsValue].flatMap { x => HeaderConfigLabelFontSizeCodec.decodeOpt(x) },
      `format` = (j \ "format").asOpt[JsValue].flatMap { x => HeaderConfigFormatCodec.decodeOpt(x) },
      `titleFont` = (j \ "titleFont").asOpt[JsValue].flatMap { x => HeaderConfigTitleFontCodec.decodeOpt(x) },
      `titleFontStyle` = (j \ "titleFontStyle").asOpt[JsValue].flatMap { x => HeaderConfigTitleFontStyleCodec.decodeOpt(x) },
      `titleLineHeight` = (j \ "titleLineHeight").asOpt[JsValue].flatMap { x => HeaderConfigTitleLineHeightCodec.decodeOpt(x) },
      `labelLineHeight` = (j \ "labelLineHeight").asOpt[JsValue].flatMap { x => HeaderConfigLabelLineHeightCodec.decodeOpt(x) },
      `formatType` = (j \ "formatType").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `labelLimit` = (j \ "labelLimit").asOpt[JsValue].flatMap { x => HeaderConfigLabelLimitCodec.decodeOpt(x) },
      `titleAnchor` = (j \ "titleAnchor").asOpt[JsValue].flatMap { x => TitleAnchorCodec.decodeOpt(x) },
      `titleColor` = (j \ "titleColor").asOpt[JsValue].flatMap { x => HeaderConfigTitleColorCodec.decodeOpt(x) },
      `orient` = (j \ "orient").asOpt[JsValue].flatMap { x => OrientCodec.decodeOpt(x) },
      `titleOrient` = (j \ "titleOrient").asOpt[JsValue].flatMap { x => OrientCodec.decodeOpt(x) },
      `labelAlign` = (j \ "labelAlign").asOpt[JsValue].flatMap { x => HeaderConfigLabelAlignCodec.decodeOpt(x) },
      `labelOrient` = (j \ "labelOrient").asOpt[JsValue].flatMap { x => OrientCodec.decodeOpt(x) },
      `titleAngle` = (j \ "titleAngle").asOpt[JsValue].flatMap { x => HeaderConfigTitleAngleCodec.decodeOpt(x) },
      `labelPadding` = (j \ "labelPadding").asOpt[JsValue].flatMap { x => HeaderConfigLabelPaddingCodec.decodeOpt(x) },
      `labelFont` = (j \ "labelFont").asOpt[JsValue].flatMap { x => HeaderConfigLabelFontCodec.decodeOpt(x) },
      `labelAnchor` = (j \ "labelAnchor").asOpt[JsValue].flatMap { x => TitleAnchorCodec.decodeOpt(x) },
      `titleLimit` = (j \ "titleLimit").asOpt[JsValue].flatMap { x => HeaderConfigTitleLimitCodec.decodeOpt(x) },
      `labelFontStyle` = (j \ "labelFontStyle").asOpt[JsValue].flatMap { x => HeaderConfigLabelFontStyleCodec.decodeOpt(x) },
      `titleAlign` = (j \ "titleAlign").asOpt[JsValue].flatMap { x => HeaderConfigTitleAlignCodec.decodeOpt(x) },
      `titleFontSize` = (j \ "titleFontSize").asOpt[JsValue].flatMap { x => HeaderConfigTitleFontSizeCodec.decodeOpt(x) },
      `titleFontWeight` = (j \ "titleFontWeight").asOpt[JsValue].flatMap { x => HeaderConfigTitleFontWeightCodec.decodeOpt(x) },
    ))

  def encode(j: HeaderConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`labelAngle`.map { x => "labelAngle" -> HeaderConfigLabelAngleCodec.encode(x) },
        j.`labelColor`.map { x => "labelColor" -> HeaderConfigLabelColorCodec.encode(x) },
        j.`labelFontWeight`.map { x => "labelFontWeight" -> HeaderConfigLabelFontWeightCodec.encode(x) },
        j.`titlePadding`.map { x => "titlePadding" -> HeaderConfigTitlePaddingCodec.encode(x) },
        j.`labels`.map { x => "labels" -> Json.toJson(x) },
        j.`labelExpr`.map { x => "labelExpr" -> Json.toJson(x) },
        j.`title`.map { x => "title" -> Json.toJson(x) },
        j.`titleBaseline`.map { x => "titleBaseline" -> HeaderConfigTitleBaselineCodec.encode(x) },
        j.`labelBaseline`.map { x => "labelBaseline" -> HeaderConfigLabelBaselineCodec.encode(x) },
        j.`labelFontSize`.map { x => "labelFontSize" -> HeaderConfigLabelFontSizeCodec.encode(x) },
        j.`format`.map { x => "format" -> HeaderConfigFormatCodec.encode(x) },
        j.`titleFont`.map { x => "titleFont" -> HeaderConfigTitleFontCodec.encode(x) },
        j.`titleFontStyle`.map { x => "titleFontStyle" -> HeaderConfigTitleFontStyleCodec.encode(x) },
        j.`titleLineHeight`.map { x => "titleLineHeight" -> HeaderConfigTitleLineHeightCodec.encode(x) },
        j.`labelLineHeight`.map { x => "labelLineHeight" -> HeaderConfigLabelLineHeightCodec.encode(x) },
        j.`formatType`.map { x => "formatType" -> Json.toJson(x) },
        j.`labelLimit`.map { x => "labelLimit" -> HeaderConfigLabelLimitCodec.encode(x) },
        j.`titleAnchor`.map { x => "titleAnchor" -> TitleAnchorCodec.encode(x) },
        j.`titleColor`.map { x => "titleColor" -> HeaderConfigTitleColorCodec.encode(x) },
        j.`orient`.map { x => "orient" -> OrientCodec.encode(x) },
        j.`titleOrient`.map { x => "titleOrient" -> OrientCodec.encode(x) },
        j.`labelAlign`.map { x => "labelAlign" -> HeaderConfigLabelAlignCodec.encode(x) },
        j.`labelOrient`.map { x => "labelOrient" -> OrientCodec.encode(x) },
        j.`titleAngle`.map { x => "titleAngle" -> HeaderConfigTitleAngleCodec.encode(x) },
        j.`labelPadding`.map { x => "labelPadding" -> HeaderConfigLabelPaddingCodec.encode(x) },
        j.`labelFont`.map { x => "labelFont" -> HeaderConfigLabelFontCodec.encode(x) },
        j.`labelAnchor`.map { x => "labelAnchor" -> TitleAnchorCodec.encode(x) },
        j.`titleLimit`.map { x => "titleLimit" -> HeaderConfigTitleLimitCodec.encode(x) },
        j.`labelFontStyle`.map { x => "labelFontStyle" -> HeaderConfigLabelFontStyleCodec.encode(x) },
        j.`titleAlign`.map { x => "titleAlign" -> HeaderConfigTitleAlignCodec.encode(x) },
        j.`titleFontSize`.map { x => "titleFontSize" -> HeaderConfigTitleFontSizeCodec.encode(x) },
        j.`titleFontWeight`.map { x => "titleFontWeight" -> HeaderConfigTitleFontWeightCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// MinMax (ConstantType)
object MinMaxCodec {
  def decode(j: JsValue): MinMax =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[MinMax] =
    j match {
      case JsString("min-max") => Some(MinMax())
      case _ => None
    }
  def encode(j: MinMax): JsValue =
    JsString("min-max")
}


////////////////////////////////////////////////////////////////////////
// AxisConfigLabelAngle (UnionType)
object AxisConfigLabelAngleCodec {
  def decode(j: JsValue): AxisConfigLabelAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigLabelAngle] =
    AxisConfigLabelAngleAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigLabelAngle): JsValue =
    j match {
      case x:AxisConfigLabelAngleAsNumber /* TypeRef */ => AxisConfigLabelAngleAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingHrefFormat (UnionType)
object SharedEncodingHrefFormatCodec {
  def decode(j: JsValue): SharedEncodingHrefFormat =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingHrefFormat] =
    j.asOpt[String].map { SharedEncodingHrefFormatAsString(_) }.orElse {
    DictOfAnyCodec.decodeOpt(j).map { SharedEncodingHrefFormatAsDictOfAny(_) } } 
  def encode(j: SharedEncodingHrefFormat): JsValue =
    j match {
      case SharedEncodingHrefFormatAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case SharedEncodingHrefFormatAsDictOfAny(x) /* Base, MapType */ => DictOfAnyCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingThetaBin (UnionType)
object SharedEncodingThetaBinCodec {
  def decode(j: JsValue): SharedEncodingThetaBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingThetaBin] =
    j.asOpt[Boolean].map { SharedEncodingThetaBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    BinnedCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingThetaBinAsNull } } } } 
  def encode(j: SharedEncodingThetaBin): JsValue =
    j match {
      case SharedEncodingThetaBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case x:Binned /* TypeRef */ => BinnedCodec.encode(x)
      case SharedEncodingThetaBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// FacetedUnitSpecCenter (UnionType)
object FacetedUnitSpecCenterCodec {
  def decode(j: JsValue): FacetedUnitSpecCenter =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetedUnitSpecCenter] =
    j.asOpt[Boolean].map { FacetedUnitSpecCenterAsBool(_) }.orElse {
    RowColBooleanCodec.decodeOpt(j) } 
  def encode(j: FacetedUnitSpecCenter): JsValue =
    j match {
      case FacetedUnitSpecCenterAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:RowColBoolean /* TypeRef */ => RowColBooleanCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigOffset (UnionType)
object LegendConfigOffsetCodec {
  def decode(j: JsValue): LegendConfigOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigOffset] =
    j.asOpt[JsNumber].map { LegendConfigOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigOffset): JsValue =
    j match {
      case LegendConfigOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisGridCap (UnionType)
object AxisGridCapCodec {
  def decode(j: JsValue): AxisGridCap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisGridCap] =
    StrokeCapCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisGridCap): JsValue =
    j match {
      case x:StrokeCap /* TypeRef */ => StrokeCapCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigFontStyle (UnionType)
object BarConfigFontStyleCodec {
  def decode(j: JsValue): BarConfigFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigFontStyle] =
    j.asOpt[String].map { BarConfigFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigFontStyle): JsValue =
    j match {
      case BarConfigFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigXReverse (UnionType)
object ScaleConfigXReverseCodec {
  def decode(j: JsValue): ScaleConfigXReverse =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleConfigXReverse] =
    j.asOpt[Boolean].map { ScaleConfigXReverseAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleConfigXReverse): JsValue =
    j match {
      case ScaleConfigXReverseAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeWidthCondition (UnionType)
object SharedEncodingStrokeWidthConditionCodec {
  def decode(j: JsValue): SharedEncodingStrokeWidthCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeWidthCondition] =
    ConditionalValueDefNumberExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefNumberExprRefCodec.decodeOpt(j).map { SharedEncodingStrokeWidthConditionAsArrayOfConditionalValueDefNumberExprRef(_) }.orElse {
    ConditionalMarkPropFieldOrDatumDefCodec.decodeOpt(j) } } 
  def encode(j: SharedEncodingStrokeWidthCondition): JsValue =
    j match {
      case x:ConditionalValueDefNumberExprRef /* TypeRef */ => ConditionalValueDefNumberExprRefCodec.encode(x)
      case SharedEncodingStrokeWidthConditionAsArrayOfConditionalValueDefNumberExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefNumberExprRefCodec.encode(x)
      case x:ConditionalMarkPropFieldOrDatumDef /* TypeRef */ => ConditionalMarkPropFieldOrDatumDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetEncodingFieldDefSort (UnionType)
object FacetEncodingFieldDefSortCodec {
  def decode(j: JsValue): FacetEncodingFieldDefSort =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetEncodingFieldDefSort] =
    SortArrayCodec.decodeOpt(j).orElse {
    SortOrderCodec.decodeOpt(j).orElse {
    EncodingSortFieldCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => FacetEncodingFieldDefSortAsNull } } } } 
  def encode(j: FacetEncodingFieldDefSort): JsValue =
    j match {
      case x:SortArray /* TypeRef */ => SortArrayCodec.encode(x)
      case x:SortOrder /* TypeRef */ => SortOrderCodec.encode(x)
      case x:EncodingSortField /* TypeRef */ => EncodingSortFieldCodec.encode(x)
      case FacetEncodingFieldDefSortAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigContinuousBandSize (ConstrainedType)
object RectConfigContinuousBandSizeCodec {
  def decode(j: JsValue): RectConfigContinuousBandSize =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RectConfigContinuousBandSize] =
    try {
      j.asOpt[JsNumber]
        .map { RectConfigContinuousBandSize(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: RectConfigContinuousBandSize): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// FontWeight (EnumType)
object FontWeightCodec {
  def decode(j: JsValue): FontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FontWeight] =
    j match {
      case JsString("normal") => Some(FontWeightNormal)
      case JsString("bold") => Some(FontWeightBold)
      case JsString("lighter") => Some(FontWeightLighter)
      case JsString("bolder") => Some(FontWeightBolder)
      case JsNumber(v) if v.toDouble == 100.0 => Some(FontWeight1000)
      case JsNumber(v) if v.toDouble == 200.0 => Some(FontWeight2000)
      case JsNumber(v) if v.toDouble == 300.0 => Some(FontWeight3000)
      case JsNumber(v) if v.toDouble == 400.0 => Some(FontWeight4000)
      case JsNumber(v) if v.toDouble == 500.0 => Some(FontWeight5000)
      case JsNumber(v) if v.toDouble == 600.0 => Some(FontWeight6000)
      case JsNumber(v) if v.toDouble == 700.0 => Some(FontWeight7000)
      case JsNumber(v) if v.toDouble == 800.0 => Some(FontWeight8000)
      case JsNumber(v) if v.toDouble == 900.0 => Some(FontWeight9000)
      case _ => None
    }
  def encode(j: FontWeight): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// ScaleReverse (UnionType)
object ScaleReverseCodec {
  def decode(j: JsValue): ScaleReverse =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleReverse] =
    j.asOpt[Boolean].map { ScaleReverseAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleReverse): JsValue =
    j match {
      case ScaleReverseAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfUnitSpecWithFrameParamsElement (ArrayType)
object ArrayOfUnitSpecWithFrameParamsElementCodec {
  def decode(j: JsValue): Seq[UnitSpecWithFrameParamsElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[UnitSpecWithFrameParamsElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      UnitSpecWithFrameParamsElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[UnitSpecWithFrameParamsElement]): JsArray =
      JsArray(j.map { x => UnitSpecWithFrameParamsElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefColor (UnionType)
object OverlayMarkDefColorCodec {
  def decode(j: JsValue): OverlayMarkDefColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefColor] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: OverlayMarkDefColor): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisLabelFontWeight (UnionType)
object AxisLabelFontWeightCodec {
  def decode(j: JsValue): AxisLabelFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisLabelFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisLabelFontWeightCodec.decodeOpt(j) } } 
  def encode(j: AxisLabelFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisLabelFontWeight /* TypeRef */ => ConditionalAxisLabelFontWeightCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigRadius (ConstrainedType)
// see RectConfigRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefTheta (ConstrainedType)
// see OverlayMarkDefTheta (UnionType)

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefEndAngle (UnionType)
object OverlayMarkDefEndAngleCodec {
  def decode(j: JsValue): OverlayMarkDefEndAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefEndAngle] =
    j.asOpt[JsNumber].map { OverlayMarkDefEndAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefEndAngle): JsValue =
    j match {
      case OverlayMarkDefEndAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigOuterRadius (UnionType)
object TickConfigOuterRadiusCodec {
  def decode(j: JsValue): TickConfigOuterRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigOuterRadius] =
    j.asOpt[JsNumber].map { TickConfigOuterRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigOuterRadius): JsValue =
    j match {
      case TickConfigOuterRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleConfigFont (UnionType)
object TitleConfigFontCodec {
  def decode(j: JsValue): TitleConfigFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigFont] =
    j.asOpt[String].map { TitleConfigFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleConfigFont): JsValue =
    j match {
      case TitleConfigFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject1Center (UnionType)
object TopLevelRepeatSpecAsObject1CenterCodec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject1Center =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject1Center] =
    j.asOpt[Boolean].map { TopLevelRepeatSpecAsObject1CenterAsBool(_) }.orElse {
    RowColBooleanCodec.decodeOpt(j) } 
  def encode(j: TopLevelRepeatSpecAsObject1Center): JsValue =
    j match {
      case TopLevelRepeatSpecAsObject1CenterAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:RowColBoolean /* TypeRef */ => RowColBooleanCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTitleBaseline (UnionType)
object AxisTitleBaselineCodec {
  def decode(j: JsValue): AxisTitleBaseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTitleBaseline] =
    TextBaselineCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisTitleBaseline): JsValue =
    j match {
      case x:TextBaseline /* TypeRef */ => TextBaselineCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeDashValue (UnionType)
object SharedEncodingStrokeDashValueCodec {
  def decode(j: JsValue): SharedEncodingStrokeDashValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeDashValue] =
    ArrayOfNumberCodec.decodeOpt(j).map { SharedEncodingStrokeDashValueAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingStrokeDashValue): JsValue =
    j match {
      case SharedEncodingStrokeDashValueAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject2Title (UnionType)
object TopLevelRepeatSpecAsObject2TitleCodec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject2Title =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject2Title] =
    TextCodec.decodeOpt(j).orElse {
    TitleParamsCodec.decodeOpt(j) } 
  def encode(j: TopLevelRepeatSpecAsObject2Title): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:TitleParams /* TypeRef */ => TitleParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// JsonDataFormat (StructType)
object JsonDataFormatCodec {
  def decode(j: JsValue): JsonDataFormat =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[JsonDataFormat] =
    Some(JsonDataFormat(
      `parse` = (j \ "parse").asOpt[JsValue].flatMap { x => DictOfParseValueCodec.decodeOpt(x).map { Some(_) }.flatten },
      `property` = (j \ "property").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => JsonDataFormatTypeCodec.decodeOpt(x) },
    ))

  def encode(j: JsonDataFormat): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`parse`.map { x => "parse" -> DictOfParseValueCodec.encode(x) },
        j.`property`.map { x => "property" -> Json.toJson(x) },
        j.`type`.map { x => "type" -> JsonDataFormatTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TickConfigCursor (UnionType)
object TickConfigCursorCodec {
  def decode(j: JsValue): TickConfigCursor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigCursor] =
    CursorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigCursor): JsValue =
    j match {
      case x:Cursor /* TypeRef */ => CursorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingFillOpacityBandPosition (ConstrainedType)
object SharedEncodingFillOpacityBandPositionCodec {
  def decode(j: JsValue): SharedEncodingFillOpacityBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingFillOpacityBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingFillOpacityBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingFillOpacityBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// UnitSpecTitle (UnionType)
object UnitSpecTitleCodec {
  def decode(j: JsValue): UnitSpecTitle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[UnitSpecTitle] =
    TextCodec.decodeOpt(j).orElse {
    TitleParamsCodec.decodeOpt(j) } 
  def encode(j: UnitSpecTitle): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:TitleParams /* TypeRef */ => TitleParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleConfigZindexAsNumber (ConstrainedType)
object TitleConfigZindexAsNumberCodec {
  def decode(j: JsValue): TitleConfigZindexAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TitleConfigZindexAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { TitleConfigZindexAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: TitleConfigZindexAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkDefFontSize (UnionType)
object MarkDefFontSizeCodec {
  def decode(j: JsValue): MarkDefFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefFontSize] =
    MarkDefFontSizeAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefFontSize): JsValue =
    j match {
      case x:MarkDefFontSizeAsNumber /* TypeRef */ => MarkDefFontSizeAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigFill (UnionType)
object AreaConfigFillCodec {
  def decode(j: JsValue): AreaConfigFill =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigFill] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => AreaConfigFillAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: AreaConfigFill): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case AreaConfigFillAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LinearGradientGradient (ConstantType)
object LinearGradientGradientCodec {
  def decode(j: JsValue): LinearGradientGradient =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LinearGradientGradient] =
    j match {
      case JsString("linear") => Some(LinearGradientGradient())
      case _ => None
    }
  def encode(j: LinearGradientGradient): JsValue =
    JsString("linear")
}


////////////////////////////////////////////////////////////////////////
// PositionDatumDefBandPosition (ConstrainedType)
object PositionDatumDefBandPositionCodec {
  def decode(j: JsValue): PositionDatumDefBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[PositionDatumDefBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { PositionDatumDefBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: PositionDatumDefBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// RowColumnEncodingFieldDef (StructType)
object RowColumnEncodingFieldDefCodec {
  def decode(j: JsValue): RowColumnEncodingFieldDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RowColumnEncodingFieldDef] =
    Some(RowColumnEncodingFieldDef(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `center` = (j \ "center").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `align` = (j \ "align").asOpt[JsValue].flatMap { x => LayoutAlignCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => RowColumnEncodingFieldDefBandPositionCodec.decodeOpt(x) },
      `header` = (j \ "header").asOpt[JsValue].flatMap { x => HeaderCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => RowColumnEncodingFieldDefBinCodec.decodeOpt(x) },
      `spacing` = (j \ "spacing").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => RowColumnEncodingFieldDefTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => RowColumnEncodingFieldDefSortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) },
    ))

  def encode(j: RowColumnEncodingFieldDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`center`.map { x => "center" -> Json.toJson(x) },
        j.`align`.map { x => "align" -> LayoutAlignCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> RowColumnEncodingFieldDefBandPositionCodec.encode(x) },
        j.`header`.map { x => "header" -> HeaderCodec.encode(x) },
        j.`bin`.map { x => "bin" -> RowColumnEncodingFieldDefBinCodec.encode(x) },
        j.`spacing`.map { x => "spacing" -> Json.toJson(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> RowColumnEncodingFieldDefTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> RowColumnEncodingFieldDefSortCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ScaleAlign (UnionType)
object ScaleAlignCodec {
  def decode(j: JsValue): ScaleAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleAlign] =
    j.asOpt[JsNumber].map { ScaleAlignAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleAlign): JsValue =
    j match {
      case ScaleAlignAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// DensityTransformExtent (ConstrainedType)
object DensityTransformExtentCodec {
  def decode(j: JsValue): DensityTransformExtent =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[DensityTransformExtent] =
    try {
      ArrayOfNumberCodec.decodeOpt(j)
        .map { DensityTransformExtent(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: DensityTransformExtent): JsValue =
    ArrayOfNumberCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// AreaConfigDir (UnionType)
object AreaConfigDirCodec {
  def decode(j: JsValue): AreaConfigDir =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigDir] =
    TextDirectionCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigDir): JsValue =
    j match {
      case x:TextDirection /* TypeRef */ => TextDirectionCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigSize (UnionType)
object AreaConfigSizeCodec {
  def decode(j: JsValue): AreaConfigSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigSize] =
    j.asOpt[JsNumber].map { AreaConfigSizeAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigSize): JsValue =
    j match {
      case AreaConfigSizeAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetFieldDefBin (UnionType)
object FacetFieldDefBinCodec {
  def decode(j: JsValue): FacetFieldDefBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetFieldDefBin] =
    j.asOpt[Boolean].map { FacetFieldDefBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => FacetFieldDefBinAsNull } } } 
  def encode(j: FacetFieldDefBin): JsValue =
    j match {
      case FacetFieldDefBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case FacetFieldDefBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// RangeConfigDiverging (UnionType)
object RangeConfigDivergingCodec {
  def decode(j: JsValue): RangeConfigDiverging =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RangeConfigDiverging] =
    RangeSchemeCodec.decodeOpt(j).orElse {
    ArrayOfColorCodec.decodeOpt(j).map { RangeConfigDivergingAsArrayOfColor(_) } } 
  def encode(j: RangeConfigDiverging): JsValue =
    j match {
      case x:RangeScheme /* TypeRef */ => RangeSchemeCodec.encode(x)
      case RangeConfigDivergingAsArrayOfColor(x) /* Base, ArrayType */ => ArrayOfColorCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisNumberAsObject1 (StructType)
object ConditionalAxisNumberAsObject1Codec {
  def decode(j: JsValue): ConditionalAxisNumberAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalAxisNumberAsObject1] =
    {
      val `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => ConditionalAxisNumberAsObject1ConditionCodec.decodeOpt(x) }
      if(`condition`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => ConditionalAxisNumberAsObject1ValueCodec.decodeOpt(x) }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalAxisNumberAsObject1(
        `condition` = `condition`.get,
        `value` = `value`.get,
      ))
    }

  def encode(j: ConditionalAxisNumberAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("condition" -> ConditionalAxisNumberAsObject1ConditionCodec.encode(j.`condition`)),
        Some("value" -> ConditionalAxisNumberAsObject1ValueCodec.encode(j.`value`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TitleConfigSubtitleFontWeight (UnionType)
object TitleConfigSubtitleFontWeightCodec {
  def decode(j: JsValue): TitleConfigSubtitleFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigSubtitleFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleConfigSubtitleFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateMarkPropFieldOrDatumDefAsObject2Datum (UnionType)
object ConditionalPredicateMarkPropFieldOrDatumDefAsObject2DatumCodec {
  def decode(j: JsValue): ConditionalPredicateMarkPropFieldOrDatumDefAsObject2Datum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateMarkPropFieldOrDatumDefAsObject2Datum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: ConditionalPredicateMarkPropFieldOrDatumDefAsObject2Datum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigDomainDash (UnionType)
object AxisConfigDomainDashCodec {
  def decode(j: JsValue): AxisConfigDomainDash =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigDomainDash] =
    ArrayOfNumberCodec.decodeOpt(j).map { AxisConfigDomainDashAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigDomainDash): JsValue =
    j match {
      case AxisConfigDomainDashAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetedEncodingDescription (UnionType)
object FacetedEncodingDescriptionCodec {
  def decode(j: JsValue): FacetedEncodingDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetedEncodingDescription] =
    StringFieldDefWithConditionCodec.decodeOpt(j).orElse {
    StringValueDefWithConditionCodec.decodeOpt(j) } 
  def encode(j: FacetedEncodingDescription): JsValue =
    j match {
      case x:StringFieldDefWithCondition /* TypeRef */ => StringFieldDefWithConditionCodec.encode(x)
      case x:StringValueDefWithCondition /* TypeRef */ => StringValueDefWithConditionCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TypeForShape (EnumType)
object TypeForShapeCodec {
  def decode(j: JsValue): TypeForShape =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TypeForShape] =
    j match {
      case JsString("nominal") => Some(TypeForShapeNominal)
      case JsString("ordinal") => Some(TypeForShapeOrdinal)
      case JsString("geojson") => Some(TypeForShapeGeojson)
      case _ => None
    }
  def encode(j: TypeForShape): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// OverlayMarkDefRadius2 (ConstrainedType)
// see OverlayMarkDefRadius2 (UnionType)

////////////////////////////////////////////////////////////////////////
// MarkDefRadius2 (UnionType)
object MarkDefRadius2Codec {
  def decode(j: JsValue): MarkDefRadius2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefRadius2] =
    j.asOpt[JsNumber].map { MarkDefRadius2AsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefRadius2): JsValue =
    j match {
      case MarkDefRadius2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BoxPlotDefOutliers (UnionType)
object BoxPlotDefOutliersCodec {
  def decode(j: JsValue): BoxPlotDefOutliers =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BoxPlotDefOutliers] =
    j.asOpt[Boolean].map { BoxPlotDefOutliersAsBool(_) }.orElse {
    MarkConfigCodec.decodeOpt(j) } 
  def encode(j: BoxPlotDefOutliers): JsValue =
    j match {
      case BoxPlotDefOutliersAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:MarkConfig /* TypeRef */ => MarkConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldRangePredicateRangeAsArrayElement (UnionType)
object FieldRangePredicateRangeAsArrayElementCodec {
  def decode(j: JsValue): FieldRangePredicateRangeAsArrayElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldRangePredicateRangeAsArrayElement] =
    j.asOpt[JsNumber].map { FieldRangePredicateRangeAsArrayElementAsNumber(_) }.orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => FieldRangePredicateRangeAsArrayElementAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: FieldRangePredicateRangeAsArrayElement): JsValue =
    j match {
      case FieldRangePredicateRangeAsArrayElementAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case FieldRangePredicateRangeAsArrayElementAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// IntervalSelectionConfigWithoutTypeOn (UnionType)
object IntervalSelectionConfigWithoutTypeOnCodec {
  def decode(j: JsValue): IntervalSelectionConfigWithoutTypeOn =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[IntervalSelectionConfigWithoutTypeOn] =
    StreamCodec.decodeOpt(j).orElse {
    j.asOpt[String].map { IntervalSelectionConfigWithoutTypeOnAsString(_) } } 
  def encode(j: IntervalSelectionConfigWithoutTypeOn): JsValue =
    j match {
      case x:Stream /* TypeRef */ => StreamCodec.encode(x)
      case IntervalSelectionConfigWithoutTypeOnAsString(x) /* Base, StringType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigText (UnionType)
object AreaConfigTextCodec {
  def decode(j: JsValue): AreaConfigText =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigText] =
    TextCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigText): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ErrorBandDefBorders (UnionType)
object ErrorBandDefBordersCodec {
  def decode(j: JsValue): ErrorBandDefBorders =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ErrorBandDefBorders] =
    j.asOpt[Boolean].map { ErrorBandDefBordersAsBool(_) }.orElse {
    MarkConfigCodec.decodeOpt(j) } 
  def encode(j: ErrorBandDefBorders): JsValue =
    j match {
      case ErrorBandDefBordersAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:MarkConfig /* TypeRef */ => MarkConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigSymbolLimit (UnionType)
object LegendConfigSymbolLimitCodec {
  def decode(j: JsValue): LegendConfigSymbolLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigSymbolLimit] =
    j.asOpt[JsNumber].map { LegendConfigSymbolLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigSymbolLimit): JsValue =
    j match {
      case LegendConfigSymbolLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefStrokeJoin (UnionType)
object OverlayMarkDefStrokeJoinCodec {
  def decode(j: JsValue): OverlayMarkDefStrokeJoin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefStrokeJoin] =
    StrokeJoinCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefStrokeJoin): JsValue =
    j match {
      case x:StrokeJoin /* TypeRef */ => StrokeJoinCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisOffset (UnionType)
object AxisOffsetCodec {
  def decode(j: JsValue): AxisOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisOffset] =
    j.asOpt[JsNumber].map { AxisOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisOffset): JsValue =
    j match {
      case AxisOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BoxPlotDefExtent (UnionType)
object BoxPlotDefExtentCodec {
  def decode(j: JsValue): BoxPlotDefExtent =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BoxPlotDefExtent] =
    MinMaxCodec.decodeOpt(j).orElse {
    j.asOpt[JsNumber].map { BoxPlotDefExtentAsNumber(_) } } 
  def encode(j: BoxPlotDefExtent): JsValue =
    j match {
      case x:MinMax /* TypeRef */ => MinMaxCodec.encode(x)
      case BoxPlotDefExtentAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefInvalid (EnumType)
object MarkDefInvalidCodec {
  def decode(j: JsValue): MarkDefInvalid =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefInvalid] =
    j match {
      case JsString("filter") => Some(MarkDefInvalidFilter)
      case JsNull => Some(MarkDefInvalidUndefined)
      case _ => None
    }
  def encode(j: MarkDefInvalid): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// NumericArrayMarkPropDef (UnionType)
object NumericArrayMarkPropDefCodec {
  def decode(j: JsValue): NumericArrayMarkPropDef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[NumericArrayMarkPropDef] =
    FieldOrDatumDefWithConditionMarkPropFieldDefNumberCodec.decodeOpt(j).orElse {
    FieldOrDatumDefWithConditionDatumDefNumberCodec.decodeOpt(j).orElse {
    ValueDefWithConditionMarkPropFieldOrDatumDefNumberCodec.decodeOpt(j) } } 
  def encode(j: NumericArrayMarkPropDef): JsValue =
    j match {
      case x:FieldOrDatumDefWithConditionMarkPropFieldDefNumber /* TypeRef */ => FieldOrDatumDefWithConditionMarkPropFieldDefNumberCodec.encode(x)
      case x:FieldOrDatumDefWithConditionDatumDefNumber /* TypeRef */ => FieldOrDatumDefWithConditionDatumDefNumberCodec.encode(x)
      case x:ValueDefWithConditionMarkPropFieldOrDatumDefNumber /* TypeRef */ => ValueDefWithConditionMarkPropFieldOrDatumDefNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefGradientStringNullExprRef (StructType)
object ConditionalPredicateValueDefGradientStringNullExprRefCodec {
  def decode(j: JsValue): ConditionalPredicateValueDefGradientStringNullExprRef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefGradientStringNullExprRef] =
    {
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => ConditionalPredicateValueDefGradientStringNullExprRefValueCodec.decodeOpt(x) }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalPredicateValueDefGradientStringNullExprRef(
        `test` = `test`.get,
        `value` = `value`.get,
      ))
    }

  def encode(j: ConditionalPredicateValueDefGradientStringNullExprRef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
        Some("value" -> ConditionalPredicateValueDefGradientStringNullExprRefValueCodec.encode(j.`value`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AxisTickWidthAsNumber (ConstrainedType)
object AxisTickWidthAsNumberCodec {
  def decode(j: JsValue): AxisTickWidthAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AxisTickWidthAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AxisTickWidthAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AxisTickWidthAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// SortArray (UnionType)
object SortArrayCodec {
  def decode(j: JsValue): SortArray =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SortArray] =
    ArrayOfNumberCodec.decodeOpt(j).map { SortArrayAsArrayOfNumber(_) }.orElse {
    ArrayOfStringCodec.decodeOpt(j).map { SortArrayAsArrayOfString(_) }.orElse {
    ArrayOfBoolCodec.decodeOpt(j).map { SortArrayAsArrayOfBool(_) }.orElse {
    ArrayOfDateTimeCodec.decodeOpt(j).map { SortArrayAsArrayOfDateTime(_) } } } } 
  def encode(j: SortArray): JsValue =
    j match {
      case SortArrayAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case SortArrayAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
      case SortArrayAsArrayOfBool(x) /* Base, ArrayType */ => ArrayOfBoolCodec.encode(x)
      case SortArrayAsArrayOfDateTime(x) /* Base, ArrayType */ => ArrayOfDateTimeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderTitleFontStyle (UnionType)
object HeaderTitleFontStyleCodec {
  def decode(j: JsValue): HeaderTitleFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderTitleFontStyle] =
    j.asOpt[String].map { HeaderTitleFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderTitleFontStyle): JsValue =
    j match {
      case HeaderTitleFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigLimit (UnionType)
object LineConfigLimitCodec {
  def decode(j: JsValue): LineConfigLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigLimit] =
    j.asOpt[JsNumber].map { LineConfigLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigLimit): JsValue =
    j match {
      case LineConfigLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefBlend (UnionType)
object OverlayMarkDefBlendCodec {
  def decode(j: JsValue): OverlayMarkDefBlend =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefBlend] =
    BlendCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefBlend): JsValue =
    j match {
      case x:Blend /* TypeRef */ => BlendCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigLabelLineHeight (UnionType)
object AxisConfigLabelLineHeightCodec {
  def decode(j: JsValue): AxisConfigLabelLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigLabelLineHeight] =
    j.asOpt[JsNumber].map { AxisConfigLabelLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigLabelLineHeight): JsValue =
    j match {
      case AxisConfigLabelLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigAriaRole (UnionType)
object BarConfigAriaRoleCodec {
  def decode(j: JsValue): BarConfigAriaRole =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigAriaRole] =
    j.asOpt[String].map { BarConfigAriaRoleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigAriaRole): JsValue =
    j match {
      case BarConfigAriaRoleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigAriaRoleDescription (UnionType)
object RectConfigAriaRoleDescriptionCodec {
  def decode(j: JsValue): RectConfigAriaRoleDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigAriaRoleDescription] =
    j.asOpt[String].map { RectConfigAriaRoleDescriptionAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigAriaRoleDescription): JsValue =
    j match {
      case RectConfigAriaRoleDescriptionAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ImputeParamsKeyvals (UnionType)
object ImputeParamsKeyvalsCodec {
  def decode(j: JsValue): ImputeParamsKeyvals =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ImputeParamsKeyvals] =
    ArrayOfAnyCodec.decodeOpt(j).map { ImputeParamsKeyvalsAsArrayOfAny(_) }.orElse {
    ImputeSequenceCodec.decodeOpt(j) } 
  def encode(j: ImputeParamsKeyvals): JsValue =
    j match {
      case ImputeParamsKeyvalsAsArrayOfAny(x) /* Base, ArrayType */ => ArrayOfAnyCodec.encode(x)
      case x:ImputeSequence /* TypeRef */ => ImputeSequenceCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigOffsetBandPaddingInner (UnionType)
object ScaleConfigOffsetBandPaddingInnerCodec {
  def decode(j: JsValue): ScaleConfigOffsetBandPaddingInner =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleConfigOffsetBandPaddingInner] =
    j.asOpt[JsNumber].map { ScaleConfigOffsetBandPaddingInnerAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleConfigOffsetBandPaddingInner): JsValue =
    j match {
      case ScaleConfigOffsetBandPaddingInnerAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigText (UnionType)
object LineConfigTextCodec {
  def decode(j: JsValue): LineConfigText =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigText] =
    TextCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigText): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfigPointRadius (UnionType)
object ProjectionConfigPointRadiusCodec {
  def decode(j: JsValue): ProjectionConfigPointRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigPointRadius] =
    j.asOpt[JsNumber].map { ProjectionConfigPointRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigPointRadius): JsValue =
    j match {
      case ProjectionConfigPointRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingHref (StructType)
object SharedEncodingHrefCodec {
  def decode(j: JsValue): SharedEncodingHref =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingHref] =
    Some(SharedEncodingHref(
      `format` = (j \ "format").asOpt[JsValue].flatMap { x => SharedEncodingHrefFormatCodec.decodeOpt(x) },
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingHrefBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => SharedEncodingHrefConditionCodec.decodeOpt(x) },
      `formatType` = (j \ "formatType").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingHrefBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingHrefValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingHrefTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingHref): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`format`.map { x => "format" -> SharedEncodingHrefFormatCodec.encode(x) },
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingHrefBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> SharedEncodingHrefConditionCodec.encode(x) },
        j.`formatType`.map { x => "formatType" -> Json.toJson(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingHrefBinCodec.encode(x) },
        j.`value`.map { x => "value" -> SharedEncodingHrefValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingHrefTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ValueDefWithConditionStringFieldDefText (ConstrainedType)
// see ValueDefWithConditionStringFieldDefText (StructType)

////////////////////////////////////////////////////////////////////////
// TopLevelFacetSpecPadding (UnionType)
object TopLevelFacetSpecPaddingCodec {
  def decode(j: JsValue): TopLevelFacetSpecPadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelFacetSpecPadding] =
    PaddingCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TopLevelFacetSpecPadding): JsValue =
    j match {
      case x:Padding /* TypeRef */ => PaddingCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PointSelectionConfigOn (UnionType)
object PointSelectionConfigOnCodec {
  def decode(j: JsValue): PointSelectionConfigOn =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PointSelectionConfigOn] =
    StreamCodec.decodeOpt(j).orElse {
    j.asOpt[String].map { PointSelectionConfigOnAsString(_) } } 
  def encode(j: PointSelectionConfigOn): JsValue =
    j match {
      case x:Stream /* TypeRef */ => StreamCodec.encode(x)
      case PointSelectionConfigOnAsString(x) /* Base, StringType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigFontWeight (UnionType)
object BarConfigFontWeightCodec {
  def decode(j: JsValue): BarConfigFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LayerRepeatSpecTitle (UnionType)
object LayerRepeatSpecTitleCodec {
  def decode(j: JsValue): LayerRepeatSpecTitle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LayerRepeatSpecTitle] =
    TextCodec.decodeOpt(j).orElse {
    TitleParamsCodec.decodeOpt(j) } 
  def encode(j: LayerRepeatSpecTitle): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:TitleParams /* TypeRef */ => TitleParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldLTPredicateTimeUnit (UnionType)
object FieldLTPredicateTimeUnitCodec {
  def decode(j: JsValue): FieldLTPredicateTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldLTPredicateTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: FieldLTPredicateTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ValueDefWithConditionMarkPropFieldOrDatumDefNumber (ConstrainedType)
// see ValueDefWithConditionMarkPropFieldOrDatumDefNumber (StructType)

////////////////////////////////////////////////////////////////////////
// BarConfigAngle (UnionType)
object BarConfigAngleCodec {
  def decode(j: JsValue): BarConfigAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigAngle] =
    BarConfigAngleAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigAngle): JsValue =
    j match {
      case x:BarConfigAngleAsNumber /* TypeRef */ => BarConfigAngleAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// EventStream (UnionType)
object EventStreamCodec {
  def decode(j: JsValue): EventStream =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[EventStream] =
    EventStreamAsObject1Codec.decodeOpt(j).orElse {
    EventStreamAsObject2Codec.decodeOpt(j) } 
  def encode(j: EventStream): JsValue =
    j match {
      case x:EventStreamAsObject1 /* TypeRef */ => EventStreamAsObject1Codec.encode(x)
      case x:EventStreamAsObject2 /* TypeRef */ => EventStreamAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigTheta2 (UnionType)
object TickConfigTheta2Codec {
  def decode(j: JsValue): TickConfigTheta2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigTheta2] =
    j.asOpt[JsNumber].map { TickConfigTheta2AsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigTheta2): JsValue =
    j match {
      case TickConfigTheta2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTitleFontStyle (UnionType)
object AxisConfigTitleFontStyleCodec {
  def decode(j: JsValue): AxisConfigTitleFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTitleFontStyle] =
    j.asOpt[String].map { AxisConfigTitleFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigTitleFontStyle): JsValue =
    j match {
      case AxisConfigTitleFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickCount (UnionType)
object TickCountCodec {
  def decode(j: JsValue): TickCount =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickCount] =
    j.asOpt[JsNumber].map { TickCountAsNumber(_) }.orElse {
    TimeIntervalCodec.decodeOpt(j).orElse {
    TimeIntervalStepCodec.decodeOpt(j) } } 
  def encode(j: TickCount): JsValue =
    j match {
      case TickCountAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:TimeInterval /* TypeRef */ => TimeIntervalCodec.encode(x)
      case x:TimeIntervalStep /* TypeRef */ => TimeIntervalStepCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Binned (ConstantType)
object BinnedCodec {
  def decode(j: JsValue): Binned =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Binned] =
    j match {
      case JsString("binned") => Some(Binned())
      case _ => None
    }
  def encode(j: Binned): JsValue =
    JsString("binned")
}


////////////////////////////////////////////////////////////////////////
// LayerRepeatMapping (StructType)
object LayerRepeatMappingCodec {
  def decode(j: JsValue): LayerRepeatMapping =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LayerRepeatMapping] =
    {
      val `column` = (j \ "column").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) }
      val `layer` = (j \ "layer").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) }
      if(`layer`.isEmpty) { return None }
      val `row` = (j \ "row").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) }
      return Some(LayerRepeatMapping(
        `column` = `column`,
        `layer` = `layer`.get,
        `row` = `row`,
      ))
    }

  def encode(j: LayerRepeatMapping): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`column`.map { x => "column" -> ArrayOfStringCodec.encode(x) },
        Some("layer" -> ArrayOfStringCodec.encode(j.`layer`)),
        j.`row`.map { x => "row" -> ArrayOfStringCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ScaleRangeMax (UnionType)
object ScaleRangeMaxCodec {
  def decode(j: JsValue): ScaleRangeMax =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleRangeMax] =
    j.asOpt[JsNumber].map { ScaleRangeMaxAsNumber(_) }.orElse {
    j.asOpt[String].map { ScaleRangeMaxAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: ScaleRangeMax): JsValue =
    j match {
      case ScaleRangeMaxAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case ScaleRangeMaxAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingY2TimeUnit (UnionType)
object SharedEncodingY2TimeUnitCodec {
  def decode(j: JsValue): SharedEncodingY2TimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingY2TimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingY2TimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigFontSize (UnionType)
object MarkConfigFontSizeCodec {
  def decode(j: JsValue): MarkConfigFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigFontSize] =
    MarkConfigFontSizeAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigFontSize): JsValue =
    j match {
      case x:MarkConfigFontSizeAsNumber /* TypeRef */ => MarkConfigFontSizeAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigRadius (ConstrainedType)
// see LineConfigRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// ViewConfigStrokeMiterLimit (UnionType)
object ViewConfigStrokeMiterLimitCodec {
  def decode(j: JsValue): ViewConfigStrokeMiterLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewConfigStrokeMiterLimit] =
    j.asOpt[JsNumber].map { ViewConfigStrokeMiterLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ViewConfigStrokeMiterLimit): JsValue =
    j match {
      case ViewConfigStrokeMiterLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigFill (UnionType)
object LineConfigFillCodec {
  def decode(j: JsValue): LineConfigFill =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigFill] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => LineConfigFillAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: LineConfigFill): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case LineConfigFillAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisMinExtent (UnionType)
object AxisMinExtentCodec {
  def decode(j: JsValue): AxisMinExtent =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisMinExtent] =
    j.asOpt[JsNumber].map { AxisMinExtentAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisMinExtent): JsValue =
    j match {
      case AxisMinExtentAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionDatumDefNumberCondition (UnionType)
object FieldOrDatumDefWithConditionDatumDefNumberConditionCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionDatumDefNumberCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionDatumDefNumberCondition] =
    ConditionalValueDefNumberExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefNumberExprRefCodec.decodeOpt(j).map { FieldOrDatumDefWithConditionDatumDefNumberConditionAsArrayOfConditionalValueDefNumberExprRef(_) } } 
  def encode(j: FieldOrDatumDefWithConditionDatumDefNumberCondition): JsValue =
    j match {
      case x:ConditionalValueDefNumberExprRef /* TypeRef */ => ConditionalValueDefNumberExprRefCodec.encode(x)
      case FieldOrDatumDefWithConditionDatumDefNumberConditionAsArrayOfConditionalValueDefNumberExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefNumberExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingY2Value (UnionType)
object SharedEncodingY2ValueCodec {
  def decode(j: JsValue): SharedEncodingY2Value =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingY2Value] =
    j.asOpt[JsNumber].map { SharedEncodingY2ValueAsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingY2Value): JsValue =
    j match {
      case SharedEncodingY2ValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigLabelPadding (UnionType)
object AxisConfigLabelPaddingCodec {
  def decode(j: JsValue): AxisConfigLabelPadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigLabelPadding] =
    j.asOpt[JsNumber].map { AxisConfigLabelPaddingAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigLabelPadding): JsValue =
    j match {
      case AxisConfigLabelPaddingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigBandPaddingInner (ConstrainedType)
// see ScaleConfigBandPaddingInner (UnionType)

////////////////////////////////////////////////////////////////////////
// DateTimeHours (ConstrainedType)
object DateTimeHoursCodec {
  def decode(j: JsValue): DateTimeHours =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[DateTimeHours] =
    try {
      j.asOpt[JsNumber]
        .map { DateTimeHours(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: DateTimeHours): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// LineConfigFillOpacityAsNumber (ConstrainedType)
object LineConfigFillOpacityAsNumberCodec {
  def decode(j: JsValue): LineConfigFillOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LineConfigFillOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { LineConfigFillOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: LineConfigFillOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// LineConfigInvalid (EnumType)
object LineConfigInvalidCodec {
  def decode(j: JsValue): LineConfigInvalid =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigInvalid] =
    j match {
      case JsString("filter") => Some(LineConfigInvalidFilter)
      case JsNull => Some(LineConfigInvalidUndefined)
      case _ => None
    }
  def encode(j: LineConfigInvalid): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject2 (StructType)
object TopLevelRepeatSpecAsObject2Codec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject2] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `description` = (j \ "description").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `params` = (j \ "params").asOpt[JsValue].flatMap { x => ArrayOfTopLevelRepeatSpecAsObject2ParamsElementCodec.decodeOpt(x) }
      val `config` = (j \ "config").asOpt[JsValue].flatMap { x => ConfigCodec.decodeOpt(x) }
      val `bounds` = (j \ "bounds").asOpt[JsValue].flatMap { x => TopLevelRepeatSpecAsObject2BoundsCodec.decodeOpt(x) }
      val `datasets` = (j \ "datasets").asOpt[JsValue].flatMap { x => DictOfInlineDatasetCodec.decodeOpt(x) }
      val `usermeta` = (j \ "usermeta").asOpt[JsValue].flatMap { x => DictOfAnyCodec.decodeOpt(x) }
      val `columns` = (j \ "columns").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `resolve` = (j \ "resolve").asOpt[JsValue].flatMap { x => ResolveCodec.decodeOpt(x) }
      val `spec` = (j \ "spec").asOpt[JsValue].flatMap { x => TopLevelRepeatSpecAsObject2SpecCodec.decodeOpt(x) }
      if(`spec`.isEmpty) { return None }
      val `padding` = (j \ "padding").asOpt[JsValue].flatMap { x => TopLevelRepeatSpecAsObject2PaddingCodec.decodeOpt(x) }
      val `background` = (j \ "background").asOpt[JsValue].flatMap { x => TopLevelRepeatSpecAsObject2BackgroundCodec.decodeOpt(x) }
      val `center` = (j \ "center").asOpt[JsValue].flatMap { x => TopLevelRepeatSpecAsObject2CenterCodec.decodeOpt(x) }
      val `align` = (j \ "align").asOpt[JsValue].flatMap { x => TopLevelRepeatSpecAsObject2AlignCodec.decodeOpt(x) }
      val `data` = (j \ "data").asOpt[JsValue].flatMap { x => DataCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `repeat` = (j \ "repeat").asOpt[JsValue].flatMap { x => LayerRepeatMappingCodec.decodeOpt(x) }
      if(`repeat`.isEmpty) { return None }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => TopLevelRepeatSpecAsObject2TitleCodec.decodeOpt(x) }
      val `spacing` = (j \ "spacing").asOpt[JsValue].flatMap { x => TopLevelRepeatSpecAsObject2SpacingCodec.decodeOpt(x) }
      val `$schema` = (j \ "$schema").asOpt[JsValue].flatMap { x => UriCodec.decodeOpt(x) }
      val `autosize` = (j \ "autosize").asOpt[JsValue].flatMap { x => TopLevelRepeatSpecAsObject2AutosizeCodec.decodeOpt(x) }
      val `transform` = (j \ "transform").asOpt[JsValue].flatMap { x => ArrayOfTransformCodec.decodeOpt(x) }
      return Some(TopLevelRepeatSpecAsObject2(
        `name` = `name`,
        `description` = `description`,
        `params` = `params`,
        `config` = `config`,
        `bounds` = `bounds`,
        `datasets` = `datasets`,
        `usermeta` = `usermeta`,
        `columns` = `columns`,
        `resolve` = `resolve`,
        `spec` = `spec`.get,
        `padding` = `padding`,
        `background` = `background`,
        `center` = `center`,
        `align` = `align`,
        `data` = `data`,
        `repeat` = `repeat`.get,
        `title` = `title`,
        `spacing` = `spacing`,
        `$schema` = `$schema`,
        `autosize` = `autosize`,
        `transform` = `transform`,
      ))
    }

  def encode(j: TopLevelRepeatSpecAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`description`.map { x => "description" -> Json.toJson(x) },
        j.`params`.map { x => "params" -> ArrayOfTopLevelRepeatSpecAsObject2ParamsElementCodec.encode(x) },
        j.`config`.map { x => "config" -> ConfigCodec.encode(x) },
        j.`bounds`.map { x => "bounds" -> TopLevelRepeatSpecAsObject2BoundsCodec.encode(x) },
        j.`datasets`.map { x => "datasets" -> DictOfInlineDatasetCodec.encode(x) },
        j.`usermeta`.map { x => "usermeta" -> DictOfAnyCodec.encode(x) },
        j.`columns`.map { x => "columns" -> Json.toJson(x) },
        j.`resolve`.map { x => "resolve" -> ResolveCodec.encode(x) },
        Some("spec" -> TopLevelRepeatSpecAsObject2SpecCodec.encode(j.`spec`)),
        j.`padding`.map { x => "padding" -> TopLevelRepeatSpecAsObject2PaddingCodec.encode(x) },
        j.`background`.map { x => "background" -> TopLevelRepeatSpecAsObject2BackgroundCodec.encode(x) },
        j.`center`.map { x => "center" -> TopLevelRepeatSpecAsObject2CenterCodec.encode(x) },
        j.`align`.map { x => "align" -> TopLevelRepeatSpecAsObject2AlignCodec.encode(x) },
        j.`data`.map { x => "data" -> DataCodec.encode(x) },
        Some("repeat" -> LayerRepeatMappingCodec.encode(j.`repeat`)),
        j.`title`.map { x => "title" -> TopLevelRepeatSpecAsObject2TitleCodec.encode(x) },
        j.`spacing`.map { x => "spacing" -> TopLevelRepeatSpecAsObject2SpacingCodec.encode(x) },
        j.`$schema`.map { x => "$schema" -> UriCodec.encode(x) },
        j.`autosize`.map { x => "autosize" -> TopLevelRepeatSpecAsObject2AutosizeCodec.encode(x) },
        j.`transform`.map { x => "transform" -> ArrayOfTransformCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// RectConfigStartAngle (UnionType)
object RectConfigStartAngleCodec {
  def decode(j: JsValue): RectConfigStartAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigStartAngle] =
    j.asOpt[JsNumber].map { RectConfigStartAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigStartAngle): JsValue =
    j match {
      case RectConfigStartAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsFrame (UnionType)
object TitleParamsFrameCodec {
  def decode(j: JsValue): TitleParamsFrame =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsFrame] =
    TitleFrameCodec.decodeOpt(j).orElse {
    j.asOpt[String].map { TitleParamsFrameAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: TitleParamsFrame): JsValue =
    j match {
      case x:TitleFrame /* TypeRef */ => TitleFrameCodec.encode(x)
      case TitleParamsFrameAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewBackground (StructType)
object ViewBackgroundCodec {
  def decode(j: JsValue): ViewBackground =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ViewBackground] =
    Some(ViewBackground(
      `fillOpacity` = (j \ "fillOpacity").asOpt[JsValue].flatMap { x => ViewBackgroundFillOpacityCodec.decodeOpt(x) },
      `cornerRadius` = (j \ "cornerRadius").asOpt[JsValue].flatMap { x => ViewBackgroundCornerRadiusCodec.decodeOpt(x) },
      `cursor` = (j \ "cursor").asOpt[JsValue].flatMap { x => CursorCodec.decodeOpt(x) },
      `strokeMiterLimit` = (j \ "strokeMiterLimit").asOpt[JsValue].flatMap { x => ViewBackgroundStrokeMiterLimitCodec.decodeOpt(x) },
      `fill` = (j \ "fill").asOpt[JsValue].flatMap { x => ViewBackgroundFillCodec.decodeOpt(x) },
      `opacity` = (j \ "opacity").asOpt[JsValue].flatMap { x => ViewBackgroundOpacityCodec.decodeOpt(x) },
      `strokeDash` = (j \ "strokeDash").asOpt[JsValue].flatMap { x => ViewBackgroundStrokeDashCodec.decodeOpt(x) },
      `strokeWidth` = (j \ "strokeWidth").asOpt[JsValue].flatMap { x => ViewBackgroundStrokeWidthCodec.decodeOpt(x) },
      `style` = (j \ "style").asOpt[JsValue].flatMap { x => ViewBackgroundStyleCodec.decodeOpt(x) },
      `strokeOpacity` = (j \ "strokeOpacity").asOpt[JsValue].flatMap { x => ViewBackgroundStrokeOpacityCodec.decodeOpt(x) },
      `stroke` = (j \ "stroke").asOpt[JsValue].flatMap { x => ViewBackgroundStrokeCodec.decodeOpt(x) },
      `strokeDashOffset` = (j \ "strokeDashOffset").asOpt[JsValue].flatMap { x => ViewBackgroundStrokeDashOffsetCodec.decodeOpt(x) },
      `strokeCap` = (j \ "strokeCap").asOpt[JsValue].flatMap { x => ViewBackgroundStrokeCapCodec.decodeOpt(x) },
      `strokeJoin` = (j \ "strokeJoin").asOpt[JsValue].flatMap { x => ViewBackgroundStrokeJoinCodec.decodeOpt(x) },
    ))

  def encode(j: ViewBackground): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`fillOpacity`.map { x => "fillOpacity" -> ViewBackgroundFillOpacityCodec.encode(x) },
        j.`cornerRadius`.map { x => "cornerRadius" -> ViewBackgroundCornerRadiusCodec.encode(x) },
        j.`cursor`.map { x => "cursor" -> CursorCodec.encode(x) },
        j.`strokeMiterLimit`.map { x => "strokeMiterLimit" -> ViewBackgroundStrokeMiterLimitCodec.encode(x) },
        j.`fill`.map { x => "fill" -> ViewBackgroundFillCodec.encode(x) },
        j.`opacity`.map { x => "opacity" -> ViewBackgroundOpacityCodec.encode(x) },
        j.`strokeDash`.map { x => "strokeDash" -> ViewBackgroundStrokeDashCodec.encode(x) },
        j.`strokeWidth`.map { x => "strokeWidth" -> ViewBackgroundStrokeWidthCodec.encode(x) },
        j.`style`.map { x => "style" -> ViewBackgroundStyleCodec.encode(x) },
        j.`strokeOpacity`.map { x => "strokeOpacity" -> ViewBackgroundStrokeOpacityCodec.encode(x) },
        j.`stroke`.map { x => "stroke" -> ViewBackgroundStrokeCodec.encode(x) },
        j.`strokeDashOffset`.map { x => "strokeDashOffset" -> ViewBackgroundStrokeDashOffsetCodec.encode(x) },
        j.`strokeCap`.map { x => "strokeCap" -> ViewBackgroundStrokeCapCodec.encode(x) },
        j.`strokeJoin`.map { x => "strokeJoin" -> ViewBackgroundStrokeJoinCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AreaConfigHeight (UnionType)
object AreaConfigHeightCodec {
  def decode(j: JsValue): AreaConfigHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigHeight] =
    j.asOpt[JsNumber].map { AreaConfigHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigHeight): JsValue =
    j match {
      case AreaConfigHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelVConcatSpecBounds (EnumType)
object TopLevelVConcatSpecBoundsCodec {
  def decode(j: JsValue): TopLevelVConcatSpecBounds =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelVConcatSpecBounds] =
    j match {
      case JsString("full") => Some(TopLevelVConcatSpecBoundsFull)
      case JsString("flush") => Some(TopLevelVConcatSpecBoundsFlush)
      case _ => None
    }
  def encode(j: TopLevelVConcatSpecBounds): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingOrder (UnionType)
object SharedEncodingOrderCodec {
  def decode(j: JsValue): SharedEncodingOrder =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingOrder] =
    OrderFieldDefCodec.decodeOpt(j).orElse {
    ArrayOfOrderFieldDefCodec.decodeOpt(j).map { SharedEncodingOrderAsArrayOfOrderFieldDef(_) }.orElse {
    OrderValueDefCodec.decodeOpt(j) } } 
  def encode(j: SharedEncodingOrder): JsValue =
    j match {
      case x:OrderFieldDef /* TypeRef */ => OrderFieldDefCodec.encode(x)
      case SharedEncodingOrderAsArrayOfOrderFieldDef(x) /* Base, ArrayType */ => ArrayOfOrderFieldDefCodec.encode(x)
      case x:OrderValueDef /* TypeRef */ => OrderValueDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Blend (EnumType)
object BlendCodec {
  def decode(j: JsValue): Blend =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Blend] =
    j match {
      case JsNull => Some(BlendUndefined)
      case JsString("multiply") => Some(BlendMultiply)
      case JsString("screen") => Some(BlendScreen)
      case JsString("overlay") => Some(BlendOverlay)
      case JsString("darken") => Some(BlendDarken)
      case JsString("lighten") => Some(BlendLighten)
      case JsString("color-dodge") => Some(BlendColorDodge)
      case JsString("color-burn") => Some(BlendColorBurn)
      case JsString("hard-light") => Some(BlendHardLight)
      case JsString("soft-light") => Some(BlendSoftLight)
      case JsString("difference") => Some(BlendDifference)
      case JsString("exclusion") => Some(BlendExclusion)
      case JsString("hue") => Some(BlendHue)
      case JsString("saturation") => Some(BlendSaturation)
      case JsString("color") => Some(BlendColor)
      case JsString("luminosity") => Some(BlendLuminosity)
      case _ => None
    }
  def encode(j: Blend): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// TitleConfigLineHeight (UnionType)
object TitleConfigLineHeightCodec {
  def decode(j: JsValue): TitleConfigLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigLineHeight] =
    j.asOpt[JsNumber].map { TitleConfigLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleConfigLineHeight): JsValue =
    j match {
      case TitleConfigLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ImputeMethod (EnumType)
object ImputeMethodCodec {
  def decode(j: JsValue): ImputeMethod =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ImputeMethod] =
    j match {
      case JsString("value") => Some(ImputeMethodValue)
      case JsString("median") => Some(ImputeMethodMedian)
      case JsString("max") => Some(ImputeMethodMax)
      case JsString("min") => Some(ImputeMethodMin)
      case JsString("mean") => Some(ImputeMethodMean)
      case _ => None
    }
  def encode(j: ImputeMethod): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// OverlayMarkDefStrokeOffset (UnionType)
object OverlayMarkDefStrokeOffsetCodec {
  def decode(j: JsValue): OverlayMarkDefStrokeOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefStrokeOffset] =
    j.asOpt[JsNumber].map { OverlayMarkDefStrokeOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefStrokeOffset): JsValue =
    j match {
      case OverlayMarkDefStrokeOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// EventStreamAsObject1Filter (UnionType)
object EventStreamAsObject1FilterCodec {
  def decode(j: JsValue): EventStreamAsObject1Filter =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[EventStreamAsObject1Filter] =
    j.asOpt[String].map { EventStreamAsObject1FilterAsString(_) }.orElse {
    ArrayOfStringCodec.decodeOpt(j).map { EventStreamAsObject1FilterAsArrayOfString(_) } } 
  def encode(j: EventStreamAsObject1Filter): JsValue =
    j match {
      case EventStreamAsObject1FilterAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case EventStreamAsObject1FilterAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfTopLevelSelectionParameterViewsElement (ArrayType)
object ArrayOfTopLevelSelectionParameterViewsElementCodec {
  def decode(j: JsValue): Seq[TopLevelSelectionParameterViewsElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[TopLevelSelectionParameterViewsElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      TopLevelSelectionParameterViewsElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[TopLevelSelectionParameterViewsElement]): JsArray =
      JsArray(j.map { x => TopLevelSelectionParameterViewsElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// LegendConfigSymbolDirection (UnionType)
object LegendConfigSymbolDirectionCodec {
  def decode(j: JsValue): LegendConfigSymbolDirection =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigSymbolDirection] =
    OrientationCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigSymbolDirection): JsValue =
    j match {
      case x:Orientation /* TypeRef */ => OrientationCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingLatitude (StructType)
object SharedEncodingLatitudeCodec {
  def decode(j: JsValue): SharedEncodingLatitude =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingLatitude] =
    Some(SharedEncodingLatitude(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingLatitudeDatumCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingLatitudeBandPositionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => x.asOpt[JsNull.type].map { _ => JsNull } },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingLatitudeTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => SharedEncodingLatitudeTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingLatitude): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingLatitudeDatumCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingLatitudeBandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> Json.toJson(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingLatitudeTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> SharedEncodingLatitudeTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// HeaderLabelFontSize (UnionType)
object HeaderLabelFontSizeCodec {
  def decode(j: JsValue): HeaderLabelFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderLabelFontSize] =
    j.asOpt[JsNumber].map { HeaderLabelFontSizeAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderLabelFontSize): JsValue =
    j match {
      case HeaderLabelFontSizeAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigFillOpacityAsNumber (ConstrainedType)
object BarConfigFillOpacityAsNumberCodec {
  def decode(j: JsValue): BarConfigFillOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BarConfigFillOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { BarConfigFillOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: BarConfigFillOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// LegendConfigRowPadding (UnionType)
object LegendConfigRowPaddingCodec {
  def decode(j: JsValue): LegendConfigRowPadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigRowPadding] =
    j.asOpt[JsNumber].map { LegendConfigRowPaddingAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigRowPadding): JsValue =
    j match {
      case LegendConfigRowPaddingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTitleLimitAsNumber (ConstrainedType)
object AxisTitleLimitAsNumberCodec {
  def decode(j: JsValue): AxisTitleLimitAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AxisTitleLimitAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AxisTitleLimitAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AxisTitleLimitAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// BarConfigRadius (UnionType)
object BarConfigRadiusCodec {
  def decode(j: JsValue): BarConfigRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigRadius] =
    j.asOpt[JsNumber].map { BarConfigRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigRadius): JsValue =
    j match {
      case BarConfigRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionTranslate (UnionType)
object ProjectionTranslateCodec {
  def decode(j: JsValue): ProjectionTranslate =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionTranslate] =
    Vector2NumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionTranslate): JsValue =
    j match {
      case x:Vector2Number /* TypeRef */ => Vector2NumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigCornerRadiusBottomRight (UnionType)
object MarkConfigCornerRadiusBottomRightCodec {
  def decode(j: JsValue): MarkConfigCornerRadiusBottomRight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigCornerRadiusBottomRight] =
    j.asOpt[JsNumber].map { MarkConfigCornerRadiusBottomRightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigCornerRadiusBottomRight): JsValue =
    j match {
      case MarkConfigCornerRadiusBottomRightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfigType (UnionType)
object ProjectionConfigTypeCodec {
  def decode(j: JsValue): ProjectionConfigType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigType] =
    ProjectionTypeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigType): JsValue =
    j match {
      case x:ProjectionType /* TypeRef */ => ProjectionTypeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisGridWidthAsNumber (ConstrainedType)
object AxisGridWidthAsNumberCodec {
  def decode(j: JsValue): AxisGridWidthAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AxisGridWidthAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AxisGridWidthAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AxisGridWidthAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkDefTheta2Offset (UnionType)
object MarkDefTheta2OffsetCodec {
  def decode(j: JsValue): MarkDefTheta2Offset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefTheta2Offset] =
    j.asOpt[JsNumber].map { MarkDefTheta2OffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefTheta2Offset): JsValue =
    j match {
      case MarkDefTheta2OffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// GraticuleParams (StructType)
object GraticuleParamsCodec {
  def decode(j: JsValue): GraticuleParams =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[GraticuleParams] =
    Some(GraticuleParams(
      `extent` = (j \ "extent").asOpt[JsValue].flatMap { x => Vector2Vector2NumberCodec.decodeOpt(x) },
      `extentMajor` = (j \ "extentMajor").asOpt[JsValue].flatMap { x => Vector2Vector2NumberCodec.decodeOpt(x) },
      `stepMajor` = (j \ "stepMajor").asOpt[JsValue].flatMap { x => Vector2NumberCodec.decodeOpt(x) },
      `extentMinor` = (j \ "extentMinor").asOpt[JsValue].flatMap { x => Vector2Vector2NumberCodec.decodeOpt(x) },
      `stepMinor` = (j \ "stepMinor").asOpt[JsValue].flatMap { x => Vector2NumberCodec.decodeOpt(x) },
      `precision` = (j \ "precision").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `step` = (j \ "step").asOpt[JsValue].flatMap { x => Vector2NumberCodec.decodeOpt(x) },
    ))

  def encode(j: GraticuleParams): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`extent`.map { x => "extent" -> Vector2Vector2NumberCodec.encode(x) },
        j.`extentMajor`.map { x => "extentMajor" -> Vector2Vector2NumberCodec.encode(x) },
        j.`stepMajor`.map { x => "stepMajor" -> Vector2NumberCodec.encode(x) },
        j.`extentMinor`.map { x => "extentMinor" -> Vector2Vector2NumberCodec.encode(x) },
        j.`stepMinor`.map { x => "stepMinor" -> Vector2NumberCodec.encode(x) },
        j.`precision`.map { x => "precision" -> Json.toJson(x) },
        j.`step`.map { x => "step" -> Vector2NumberCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ScaleNice (UnionType)
object ScaleNiceCodec {
  def decode(j: JsValue): ScaleNice =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleNice] =
    ExprRefCodec.decodeOpt(j).orElse {
    j.asOpt[Boolean].map { ScaleNiceAsBool(_) }.orElse {
    TimeIntervalCodec.decodeOpt(j).orElse {
    TimeIntervalStepCodec.decodeOpt(j).orElse {
    j.asOpt[JsNumber].map { ScaleNiceAsNumber(_) } } } } } 
  def encode(j: ScaleNice): JsValue =
    j match {
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case ScaleNiceAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:TimeInterval /* TypeRef */ => TimeIntervalCodec.encode(x)
      case x:TimeIntervalStep /* TypeRef */ => TimeIntervalStepCodec.encode(x)
      case ScaleNiceAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RepeatRefRepeat (EnumType)
object RepeatRefRepeatCodec {
  def decode(j: JsValue): RepeatRefRepeat =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RepeatRefRepeat] =
    j match {
      case JsString("row") => Some(RepeatRefRepeatRow)
      case JsString("column") => Some(RepeatRefRepeatColumn)
      case JsString("repeat") => Some(RepeatRefRepeatRepeat)
      case JsString("layer") => Some(RepeatRefRepeatLayer)
      case _ => None
    }
  def encode(j: RepeatRefRepeat): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// SelectionInit (UnionType)
object SelectionInitCodec {
  def decode(j: JsValue): SelectionInit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SelectionInit] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j) } 
  def encode(j: SelectionInit): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PositionFieldDef (StructType)
object PositionFieldDefCodec {
  def decode(j: JsValue): PositionFieldDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[PositionFieldDef] =
    Some(PositionFieldDef(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `impute` = (j \ "impute").asOpt[JsValue].flatMap { x => ImputeParamsCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => PositionFieldDefBandPositionCodec.decodeOpt(x) },
      `stack` = (j \ "stack").asOpt[JsValue].flatMap { x => PositionFieldDefStackCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => PositionFieldDefBinCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => PositionFieldDefTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `axis` = (j \ "axis").asOpt[JsValue].flatMap { x => AxisCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) },
    ))

  def encode(j: PositionFieldDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`impute`.map { x => "impute" -> ImputeParamsCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> PositionFieldDefBandPositionCodec.encode(x) },
        j.`stack`.map { x => "stack" -> PositionFieldDefStackCodec.encode(x) },
        j.`bin`.map { x => "bin" -> PositionFieldDefBinCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> PositionFieldDefTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`axis`.map { x => "axis" -> AxisCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// MarkDefStyle (UnionType)
object MarkDefStyleCodec {
  def decode(j: JsValue): MarkDefStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefStyle] =
    j.asOpt[String].map { MarkDefStyleAsString(_) }.orElse {
    ArrayOfStringCodec.decodeOpt(j).map { MarkDefStyleAsArrayOfString(_) } } 
  def encode(j: MarkDefStyle): JsValue =
    j match {
      case MarkDefStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case MarkDefStyleAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MultiTimeUnit (UnionType)
object MultiTimeUnitCodec {
  def decode(j: JsValue): MultiTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MultiTimeUnit] =
    LocalMultiTimeUnitCodec.decodeOpt(j).orElse {
    UtcMultiTimeUnitCodec.decodeOpt(j) } 
  def encode(j: MultiTimeUnit): JsValue =
    j match {
      case x:LocalMultiTimeUnit /* TypeRef */ => LocalMultiTimeUnitCodec.encode(x)
      case x:UtcMultiTimeUnit /* TypeRef */ => UtcMultiTimeUnitCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisLabelOverlap (UnionType)
object AxisLabelOverlapCodec {
  def decode(j: JsValue): AxisLabelOverlap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisLabelOverlap] =
    LabelOverlapCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisLabelOverlap): JsValue =
    j match {
      case x:LabelOverlap /* TypeRef */ => LabelOverlapCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewBackgroundStrokeOpacity (UnionType)
object ViewBackgroundStrokeOpacityCodec {
  def decode(j: JsValue): ViewBackgroundStrokeOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewBackgroundStrokeOpacity] =
    ViewBackgroundStrokeOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ViewBackgroundStrokeOpacity): JsValue =
    j match {
      case x:ViewBackgroundStrokeOpacityAsNumber /* TypeRef */ => ViewBackgroundStrokeOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// EventStreamAsObject2 (StructType)
object EventStreamAsObject2Codec {
  def decode(j: JsValue): EventStreamAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[EventStreamAsObject2] =
    {
      val `source` = (j \ "source").asOpt[JsValue].flatMap { x => EventStreamAsObject2SourceCodec.decodeOpt(x) }
      if(`source`.isEmpty) { return None }
      val `marktype` = (j \ "marktype").asOpt[JsValue].flatMap { x => MarkTypeCodec.decodeOpt(x) }
      val `filter` = (j \ "filter").asOpt[JsValue].flatMap { x => EventStreamAsObject2FilterCodec.decodeOpt(x) }
      val `markname` = (j \ "markname").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `consume` = (j \ "consume").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `type` = (j \ "type").asOpt[JsValue].flatMap { x => WindowEventTypeCodec.decodeOpt(x) }
      if(`type`.isEmpty) { return None }
      val `debounce` = (j \ "debounce").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `between` = (j \ "between").asOpt[JsValue].flatMap { x => ArrayOfStreamCodec.decodeOpt(x) }
      val `throttle` = (j \ "throttle").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      return Some(EventStreamAsObject2(
        `source` = `source`.get,
        `marktype` = `marktype`,
        `filter` = `filter`,
        `markname` = `markname`,
        `consume` = `consume`,
        `type` = `type`.get,
        `debounce` = `debounce`,
        `between` = `between`,
        `throttle` = `throttle`,
      ))
    }

  def encode(j: EventStreamAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("source" -> EventStreamAsObject2SourceCodec.encode(j.`source`)),
        j.`marktype`.map { x => "marktype" -> MarkTypeCodec.encode(x) },
        j.`filter`.map { x => "filter" -> EventStreamAsObject2FilterCodec.encode(x) },
        j.`markname`.map { x => "markname" -> Json.toJson(x) },
        j.`consume`.map { x => "consume" -> Json.toJson(x) },
        Some("type" -> WindowEventTypeCodec.encode(j.`type`)),
        j.`debounce`.map { x => "debounce" -> Json.toJson(x) },
        j.`between`.map { x => "between" -> ArrayOfStreamCodec.encode(x) },
        j.`throttle`.map { x => "throttle" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeWidth (StructType)
object SharedEncodingStrokeWidthCodec {
  def decode(j: JsValue): SharedEncodingStrokeWidth =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeWidth] =
    Some(SharedEncodingStrokeWidth(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingStrokeWidthDatumCodec.decodeOpt(x) },
      `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingStrokeWidthBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => SharedEncodingStrokeWidthConditionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingStrokeWidthBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingStrokeWidthValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingStrokeWidthTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => SharedEncodingStrokeWidthTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingStrokeWidth): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingStrokeWidthDatumCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingStrokeWidthBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> SharedEncodingStrokeWidthConditionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingStrokeWidthBinCodec.encode(x) },
        j.`value`.map { x => "value" -> SharedEncodingStrokeWidthValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingStrokeWidthTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> SharedEncodingStrokeWidthTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AxisLabelBaseline (UnionType)
object AxisLabelBaselineCodec {
  def decode(j: JsValue): AxisLabelBaseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisLabelBaseline] =
    TextBaselineCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisLabelBaselineCodec.decodeOpt(j) } } 
  def encode(j: AxisLabelBaseline): JsValue =
    j match {
      case x:TextBaseline /* TypeRef */ => TextBaselineCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisLabelBaseline /* TypeRef */ => ConditionalAxisLabelBaselineCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullTimeUnit (UnionType)
object FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullTimeUnitCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewBackgroundStrokeMiterLimit (UnionType)
object ViewBackgroundStrokeMiterLimitCodec {
  def decode(j: JsValue): ViewBackgroundStrokeMiterLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewBackgroundStrokeMiterLimit] =
    j.asOpt[JsNumber].map { ViewBackgroundStrokeMiterLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ViewBackgroundStrokeMiterLimit): JsValue =
    j match {
      case ViewBackgroundStrokeMiterLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingYError2TimeUnit (UnionType)
object SharedEncodingYError2TimeUnitCodec {
  def decode(j: JsValue): SharedEncodingYError2TimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingYError2TimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingYError2TimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefYOffset (UnionType)
object MarkDefYOffsetCodec {
  def decode(j: JsValue): MarkDefYOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefYOffset] =
    j.asOpt[JsNumber].map { MarkDefYOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefYOffset): JsValue =
    j match {
      case MarkDefYOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullBandPosition (ConstrainedType)
object FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullBandPositionCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// HeaderLabelAlign (UnionType)
object HeaderLabelAlignCodec {
  def decode(j: JsValue): HeaderLabelAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderLabelAlign] =
    AlignCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderLabelAlign): JsValue =
    j match {
      case x:Align /* TypeRef */ => AlignCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigLabelFontWeight (UnionType)
object AxisConfigLabelFontWeightCodec {
  def decode(j: JsValue): AxisConfigLabelFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigLabelFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisLabelFontWeightCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigLabelFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisLabelFontWeight /* TypeRef */ => ConditionalAxisLabelFontWeightCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SphereGenerator (StructType)
object SphereGeneratorCodec {
  def decode(j: JsValue): SphereGenerator =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SphereGenerator] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `sphere` = (j \ "sphere").asOpt[JsValue].flatMap { x => SphereGeneratorSphereCodec.decodeOpt(x) }
      if(`sphere`.isEmpty) { return None }
      return Some(SphereGenerator(
        `name` = `name`,
        `sphere` = `sphere`.get,
      ))
    }

  def encode(j: SphereGenerator): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        Some("sphere" -> SphereGeneratorSphereCodec.encode(j.`sphere`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LegendConfigSymbolOffset (UnionType)
object LegendConfigSymbolOffsetCodec {
  def decode(j: JsValue): LegendConfigSymbolOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigSymbolOffset] =
    j.asOpt[JsNumber].map { LegendConfigSymbolOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigSymbolOffset): JsValue =
    j match {
      case LegendConfigSymbolOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// DomainUnionWith (StructType)
object DomainUnionWithCodec {
  def decode(j: JsValue): DomainUnionWith =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[DomainUnionWith] =
    {
      val `unionWith` = (j \ "unionWith").asOpt[JsValue].flatMap { x => DomainUnionWithUnionWithCodec.decodeOpt(x) }
      if(`unionWith`.isEmpty) { return None }
      return Some(DomainUnionWith(
        `unionWith` = `unionWith`.get,
      ))
    }

  def encode(j: DomainUnionWith): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("unionWith" -> DomainUnionWithUnionWithCodec.encode(j.`unionWith`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AxisOrient (EnumType)
object AxisOrientCodec {
  def decode(j: JsValue): AxisOrient =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisOrient] =
    j match {
      case JsString("top") => Some(AxisOrientTop)
      case JsString("bottom") => Some(AxisOrientBottom)
      case JsString("left") => Some(AxisOrientLeft)
      case JsString("right") => Some(AxisOrientRight)
      case _ => None
    }
  def encode(j: AxisOrient): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefStringNullExprRefAsObject1Value (UnionType)
object ConditionalPredicateValueDefStringNullExprRefAsObject1ValueCodec {
  def decode(j: JsValue): ConditionalPredicateValueDefStringNullExprRefAsObject1Value =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefStringNullExprRefAsObject1Value] =
    j.asOpt[String].map { ConditionalPredicateValueDefStringNullExprRefAsObject1ValueAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ConditionalPredicateValueDefStringNullExprRefAsObject1ValueAsNull } } 
  def encode(j: ConditionalPredicateValueDefStringNullExprRefAsObject1Value): JsValue =
    j match {
      case ConditionalPredicateValueDefStringNullExprRefAsObject1ValueAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case ConditionalPredicateValueDefStringNullExprRefAsObject1ValueAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigUrl (UnionType)
object AreaConfigUrlCodec {
  def decode(j: JsValue): AreaConfigUrl =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigUrl] =
    UriReferenceCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigUrl): JsValue =
    j match {
      case x:UriReference /* TypeRef */ => UriReferenceCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfImputeParamsFrameElement (ArrayType)
object ArrayOfImputeParamsFrameElementCodec {
  def decode(j: JsValue): Seq[ImputeParamsFrameElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[ImputeParamsFrameElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      ImputeParamsFrameElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[ImputeParamsFrameElement]): JsArray =
      JsArray(j.map { x => ImputeParamsFrameElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// ArrayOfAny (ArrayType)
object ArrayOfAnyCodec {
  def decode(j: JsValue): Seq[JsValue] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[JsValue]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      x.asOpt[JsValue].getOrElse { return None } } }
  def encode(j: Seq[JsValue]): JsArray =
      JsArray(j.map { x => Json.toJson(x) })
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefStrokeWidthAsNumber (ConstrainedType)
object OverlayMarkDefStrokeWidthAsNumberCodec {
  def decode(j: JsValue): OverlayMarkDefStrokeWidthAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[OverlayMarkDefStrokeWidthAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { OverlayMarkDefStrokeWidthAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: OverlayMarkDefStrokeWidthAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AreaConfigTension (UnionType)
object AreaConfigTensionCodec {
  def decode(j: JsValue): AreaConfigTension =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigTension] =
    j.asOpt[JsNumber].map { AreaConfigTensionAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigTension): JsValue =
    j match {
      case AreaConfigTensionAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefInterpolate (UnionType)
object OverlayMarkDefInterpolateCodec {
  def decode(j: JsValue): OverlayMarkDefInterpolate =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefInterpolate] =
    InterpolateCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefInterpolate): JsValue =
    j match {
      case x:Interpolate /* TypeRef */ => InterpolateCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefX2 (UnionType)
object OverlayMarkDefX2Codec {
  def decode(j: JsValue): OverlayMarkDefX2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefX2] =
    j.asOpt[JsNumber].map { OverlayMarkDefX2AsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: OverlayMarkDefX2): JsValue =
    j match {
      case OverlayMarkDefX2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigGradientStrokeWidth (UnionType)
object LegendConfigGradientStrokeWidthCodec {
  def decode(j: JsValue): LegendConfigGradientStrokeWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigGradientStrokeWidth] =
    LegendConfigGradientStrokeWidthAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigGradientStrokeWidth): JsValue =
    j match {
      case x:LegendConfigGradientStrokeWidthAsNumber /* TypeRef */ => LegendConfigGradientStrokeWidthAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeOpacityType (UnionType)
object SharedEncodingStrokeOpacityTypeCodec {
  def decode(j: JsValue): SharedEncodingStrokeOpacityType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeOpacityType] =
    StandardTypeCodec.decodeOpt(j).orElse {
    TypeCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingStrokeOpacityType): JsValue =
    j match {
      case x:StandardType /* TypeRef */ => StandardTypeCodec.encode(x)
      case x:Type /* TypeRef */ => TypeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefInnerRadius (UnionType)
object OverlayMarkDefInnerRadiusCodec {
  def decode(j: JsValue): OverlayMarkDefInnerRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefInnerRadius] =
    j.asOpt[JsNumber].map { OverlayMarkDefInnerRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefInnerRadius): JsValue =
    j match {
      case OverlayMarkDefInnerRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PositionDatumDefBaseStack (UnionType)
object PositionDatumDefBaseStackCodec {
  def decode(j: JsValue): PositionDatumDefBaseStack =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PositionDatumDefBaseStack] =
    StackOffsetCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => PositionDatumDefBaseStackAsNull }.orElse {
    j.asOpt[Boolean].map { PositionDatumDefBaseStackAsBool(_) } } } 
  def encode(j: PositionDatumDefBaseStack): JsValue =
    j match {
      case x:StackOffset /* TypeRef */ => StackOffsetCodec.encode(x)
      case PositionDatumDefBaseStackAsNull /* Global, NullType$ */ => JsNull
      case PositionDatumDefBaseStackAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleFrame (EnumType)
object TitleFrameCodec {
  def decode(j: JsValue): TitleFrame =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleFrame] =
    j match {
      case JsString("bounds") => Some(TitleFrameBounds)
      case JsString("group") => Some(TitleFrameGroup)
      case _ => None
    }
  def encode(j: TitleFrame): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// StringValueDefWithCondition (ConstrainedType)
// see StringValueDefWithCondition (StructType)

////////////////////////////////////////////////////////////////////////
// ShapeDef (UnionType)
object ShapeDefCodec {
  def decode(j: JsValue): ShapeDef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ShapeDef] =
    FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullCodec.decodeOpt(j).orElse {
    FieldOrDatumDefWithConditionDatumDefStringNullCodec.decodeOpt(j).orElse {
    ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullCodec.decodeOpt(j) } } 
  def encode(j: ShapeDef): JsValue =
    j match {
      case x:FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNull /* TypeRef */ => FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullCodec.encode(x)
      case x:FieldOrDatumDefWithConditionDatumDefStringNull /* TypeRef */ => FieldOrDatumDefWithConditionDatumDefStringNullCodec.encode(x)
      case x:ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNull /* TypeRef */ => ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LatLongFieldDefType (ConstantType)
object LatLongFieldDefTypeCodec {
  def decode(j: JsValue): LatLongFieldDefType =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LatLongFieldDefType] =
    j match {
      case JsString("quantitative") => Some(LatLongFieldDefType())
      case _ => None
    }
  def encode(j: LatLongFieldDefType): JsValue =
    JsString("quantitative")
}


////////////////////////////////////////////////////////////////////////
// FieldOneOfPredicateTimeUnit (UnionType)
object FieldOneOfPredicateTimeUnitCodec {
  def decode(j: JsValue): FieldOneOfPredicateTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOneOfPredicateTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: FieldOneOfPredicateTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SingleDefUnitChannel (EnumType)
object SingleDefUnitChannelCodec {
  def decode(j: JsValue): SingleDefUnitChannel =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SingleDefUnitChannel] =
    j match {
      case JsString("x") => Some(SingleDefUnitChannelX)
      case JsString("y") => Some(SingleDefUnitChannelY)
      case JsString("xOffset") => Some(SingleDefUnitChannelXOffset)
      case JsString("yOffset") => Some(SingleDefUnitChannelYOffset)
      case JsString("x2") => Some(SingleDefUnitChannelX2)
      case JsString("y2") => Some(SingleDefUnitChannelY2)
      case JsString("longitude") => Some(SingleDefUnitChannelLongitude)
      case JsString("latitude") => Some(SingleDefUnitChannelLatitude)
      case JsString("longitude2") => Some(SingleDefUnitChannelLongitude2)
      case JsString("latitude2") => Some(SingleDefUnitChannelLatitude2)
      case JsString("theta") => Some(SingleDefUnitChannelTheta)
      case JsString("theta2") => Some(SingleDefUnitChannelTheta2)
      case JsString("radius") => Some(SingleDefUnitChannelRadius)
      case JsString("radius2") => Some(SingleDefUnitChannelRadius2)
      case JsString("color") => Some(SingleDefUnitChannelColor)
      case JsString("fill") => Some(SingleDefUnitChannelFill)
      case JsString("stroke") => Some(SingleDefUnitChannelStroke)
      case JsString("opacity") => Some(SingleDefUnitChannelOpacity)
      case JsString("fillOpacity") => Some(SingleDefUnitChannelFillOpacity)
      case JsString("strokeOpacity") => Some(SingleDefUnitChannelStrokeOpacity)
      case JsString("strokeWidth") => Some(SingleDefUnitChannelStrokeWidth)
      case JsString("strokeDash") => Some(SingleDefUnitChannelStrokeDash)
      case JsString("size") => Some(SingleDefUnitChannelSize)
      case JsString("angle") => Some(SingleDefUnitChannelAngle)
      case JsString("shape") => Some(SingleDefUnitChannelShape)
      case JsString("key") => Some(SingleDefUnitChannelKey)
      case JsString("text") => Some(SingleDefUnitChannelText)
      case JsString("href") => Some(SingleDefUnitChannelHref)
      case JsString("url") => Some(SingleDefUnitChannelUrl)
      case JsString("description") => Some(SingleDefUnitChannelDescription)
      case _ => None
    }
  def encode(j: SingleDefUnitChannel): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// AxisMaxExtent (UnionType)
object AxisMaxExtentCodec {
  def decode(j: JsValue): AxisMaxExtent =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisMaxExtent] =
    j.asOpt[JsNumber].map { AxisMaxExtentAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisMaxExtent): JsValue =
    j match {
      case AxisMaxExtentAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsSubtitlePadding (UnionType)
object TitleParamsSubtitlePaddingCodec {
  def decode(j: JsValue): TitleParamsSubtitlePadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsSubtitlePadding] =
    j.asOpt[JsNumber].map { TitleParamsSubtitlePaddingAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleParamsSubtitlePadding): JsValue =
    j match {
      case TitleParamsSubtitlePaddingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefDy (UnionType)
object MarkDefDyCodec {
  def decode(j: JsValue): MarkDefDy =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefDy] =
    j.asOpt[JsNumber].map { MarkDefDyAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefDy): JsValue =
    j match {
      case MarkDefDyAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefFillOpacity (UnionType)
object OverlayMarkDefFillOpacityCodec {
  def decode(j: JsValue): OverlayMarkDefFillOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefFillOpacity] =
    OverlayMarkDefFillOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefFillOpacity): JsValue =
    j match {
      case x:OverlayMarkDefFillOpacityAsNumber /* TypeRef */ => OverlayMarkDefFillOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefInnerRadius (UnionType)
object MarkDefInnerRadiusCodec {
  def decode(j: JsValue): MarkDefInnerRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefInnerRadius] =
    j.asOpt[JsNumber].map { MarkDefInnerRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefInnerRadius): JsValue =
    j match {
      case MarkDefInnerRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LookupTransformAs (UnionType)
object LookupTransformAsCodec {
  def decode(j: JsValue): LookupTransformAs =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LookupTransformAs] =
    j.asOpt[String].map { LookupTransformAsAsString(_) }.orElse {
    ArrayOfStringCodec.decodeOpt(j).map { LookupTransformAsAsArrayOfString(_) } } 
  def encode(j: LookupTransformAs): JsValue =
    j match {
      case LookupTransformAsAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case LookupTransformAsAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SchemeParams (StructType)
object SchemeParamsCodec {
  def decode(j: JsValue): SchemeParams =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SchemeParams] =
    {
      val `count` = (j \ "count").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `extent` = (j \ "extent").asOpt[JsValue].flatMap { x => ArrayOfNumberCodec.decodeOpt(x) }
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`name`.isEmpty) { return None }
      return Some(SchemeParams(
        `count` = `count`,
        `extent` = `extent`,
        `name` = `name`.get,
      ))
    }

  def encode(j: SchemeParams): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`count`.map { x => "count" -> Json.toJson(x) },
        j.`extent`.map { x => "extent" -> ArrayOfNumberCodec.encode(x) },
        Some("name" -> Json.toJson(j.`name`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullValue (UnionType)
object ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullValueCodec {
  def decode(j: JsValue): ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullValue] =
    j.asOpt[String].map { ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullValueAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullValueAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullValue): JsValue =
    j match {
      case ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullValueAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullValueAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// True (ConstantType)
object TrueCodec {
  def decode(j: JsValue): True =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[True] =
    j match {
      case JsBoolean(true) => Some(True())
      case _ => None
    }
  def encode(j: True): JsValue =
    JsBoolean(true)
}


////////////////////////////////////////////////////////////////////////
// AxisConfigGridCap (UnionType)
object AxisConfigGridCapCodec {
  def decode(j: JsValue): AxisConfigGridCap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigGridCap] =
    StrokeCapCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigGridCap): JsValue =
    j match {
      case x:StrokeCap /* TypeRef */ => StrokeCapCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ParseValue (UnionType)
object ParseValueCodec {
  def decode(j: JsValue): ParseValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ParseValue] =
    j.asOpt[String].map { ParseValueAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ParseValueAsNull }.orElse {
    StringConstCodec.decodeOpt(j).orElse {
    DateCodec.decodeOpt(j).orElse {
    BooleanConstCodec.decodeOpt(j).orElse {
    NumberCodec.decodeOpt(j) } } } } } 
  def encode(j: ParseValue): JsValue =
    j match {
      case ParseValueAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case ParseValueAsNull /* Global, NullType$ */ => JsNull
      case x:StringConst /* TypeRef */ => StringConstCodec.encode(x)
      case x:Date /* TypeRef */ => DateCodec.encode(x)
      case x:BooleanConst /* TypeRef */ => BooleanConstCodec.encode(x)
      case x:Number /* TypeRef */ => NumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfNumber (ArrayType)
object ArrayOfNumberCodec {
  def decode(j: JsValue): Seq[JsNumber] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[JsNumber]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      x.asOpt[JsNumber].getOrElse { return None } } }
  def encode(j: Seq[JsNumber]): JsArray =
      JsArray(j.map { x => Json.toJson(x) })
}

////////////////////////////////////////////////////////////////////////
// TopLevelVConcatSpecPadding (UnionType)
object TopLevelVConcatSpecPaddingCodec {
  def decode(j: JsValue): TopLevelVConcatSpecPadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelVConcatSpecPadding] =
    PaddingCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TopLevelVConcatSpecPadding): JsValue =
    j match {
      case x:Padding /* TypeRef */ => PaddingCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTitleFont (UnionType)
object AxisTitleFontCodec {
  def decode(j: JsValue): AxisTitleFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTitleFont] =
    j.asOpt[String].map { AxisTitleFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisTitleFont): JsValue =
    j match {
      case AxisTitleFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTickDashOffset (UnionType)
object AxisTickDashOffsetCodec {
  def decode(j: JsValue): AxisTickDashOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTickDashOffset] =
    j.asOpt[JsNumber].map { AxisTickDashOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisTickDashOffset): JsValue =
    j match {
      case AxisTickDashOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefStringNullExprRef (UnionType)
object ConditionalPredicateValueDefStringNullExprRefCodec {
  def decode(j: JsValue): ConditionalPredicateValueDefStringNullExprRef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefStringNullExprRef] =
    ConditionalPredicateValueDefStringNullExprRefAsObject1Codec.decodeOpt(j).orElse {
    ConditionalPredicateValueDefStringNullExprRefAsObject2Codec.decodeOpt(j) } 
  def encode(j: ConditionalPredicateValueDefStringNullExprRef): JsValue =
    j match {
      case x:ConditionalPredicateValueDefStringNullExprRefAsObject1 /* TypeRef */ => ConditionalPredicateValueDefStringNullExprRefAsObject1Codec.encode(x)
      case x:ConditionalPredicateValueDefStringNullExprRefAsObject2 /* TypeRef */ => ConditionalPredicateValueDefStringNullExprRefAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionStringFieldDefTextTimeUnit (UnionType)
object FieldOrDatumDefWithConditionStringFieldDefTextTimeUnitCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionStringFieldDefTextTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionStringFieldDefTextTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: FieldOrDatumDefWithConditionStringFieldDefTextTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfSingleDefUnitChannel (ArrayType)
object ArrayOfSingleDefUnitChannelCodec {
  def decode(j: JsValue): Seq[SingleDefUnitChannel] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[SingleDefUnitChannel]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      SingleDefUnitChannelCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[SingleDefUnitChannel]): JsArray =
      JsArray(j.map { x => SingleDefUnitChannelCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// MarkConfigCornerRadiusTopRight (UnionType)
object MarkConfigCornerRadiusTopRightCodec {
  def decode(j: JsValue): MarkConfigCornerRadiusTopRight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigCornerRadiusTopRight] =
    j.asOpt[JsNumber].map { MarkConfigCornerRadiusTopRightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigCornerRadiusTopRight): JsValue =
    j match {
      case MarkConfigCornerRadiusTopRightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigTooltip (UnionType)
object MarkConfigTooltipCodec {
  def decode(j: JsValue): MarkConfigTooltip =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigTooltip] =
    j.asOpt[String].map { MarkConfigTooltipAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => MarkConfigTooltipAsNull }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    TooltipContentCodec.decodeOpt(j).orElse {
    j.asOpt[Boolean].map { MarkConfigTooltipAsBool(_) }.orElse {
    j.asOpt[JsNumber].map { MarkConfigTooltipAsNumber(_) } } } } } } 
  def encode(j: MarkConfigTooltip): JsValue =
    j match {
      case MarkConfigTooltipAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case MarkConfigTooltipAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:TooltipContent /* TypeRef */ => TooltipContentCodec.encode(x)
      case MarkConfigTooltipAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case MarkConfigTooltipAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingXOffsetType (UnionType)
object SharedEncodingXOffsetTypeCodec {
  def decode(j: JsValue): SharedEncodingXOffsetType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingXOffsetType] =
    StandardTypeCodec.decodeOpt(j).orElse {
    TypeCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingXOffsetType): JsValue =
    j match {
      case x:StandardType /* TypeRef */ => StandardTypeCodec.encode(x)
      case x:Type /* TypeRef */ => TypeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigX (UnionType)
object LineConfigXCodec {
  def decode(j: JsValue): LineConfigX =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigX] =
    j.asOpt[JsNumber].map { LineConfigXAsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: LineConfigX): JsValue =
    j match {
      case LineConfigXAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTitlePadding (UnionType)
object AxisTitlePaddingCodec {
  def decode(j: JsValue): AxisTitlePadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTitlePadding] =
    j.asOpt[JsNumber].map { AxisTitlePaddingAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisTitlePadding): JsValue =
    j match {
      case AxisTitlePaddingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfConditionalPredicateValueDefFontWeightNullExprRef (ArrayType)
object ArrayOfConditionalPredicateValueDefFontWeightNullExprRefCodec {
  def decode(j: JsValue): Seq[ConditionalPredicateValueDefFontWeightNullExprRef] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[ConditionalPredicateValueDefFontWeightNullExprRef]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      ConditionalPredicateValueDefFontWeightNullExprRefCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[ConditionalPredicateValueDefFontWeightNullExprRef]): JsArray =
      JsArray(j.map { x => ConditionalPredicateValueDefFontWeightNullExprRefCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// ViewBackgroundFillOpacity (UnionType)
object ViewBackgroundFillOpacityCodec {
  def decode(j: JsValue): ViewBackgroundFillOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewBackgroundFillOpacity] =
    ViewBackgroundFillOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ViewBackgroundFillOpacity): JsValue =
    j match {
      case x:ViewBackgroundFillOpacityAsNumber /* TypeRef */ => ViewBackgroundFillOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfConditionalPredicateValueDefNumberNullExprRef (ArrayType)
object ArrayOfConditionalPredicateValueDefNumberNullExprRefCodec {
  def decode(j: JsValue): Seq[ConditionalPredicateValueDefNumberNullExprRef] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[ConditionalPredicateValueDefNumberNullExprRef]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      ConditionalPredicateValueDefNumberNullExprRefCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[ConditionalPredicateValueDefNumberNullExprRef]): JsArray =
      JsArray(j.map { x => ConditionalPredicateValueDefNumberNullExprRefCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// FieldEqualPredicate (StructType)
object FieldEqualPredicateCodec {
  def decode(j: JsValue): FieldEqualPredicate =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldEqualPredicate] =
    {
      val `equal` = (j \ "equal").asOpt[JsValue].flatMap { x => FieldEqualPredicateEqualCodec.decodeOpt(x) }
      if(`equal`.isEmpty) { return None }
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`field`.isEmpty) { return None }
      val `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => FieldEqualPredicateTimeUnitCodec.decodeOpt(x) }
      return Some(FieldEqualPredicate(
        `equal` = `equal`.get,
        `field` = `field`.get,
        `timeUnit` = `timeUnit`,
      ))
    }

  def encode(j: FieldEqualPredicate): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("equal" -> FieldEqualPredicateEqualCodec.encode(j.`equal`)),
        Some("field" -> Json.toJson(j.`field`)),
        j.`timeUnit`.map { x => "timeUnit" -> FieldEqualPredicateTimeUnitCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingRadius2Datum (UnionType)
object SharedEncodingRadius2DatumCodec {
  def decode(j: JsValue): SharedEncodingRadius2Datum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingRadius2Datum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingRadius2Datum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisLabelAlignAsObject1Condition (UnionType)
object ConditionalAxisLabelAlignAsObject1ConditionCodec {
  def decode(j: JsValue): ConditionalAxisLabelAlignAsObject1Condition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisLabelAlignAsObject1Condition] =
    ConditionalPredicateValueDefAlignNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalPredicateValueDefAlignNullExprRefCodec.decodeOpt(j).map { ConditionalAxisLabelAlignAsObject1ConditionAsArrayOfConditionalPredicateValueDefAlignNullExprRef(_) } } 
  def encode(j: ConditionalAxisLabelAlignAsObject1Condition): JsValue =
    j match {
      case x:ConditionalPredicateValueDefAlignNullExprRef /* TypeRef */ => ConditionalPredicateValueDefAlignNullExprRefCodec.encode(x)
      case ConditionalAxisLabelAlignAsObject1ConditionAsArrayOfConditionalPredicateValueDefAlignNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalPredicateValueDefAlignNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RangeConfigHeatmap (UnionType)
object RangeConfigHeatmapCodec {
  def decode(j: JsValue): RangeConfigHeatmap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RangeConfigHeatmap] =
    RangeSchemeCodec.decodeOpt(j).orElse {
    ArrayOfColorCodec.decodeOpt(j).map { RangeConfigHeatmapAsArrayOfColor(_) } } 
  def encode(j: RangeConfigHeatmap): JsValue =
    j match {
      case x:RangeScheme /* TypeRef */ => RangeSchemeCodec.encode(x)
      case RangeConfigHeatmapAsArrayOfColor(x) /* Base, ArrayType */ => ArrayOfColorCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigX2 (UnionType)
object MarkConfigX2Codec {
  def decode(j: JsValue): MarkConfigX2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigX2] =
    j.asOpt[JsNumber].map { MarkConfigX2AsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: MarkConfigX2): JsValue =
    j match {
      case MarkConfigX2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigZindex (ConstrainedType)
object AxisConfigZindexCodec {
  def decode(j: JsValue): AxisConfigZindex =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AxisConfigZindex] =
    try {
      j.asOpt[JsNumber]
        .map { AxisConfigZindex(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AxisConfigZindex): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// LegendConfigLabelFontWeight (UnionType)
object LegendConfigLabelFontWeightCodec {
  def decode(j: JsValue): LegendConfigLabelFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigLabelFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigLabelFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsOrient (UnionType)
object TitleParamsOrientCodec {
  def decode(j: JsValue): TitleParamsOrient =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsOrient] =
    TitleOrientCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleParamsOrient): JsValue =
    j match {
      case x:TitleOrient /* TypeRef */ => TitleOrientCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ErrorBarConfigRule (UnionType)
object ErrorBarConfigRuleCodec {
  def decode(j: JsValue): ErrorBarConfigRule =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ErrorBarConfigRule] =
    j.asOpt[Boolean].map { ErrorBarConfigRuleAsBool(_) }.orElse {
    MarkConfigCodec.decodeOpt(j) } 
  def encode(j: ErrorBarConfigRule): JsValue =
    j match {
      case ErrorBarConfigRuleAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:MarkConfig /* TypeRef */ => MarkConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldLTEPredicate (StructType)
object FieldLTEPredicateCodec {
  def decode(j: JsValue): FieldLTEPredicate =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldLTEPredicate] =
    {
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`field`.isEmpty) { return None }
      val `lte` = (j \ "lte").asOpt[JsValue].flatMap { x => FieldLTEPredicateLteCodec.decodeOpt(x) }
      if(`lte`.isEmpty) { return None }
      val `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => FieldLTEPredicateTimeUnitCodec.decodeOpt(x) }
      return Some(FieldLTEPredicate(
        `field` = `field`.get,
        `lte` = `lte`.get,
        `timeUnit` = `timeUnit`,
      ))
    }

  def encode(j: FieldLTEPredicate): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("field" -> Json.toJson(j.`field`)),
        Some("lte" -> FieldLTEPredicateLteCodec.encode(j.`lte`)),
        j.`timeUnit`.map { x => "timeUnit" -> FieldLTEPredicateTimeUnitCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AreaConfigCornerRadiusBottomLeft (UnionType)
object AreaConfigCornerRadiusBottomLeftCodec {
  def decode(j: JsValue): AreaConfigCornerRadiusBottomLeft =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigCornerRadiusBottomLeft] =
    j.asOpt[JsNumber].map { AreaConfigCornerRadiusBottomLeftAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigCornerRadiusBottomLeft): JsValue =
    j match {
      case AreaConfigCornerRadiusBottomLeftAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigStroke (UnionType)
object AreaConfigStrokeCodec {
  def decode(j: JsValue): AreaConfigStroke =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigStroke] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => AreaConfigStrokeAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: AreaConfigStroke): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case AreaConfigStrokeAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisResolveMap (StructType)
object AxisResolveMapCodec {
  def decode(j: JsValue): AxisResolveMap =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AxisResolveMap] =
    Some(AxisResolveMap(
      `x` = (j \ "x").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `y` = (j \ "y").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
    ))

  def encode(j: AxisResolveMap): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`x`.map { x => "x" -> ResolveModeCodec.encode(x) },
        j.`y`.map { x => "y" -> ResolveModeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingColorTimeUnit (UnionType)
object SharedEncodingColorTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingColorTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingColorTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingColorTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigAspect (UnionType)
object TickConfigAspectCodec {
  def decode(j: JsValue): TickConfigAspect =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigAspect] =
    j.asOpt[Boolean].map { TickConfigAspectAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigAspect): JsValue =
    j match {
      case TickConfigAspectAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigInterpolate (UnionType)
object MarkConfigInterpolateCodec {
  def decode(j: JsValue): MarkConfigInterpolate =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigInterpolate] =
    InterpolateCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigInterpolate): JsValue =
    j match {
      case x:Interpolate /* TypeRef */ => InterpolateCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConfigParamsElement (UnionType)
object ConfigParamsElementCodec {
  def decode(j: JsValue): ConfigParamsElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConfigParamsElement] =
    VariableParameterCodec.decodeOpt(j).orElse {
    TopLevelSelectionParameterCodec.decodeOpt(j) } 
  def encode(j: ConfigParamsElement): JsValue =
    j match {
      case x:VariableParameter /* TypeRef */ => VariableParameterCodec.encode(x)
      case x:TopLevelSelectionParameter /* TypeRef */ => TopLevelSelectionParameterCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigInnerRadius (ConstrainedType)
// see RectConfigInnerRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// AreaConfigCursor (UnionType)
object AreaConfigCursorCodec {
  def decode(j: JsValue): AreaConfigCursor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigCursor] =
    CursorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigCursor): JsValue =
    j match {
      case x:Cursor /* TypeRef */ => CursorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelHConcatSpecTitle (UnionType)
object TopLevelHConcatSpecTitleCodec {
  def decode(j: JsValue): TopLevelHConcatSpecTitle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelHConcatSpecTitle] =
    TextCodec.decodeOpt(j).orElse {
    TitleParamsCodec.decodeOpt(j) } 
  def encode(j: TopLevelHConcatSpecTitle): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:TitleParams /* TypeRef */ => TitleParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTickDash (UnionType)
object AxisTickDashCodec {
  def decode(j: JsValue): AxisTickDash =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTickDash] =
    ArrayOfNumberCodec.decodeOpt(j).map { AxisTickDashAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberArrayCodec.decodeOpt(j) } } 
  def encode(j: AxisTickDash): JsValue =
    j match {
      case AxisTickDashAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumberArray /* TypeRef */ => ConditionalAxisNumberArrayCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigStyle (UnionType)
object AxisConfigStyleCodec {
  def decode(j: JsValue): AxisConfigStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigStyle] =
    j.asOpt[String].map { AxisConfigStyleAsString(_) }.orElse {
    ArrayOfStringCodec.decodeOpt(j).map { AxisConfigStyleAsArrayOfString(_) } } 
  def encode(j: AxisConfigStyle): JsValue =
    j match {
      case AxisConfigStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case AxisConfigStyleAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TextDirection (EnumType)
object TextDirectionCodec {
  def decode(j: JsValue): TextDirection =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TextDirection] =
    j match {
      case JsString("ltr") => Some(TextDirectionLtr)
      case JsString("rtl") => Some(TextDirectionRtl)
      case _ => None
    }
  def encode(j: TextDirection): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// ArgminDef (StructType)
object ArgminDefCodec {
  def decode(j: JsValue): ArgminDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ArgminDef] =
    {
      val `argmin` = (j \ "argmin").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`argmin`.isEmpty) { return None }
      return Some(ArgminDef(
        `argmin` = `argmin`.get,
      ))
    }

  def encode(j: ArgminDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("argmin" -> Json.toJson(j.`argmin`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// VConcatSpecGenericSpecTitle (UnionType)
object VConcatSpecGenericSpecTitleCodec {
  def decode(j: JsValue): VConcatSpecGenericSpecTitle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[VConcatSpecGenericSpecTitle] =
    TextCodec.decodeOpt(j).orElse {
    TitleParamsCodec.decodeOpt(j) } 
  def encode(j: VConcatSpecGenericSpecTitle): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:TitleParams /* TypeRef */ => TitleParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingLongitude (StructType)
object SharedEncodingLongitudeCodec {
  def decode(j: JsValue): SharedEncodingLongitude =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingLongitude] =
    Some(SharedEncodingLongitude(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingLongitudeDatumCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingLongitudeBandPositionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => x.asOpt[JsNull.type].map { _ => JsNull } },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingLongitudeTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => SharedEncodingLongitudeTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingLongitude): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingLongitudeDatumCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingLongitudeBandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> Json.toJson(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingLongitudeTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> SharedEncodingLongitudeTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ArrayOfBool (ArrayType)
object ArrayOfBoolCodec {
  def decode(j: JsValue): Seq[Boolean] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[Boolean]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      x.asOpt[Boolean].getOrElse { return None } } }
  def encode(j: Seq[Boolean]): JsArray =
      JsArray(j.map { x => Json.toJson(x) })
}

////////////////////////////////////////////////////////////////////////
// HeaderConfigTitleColor (UnionType)
object HeaderConfigTitleColorCodec {
  def decode(j: JsValue): HeaderConfigTitleColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigTitleColor] =
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderConfigTitleColor): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BinExtentAsArray (ConstrainedType)
object BinExtentAsArrayCodec {
  def decode(j: JsValue): BinExtentAsArray =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BinExtentAsArray] =
    try {
      ArrayOfNumberCodec.decodeOpt(j)
        .map { BinExtentAsArray(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: BinExtentAsArray): JsValue =
    ArrayOfNumberCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// BarConfigAngleAsNumber (ConstrainedType)
object BarConfigAngleAsNumberCodec {
  def decode(j: JsValue): BarConfigAngleAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BarConfigAngleAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { BarConfigAngleAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: BarConfigAngleAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// TickConfigRadius (UnionType)
object TickConfigRadiusCodec {
  def decode(j: JsValue): TickConfigRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigRadius] =
    j.asOpt[JsNumber].map { TickConfigRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigRadius): JsValue =
    j match {
      case TickConfigRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingY2Datum (UnionType)
object SharedEncodingY2DatumCodec {
  def decode(j: JsValue): SharedEncodingY2Datum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingY2Datum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingY2Datum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// StringFieldDefWithCondition (StructType)
object StringFieldDefWithConditionCodec {
  def decode(j: JsValue): StringFieldDefWithCondition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[StringFieldDefWithCondition] =
    Some(StringFieldDefWithCondition(
      `format` = (j \ "format").asOpt[JsValue].flatMap { x => StringFieldDefWithConditionFormatCodec.decodeOpt(x) },
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => StringFieldDefWithConditionBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => StringFieldDefWithConditionConditionCodec.decodeOpt(x) },
      `formatType` = (j \ "formatType").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => StringFieldDefWithConditionBinCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => StringFieldDefWithConditionTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) },
    ))

  def encode(j: StringFieldDefWithCondition): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`format`.map { x => "format" -> StringFieldDefWithConditionFormatCodec.encode(x) },
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> StringFieldDefWithConditionBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> StringFieldDefWithConditionConditionCodec.encode(x) },
        j.`formatType`.map { x => "formatType" -> Json.toJson(x) },
        j.`bin`.map { x => "bin" -> StringFieldDefWithConditionBinCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> StringFieldDefWithConditionTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AxisConfigTickMinStep (UnionType)
object AxisConfigTickMinStepCodec {
  def decode(j: JsValue): AxisConfigTickMinStep =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTickMinStep] =
    j.asOpt[JsNumber].map { AxisConfigTickMinStepAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigTickMinStep): JsValue =
    j match {
      case AxisConfigTickMinStepAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// DictOfSelectionInit (MapType)
object DictOfSelectionInitCodec {
  def decode(j: JsValue): Map[String,SelectionInit] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Map[String,SelectionInit]] =
    j.asOpt[Map[String,JsValue]].map { _.mapValues { x => 
      SelectionInitCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Map[String,SelectionInit]): JsObject =
      JsObject(j.mapValues { x => SelectionInitCodec.encode(x) })
}


////////////////////////////////////////////////////////////////////////
// OverlayMarkDefAspect (UnionType)
object OverlayMarkDefAspectCodec {
  def decode(j: JsValue): OverlayMarkDefAspect =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefAspect] =
    j.asOpt[Boolean].map { OverlayMarkDefAspectAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefAspect): JsValue =
    j match {
      case OverlayMarkDefAspectAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingLatitudeDatum (UnionType)
object SharedEncodingLatitudeDatumCodec {
  def decode(j: JsValue): SharedEncodingLatitudeDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingLatitudeDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingLatitudeDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PointSelectionConfigType (ConstantType)
object PointSelectionConfigTypeCodec {
  def decode(j: JsValue): PointSelectionConfigType =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[PointSelectionConfigType] =
    j match {
      case JsString("point") => Some(PointSelectionConfigType())
      case _ => None
    }
  def encode(j: PointSelectionConfigType): JsValue =
    JsString("point")
}


////////////////////////////////////////////////////////////////////////
// BinParamsDivide (ConstrainedType)
object BinParamsDivideCodec {
  def decode(j: JsValue): BinParamsDivide =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BinParamsDivide] =
    try {
      ArrayOfNumberCodec.decodeOpt(j)
        .map { BinParamsDivide(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: BinParamsDivide): JsValue =
    ArrayOfNumberCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// AreaConfigOpacity (UnionType)
object AreaConfigOpacityCodec {
  def decode(j: JsValue): AreaConfigOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigOpacity] =
    j.asOpt[JsNumber].map { AreaConfigOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigOpacity): JsValue =
    j match {
      case AreaConfigOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigBaseline (UnionType)
object LineConfigBaselineCodec {
  def decode(j: JsValue): LineConfigBaseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigBaseline] =
    TextBaselineCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigBaseline): JsValue =
    j match {
      case x:TextBaseline /* TypeRef */ => TextBaselineCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RowColNumber (StructType)
object RowColNumberCodec {
  def decode(j: JsValue): RowColNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RowColNumber] =
    Some(RowColNumber(
      `column` = (j \ "column").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `row` = (j \ "row").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
    ))

  def encode(j: RowColNumber): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`column`.map { x => "column" -> Json.toJson(x) },
        j.`row`.map { x => "row" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// OverlayMarkDefDy (UnionType)
object OverlayMarkDefDyCodec {
  def decode(j: JsValue): OverlayMarkDefDy =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefDy] =
    j.asOpt[JsNumber].map { OverlayMarkDefDyAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefDy): JsValue =
    j match {
      case OverlayMarkDefDyAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisLabelBaseline (UnionType)
object ConditionalAxisLabelBaselineCodec {
  def decode(j: JsValue): ConditionalAxisLabelBaseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisLabelBaseline] =
    ConditionalAxisLabelBaselineAsObject1Codec.decodeOpt(j).orElse {
    ConditionalAxisLabelBaselineAsObject2Codec.decodeOpt(j) } 
  def encode(j: ConditionalAxisLabelBaseline): JsValue =
    j match {
      case x:ConditionalAxisLabelBaselineAsObject1 /* TypeRef */ => ConditionalAxisLabelBaselineAsObject1Codec.encode(x)
      case x:ConditionalAxisLabelBaselineAsObject2 /* TypeRef */ => ConditionalAxisLabelBaselineAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderTitleFontWeight (UnionType)
object HeaderTitleFontWeightCodec {
  def decode(j: JsValue): HeaderTitleFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderTitleFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderTitleFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelFacetSpecTitle (UnionType)
object TopLevelFacetSpecTitleCodec {
  def decode(j: JsValue): TopLevelFacetSpecTitle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelFacetSpecTitle] =
    TextCodec.decodeOpt(j).orElse {
    TitleParamsCodec.decodeOpt(j) } 
  def encode(j: TopLevelFacetSpecTitle): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:TitleParams /* TypeRef */ => TitleParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingY2BandPosition (ConstrainedType)
object SharedEncodingY2BandPositionCodec {
  def decode(j: JsValue): SharedEncodingY2BandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingY2BandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingY2BandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingY2BandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// HeaderConfigLabelPadding (UnionType)
object HeaderConfigLabelPaddingCodec {
  def decode(j: JsValue): HeaderConfigLabelPadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigLabelPadding] =
    j.asOpt[JsNumber].map { HeaderConfigLabelPaddingAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderConfigLabelPadding): JsValue =
    j match {
      case HeaderConfigLabelPaddingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullCondition (UnionType)
object ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullConditionCodec {
  def decode(j: JsValue): ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullCondition] =
    ConditionalMarkPropFieldOrDatumDefTypeForShapeCodec.decodeOpt(j).orElse {
    ConditionalValueDefStringNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefStringNullExprRefCodec.decodeOpt(j).map { ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullConditionAsArrayOfConditionalValueDefStringNullExprRef(_) } } } 
  def encode(j: ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullCondition): JsValue =
    j match {
      case x:ConditionalMarkPropFieldOrDatumDefTypeForShape /* TypeRef */ => ConditionalMarkPropFieldOrDatumDefTypeForShapeCodec.encode(x)
      case x:ConditionalValueDefStringNullExprRef /* TypeRef */ => ConditionalValueDefStringNullExprRefCodec.encode(x)
      case ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNullConditionAsArrayOfConditionalValueDefStringNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefStringNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionScale (UnionType)
object ProjectionScaleCodec {
  def decode(j: JsValue): ProjectionScale =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionScale] =
    j.asOpt[JsNumber].map { ProjectionScaleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionScale): JsValue =
    j match {
      case ProjectionScaleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Unaggregated (ConstantType)
object UnaggregatedCodec {
  def decode(j: JsValue): Unaggregated =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Unaggregated] =
    j match {
      case JsString("unaggregated") => Some(Unaggregated())
      case _ => None
    }
  def encode(j: Unaggregated): JsValue =
    JsString("unaggregated")
}


////////////////////////////////////////////////////////////////////////
// AreaConfigLine (UnionType)
object AreaConfigLineCodec {
  def decode(j: JsValue): AreaConfigLine =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigLine] =
    j.asOpt[Boolean].map { AreaConfigLineAsBool(_) }.orElse {
    OverlayMarkDefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigLine): JsValue =
    j match {
      case AreaConfigLineAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:OverlayMarkDef /* TypeRef */ => OverlayMarkDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsZindex (ConstrainedType)
object TitleParamsZindexCodec {
  def decode(j: JsValue): TitleParamsZindex =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TitleParamsZindex] =
    try {
      j.asOpt[JsNumber]
        .map { TitleParamsZindex(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: TitleParamsZindex): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AxisConfigBandPosition (UnionType)
object AxisConfigBandPositionCodec {
  def decode(j: JsValue): AxisConfigBandPosition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigBandPosition] =
    j.asOpt[JsNumber].map { AxisConfigBandPositionAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigBandPosition): JsValue =
    j match {
      case AxisConfigBandPositionAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigLabelAngleAsNumber (ConstrainedType)
object AxisConfigLabelAngleAsNumberCodec {
  def decode(j: JsValue): AxisConfigLabelAngleAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AxisConfigLabelAngleAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AxisConfigLabelAngleAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AxisConfigLabelAngleAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AreaConfigRadius2 (UnionType)
object AreaConfigRadius2Codec {
  def decode(j: JsValue): AreaConfigRadius2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigRadius2] =
    j.asOpt[JsNumber].map { AreaConfigRadius2AsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigRadius2): JsValue =
    j match {
      case AreaConfigRadius2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Cursor (EnumType)
object CursorCodec {
  def decode(j: JsValue): Cursor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Cursor] =
    j match {
      case JsString("auto") => Some(CursorAuto)
      case JsString("default") => Some(CursorDefault)
      case JsString("none") => Some(CursorNone)
      case JsString("context-menu") => Some(CursorContextMenu)
      case JsString("help") => Some(CursorHelp)
      case JsString("pointer") => Some(CursorPointer)
      case JsString("progress") => Some(CursorProgress)
      case JsString("wait") => Some(CursorWait)
      case JsString("cell") => Some(CursorCell)
      case JsString("crosshair") => Some(CursorCrosshair)
      case JsString("text") => Some(CursorText)
      case JsString("vertical-text") => Some(CursorVerticalText)
      case JsString("alias") => Some(CursorAlias)
      case JsString("copy") => Some(CursorCopy)
      case JsString("move") => Some(CursorMove)
      case JsString("no-drop") => Some(CursorNoDrop)
      case JsString("not-allowed") => Some(CursorNotAllowed)
      case JsString("e-resize") => Some(CursorEResize)
      case JsString("n-resize") => Some(CursorNResize)
      case JsString("ne-resize") => Some(CursorNeResize)
      case JsString("nw-resize") => Some(CursorNwResize)
      case JsString("s-resize") => Some(CursorSResize)
      case JsString("se-resize") => Some(CursorSeResize)
      case JsString("sw-resize") => Some(CursorSwResize)
      case JsString("w-resize") => Some(CursorWResize)
      case JsString("ew-resize") => Some(CursorEwResize)
      case JsString("ns-resize") => Some(CursorNsResize)
      case JsString("nesw-resize") => Some(CursorNeswResize)
      case JsString("nwse-resize") => Some(CursorNwseResize)
      case JsString("col-resize") => Some(CursorColResize)
      case JsString("row-resize") => Some(CursorRowResize)
      case JsString("all-scroll") => Some(CursorAllScroll)
      case JsString("zoom-in") => Some(CursorZoomIn)
      case JsString("zoom-out") => Some(CursorZoomOut)
      case JsString("grab") => Some(CursorGrab)
      case JsString("grabbing") => Some(CursorGrabbing)
      case _ => None
    }
  def encode(j: Cursor): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingDetail (UnionType)
object SharedEncodingDetailCodec {
  def decode(j: JsValue): SharedEncodingDetail =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingDetail] =
    FieldDefWithoutScaleCodec.decodeOpt(j).orElse {
    ArrayOfFieldDefWithoutScaleCodec.decodeOpt(j).map { SharedEncodingDetailAsArrayOfFieldDefWithoutScale(_) } } 
  def encode(j: SharedEncodingDetail): JsValue =
    j match {
      case x:FieldDefWithoutScale /* TypeRef */ => FieldDefWithoutScaleCodec.encode(x)
      case SharedEncodingDetailAsArrayOfFieldDefWithoutScale(x) /* Base, ArrayType */ => ArrayOfFieldDefWithoutScaleCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterMarkPropFieldOrDatumDefAsObject2Datum (UnionType)
object ConditionalParameterMarkPropFieldOrDatumDefAsObject2DatumCodec {
  def decode(j: JsValue): ConditionalParameterMarkPropFieldOrDatumDefAsObject2Datum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalParameterMarkPropFieldOrDatumDefAsObject2Datum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: ConditionalParameterMarkPropFieldOrDatumDefAsObject2Datum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1 (StructType)
object ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1Codec {
  def decode(j: JsValue): ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1] =
    {
      val `empty` = (j \ "empty").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) }
      val `param` = (j \ "param").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`param`.isEmpty) { return None }
      val `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1BandPositionCodec.decodeOpt(x) }
      val `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1BinCodec.decodeOpt(x) }
      val `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) }
      val `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1TimeUnitCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) }
      val `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeForShapeCodec.decodeOpt(x) }
      return Some(ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1(
        `empty` = `empty`,
        `field` = `field`,
        `param` = `param`.get,
        `scale` = `scale`,
        `legend` = `legend`,
        `bandPosition` = `bandPosition`,
        `bin` = `bin`,
        `aggregate` = `aggregate`,
        `timeUnit` = `timeUnit`,
        `title` = `title`,
        `sort` = `sort`,
        `type` = `type`,
      ))
    }

  def encode(j: ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`empty`.map { x => "empty" -> Json.toJson(x) },
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        Some("param" -> Json.toJson(j.`param`)),
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1BandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1BinCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1TimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeForShapeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AreaConfigStrokeOffset (UnionType)
object AreaConfigStrokeOffsetCodec {
  def decode(j: JsValue): AreaConfigStrokeOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigStrokeOffset] =
    j.asOpt[JsNumber].map { AreaConfigStrokeOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigStrokeOffset): JsValue =
    j match {
      case AreaConfigStrokeOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LogicalOrPredicate (StructType)
object LogicalOrPredicateCodec {
  def decode(j: JsValue): LogicalOrPredicate =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LogicalOrPredicate] =
    {
      val `or` = (j \ "or").asOpt[JsValue].flatMap { x => ArrayOfPredicateCompositionCodec.decodeOpt(x) }
      if(`or`.isEmpty) { return None }
      return Some(LogicalOrPredicate(
        `or` = `or`.get,
      ))
    }

  def encode(j: LogicalOrPredicate): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("or" -> ArrayOfPredicateCompositionCodec.encode(j.`or`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionDatumDefNumberBandPosition (ConstrainedType)
object FieldOrDatumDefWithConditionDatumDefNumberBandPositionCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionDatumDefNumberBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionDatumDefNumberBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { FieldOrDatumDefWithConditionDatumDefNumberBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: FieldOrDatumDefWithConditionDatumDefNumberBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkConfigText (UnionType)
object MarkConfigTextCodec {
  def decode(j: JsValue): MarkConfigText =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigText] =
    TextCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigText): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefAlignNullExprRef (UnionType)
object ConditionalPredicateValueDefAlignNullExprRefCodec {
  def decode(j: JsValue): ConditionalPredicateValueDefAlignNullExprRef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefAlignNullExprRef] =
    ConditionalPredicateValueDefAlignNullExprRefAsObject1Codec.decodeOpt(j).orElse {
    ConditionalPredicateValueDefAlignNullExprRefAsObject2Codec.decodeOpt(j) } 
  def encode(j: ConditionalPredicateValueDefAlignNullExprRef): JsValue =
    j match {
      case x:ConditionalPredicateValueDefAlignNullExprRefAsObject1 /* TypeRef */ => ConditionalPredicateValueDefAlignNullExprRefAsObject1Codec.encode(x)
      case x:ConditionalPredicateValueDefAlignNullExprRefAsObject2 /* TypeRef */ => ConditionalPredicateValueDefAlignNullExprRefAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTitleLineHeight (UnionType)
object AxisConfigTitleLineHeightCodec {
  def decode(j: JsValue): AxisConfigTitleLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTitleLineHeight] =
    j.asOpt[JsNumber].map { AxisConfigTitleLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigTitleLineHeight): JsValue =
    j match {
      case AxisConfigTitleLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigSize (ConstrainedType)
// see LineConfigSize (UnionType)

////////////////////////////////////////////////////////////////////////
// DateTimeSeconds (ConstrainedType)
object DateTimeSecondsCodec {
  def decode(j: JsValue): DateTimeSeconds =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[DateTimeSeconds] =
    try {
      j.asOpt[JsNumber]
        .map { DateTimeSeconds(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: DateTimeSeconds): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// TimeUnit (UnionType)
object TimeUnitCodec {
  def decode(j: JsValue): TimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TimeUnit] =
    SingleTimeUnitCodec.decodeOpt(j).orElse {
    MultiTimeUnitCodec.decodeOpt(j) } 
  def encode(j: TimeUnit): JsValue =
    j match {
      case x:SingleTimeUnit /* TypeRef */ => SingleTimeUnitCodec.encode(x)
      case x:MultiTimeUnit /* TypeRef */ => MultiTimeUnitCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConcatSpecGenericSpecCenter (UnionType)
object ConcatSpecGenericSpecCenterCodec {
  def decode(j: JsValue): ConcatSpecGenericSpecCenter =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConcatSpecGenericSpecCenter] =
    j.asOpt[Boolean].map { ConcatSpecGenericSpecCenterAsBool(_) }.orElse {
    RowColBooleanCodec.decodeOpt(j) } 
  def encode(j: ConcatSpecGenericSpecCenter): JsValue =
    j match {
      case ConcatSpecGenericSpecCenterAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:RowColBoolean /* TypeRef */ => RowColBooleanCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelUnitSpecTitle (UnionType)
object TopLevelUnitSpecTitleCodec {
  def decode(j: JsValue): TopLevelUnitSpecTitle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelUnitSpecTitle] =
    TextCodec.decodeOpt(j).orElse {
    TitleParamsCodec.decodeOpt(j) } 
  def encode(j: TopLevelUnitSpecTitle): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:TitleParams /* TypeRef */ => TitleParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterValueDefTextExprRefValue (UnionType)
object ConditionalParameterValueDefTextExprRefValueCodec {
  def decode(j: JsValue): ConditionalParameterValueDefTextExprRefValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalParameterValueDefTextExprRefValue] =
    TextCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ConditionalParameterValueDefTextExprRefValue): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AggregateTransform (StructType)
object AggregateTransformCodec {
  def decode(j: JsValue): AggregateTransform =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AggregateTransform] =
    {
      val `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => ArrayOfAggregatedFieldDefCodec.decodeOpt(x) }
      if(`aggregate`.isEmpty) { return None }
      val `groupby` = (j \ "groupby").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) }
      return Some(AggregateTransform(
        `aggregate` = `aggregate`.get,
        `groupby` = `groupby`,
      ))
    }

  def encode(j: AggregateTransform): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("aggregate" -> ArrayOfAggregatedFieldDefCodec.encode(j.`aggregate`)),
        j.`groupby`.map { x => "groupby" -> ArrayOfStringCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingXValue (UnionType)
object SharedEncodingXValueCodec {
  def decode(j: JsValue): SharedEncodingXValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingXValue] =
    j.asOpt[JsNumber].map { SharedEncodingXValueAsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingXValue): JsValue =
    j match {
      case SharedEncodingXValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetSpecSpacing (UnionType)
object FacetSpecSpacingCodec {
  def decode(j: JsValue): FacetSpecSpacing =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetSpecSpacing] =
    j.asOpt[JsNumber].map { FacetSpecSpacingAsNumber(_) }.orElse {
    RowColNumberCodec.decodeOpt(j) } 
  def encode(j: FacetSpecSpacing): JsValue =
    j match {
      case FacetSpecSpacingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:RowColNumber /* TypeRef */ => RowColNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigFill (UnionType)
object RectConfigFillCodec {
  def decode(j: JsValue): RectConfigFill =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigFill] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => RectConfigFillAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: RectConfigFill): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case RectConfigFillAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BoxPlotDefRule (UnionType)
object BoxPlotDefRuleCodec {
  def decode(j: JsValue): BoxPlotDefRule =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BoxPlotDefRule] =
    j.asOpt[Boolean].map { BoxPlotDefRuleAsBool(_) }.orElse {
    MarkConfigCodec.decodeOpt(j) } 
  def encode(j: BoxPlotDefRule): JsValue =
    j match {
      case BoxPlotDefRuleAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:MarkConfig /* TypeRef */ => MarkConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingXOffset (StructType)
object SharedEncodingXOffsetCodec {
  def decode(j: JsValue): SharedEncodingXOffset =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingXOffset] =
    Some(SharedEncodingXOffset(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingXOffsetDatumCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingXOffsetBandPositionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingXOffsetBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingXOffsetTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => SharedEncodingXOffsetTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingXOffset): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingXOffsetDatumCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingXOffsetBandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingXOffsetBinCodec.encode(x) },
        j.`value`.map { x => "value" -> Json.toJson(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingXOffsetTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> SharedEncodingXOffsetTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// BarConfigOpacity (UnionType)
object BarConfigOpacityCodec {
  def decode(j: JsValue): BarConfigOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigOpacity] =
    j.asOpt[JsNumber].map { BarConfigOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigOpacity): JsValue =
    j match {
      case BarConfigOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingShapeDatum (UnionType)
object SharedEncodingShapeDatumCodec {
  def decode(j: JsValue): SharedEncodingShapeDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingShapeDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingShapeDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigBandWithNestedOffsetPaddingInner (UnionType)
object ScaleConfigBandWithNestedOffsetPaddingInnerCodec {
  def decode(j: JsValue): ScaleConfigBandWithNestedOffsetPaddingInner =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleConfigBandWithNestedOffsetPaddingInner] =
    j.asOpt[JsNumber].map { ScaleConfigBandWithNestedOffsetPaddingInnerAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleConfigBandWithNestedOffsetPaddingInner): JsValue =
    j match {
      case ScaleConfigBandWithNestedOffsetPaddingInnerAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleRound (UnionType)
object ScaleRoundCodec {
  def decode(j: JsValue): ScaleRound =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleRound] =
    j.asOpt[Boolean].map { ScaleRoundAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleRound): JsValue =
    j match {
      case ScaleRoundAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigLabelOffset (UnionType)
object LegendConfigLabelOffsetCodec {
  def decode(j: JsValue): LegendConfigLabelOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigLabelOffset] =
    LegendConfigLabelOffsetAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigLabelOffset): JsValue =
    j match {
      case x:LegendConfigLabelOffsetAsNumber /* TypeRef */ => LegendConfigLabelOffsetAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigDy (UnionType)
object LineConfigDyCodec {
  def decode(j: JsValue): LineConfigDy =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigDy] =
    j.asOpt[JsNumber].map { LineConfigDyAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigDy): JsValue =
    j match {
      case LineConfigDyAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullCondition (UnionType)
object FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullConditionCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullCondition] =
    ConditionalValueDefGradientStringNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefGradientStringNullExprRefCodec.decodeOpt(j).map { FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullConditionAsArrayOfConditionalValueDefGradientStringNullExprRef(_) } } 
  def encode(j: FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullCondition): JsValue =
    j match {
      case x:ConditionalValueDefGradientStringNullExprRef /* TypeRef */ => ConditionalValueDefGradientStringNullExprRefCodec.encode(x)
      case FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullConditionAsArrayOfConditionalValueDefGradientStringNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefGradientStringNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PositionDatumDef (StructType)
object PositionDatumDefCodec {
  def decode(j: JsValue): PositionDatumDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[PositionDatumDef] =
    Some(PositionDatumDef(
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => PositionDatumDefBandPositionCodec.decodeOpt(x) },
      `stack` = (j \ "stack").asOpt[JsValue].flatMap { x => PositionDatumDefStackCodec.decodeOpt(x) },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => PositionDatumDefDatumCodec.decodeOpt(x) },
      `impute` = (j \ "impute").asOpt[JsValue].flatMap { x => ImputeParamsCodec.decodeOpt(x).map { Some(_) }.flatten },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `axis` = (j \ "axis").asOpt[JsValue].flatMap { x => AxisCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeCodec.decodeOpt(x) },
    ))

  def encode(j: PositionDatumDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> PositionDatumDefBandPositionCodec.encode(x) },
        j.`stack`.map { x => "stack" -> PositionDatumDefStackCodec.encode(x) },
        j.`datum`.map { x => "datum" -> PositionDatumDefDatumCodec.encode(x) },
        j.`impute`.map { x => "impute" -> ImputeParamsCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`axis`.map { x => "axis" -> AxisCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefNumberExprRefValue (UnionType)
object ConditionalPredicateValueDefNumberExprRefValueCodec {
  def decode(j: JsValue): ConditionalPredicateValueDefNumberExprRefValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefNumberExprRefValue] =
    j.asOpt[JsNumber].map { ConditionalPredicateValueDefNumberExprRefValueAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ConditionalPredicateValueDefNumberExprRefValue): JsValue =
    j match {
      case ConditionalPredicateValueDefNumberExprRefValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigDescription (UnionType)
object AreaConfigDescriptionCodec {
  def decode(j: JsValue): AreaConfigDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigDescription] =
    j.asOpt[String].map { AreaConfigDescriptionAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigDescription): JsValue =
    j match {
      case AreaConfigDescriptionAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigZindexAsNumber (ConstrainedType)
object LegendConfigZindexAsNumberCodec {
  def decode(j: JsValue): LegendConfigZindexAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LegendConfigZindexAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { LegendConfigZindexAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: LegendConfigZindexAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// Encoding (StructType)
object EncodingCodec {
  def decode(j: JsValue): Encoding =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Encoding] =
    Some(Encoding(
      `x` = (j \ "x").asOpt[JsValue].flatMap { x => PositionDefCodec.decodeOpt(x) },
      `longitude2` = (j \ "longitude2").asOpt[JsValue].flatMap { x => Position2DefCodec.decodeOpt(x) },
      `url` = (j \ "url").asOpt[JsValue].flatMap { x => EncodingUrlCodec.decodeOpt(x) },
      `fillOpacity` = (j \ "fillOpacity").asOpt[JsValue].flatMap { x => NumericMarkPropDefCodec.decodeOpt(x) },
      `text` = (j \ "text").asOpt[JsValue].flatMap { x => TextDefCodec.decodeOpt(x) },
      `key` = (j \ "key").asOpt[JsValue].flatMap { x => FieldDefWithoutScaleCodec.decodeOpt(x) },
      `radius2` = (j \ "radius2").asOpt[JsValue].flatMap { x => Position2DefCodec.decodeOpt(x) },
      `yError2` = (j \ "yError2").asOpt[JsValue].flatMap { x => EncodingYError2Codec.decodeOpt(x) },
      `yError` = (j \ "yError").asOpt[JsValue].flatMap { x => EncodingYErrorCodec.decodeOpt(x) },
      `yOffset` = (j \ "yOffset").asOpt[JsValue].flatMap { x => OffsetDefCodec.decodeOpt(x) },
      `xOffset` = (j \ "xOffset").asOpt[JsValue].flatMap { x => OffsetDefCodec.decodeOpt(x) },
      `size` = (j \ "size").asOpt[JsValue].flatMap { x => NumericMarkPropDefCodec.decodeOpt(x) },
      `latitude` = (j \ "latitude").asOpt[JsValue].flatMap { x => LatLongDefCodec.decodeOpt(x) },
      `y` = (j \ "y").asOpt[JsValue].flatMap { x => PositionDefCodec.decodeOpt(x) },
      `strokeOpacity` = (j \ "strokeOpacity").asOpt[JsValue].flatMap { x => NumericMarkPropDefCodec.decodeOpt(x) },
      `description` = (j \ "description").asOpt[JsValue].flatMap { x => EncodingDescriptionCodec.decodeOpt(x) },
      `angle` = (j \ "angle").asOpt[JsValue].flatMap { x => NumericMarkPropDefCodec.decodeOpt(x) },
      `stroke` = (j \ "stroke").asOpt[JsValue].flatMap { x => ColorDefCodec.decodeOpt(x) },
      `color` = (j \ "color").asOpt[JsValue].flatMap { x => ColorDefCodec.decodeOpt(x) },
      `x2` = (j \ "x2").asOpt[JsValue].flatMap { x => Position2DefCodec.decodeOpt(x) },
      `radius` = (j \ "radius").asOpt[JsValue].flatMap { x => PolarDefCodec.decodeOpt(x) },
      `longitude` = (j \ "longitude").asOpt[JsValue].flatMap { x => LatLongDefCodec.decodeOpt(x) },
      `order` = (j \ "order").asOpt[JsValue].flatMap { x => EncodingOrderCodec.decodeOpt(x) },
      `fill` = (j \ "fill").asOpt[JsValue].flatMap { x => ColorDefCodec.decodeOpt(x) },
      `theta` = (j \ "theta").asOpt[JsValue].flatMap { x => PolarDefCodec.decodeOpt(x) },
      `y2` = (j \ "y2").asOpt[JsValue].flatMap { x => Position2DefCodec.decodeOpt(x) },
      `xError` = (j \ "xError").asOpt[JsValue].flatMap { x => EncodingXErrorCodec.decodeOpt(x) },
      `tooltip` = (j \ "tooltip").asOpt[JsValue].flatMap { x => EncodingTooltipCodec.decodeOpt(x) },
      `latitude2` = (j \ "latitude2").asOpt[JsValue].flatMap { x => Position2DefCodec.decodeOpt(x) },
      `detail` = (j \ "detail").asOpt[JsValue].flatMap { x => EncodingDetailCodec.decodeOpt(x) },
      `shape` = (j \ "shape").asOpt[JsValue].flatMap { x => ShapeDefCodec.decodeOpt(x) },
      `opacity` = (j \ "opacity").asOpt[JsValue].flatMap { x => NumericMarkPropDefCodec.decodeOpt(x) },
      `href` = (j \ "href").asOpt[JsValue].flatMap { x => EncodingHrefCodec.decodeOpt(x) },
      `strokeDash` = (j \ "strokeDash").asOpt[JsValue].flatMap { x => NumericArrayMarkPropDefCodec.decodeOpt(x) },
      `xError2` = (j \ "xError2").asOpt[JsValue].flatMap { x => EncodingXError2Codec.decodeOpt(x) },
      `strokeWidth` = (j \ "strokeWidth").asOpt[JsValue].flatMap { x => NumericMarkPropDefCodec.decodeOpt(x) },
      `theta2` = (j \ "theta2").asOpt[JsValue].flatMap { x => Position2DefCodec.decodeOpt(x) },
    ))

  def encode(j: Encoding): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`x`.map { x => "x" -> PositionDefCodec.encode(x) },
        j.`longitude2`.map { x => "longitude2" -> Position2DefCodec.encode(x) },
        j.`url`.map { x => "url" -> EncodingUrlCodec.encode(x) },
        j.`fillOpacity`.map { x => "fillOpacity" -> NumericMarkPropDefCodec.encode(x) },
        j.`text`.map { x => "text" -> TextDefCodec.encode(x) },
        j.`key`.map { x => "key" -> FieldDefWithoutScaleCodec.encode(x) },
        j.`radius2`.map { x => "radius2" -> Position2DefCodec.encode(x) },
        j.`yError2`.map { x => "yError2" -> EncodingYError2Codec.encode(x) },
        j.`yError`.map { x => "yError" -> EncodingYErrorCodec.encode(x) },
        j.`yOffset`.map { x => "yOffset" -> OffsetDefCodec.encode(x) },
        j.`xOffset`.map { x => "xOffset" -> OffsetDefCodec.encode(x) },
        j.`size`.map { x => "size" -> NumericMarkPropDefCodec.encode(x) },
        j.`latitude`.map { x => "latitude" -> LatLongDefCodec.encode(x) },
        j.`y`.map { x => "y" -> PositionDefCodec.encode(x) },
        j.`strokeOpacity`.map { x => "strokeOpacity" -> NumericMarkPropDefCodec.encode(x) },
        j.`description`.map { x => "description" -> EncodingDescriptionCodec.encode(x) },
        j.`angle`.map { x => "angle" -> NumericMarkPropDefCodec.encode(x) },
        j.`stroke`.map { x => "stroke" -> ColorDefCodec.encode(x) },
        j.`color`.map { x => "color" -> ColorDefCodec.encode(x) },
        j.`x2`.map { x => "x2" -> Position2DefCodec.encode(x) },
        j.`radius`.map { x => "radius" -> PolarDefCodec.encode(x) },
        j.`longitude`.map { x => "longitude" -> LatLongDefCodec.encode(x) },
        j.`order`.map { x => "order" -> EncodingOrderCodec.encode(x) },
        j.`fill`.map { x => "fill" -> ColorDefCodec.encode(x) },
        j.`theta`.map { x => "theta" -> PolarDefCodec.encode(x) },
        j.`y2`.map { x => "y2" -> Position2DefCodec.encode(x) },
        j.`xError`.map { x => "xError" -> EncodingXErrorCodec.encode(x) },
        j.`tooltip`.map { x => "tooltip" -> EncodingTooltipCodec.encode(x) },
        j.`latitude2`.map { x => "latitude2" -> Position2DefCodec.encode(x) },
        j.`detail`.map { x => "detail" -> EncodingDetailCodec.encode(x) },
        j.`shape`.map { x => "shape" -> ShapeDefCodec.encode(x) },
        j.`opacity`.map { x => "opacity" -> NumericMarkPropDefCodec.encode(x) },
        j.`href`.map { x => "href" -> EncodingHrefCodec.encode(x) },
        j.`strokeDash`.map { x => "strokeDash" -> NumericArrayMarkPropDefCodec.encode(x) },
        j.`xError2`.map { x => "xError2" -> EncodingXError2Codec.encode(x) },
        j.`strokeWidth`.map { x => "strokeWidth" -> NumericMarkPropDefCodec.encode(x) },
        j.`theta2`.map { x => "theta2" -> Position2DefCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConfigBackground (UnionType)
object ConfigBackgroundCodec {
  def decode(j: JsValue): ConfigBackground =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConfigBackground] =
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ConfigBackground): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderConfigLabelColor (UnionType)
object HeaderConfigLabelColorCodec {
  def decode(j: JsValue): HeaderConfigLabelColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigLabelColor] =
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderConfigLabelColor): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisStyle (UnionType)
object AxisStyleCodec {
  def decode(j: JsValue): AxisStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisStyle] =
    j.asOpt[String].map { AxisStyleAsString(_) }.orElse {
    ArrayOfStringCodec.decodeOpt(j).map { AxisStyleAsArrayOfString(_) } } 
  def encode(j: AxisStyle): JsValue =
    j match {
      case AxisStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case AxisStyleAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionStringDatumDefTextBandPosition (ConstrainedType)
object FieldOrDatumDefWithConditionStringDatumDefTextBandPositionCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionStringDatumDefTextBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionStringDatumDefTextBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { FieldOrDatumDefWithConditionStringDatumDefTextBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: FieldOrDatumDefWithConditionStringDatumDefTextBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// RectConfigTheta (UnionType)
object RectConfigThetaCodec {
  def decode(j: JsValue): RectConfigTheta =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigTheta] =
    j.asOpt[JsNumber].map { RectConfigThetaAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigTheta): JsValue =
    j match {
      case RectConfigThetaAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingX2TimeUnit (UnionType)
object SharedEncodingX2TimeUnitCodec {
  def decode(j: JsValue): SharedEncodingX2TimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingX2TimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingX2TimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// UtcSingleTimeUnit (EnumType)
object UtcSingleTimeUnitCodec {
  def decode(j: JsValue): UtcSingleTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[UtcSingleTimeUnit] =
    j match {
      case JsString("utcyear") => Some(UtcSingleTimeUnitUtcyear)
      case JsString("utcquarter") => Some(UtcSingleTimeUnitUtcquarter)
      case JsString("utcmonth") => Some(UtcSingleTimeUnitUtcmonth)
      case JsString("utcweek") => Some(UtcSingleTimeUnitUtcweek)
      case JsString("utcday") => Some(UtcSingleTimeUnitUtcday)
      case JsString("utcdayofyear") => Some(UtcSingleTimeUnitUtcdayofyear)
      case JsString("utcdate") => Some(UtcSingleTimeUnitUtcdate)
      case JsString("utchours") => Some(UtcSingleTimeUnitUtchours)
      case JsString("utcminutes") => Some(UtcSingleTimeUnitUtcminutes)
      case JsString("utcseconds") => Some(UtcSingleTimeUnitUtcseconds)
      case JsString("utcmilliseconds") => Some(UtcSingleTimeUnitUtcmilliseconds)
      case _ => None
    }
  def encode(j: UtcSingleTimeUnit): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// LineConfigAria (UnionType)
object LineConfigAriaCodec {
  def decode(j: JsValue): LineConfigAria =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigAria] =
    j.asOpt[Boolean].map { LineConfigAriaAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigAria): JsValue =
    j match {
      case LineConfigAriaAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleResolveMap (StructType)
object ScaleResolveMapCodec {
  def decode(j: JsValue): ScaleResolveMap =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ScaleResolveMap] =
    Some(ScaleResolveMap(
      `x` = (j \ "x").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `fillOpacity` = (j \ "fillOpacity").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `color` = (j \ "color").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `radius` = (j \ "radius").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `strokeDash` = (j \ "strokeDash").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `yOffset` = (j \ "yOffset").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `strokeWidth` = (j \ "strokeWidth").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `xOffset` = (j \ "xOffset").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `size` = (j \ "size").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `y` = (j \ "y").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `strokeOpacity` = (j \ "strokeOpacity").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `angle` = (j \ "angle").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `stroke` = (j \ "stroke").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `fill` = (j \ "fill").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `theta` = (j \ "theta").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `shape` = (j \ "shape").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `opacity` = (j \ "opacity").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
    ))

  def encode(j: ScaleResolveMap): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`x`.map { x => "x" -> ResolveModeCodec.encode(x) },
        j.`fillOpacity`.map { x => "fillOpacity" -> ResolveModeCodec.encode(x) },
        j.`color`.map { x => "color" -> ResolveModeCodec.encode(x) },
        j.`radius`.map { x => "radius" -> ResolveModeCodec.encode(x) },
        j.`strokeDash`.map { x => "strokeDash" -> ResolveModeCodec.encode(x) },
        j.`yOffset`.map { x => "yOffset" -> ResolveModeCodec.encode(x) },
        j.`strokeWidth`.map { x => "strokeWidth" -> ResolveModeCodec.encode(x) },
        j.`xOffset`.map { x => "xOffset" -> ResolveModeCodec.encode(x) },
        j.`size`.map { x => "size" -> ResolveModeCodec.encode(x) },
        j.`y`.map { x => "y" -> ResolveModeCodec.encode(x) },
        j.`strokeOpacity`.map { x => "strokeOpacity" -> ResolveModeCodec.encode(x) },
        j.`angle`.map { x => "angle" -> ResolveModeCodec.encode(x) },
        j.`stroke`.map { x => "stroke" -> ResolveModeCodec.encode(x) },
        j.`fill`.map { x => "fill" -> ResolveModeCodec.encode(x) },
        j.`theta`.map { x => "theta" -> ResolveModeCodec.encode(x) },
        j.`shape`.map { x => "shape" -> ResolveModeCodec.encode(x) },
        j.`opacity`.map { x => "opacity" -> ResolveModeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject1Spacing (UnionType)
object TopLevelRepeatSpecAsObject1SpacingCodec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject1Spacing =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject1Spacing] =
    j.asOpt[JsNumber].map { TopLevelRepeatSpecAsObject1SpacingAsNumber(_) }.orElse {
    RowColNumberCodec.decodeOpt(j) } 
  def encode(j: TopLevelRepeatSpecAsObject1Spacing): JsValue =
    j match {
      case TopLevelRepeatSpecAsObject1SpacingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:RowColNumber /* TypeRef */ => RowColNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfigSpacing (UnionType)
object ProjectionConfigSpacingCodec {
  def decode(j: JsValue): ProjectionConfigSpacing =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigSpacing] =
    j.asOpt[JsNumber].map { ProjectionConfigSpacingAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigSpacing): JsValue =
    j match {
      case ProjectionConfigSpacingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionSize (UnionType)
object ProjectionSizeCodec {
  def decode(j: JsValue): ProjectionSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionSize] =
    Vector2NumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionSize): JsValue =
    j match {
      case x:Vector2Number /* TypeRef */ => Vector2NumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingShapeBin (UnionType)
object SharedEncodingShapeBinCodec {
  def decode(j: JsValue): SharedEncodingShapeBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingShapeBin] =
    j.asOpt[Boolean].map { SharedEncodingShapeBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingShapeBinAsNull } } } 
  def encode(j: SharedEncodingShapeBin): JsValue =
    j match {
      case SharedEncodingShapeBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case SharedEncodingShapeBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigEllipsis (UnionType)
object LineConfigEllipsisCodec {
  def decode(j: JsValue): LineConfigEllipsis =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigEllipsis] =
    j.asOpt[String].map { LineConfigEllipsisAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigEllipsis): JsValue =
    j match {
      case LineConfigEllipsisAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigAspect (UnionType)
object RectConfigAspectCodec {
  def decode(j: JsValue): RectConfigAspect =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigAspect] =
    j.asOpt[Boolean].map { RectConfigAspectAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigAspect): JsValue =
    j match {
      case RectConfigAspectAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigBaseline (UnionType)
object AreaConfigBaselineCodec {
  def decode(j: JsValue): AreaConfigBaseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigBaseline] =
    TextBaselineCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigBaseline): JsValue =
    j match {
      case x:TextBaseline /* TypeRef */ => TextBaselineCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisNumberArrayAsObject2Condition (UnionType)
object ConditionalAxisNumberArrayAsObject2ConditionCodec {
  def decode(j: JsValue): ConditionalAxisNumberArrayAsObject2Condition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisNumberArrayAsObject2Condition] =
    ConditionalPredicateValueDefNumberNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalPredicateValueDefNumberNullExprRefCodec.decodeOpt(j).map { ConditionalAxisNumberArrayAsObject2ConditionAsArrayOfConditionalPredicateValueDefNumberNullExprRef(_) } } 
  def encode(j: ConditionalAxisNumberArrayAsObject2Condition): JsValue =
    j match {
      case x:ConditionalPredicateValueDefNumberNullExprRef /* TypeRef */ => ConditionalPredicateValueDefNumberNullExprRefCodec.encode(x)
      case ConditionalAxisNumberArrayAsObject2ConditionAsArrayOfConditionalPredicateValueDefNumberNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalPredicateValueDefNumberNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelFacetSpecSpacing (UnionType)
object TopLevelFacetSpecSpacingCodec {
  def decode(j: JsValue): TopLevelFacetSpecSpacing =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelFacetSpecSpacing] =
    j.asOpt[JsNumber].map { TopLevelFacetSpecSpacingAsNumber(_) }.orElse {
    RowColNumberCodec.decodeOpt(j) } 
  def encode(j: TopLevelFacetSpecSpacing): JsValue =
    j match {
      case TopLevelFacetSpecSpacingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:RowColNumber /* TypeRef */ => RowColNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// CompositionConfig (StructType)
object CompositionConfigCodec {
  def decode(j: JsValue): CompositionConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[CompositionConfig] =
    Some(CompositionConfig(
      `columns` = (j \ "columns").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `spacing` = (j \ "spacing").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
    ))

  def encode(j: CompositionConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`columns`.map { x => "columns" -> Json.toJson(x) },
        j.`spacing`.map { x => "spacing" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeOpacityBandPosition (ConstrainedType)
object SharedEncodingStrokeOpacityBandPositionCodec {
  def decode(j: JsValue): SharedEncodingStrokeOpacityBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeOpacityBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingStrokeOpacityBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingStrokeOpacityBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AreaConfigPadAngle (UnionType)
object AreaConfigPadAngleCodec {
  def decode(j: JsValue): AreaConfigPadAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigPadAngle] =
    j.asOpt[JsNumber].map { AreaConfigPadAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigPadAngle): JsValue =
    j match {
      case AreaConfigPadAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigLabelFlush (UnionType)
object AxisConfigLabelFlushCodec {
  def decode(j: JsValue): AxisConfigLabelFlush =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigLabelFlush] =
    j.asOpt[Boolean].map { AxisConfigLabelFlushAsBool(_) }.orElse {
    j.asOpt[JsNumber].map { AxisConfigLabelFlushAsNumber(_) } } 
  def encode(j: AxisConfigLabelFlush): JsValue =
    j match {
      case AxisConfigLabelFlushAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case AxisConfigLabelFlushAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfigClipExtent (UnionType)
object ProjectionConfigClipExtentCodec {
  def decode(j: JsValue): ProjectionConfigClipExtent =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigClipExtent] =
    Vector2Vector2NumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigClipExtent): JsValue =
    j match {
      case x:Vector2Vector2Number /* TypeRef */ => Vector2Vector2NumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefContinuousBandSize (ConstrainedType)
object MarkDefContinuousBandSizeCodec {
  def decode(j: JsValue): MarkDefContinuousBandSize =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[MarkDefContinuousBandSize] =
    try {
      j.asOpt[JsNumber]
        .map { MarkDefContinuousBandSize(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: MarkDefContinuousBandSize): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ParameterExtentAsObject1 (StructType)
object ParameterExtentAsObject1Codec {
  def decode(j: JsValue): ParameterExtentAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ParameterExtentAsObject1] =
    {
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `param` = (j \ "param").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`param`.isEmpty) { return None }
      return Some(ParameterExtentAsObject1(
        `field` = `field`,
        `param` = `param`.get,
      ))
    }

  def encode(j: ParameterExtentAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> Json.toJson(x) },
        Some("param" -> Json.toJson(j.`param`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TitleConfigLimitAsNumber (ConstrainedType)
object TitleConfigLimitAsNumberCodec {
  def decode(j: JsValue): TitleConfigLimitAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TitleConfigLimitAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { TitleConfigLimitAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: TitleConfigLimitAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AxisConfigGridOpacity (UnionType)
object AxisConfigGridOpacityCodec {
  def decode(j: JsValue): AxisConfigGridOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigGridOpacity] =
    AxisConfigGridOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigGridOpacity): JsValue =
    j match {
      case x:AxisConfigGridOpacityAsNumber /* TypeRef */ => AxisConfigGridOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2 (StructType)
object ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2Codec {
  def decode(j: JsValue): ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2] =
    {
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      val `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2DatumCodec.decodeOpt(x) }
      val `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2BandPositionCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeCodec.decodeOpt(x) }
      return Some(ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2(
        `test` = `test`.get,
        `scale` = `scale`,
        `datum` = `datum`,
        `legend` = `legend`,
        `bandPosition` = `bandPosition`,
        `title` = `title`,
        `type` = `type`,
      ))
    }

  def encode(j: ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2DatumCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2BandPositionCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingOpacityBin (UnionType)
object SharedEncodingOpacityBinCodec {
  def decode(j: JsValue): SharedEncodingOpacityBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingOpacityBin] =
    j.asOpt[Boolean].map { SharedEncodingOpacityBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingOpacityBinAsNull } } } 
  def encode(j: SharedEncodingOpacityBin): JsValue =
    j match {
      case SharedEncodingOpacityBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case SharedEncodingOpacityBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigInvalid (EnumType)
object BarConfigInvalidCodec {
  def decode(j: JsValue): BarConfigInvalid =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigInvalid] =
    j match {
      case JsString("filter") => Some(BarConfigInvalidFilter)
      case JsNull => Some(BarConfigInvalidUndefined)
      case _ => None
    }
  def encode(j: BarConfigInvalid): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// FieldEqualPredicateTimeUnit (UnionType)
object FieldEqualPredicateTimeUnitCodec {
  def decode(j: JsValue): FieldEqualPredicateTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldEqualPredicateTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: FieldEqualPredicateTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigLabelOpacity (UnionType)
object LegendConfigLabelOpacityCodec {
  def decode(j: JsValue): LegendConfigLabelOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigLabelOpacity] =
    j.asOpt[JsNumber].map { LegendConfigLabelOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigLabelOpacity): JsValue =
    j match {
      case LegendConfigLabelOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingLongitude2BandPosition (ConstrainedType)
object SharedEncodingLongitude2BandPositionCodec {
  def decode(j: JsValue): SharedEncodingLongitude2BandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingLongitude2BandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingLongitude2BandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingLongitude2BandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AxisTitleFontSizeAsNumber (ConstrainedType)
object AxisTitleFontSizeAsNumberCodec {
  def decode(j: JsValue): AxisTitleFontSizeAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AxisTitleFontSizeAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AxisTitleFontSizeAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AxisTitleFontSizeAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AreaConfigStrokeDash (UnionType)
object AreaConfigStrokeDashCodec {
  def decode(j: JsValue): AreaConfigStrokeDash =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigStrokeDash] =
    ArrayOfNumberCodec.decodeOpt(j).map { AreaConfigStrokeDashAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigStrokeDash): JsValue =
    j match {
      case AreaConfigStrokeDashAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfTopLevelLayerSpecLayerElement (ArrayType)
object ArrayOfTopLevelLayerSpecLayerElementCodec {
  def decode(j: JsValue): Seq[TopLevelLayerSpecLayerElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[TopLevelLayerSpecLayerElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      TopLevelLayerSpecLayerElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[TopLevelLayerSpecLayerElement]): JsArray =
      JsArray(j.map { x => TopLevelLayerSpecLayerElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2 (StructType)
object ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2Codec {
  def decode(j: JsValue): ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2] =
    {
      val `empty` = (j \ "empty").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `param` = (j \ "param").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`param`.isEmpty) { return None }
      val `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2DatumCodec.decodeOpt(x) }
      val `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2BandPositionCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeCodec.decodeOpt(x) }
      return Some(ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2(
        `empty` = `empty`,
        `param` = `param`.get,
        `scale` = `scale`,
        `datum` = `datum`,
        `legend` = `legend`,
        `bandPosition` = `bandPosition`,
        `title` = `title`,
        `type` = `type`,
      ))
    }

  def encode(j: ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`empty`.map { x => "empty" -> Json.toJson(x) },
        Some("param" -> Json.toJson(j.`param`)),
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2DatumCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2BandPositionCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LineConfigOpacity (ConstrainedType)
// see LineConfigOpacity (UnionType)

////////////////////////////////////////////////////////////////////////
// AreaConfigColor (UnionType)
object AreaConfigColorCodec {
  def decode(j: JsValue): AreaConfigColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigColor] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: AreaConfigColor): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterValueDefNumberExprRef (StructType)
object ConditionalParameterValueDefNumberExprRefCodec {
  def decode(j: JsValue): ConditionalParameterValueDefNumberExprRef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalParameterValueDefNumberExprRef] =
    {
      val `empty` = (j \ "empty").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `param` = (j \ "param").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`param`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => ConditionalParameterValueDefNumberExprRefValueCodec.decodeOpt(x) }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalParameterValueDefNumberExprRef(
        `empty` = `empty`,
        `param` = `param`.get,
        `value` = `value`.get,
      ))
    }

  def encode(j: ConditionalParameterValueDefNumberExprRef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`empty`.map { x => "empty" -> Json.toJson(x) },
        Some("param" -> Json.toJson(j.`param`)),
        Some("value" -> ConditionalParameterValueDefNumberExprRefValueCodec.encode(j.`value`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// BarConfigBaseline (UnionType)
object BarConfigBaselineCodec {
  def decode(j: JsValue): BarConfigBaseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigBaseline] =
    TextBaselineCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigBaseline): JsValue =
    j match {
      case x:TextBaseline /* TypeRef */ => TextBaselineCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefFill (UnionType)
object OverlayMarkDefFillCodec {
  def decode(j: JsValue): OverlayMarkDefFill =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefFill] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => OverlayMarkDefFillAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: OverlayMarkDefFill): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case OverlayMarkDefFillAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingHrefCondition (UnionType)
object SharedEncodingHrefConditionCodec {
  def decode(j: JsValue): SharedEncodingHrefCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingHrefCondition] =
    ConditionalValueDefStringExprRefCodec.decodeOpt(j).orElse {
    ConditionalValueDefStringNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefStringExprRefCodec.decodeOpt(j).map { SharedEncodingHrefConditionAsArrayOfConditionalValueDefStringExprRef(_) }.orElse {
    ConditionalMarkPropFieldOrDatumDefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefStringNullExprRefCodec.decodeOpt(j).map { SharedEncodingHrefConditionAsArrayOfConditionalValueDefStringNullExprRef(_) } } } } } 
  def encode(j: SharedEncodingHrefCondition): JsValue =
    j match {
      case x:ConditionalValueDefStringExprRef /* TypeRef */ => ConditionalValueDefStringExprRefCodec.encode(x)
      case x:ConditionalValueDefStringNullExprRef /* TypeRef */ => ConditionalValueDefStringNullExprRefCodec.encode(x)
      case SharedEncodingHrefConditionAsArrayOfConditionalValueDefStringExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefStringExprRefCodec.encode(x)
      case x:ConditionalMarkPropFieldOrDatumDef /* TypeRef */ => ConditionalMarkPropFieldOrDatumDefCodec.encode(x)
      case SharedEncodingHrefConditionAsArrayOfConditionalValueDefStringNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefStringNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigHref (UnionType)
object TickConfigHrefCodec {
  def decode(j: JsValue): TickConfigHref =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigHref] =
    UriReferenceCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigHref): JsValue =
    j match {
      case x:UriReference /* TypeRef */ => UriReferenceCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigSize (ConstrainedType)
// see BarConfigSize (UnionType)

////////////////////////////////////////////////////////////////////////
// Day (ConstrainedType)
object DayCodec {
  def decode(j: JsValue): Day =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Day] =
    try {
      j.asOpt[JsNumber]
        .map { Day(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: Day): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefTheta2 (UnionType)
object OverlayMarkDefTheta2Codec {
  def decode(j: JsValue): OverlayMarkDefTheta2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefTheta2] =
    j.asOpt[JsNumber].map { OverlayMarkDefTheta2AsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefTheta2): JsValue =
    j match {
      case OverlayMarkDefTheta2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefTheta2 (UnionType)
object MarkDefTheta2Codec {
  def decode(j: JsValue): MarkDefTheta2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefTheta2] =
    j.asOpt[JsNumber].map { MarkDefTheta2AsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefTheta2): JsValue =
    j match {
      case MarkDefTheta2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderConfigTitleFont (UnionType)
object HeaderConfigTitleFontCodec {
  def decode(j: JsValue): HeaderConfigTitleFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigTitleFont] =
    j.asOpt[String].map { HeaderConfigTitleFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderConfigTitleFont): JsValue =
    j match {
      case HeaderConfigTitleFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ErrorBandDefTension (ConstrainedType)
object ErrorBandDefTensionCodec {
  def decode(j: JsValue): ErrorBandDefTension =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ErrorBandDefTension] =
    try {
      j.asOpt[JsNumber]
        .map { ErrorBandDefTension(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ErrorBandDefTension): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingXBin (UnionType)
object SharedEncodingXBinCodec {
  def decode(j: JsValue): SharedEncodingXBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingXBin] =
    j.asOpt[Boolean].map { SharedEncodingXBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    BinnedCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingXBinAsNull } } } } 
  def encode(j: SharedEncodingXBin): JsValue =
    j match {
      case SharedEncodingXBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case x:Binned /* TypeRef */ => BinnedCodec.encode(x)
      case SharedEncodingXBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingKeyBandPosition (ConstrainedType)
object SharedEncodingKeyBandPositionCodec {
  def decode(j: JsValue): SharedEncodingKeyBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingKeyBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingKeyBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingKeyBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// EncodingDescription (UnionType)
object EncodingDescriptionCodec {
  def decode(j: JsValue): EncodingDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[EncodingDescription] =
    StringFieldDefWithConditionCodec.decodeOpt(j).orElse {
    StringValueDefWithConditionCodec.decodeOpt(j) } 
  def encode(j: EncodingDescription): JsValue =
    j match {
      case x:StringFieldDefWithCondition /* TypeRef */ => StringFieldDefWithConditionCodec.encode(x)
      case x:StringValueDefWithCondition /* TypeRef */ => StringValueDefWithConditionCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefColorNullExprRefAsObject1 (StructType)
object ConditionalPredicateValueDefColorNullExprRefAsObject1Codec {
  def decode(j: JsValue): ConditionalPredicateValueDefColorNullExprRefAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefColorNullExprRefAsObject1] =
    {
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => ColorCodec.decodeOpt(x).map { Some(_) }.flatten }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalPredicateValueDefColorNullExprRefAsObject1(
        `test` = `test`.get,
        `value` = `value`,
      ))
    }

  def encode(j: ConditionalPredicateValueDefColorNullExprRefAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
        j.`value`.map { x => "value" -> ColorCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionStringFieldDefTextCondition (UnionType)
object FieldOrDatumDefWithConditionStringFieldDefTextConditionCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionStringFieldDefTextCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionStringFieldDefTextCondition] =
    ConditionalValueDefTextExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefTextExprRefCodec.decodeOpt(j).map { FieldOrDatumDefWithConditionStringFieldDefTextConditionAsArrayOfConditionalValueDefTextExprRef(_) } } 
  def encode(j: FieldOrDatumDefWithConditionStringFieldDefTextCondition): JsValue =
    j match {
      case x:ConditionalValueDefTextExprRef /* TypeRef */ => ConditionalValueDefTextExprRefCodec.encode(x)
      case FieldOrDatumDefWithConditionStringFieldDefTextConditionAsArrayOfConditionalValueDefTextExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefTextExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsFontSize (UnionType)
object TitleParamsFontSizeCodec {
  def decode(j: JsValue): TitleParamsFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsFontSize] =
    TitleParamsFontSizeAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleParamsFontSize): JsValue =
    j match {
      case x:TitleParamsFontSizeAsNumber /* TypeRef */ => TitleParamsFontSizeAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeCondition (UnionType)
object SharedEncodingStrokeConditionCodec {
  def decode(j: JsValue): SharedEncodingStrokeCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeCondition] =
    ConditionalValueDefGradientStringNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefGradientStringNullExprRefCodec.decodeOpt(j).map { SharedEncodingStrokeConditionAsArrayOfConditionalValueDefGradientStringNullExprRef(_) }.orElse {
    ConditionalMarkPropFieldOrDatumDefCodec.decodeOpt(j) } } 
  def encode(j: SharedEncodingStrokeCondition): JsValue =
    j match {
      case x:ConditionalValueDefGradientStringNullExprRef /* TypeRef */ => ConditionalValueDefGradientStringNullExprRefCodec.encode(x)
      case SharedEncodingStrokeConditionAsArrayOfConditionalValueDefGradientStringNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefGradientStringNullExprRefCodec.encode(x)
      case x:ConditionalMarkPropFieldOrDatumDef /* TypeRef */ => ConditionalMarkPropFieldOrDatumDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewConfig (StructType)
object ViewConfigCodec {
  def decode(j: JsValue): ViewConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ViewConfig] =
    Some(ViewConfig(
      `step` = (j \ "step").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `continuousHeight` = (j \ "continuousHeight").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `fillOpacity` = (j \ "fillOpacity").asOpt[JsValue].flatMap { x => ViewConfigFillOpacityCodec.decodeOpt(x) },
      `cornerRadius` = (j \ "cornerRadius").asOpt[JsValue].flatMap { x => ViewConfigCornerRadiusCodec.decodeOpt(x) },
      `strokeMiterLimit` = (j \ "strokeMiterLimit").asOpt[JsValue].flatMap { x => ViewConfigStrokeMiterLimitCodec.decodeOpt(x) },
      `fill` = (j \ "fill").asOpt[JsValue].flatMap { x => ViewConfigFillCodec.decodeOpt(x) },
      `opacity` = (j \ "opacity").asOpt[JsValue].flatMap { x => ViewConfigOpacityCodec.decodeOpt(x) },
      `clip` = (j \ "clip").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `strokeDash` = (j \ "strokeDash").asOpt[JsValue].flatMap { x => ViewConfigStrokeDashCodec.decodeOpt(x) },
      `strokeOpacity` = (j \ "strokeOpacity").asOpt[JsValue].flatMap { x => ViewConfigStrokeOpacityCodec.decodeOpt(x) },
      `discreteWidth` = (j \ "discreteWidth").asOpt[JsValue].flatMap { x => ViewConfigDiscreteWidthCodec.decodeOpt(x) },
      `stroke` = (j \ "stroke").asOpt[JsValue].flatMap { x => ViewConfigStrokeCodec.decodeOpt(x) },
      `strokeDashOffset` = (j \ "strokeDashOffset").asOpt[JsValue].flatMap { x => ViewConfigStrokeDashOffsetCodec.decodeOpt(x) },
      `strokeCap` = (j \ "strokeCap").asOpt[JsValue].flatMap { x => ViewConfigStrokeCapCodec.decodeOpt(x) },
      `strokeJoin` = (j \ "strokeJoin").asOpt[JsValue].flatMap { x => ViewConfigStrokeJoinCodec.decodeOpt(x) },
      `cursor` = (j \ "cursor").asOpt[JsValue].flatMap { x => CursorCodec.decodeOpt(x) },
      `discreteHeight` = (j \ "discreteHeight").asOpt[JsValue].flatMap { x => ViewConfigDiscreteHeightCodec.decodeOpt(x) },
      `strokeWidth` = (j \ "strokeWidth").asOpt[JsValue].flatMap { x => ViewConfigStrokeWidthCodec.decodeOpt(x) },
      `continuousWidth` = (j \ "continuousWidth").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
    ))

  def encode(j: ViewConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`step`.map { x => "step" -> Json.toJson(x) },
        j.`continuousHeight`.map { x => "continuousHeight" -> Json.toJson(x) },
        j.`fillOpacity`.map { x => "fillOpacity" -> ViewConfigFillOpacityCodec.encode(x) },
        j.`cornerRadius`.map { x => "cornerRadius" -> ViewConfigCornerRadiusCodec.encode(x) },
        j.`strokeMiterLimit`.map { x => "strokeMiterLimit" -> ViewConfigStrokeMiterLimitCodec.encode(x) },
        j.`fill`.map { x => "fill" -> ViewConfigFillCodec.encode(x) },
        j.`opacity`.map { x => "opacity" -> ViewConfigOpacityCodec.encode(x) },
        j.`clip`.map { x => "clip" -> Json.toJson(x) },
        j.`strokeDash`.map { x => "strokeDash" -> ViewConfigStrokeDashCodec.encode(x) },
        j.`strokeOpacity`.map { x => "strokeOpacity" -> ViewConfigStrokeOpacityCodec.encode(x) },
        j.`discreteWidth`.map { x => "discreteWidth" -> ViewConfigDiscreteWidthCodec.encode(x) },
        j.`stroke`.map { x => "stroke" -> ViewConfigStrokeCodec.encode(x) },
        j.`strokeDashOffset`.map { x => "strokeDashOffset" -> ViewConfigStrokeDashOffsetCodec.encode(x) },
        j.`strokeCap`.map { x => "strokeCap" -> ViewConfigStrokeCapCodec.encode(x) },
        j.`strokeJoin`.map { x => "strokeJoin" -> ViewConfigStrokeJoinCodec.encode(x) },
        j.`cursor`.map { x => "cursor" -> CursorCodec.encode(x) },
        j.`discreteHeight`.map { x => "discreteHeight" -> ViewConfigDiscreteHeightCodec.encode(x) },
        j.`strokeWidth`.map { x => "strokeWidth" -> ViewConfigStrokeWidthCodec.encode(x) },
        j.`continuousWidth`.map { x => "continuousWidth" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// Mark (EnumType)
object MarkCodec {
  def decode(j: JsValue): Mark =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Mark] =
    j match {
      case JsString("arc") => Some(MarkArc)
      case JsString("area") => Some(MarkArea)
      case JsString("bar") => Some(MarkBar)
      case JsString("image") => Some(MarkImage)
      case JsString("line") => Some(MarkLine)
      case JsString("point") => Some(MarkPoint)
      case JsString("rect") => Some(MarkRect)
      case JsString("rule") => Some(MarkRule)
      case JsString("text") => Some(MarkText)
      case JsString("tick") => Some(MarkTick)
      case JsString("trail") => Some(MarkTrail)
      case JsString("circle") => Some(MarkCircle)
      case JsString("square") => Some(MarkSquare)
      case JsString("geoshape") => Some(MarkGeoshape)
      case _ => None
    }
  def encode(j: Mark): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// FieldEqualPredicateEqual (UnionType)
object FieldEqualPredicateEqualCodec {
  def decode(j: JsValue): FieldEqualPredicateEqual =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldEqualPredicateEqual] =
    j.asOpt[String].map { FieldEqualPredicateEqualAsString(_) }.orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    j.asOpt[Boolean].map { FieldEqualPredicateEqualAsBool(_) }.orElse {
    j.asOpt[JsNumber].map { FieldEqualPredicateEqualAsNumber(_) } } } } } 
  def encode(j: FieldEqualPredicateEqual): JsValue =
    j match {
      case FieldEqualPredicateEqualAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case FieldEqualPredicateEqualAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case FieldEqualPredicateEqualAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigRadius2 (UnionType)
object TickConfigRadius2Codec {
  def decode(j: JsValue): TickConfigRadius2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigRadius2] =
    j.asOpt[JsNumber].map { TickConfigRadius2AsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigRadius2): JsValue =
    j match {
      case TickConfigRadius2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SelectionParameterBind (UnionType)
object SelectionParameterBindCodec {
  def decode(j: JsValue): SelectionParameterBind =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SelectionParameterBind] =
    BindingCodec.decodeOpt(j).orElse {
    DictOfBindingCodec.decodeOpt(j).map { SelectionParameterBindAsDictOfBinding(_) }.orElse {
    LegendBindingCodec.decodeOpt(j).orElse {
    ScalesCodec.decodeOpt(j) } } } 
  def encode(j: SelectionParameterBind): JsValue =
    j match {
      case x:Binding /* TypeRef */ => BindingCodec.encode(x)
      case SelectionParameterBindAsDictOfBinding(x) /* Base, MapType */ => DictOfBindingCodec.encode(x)
      case x:LegendBinding /* TypeRef */ => LegendBindingCodec.encode(x)
      case x:Scales /* TypeRef */ => ScalesCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Vector10String (ConstrainedType)
object Vector10StringCodec {
  def decode(j: JsValue): Vector10String =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Vector10String] =
    try {
      ArrayOfStringCodec.decodeOpt(j)
        .map { Vector10String(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: Vector10String): JsValue =
    ArrayOfStringCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// AreaConfigStrokeWidth (UnionType)
object AreaConfigStrokeWidthCodec {
  def decode(j: JsValue): AreaConfigStrokeWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigStrokeWidth] =
    AreaConfigStrokeWidthAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigStrokeWidth): JsValue =
    j match {
      case x:AreaConfigStrokeWidthAsNumber /* TypeRef */ => AreaConfigStrokeWidthAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// DictOfSelectionInitInterval (MapType)
object DictOfSelectionInitIntervalCodec {
  def decode(j: JsValue): Map[String,SelectionInitInterval] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Map[String,SelectionInitInterval]] =
    j.asOpt[Map[String,JsValue]].map { _.mapValues { x => 
      SelectionInitIntervalCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Map[String,SelectionInitInterval]): JsObject =
      JsObject(j.mapValues { x => SelectionInitIntervalCodec.encode(x) })
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingThetaType (UnionType)
object SharedEncodingThetaTypeCodec {
  def decode(j: JsValue): SharedEncodingThetaType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingThetaType] =
    StandardTypeCodec.decodeOpt(j).orElse {
    TypeCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingThetaType): JsValue =
    j match {
      case x:StandardType /* TypeRef */ => StandardTypeCodec.encode(x)
      case x:Type /* TypeRef */ => TypeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfFit (ArrayType)
object ArrayOfFitCodec {
  def decode(j: JsValue): Seq[Fit] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[Fit]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      FitCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[Fit]): JsArray =
      JsArray(j.map { x => FitCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// SelectionParameter (StructType)
object SelectionParameterCodec {
  def decode(j: JsValue): SelectionParameter =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SelectionParameter] =
    {
      val `bind` = (j \ "bind").asOpt[JsValue].flatMap { x => SelectionParameterBindCodec.decodeOpt(x) }
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`name`.isEmpty) { return None }
      val `select` = (j \ "select").asOpt[JsValue].flatMap { x => SelectionParameterSelectCodec.decodeOpt(x) }
      if(`select`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => SelectionParameterValueCodec.decodeOpt(x) }
      return Some(SelectionParameter(
        `bind` = `bind`,
        `name` = `name`.get,
        `select` = `select`.get,
        `value` = `value`,
      ))
    }

  def encode(j: SelectionParameter): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`bind`.map { x => "bind" -> SelectionParameterBindCodec.encode(x) },
        Some("name" -> Json.toJson(j.`name`)),
        Some("select" -> SelectionParameterSelectCodec.encode(j.`select`)),
        j.`value`.map { x => "value" -> SelectionParameterValueCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConditionalPredicateMarkPropFieldOrDatumDef (UnionType)
object ConditionalPredicateMarkPropFieldOrDatumDefCodec {
  def decode(j: JsValue): ConditionalPredicateMarkPropFieldOrDatumDef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateMarkPropFieldOrDatumDef] =
    ConditionalPredicateMarkPropFieldOrDatumDefAsObject1Codec.decodeOpt(j).orElse {
    ConditionalPredicateMarkPropFieldOrDatumDefAsObject2Codec.decodeOpt(j) } 
  def encode(j: ConditionalPredicateMarkPropFieldOrDatumDef): JsValue =
    j match {
      case x:ConditionalPredicateMarkPropFieldOrDatumDefAsObject1 /* TypeRef */ => ConditionalPredicateMarkPropFieldOrDatumDefAsObject1Codec.encode(x)
      case x:ConditionalPredicateMarkPropFieldOrDatumDefAsObject2 /* TypeRef */ => ConditionalPredicateMarkPropFieldOrDatumDefAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefCornerRadiusBottomRight (UnionType)
object MarkDefCornerRadiusBottomRightCodec {
  def decode(j: JsValue): MarkDefCornerRadiusBottomRight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefCornerRadiusBottomRight] =
    j.asOpt[JsNumber].map { MarkDefCornerRadiusBottomRightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefCornerRadiusBottomRight): JsValue =
    j match {
      case MarkDefCornerRadiusBottomRightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefAriaRoleDescription (UnionType)
object MarkDefAriaRoleDescriptionCodec {
  def decode(j: JsValue): MarkDefAriaRoleDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefAriaRoleDescription] =
    j.asOpt[String].map { MarkDefAriaRoleDescriptionAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefAriaRoleDescription): JsValue =
    j match {
      case MarkDefAriaRoleDescriptionAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigFontSizeAsNumber (ConstrainedType)
object LineConfigFontSizeAsNumberCodec {
  def decode(j: JsValue): LineConfigFontSizeAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LineConfigFontSizeAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { LineConfigFontSizeAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: LineConfigFontSizeAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// HeaderTitleAngle (ConstrainedType)
object HeaderTitleAngleCodec {
  def decode(j: JsValue): HeaderTitleAngle =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[HeaderTitleAngle] =
    try {
      j.asOpt[JsNumber]
        .map { HeaderTitleAngle(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: HeaderTitleAngle): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ScaleDomainAsArrayElement (UnionType)
object ScaleDomainAsArrayElementCodec {
  def decode(j: JsValue): ScaleDomainAsArrayElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleDomainAsArrayElement] =
    j.asOpt[String].map { ScaleDomainAsArrayElementAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ScaleDomainAsArrayElementAsNull }.orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    j.asOpt[Boolean].map { ScaleDomainAsArrayElementAsBool(_) }.orElse {
    j.asOpt[JsNumber].map { ScaleDomainAsArrayElementAsNumber(_) } } } } } } 
  def encode(j: ScaleDomainAsArrayElement): JsValue =
    j match {
      case ScaleDomainAsArrayElementAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case ScaleDomainAsArrayElementAsNull /* Global, NullType$ */ => JsNull
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case ScaleDomainAsArrayElementAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case ScaleDomainAsArrayElementAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigAria (UnionType)
object BarConfigAriaCodec {
  def decode(j: JsValue): BarConfigAria =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigAria] =
    j.asOpt[Boolean].map { BarConfigAriaAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigAria): JsValue =
    j match {
      case BarConfigAriaAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderTitleFontSize (UnionType)
object HeaderTitleFontSizeCodec {
  def decode(j: JsValue): HeaderTitleFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderTitleFontSize] =
    j.asOpt[JsNumber].map { HeaderTitleFontSizeAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderTitleFontSize): JsValue =
    j match {
      case HeaderTitleFontSizeAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingRadiusBandPosition (ConstrainedType)
object SharedEncodingRadiusBandPositionCodec {
  def decode(j: JsValue): SharedEncodingRadiusBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingRadiusBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingRadiusBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingRadiusBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingY2 (StructType)
object SharedEncodingY2Codec {
  def decode(j: JsValue): SharedEncodingY2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingY2] =
    Some(SharedEncodingY2(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingY2DatumCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingY2BandPositionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => x.asOpt[JsNull.type].map { _ => JsNull } },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingY2ValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingY2TimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingY2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingY2DatumCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingY2BandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> Json.toJson(x) },
        j.`value`.map { x => "value" -> SharedEncodingY2ValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingY2TimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TopLevelSelectionParameterViewsElement (UnionType)
object TopLevelSelectionParameterViewsElementCodec {
  def decode(j: JsValue): TopLevelSelectionParameterViewsElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelSelectionParameterViewsElement] =
    j.asOpt[String].map { TopLevelSelectionParameterViewsElementAsString(_) }.orElse {
    ArrayOfStringCodec.decodeOpt(j).map { TopLevelSelectionParameterViewsElementAsArrayOfString(_) } } 
  def encode(j: TopLevelSelectionParameterViewsElement): JsValue =
    j match {
      case TopLevelSelectionParameterViewsElementAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case TopLevelSelectionParameterViewsElementAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefNumber (StructType)
object ConditionalPredicateValueDefNumberCodec {
  def decode(j: JsValue): ConditionalPredicateValueDefNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefNumber] =
    {
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalPredicateValueDefNumber(
        `test` = `test`.get,
        `value` = `value`.get,
      ))
    }

  def encode(j: ConditionalPredicateValueDefNumber): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
        Some("value" -> Json.toJson(j.`value`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ScaleZero (UnionType)
object ScaleZeroCodec {
  def decode(j: JsValue): ScaleZero =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleZero] =
    j.asOpt[Boolean].map { ScaleZeroAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleZero): JsValue =
    j match {
      case ScaleZeroAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewBackgroundStrokeDashOffset (UnionType)
object ViewBackgroundStrokeDashOffsetCodec {
  def decode(j: JsValue): ViewBackgroundStrokeDashOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewBackgroundStrokeDashOffset] =
    j.asOpt[JsNumber].map { ViewBackgroundStrokeDashOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ViewBackgroundStrokeDashOffset): JsValue =
    j match {
      case ViewBackgroundStrokeDashOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigFontSizeAsNumber (ConstrainedType)
object AreaConfigFontSizeAsNumberCodec {
  def decode(j: JsValue): AreaConfigFontSizeAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AreaConfigFontSizeAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AreaConfigFontSizeAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AreaConfigFontSizeAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkDefRadiusOffset (UnionType)
object MarkDefRadiusOffsetCodec {
  def decode(j: JsValue): MarkDefRadiusOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefRadiusOffset] =
    j.asOpt[JsNumber].map { MarkDefRadiusOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefRadiusOffset): JsValue =
    j match {
      case MarkDefRadiusOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterMarkPropFieldOrDatumDefAsObject1Bin (UnionType)
object ConditionalParameterMarkPropFieldOrDatumDefAsObject1BinCodec {
  def decode(j: JsValue): ConditionalParameterMarkPropFieldOrDatumDefAsObject1Bin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalParameterMarkPropFieldOrDatumDefAsObject1Bin] =
    j.asOpt[Boolean].map { ConditionalParameterMarkPropFieldOrDatumDefAsObject1BinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ConditionalParameterMarkPropFieldOrDatumDefAsObject1BinAsNull } } } 
  def encode(j: ConditionalParameterMarkPropFieldOrDatumDefAsObject1Bin): JsValue =
    j match {
      case ConditionalParameterMarkPropFieldOrDatumDefAsObject1BinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case ConditionalParameterMarkPropFieldOrDatumDefAsObject1BinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTitleLimit (UnionType)
object AxisConfigTitleLimitCodec {
  def decode(j: JsValue): AxisConfigTitleLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTitleLimit] =
    AxisConfigTitleLimitAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigTitleLimit): JsValue =
    j match {
      case x:AxisConfigTitleLimitAsNumber /* TypeRef */ => AxisConfigTitleLimitAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfColor (ArrayType)
object ArrayOfColorCodec {
  def decode(j: JsValue): Seq[Color] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[Color]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      ColorCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[Color]): JsArray =
      JsArray(j.map { x => ColorCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingXError2 (StructType)
object SharedEncodingXError2Codec {
  def decode(j: JsValue): SharedEncodingXError2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingXError2] =
    Some(SharedEncodingXError2(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingXError2BandPositionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => x.asOpt[JsNull.type].map { _ => JsNull } },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingXError2TimeUnitCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingXError2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingXError2BandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> Json.toJson(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`value`.map { x => "value" -> Json.toJson(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingXError2TimeUnitCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// Sort (UnionType)
object SortCodec {
  def decode(j: JsValue): Sort =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Sort] =
    SortByEncodingCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SortAsNull }.orElse {
    EncodingSortFieldCodec.decodeOpt(j).orElse {
    AllSortStringCodec.decodeOpt(j).orElse {
    SortArrayCodec.decodeOpt(j) } } } } 
  def encode(j: Sort): JsValue =
    j match {
      case x:SortByEncoding /* TypeRef */ => SortByEncodingCodec.encode(x)
      case SortAsNull /* Global, NullType$ */ => JsNull
      case x:EncodingSortField /* TypeRef */ => EncodingSortFieldCodec.encode(x)
      case x:AllSortString /* TypeRef */ => AllSortStringCodec.encode(x)
      case x:SortArray /* TypeRef */ => SortArrayCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// NonLayerRepeatSpecBounds (EnumType)
object NonLayerRepeatSpecBoundsCodec {
  def decode(j: JsValue): NonLayerRepeatSpecBounds =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[NonLayerRepeatSpecBounds] =
    j match {
      case JsString("full") => Some(NonLayerRepeatSpecBoundsFull)
      case JsString("flush") => Some(NonLayerRepeatSpecBoundsFlush)
      case _ => None
    }
  def encode(j: NonLayerRepeatSpecBounds): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingTheta (StructType)
object SharedEncodingThetaCodec {
  def decode(j: JsValue): SharedEncodingTheta =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingTheta] =
    Some(SharedEncodingTheta(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingThetaDatumCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingThetaBandPositionCodec.decodeOpt(x) },
      `stack` = (j \ "stack").asOpt[JsValue].flatMap { x => SharedEncodingThetaStackCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingThetaBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingThetaValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingThetaTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => SharedEncodingThetaTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingTheta): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingThetaDatumCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingThetaBandPositionCodec.encode(x) },
        j.`stack`.map { x => "stack" -> SharedEncodingThetaStackCodec.encode(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingThetaBinCodec.encode(x) },
        j.`value`.map { x => "value" -> SharedEncodingThetaValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingThetaTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> SharedEncodingThetaTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// Spec (UnionType)
object SpecCodec {
  def decode(j: JsValue): Spec =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Spec] =
    FacetSpecCodec.decodeOpt(j).orElse {
    LayerSpecCodec.decodeOpt(j).orElse {
    HConcatSpecGenericSpecCodec.decodeOpt(j).orElse {
    FacetedUnitSpecCodec.decodeOpt(j).orElse {
    ConcatSpecGenericSpecCodec.decodeOpt(j).orElse {
    RepeatSpecCodec.decodeOpt(j).orElse {
    VConcatSpecGenericSpecCodec.decodeOpt(j) } } } } } } 
  def encode(j: Spec): JsValue =
    j match {
      case x:FacetSpec /* TypeRef */ => FacetSpecCodec.encode(x)
      case x:LayerSpec /* TypeRef */ => LayerSpecCodec.encode(x)
      case x:HConcatSpecGenericSpec /* TypeRef */ => HConcatSpecGenericSpecCodec.encode(x)
      case x:FacetedUnitSpec /* TypeRef */ => FacetedUnitSpecCodec.encode(x)
      case x:ConcatSpecGenericSpec /* TypeRef */ => ConcatSpecGenericSpecCodec.encode(x)
      case x:RepeatSpec /* TypeRef */ => RepeatSpecCodec.encode(x)
      case x:VConcatSpecGenericSpec /* TypeRef */ => VConcatSpecGenericSpecCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigRadius2 (ConstrainedType)
// see TickConfigRadius2 (UnionType)

////////////////////////////////////////////////////////////////////////
// ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2BandPosition (ConstrainedType)
object ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2BandPositionCodec {
  def decode(j: JsValue): ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2BandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2BandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2BandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2BandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// HeaderLabelColor (UnionType)
object HeaderLabelColorCodec {
  def decode(j: JsValue): HeaderLabelColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderLabelColor] =
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderLabelColor): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisLabelAlignAsObject2Condition (UnionType)
object ConditionalAxisLabelAlignAsObject2ConditionCodec {
  def decode(j: JsValue): ConditionalAxisLabelAlignAsObject2Condition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisLabelAlignAsObject2Condition] =
    ConditionalPredicateValueDefAlignNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalPredicateValueDefAlignNullExprRefCodec.decodeOpt(j).map { ConditionalAxisLabelAlignAsObject2ConditionAsArrayOfConditionalPredicateValueDefAlignNullExprRef(_) } } 
  def encode(j: ConditionalAxisLabelAlignAsObject2Condition): JsValue =
    j match {
      case x:ConditionalPredicateValueDefAlignNullExprRef /* TypeRef */ => ConditionalPredicateValueDefAlignNullExprRefCodec.encode(x)
      case ConditionalAxisLabelAlignAsObject2ConditionAsArrayOfConditionalPredicateValueDefAlignNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalPredicateValueDefAlignNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingSizeType (UnionType)
object SharedEncodingSizeTypeCodec {
  def decode(j: JsValue): SharedEncodingSizeType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingSizeType] =
    StandardTypeCodec.decodeOpt(j).orElse {
    TypeCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingSizeType): JsValue =
    j match {
      case x:StandardType /* TypeRef */ => StandardTypeCodec.encode(x)
      case x:Type /* TypeRef */ => TypeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfigRotate (UnionType)
object ProjectionConfigRotateCodec {
  def decode(j: JsValue): ProjectionConfigRotate =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigRotate] =
    Vector2NumberCodec.decodeOpt(j).orElse {
    Vector3NumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: ProjectionConfigRotate): JsValue =
    j match {
      case x:Vector2Number /* TypeRef */ => Vector2NumberCodec.encode(x)
      case x:Vector3Number /* TypeRef */ => Vector3NumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleConfigSubtitleFontSize (UnionType)
object TitleConfigSubtitleFontSizeCodec {
  def decode(j: JsValue): TitleConfigSubtitleFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigSubtitleFontSize] =
    TitleConfigSubtitleFontSizeAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleConfigSubtitleFontSize): JsValue =
    j match {
      case x:TitleConfigSubtitleFontSizeAsNumber /* TypeRef */ => TitleConfigSubtitleFontSizeAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PositionFieldDefBin (UnionType)
object PositionFieldDefBinCodec {
  def decode(j: JsValue): PositionFieldDefBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PositionFieldDefBin] =
    j.asOpt[Boolean].map { PositionFieldDefBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    BinnedCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => PositionFieldDefBinAsNull } } } } 
  def encode(j: PositionFieldDefBin): JsValue =
    j match {
      case PositionFieldDefBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case x:Binned /* TypeRef */ => BinnedCodec.encode(x)
      case PositionFieldDefBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigValues (UnionType)
object AxisConfigValuesCodec {
  def decode(j: JsValue): AxisConfigValues =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigValues] =
    ArrayOfNumberCodec.decodeOpt(j).map { AxisConfigValuesAsArrayOfNumber(_) }.orElse {
    ArrayOfBoolCodec.decodeOpt(j).map { AxisConfigValuesAsArrayOfBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ArrayOfDateTimeCodec.decodeOpt(j).map { AxisConfigValuesAsArrayOfDateTime(_) }.orElse {
    ArrayOfStringCodec.decodeOpt(j).map { AxisConfigValuesAsArrayOfString(_) } } } } } 
  def encode(j: AxisConfigValues): JsValue =
    j match {
      case AxisConfigValuesAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case AxisConfigValuesAsArrayOfBool(x) /* Base, ArrayType */ => ArrayOfBoolCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case AxisConfigValuesAsArrayOfDateTime(x) /* Base, ArrayType */ => ArrayOfDateTimeCodec.encode(x)
      case AxisConfigValuesAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigStrokeWidthAsNumber (ConstrainedType)
object LineConfigStrokeWidthAsNumberCodec {
  def decode(j: JsValue): LineConfigStrokeWidthAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LineConfigStrokeWidthAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { LineConfigStrokeWidthAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: LineConfigStrokeWidthAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// HeaderConfigLabelFontStyle (UnionType)
object HeaderConfigLabelFontStyleCodec {
  def decode(j: JsValue): HeaderConfigLabelFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigLabelFontStyle] =
    j.asOpt[String].map { HeaderConfigLabelFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderConfigLabelFontStyle): JsValue =
    j match {
      case HeaderConfigLabelFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// DateTimeMilliseconds (ConstrainedType)
object DateTimeMillisecondsCodec {
  def decode(j: JsValue): DateTimeMilliseconds =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[DateTimeMilliseconds] =
    try {
      j.asOpt[JsNumber]
        .map { DateTimeMilliseconds(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: DateTimeMilliseconds): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ScaleRangeMin (UnionType)
object ScaleRangeMinCodec {
  def decode(j: JsValue): ScaleRangeMin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleRangeMin] =
    j.asOpt[JsNumber].map { ScaleRangeMinAsNumber(_) }.orElse {
    j.asOpt[String].map { ScaleRangeMinAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: ScaleRangeMin): JsValue =
    j match {
      case ScaleRangeMinAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case ScaleRangeMinAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterMarkPropFieldOrDatumDefAsObject2BandPosition (ConstrainedType)
object ConditionalParameterMarkPropFieldOrDatumDefAsObject2BandPositionCodec {
  def decode(j: JsValue): ConditionalParameterMarkPropFieldOrDatumDefAsObject2BandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalParameterMarkPropFieldOrDatumDefAsObject2BandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { ConditionalParameterMarkPropFieldOrDatumDefAsObject2BandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ConditionalParameterMarkPropFieldOrDatumDefAsObject2BandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// LineConfigRadius (UnionType)
object LineConfigRadiusCodec {
  def decode(j: JsValue): LineConfigRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigRadius] =
    j.asOpt[JsNumber].map { LineConfigRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigRadius): JsValue =
    j match {
      case LineConfigRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// DateTimeDate (ConstrainedType)
object DateTimeDateCodec {
  def decode(j: JsValue): DateTimeDate =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[DateTimeDate] =
    try {
      j.asOpt[JsNumber]
        .map { DateTimeDate(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: DateTimeDate): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// BarConfigStrokeDash (UnionType)
object BarConfigStrokeDashCodec {
  def decode(j: JsValue): BarConfigStrokeDash =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigStrokeDash] =
    ArrayOfNumberCodec.decodeOpt(j).map { BarConfigStrokeDashAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigStrokeDash): JsValue =
    j match {
      case BarConfigStrokeDashAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionClipAngle (UnionType)
object ProjectionClipAngleCodec {
  def decode(j: JsValue): ProjectionClipAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionClipAngle] =
    j.asOpt[JsNumber].map { ProjectionClipAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionClipAngle): JsValue =
    j match {
      case ProjectionClipAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// DateTime (StructType)
object DateTimeCodec {
  def decode(j: JsValue): DateTime =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[DateTime] =
    Some(DateTime(
      `seconds` = (j \ "seconds").asOpt[JsValue].flatMap { x => DateTimeSecondsCodec.decodeOpt(x) },
      `year` = (j \ "year").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `quarter` = (j \ "quarter").asOpt[JsValue].flatMap { x => DateTimeQuarterCodec.decodeOpt(x) },
      `utc` = (j \ "utc").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `minutes` = (j \ "minutes").asOpt[JsValue].flatMap { x => DateTimeMinutesCodec.decodeOpt(x) },
      `hours` = (j \ "hours").asOpt[JsValue].flatMap { x => DateTimeHoursCodec.decodeOpt(x) },
      `date` = (j \ "date").asOpt[JsValue].flatMap { x => DateTimeDateCodec.decodeOpt(x) },
      `milliseconds` = (j \ "milliseconds").asOpt[JsValue].flatMap { x => DateTimeMillisecondsCodec.decodeOpt(x) },
      `day` = (j \ "day").asOpt[JsValue].flatMap { x => DateTimeDayCodec.decodeOpt(x) },
      `month` = (j \ "month").asOpt[JsValue].flatMap { x => DateTimeMonthCodec.decodeOpt(x) },
    ))

  def encode(j: DateTime): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`seconds`.map { x => "seconds" -> DateTimeSecondsCodec.encode(x) },
        j.`year`.map { x => "year" -> Json.toJson(x) },
        j.`quarter`.map { x => "quarter" -> DateTimeQuarterCodec.encode(x) },
        j.`utc`.map { x => "utc" -> Json.toJson(x) },
        j.`minutes`.map { x => "minutes" -> DateTimeMinutesCodec.encode(x) },
        j.`hours`.map { x => "hours" -> DateTimeHoursCodec.encode(x) },
        j.`date`.map { x => "date" -> DateTimeDateCodec.encode(x) },
        j.`milliseconds`.map { x => "milliseconds" -> DateTimeMillisecondsCodec.encode(x) },
        j.`day`.map { x => "day" -> DateTimeDayCodec.encode(x) },
        j.`month`.map { x => "month" -> DateTimeMonthCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LineConfigLineHeight (UnionType)
object LineConfigLineHeightCodec {
  def decode(j: JsValue): LineConfigLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigLineHeight] =
    j.asOpt[JsNumber].map { LineConfigLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigLineHeight): JsValue =
    j match {
      case LineConfigLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SingleTimeUnit (UnionType)
object SingleTimeUnitCodec {
  def decode(j: JsValue): SingleTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SingleTimeUnit] =
    LocalSingleTimeUnitCodec.decodeOpt(j).orElse {
    UtcSingleTimeUnitCodec.decodeOpt(j) } 
  def encode(j: SingleTimeUnit): JsValue =
    j match {
      case x:LocalSingleTimeUnit /* TypeRef */ => LocalSingleTimeUnitCodec.encode(x)
      case x:UtcSingleTimeUnit /* TypeRef */ => UtcSingleTimeUnitCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingFillType (UnionType)
object SharedEncodingFillTypeCodec {
  def decode(j: JsValue): SharedEncodingFillType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingFillType] =
    StandardTypeCodec.decodeOpt(j).orElse {
    TypeCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingFillType): JsValue =
    j match {
      case x:StandardType /* TypeRef */ => StandardTypeCodec.encode(x)
      case x:Type /* TypeRef */ => TypeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefBinSpacing (ConstrainedType)
object MarkDefBinSpacingCodec {
  def decode(j: JsValue): MarkDefBinSpacing =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[MarkDefBinSpacing] =
    try {
      j.asOpt[JsNumber]
        .map { MarkDefBinSpacing(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: MarkDefBinSpacing): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingLongitude2Datum (UnionType)
object SharedEncodingLongitude2DatumCodec {
  def decode(j: JsValue): SharedEncodingLongitude2Datum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingLongitude2Datum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingLongitude2Datum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigStrokeMiterLimit (UnionType)
object MarkConfigStrokeMiterLimitCodec {
  def decode(j: JsValue): MarkConfigStrokeMiterLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigStrokeMiterLimit] =
    j.asOpt[JsNumber].map { MarkConfigStrokeMiterLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigStrokeMiterLimit): JsValue =
    j match {
      case MarkConfigStrokeMiterLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfConditionalValueDefNumberExprRef (ArrayType)
object ArrayOfConditionalValueDefNumberExprRefCodec {
  def decode(j: JsValue): Seq[ConditionalValueDefNumberExprRef] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[ConditionalValueDefNumberExprRef]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      ConditionalValueDefNumberExprRefCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[ConditionalValueDefNumberExprRef]): JsArray =
      JsArray(j.map { x => ConditionalValueDefNumberExprRefCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingAngleValue (UnionType)
object SharedEncodingAngleValueCodec {
  def decode(j: JsValue): SharedEncodingAngleValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingAngleValue] =
    j.asOpt[JsNumber].map { SharedEncodingAngleValueAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingAngleValue): JsValue =
    j match {
      case SharedEncodingAngleValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Width (ConstantType)
object WidthCodec {
  def decode(j: JsValue): Width =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Width] =
    j match {
      case JsString("width") => Some(Width())
      case _ => None
    }
  def encode(j: Width): JsValue =
    JsString("width")
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingTextBin (UnionType)
object SharedEncodingTextBinCodec {
  def decode(j: JsValue): SharedEncodingTextBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingTextBin] =
    j.asOpt[Boolean].map { SharedEncodingTextBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    BinnedCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingTextBinAsNull } } } } 
  def encode(j: SharedEncodingTextBin): JsValue =
    j match {
      case SharedEncodingTextBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case x:Binned /* TypeRef */ => BinnedCodec.encode(x)
      case SharedEncodingTextBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefAngle (UnionType)
object MarkDefAngleCodec {
  def decode(j: JsValue): MarkDefAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefAngle] =
    MarkDefAngleAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefAngle): JsValue =
    j match {
      case x:MarkDefAngleAsNumber /* TypeRef */ => MarkDefAngleAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefStringNullExprRefAsObject2 (StructType)
object ConditionalPredicateValueDefStringNullExprRefAsObject2Codec {
  def decode(j: JsValue): ConditionalPredicateValueDefStringNullExprRefAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefStringNullExprRefAsObject2] =
    {
      val `expr` = (j \ "expr").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`expr`.isEmpty) { return None }
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      return Some(ConditionalPredicateValueDefStringNullExprRefAsObject2(
        `expr` = `expr`.get,
        `test` = `test`.get,
      ))
    }

  def encode(j: ConditionalPredicateValueDefStringNullExprRefAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("expr" -> Json.toJson(j.`expr`)),
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject2Spec (UnionType)
object TopLevelRepeatSpecAsObject2SpecCodec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject2Spec =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject2Spec] =
    LayerSpecCodec.decodeOpt(j).orElse {
    UnitSpecCodec.decodeOpt(j) } 
  def encode(j: TopLevelRepeatSpecAsObject2Spec): JsValue =
    j match {
      case x:LayerSpec /* TypeRef */ => LayerSpecCodec.encode(x)
      case x:UnitSpec /* TypeRef */ => UnitSpecCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ErrorBandDef (StructType)
object ErrorBandDefCodec {
  def decode(j: JsValue): ErrorBandDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ErrorBandDef] =
    {
      val `extent` = (j \ "extent").asOpt[JsValue].flatMap { x => ErrorBarExtentCodec.decodeOpt(x) }
      val `color` = (j \ "color").asOpt[JsValue].flatMap { x => ErrorBandDefColorCodec.decodeOpt(x) }
      val `borders` = (j \ "borders").asOpt[JsValue].flatMap { x => ErrorBandDefBordersCodec.decodeOpt(x) }
      val `interpolate` = (j \ "interpolate").asOpt[JsValue].flatMap { x => InterpolateCodec.decodeOpt(x) }
      val `orient` = (j \ "orient").asOpt[JsValue].flatMap { x => OrientationCodec.decodeOpt(x) }
      val `opacity` = (j \ "opacity").asOpt[JsValue].flatMap { x => ErrorBandDefOpacityCodec.decodeOpt(x) }
      val `tension` = (j \ "tension").asOpt[JsValue].flatMap { x => ErrorBandDefTensionCodec.decodeOpt(x) }
      val `band` = (j \ "band").asOpt[JsValue].flatMap { x => ErrorBandDefBandCodec.decodeOpt(x) }
      val `type` = (j \ "type").asOpt[JsValue].flatMap { x => ErrorBandCodec.decodeOpt(x) }
      if(`type`.isEmpty) { return None }
      val `clip` = (j \ "clip").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      return Some(ErrorBandDef(
        `extent` = `extent`,
        `color` = `color`,
        `borders` = `borders`,
        `interpolate` = `interpolate`,
        `orient` = `orient`,
        `opacity` = `opacity`,
        `tension` = `tension`,
        `band` = `band`,
        `type` = `type`.get,
        `clip` = `clip`,
      ))
    }

  def encode(j: ErrorBandDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`extent`.map { x => "extent" -> ErrorBarExtentCodec.encode(x) },
        j.`color`.map { x => "color" -> ErrorBandDefColorCodec.encode(x) },
        j.`borders`.map { x => "borders" -> ErrorBandDefBordersCodec.encode(x) },
        j.`interpolate`.map { x => "interpolate" -> InterpolateCodec.encode(x) },
        j.`orient`.map { x => "orient" -> OrientationCodec.encode(x) },
        j.`opacity`.map { x => "opacity" -> ErrorBandDefOpacityCodec.encode(x) },
        j.`tension`.map { x => "tension" -> ErrorBandDefTensionCodec.encode(x) },
        j.`band`.map { x => "band" -> ErrorBandDefBandCodec.encode(x) },
        Some("type" -> ErrorBandCodec.encode(j.`type`)),
        j.`clip`.map { x => "clip" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AxisConfigTitleY (UnionType)
object AxisConfigTitleYCodec {
  def decode(j: JsValue): AxisConfigTitleY =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTitleY] =
    j.asOpt[JsNumber].map { AxisConfigTitleYAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigTitleY): JsValue =
    j match {
      case AxisConfigTitleYAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigPadAngle (UnionType)
object TickConfigPadAngleCodec {
  def decode(j: JsValue): TickConfigPadAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigPadAngle] =
    j.asOpt[JsNumber].map { TickConfigPadAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigPadAngle): JsValue =
    j match {
      case TickConfigPadAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigRadius2 (ConstrainedType)
// see AreaConfigRadius2 (UnionType)

////////////////////////////////////////////////////////////////////////
// PositionFieldDefBaseBin (UnionType)
object PositionFieldDefBaseBinCodec {
  def decode(j: JsValue): PositionFieldDefBaseBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PositionFieldDefBaseBin] =
    j.asOpt[Boolean].map { PositionFieldDefBaseBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    BinnedCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => PositionFieldDefBaseBinAsNull } } } } 
  def encode(j: PositionFieldDefBaseBin): JsValue =
    j match {
      case PositionFieldDefBaseBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case x:Binned /* TypeRef */ => BinnedCodec.encode(x)
      case PositionFieldDefBaseBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// AxisDomainWidth (UnionType)
object AxisDomainWidthCodec {
  def decode(j: JsValue): AxisDomainWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisDomainWidth] =
    j.asOpt[JsNumber].map { AxisDomainWidthAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisDomainWidth): JsValue =
    j match {
      case AxisDomainWidthAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingLongitudeTimeUnit (UnionType)
object SharedEncodingLongitudeTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingLongitudeTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingLongitudeTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingLongitudeTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigEllipsis (UnionType)
object RectConfigEllipsisCodec {
  def decode(j: JsValue): RectConfigEllipsis =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigEllipsis] =
    j.asOpt[String].map { RectConfigEllipsisAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigEllipsis): JsValue =
    j match {
      case RectConfigEllipsisAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// QuantileTransform (StructType)
object QuantileTransformCodec {
  def decode(j: JsValue): QuantileTransform =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[QuantileTransform] =
    {
      val `step` = (j \ "step").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `probs` = (j \ "probs").asOpt[JsValue].flatMap { x => ArrayOfNumberCodec.decodeOpt(x) }
      val `as` = (j \ "as").asOpt[JsValue].flatMap { x => QuantileTransformAsCodec.decodeOpt(x) }
      val `quantile` = (j \ "quantile").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`quantile`.isEmpty) { return None }
      val `groupby` = (j \ "groupby").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) }
      return Some(QuantileTransform(
        `step` = `step`,
        `probs` = `probs`,
        `as` = `as`,
        `quantile` = `quantile`.get,
        `groupby` = `groupby`,
      ))
    }

  def encode(j: QuantileTransform): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`step`.map { x => "step" -> Json.toJson(x) },
        j.`probs`.map { x => "probs" -> ArrayOfNumberCodec.encode(x) },
        j.`as`.map { x => "as" -> QuantileTransformAsCodec.encode(x) },
        Some("quantile" -> Json.toJson(j.`quantile`)),
        j.`groupby`.map { x => "groupby" -> ArrayOfStringCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ScaleConfigBandPaddingOuter (UnionType)
object ScaleConfigBandPaddingOuterCodec {
  def decode(j: JsValue): ScaleConfigBandPaddingOuter =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleConfigBandPaddingOuter] =
    j.asOpt[JsNumber].map { ScaleConfigBandPaddingOuterAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleConfigBandPaddingOuter): JsValue =
    j match {
      case ScaleConfigBandPaddingOuterAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisDomainColor (UnionType)
object AxisDomainColorCodec {
  def decode(j: JsValue): AxisDomainColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisDomainColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => AxisDomainColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: AxisDomainColor): JsValue =
    j match {
      case AxisDomainColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefRadius2 (ConstrainedType)
// see MarkDefRadius2 (UnionType)

////////////////////////////////////////////////////////////////////////
// TopLevelUnitSpecSpacing (UnionType)
object TopLevelUnitSpecSpacingCodec {
  def decode(j: JsValue): TopLevelUnitSpecSpacing =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelUnitSpecSpacing] =
    j.asOpt[JsNumber].map { TopLevelUnitSpecSpacingAsNumber(_) }.orElse {
    RowColNumberCodec.decodeOpt(j) } 
  def encode(j: TopLevelUnitSpecSpacing): JsValue =
    j match {
      case TopLevelUnitSpecSpacingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:RowColNumber /* TypeRef */ => RowColNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ColorHex (ConstrainedType)
object ColorHexCodec {
  def decode(j: JsValue): ColorHex =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ColorHex] =
    try {
      j.asOpt[String]
        .map { ColorHex(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ColorHex): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterMarkPropFieldOrDatumDefAsObject1BandPosition (ConstrainedType)
object ConditionalParameterMarkPropFieldOrDatumDefAsObject1BandPositionCodec {
  def decode(j: JsValue): ConditionalParameterMarkPropFieldOrDatumDefAsObject1BandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalParameterMarkPropFieldOrDatumDefAsObject1BandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { ConditionalParameterMarkPropFieldOrDatumDefAsObject1BandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ConditionalParameterMarkPropFieldOrDatumDefAsObject1BandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// TickConfigEndAngle (UnionType)
object TickConfigEndAngleCodec {
  def decode(j: JsValue): TickConfigEndAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigEndAngle] =
    j.asOpt[JsNumber].map { TickConfigEndAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigEndAngle): JsValue =
    j match {
      case TickConfigEndAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefRadius2Offset (UnionType)
object OverlayMarkDefRadius2OffsetCodec {
  def decode(j: JsValue): OverlayMarkDefRadius2Offset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefRadius2Offset] =
    j.asOpt[JsNumber].map { OverlayMarkDefRadius2OffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefRadius2Offset): JsValue =
    j match {
      case OverlayMarkDefRadius2OffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderConfigFormat (UnionType)
object HeaderConfigFormatCodec {
  def decode(j: JsValue): HeaderConfigFormat =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigFormat] =
    j.asOpt[String].map { HeaderConfigFormatAsString(_) }.orElse {
    DictOfAnyCodec.decodeOpt(j).map { HeaderConfigFormatAsDictOfAny(_) } } 
  def encode(j: HeaderConfigFormat): JsValue =
    j match {
      case HeaderConfigFormatAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case HeaderConfigFormatAsDictOfAny(x) /* Base, MapType */ => DictOfAnyCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigStrokeOffset (UnionType)
object MarkConfigStrokeOffsetCodec {
  def decode(j: JsValue): MarkConfigStrokeOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigStrokeOffset] =
    j.asOpt[JsNumber].map { MarkConfigStrokeOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigStrokeOffset): JsValue =
    j match {
      case MarkConfigStrokeOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelLayerSpecTitle (UnionType)
object TopLevelLayerSpecTitleCodec {
  def decode(j: JsValue): TopLevelLayerSpecTitle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelLayerSpecTitle] =
    TextCodec.decodeOpt(j).orElse {
    TitleParamsCodec.decodeOpt(j) } 
  def encode(j: TopLevelLayerSpecTitle): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:TitleParams /* TypeRef */ => TitleParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Vector2Number (ConstrainedType)
object Vector2NumberCodec {
  def decode(j: JsValue): Vector2Number =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Vector2Number] =
    try {
      ArrayOfNumberCodec.decodeOpt(j)
        .map { Vector2Number(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: Vector2Number): JsValue =
    ArrayOfNumberCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// TopLevelFacetSpecParamsElement (UnionType)
object TopLevelFacetSpecParamsElementCodec {
  def decode(j: JsValue): TopLevelFacetSpecParamsElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelFacetSpecParamsElement] =
    VariableParameterCodec.decodeOpt(j).orElse {
    TopLevelSelectionParameterCodec.decodeOpt(j) } 
  def encode(j: TopLevelFacetSpecParamsElement): JsValue =
    j match {
      case x:VariableParameter /* TypeRef */ => VariableParameterCodec.encode(x)
      case x:TopLevelSelectionParameter /* TypeRef */ => TopLevelSelectionParameterCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingDescriptionTimeUnit (UnionType)
object SharedEncodingDescriptionTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingDescriptionTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingDescriptionTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingDescriptionTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigDescription (UnionType)
object LineConfigDescriptionCodec {
  def decode(j: JsValue): LineConfigDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigDescription] =
    j.asOpt[String].map { LineConfigDescriptionAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigDescription): JsValue =
    j match {
      case LineConfigDescriptionAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelLayerSpecBackground (UnionType)
object TopLevelLayerSpecBackgroundCodec {
  def decode(j: JsValue): TopLevelLayerSpecBackground =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelLayerSpecBackground] =
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TopLevelLayerSpecBackground): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateStringFieldDef (StructType)
object ConditionalPredicateStringFieldDefCodec {
  def decode(j: JsValue): ConditionalPredicateStringFieldDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateStringFieldDef] =
    {
      val `format` = (j \ "format").asOpt[JsValue].flatMap { x => ConditionalPredicateStringFieldDefFormatCodec.decodeOpt(x) }
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) }
      val `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => ConditionalPredicateStringFieldDefBandPositionCodec.decodeOpt(x) }
      val `formatType` = (j \ "formatType").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => ConditionalPredicateStringFieldDefBinCodec.decodeOpt(x) }
      val `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) }
      val `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => ConditionalPredicateStringFieldDefTimeUnitCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) }
      return Some(ConditionalPredicateStringFieldDef(
        `format` = `format`,
        `test` = `test`.get,
        `field` = `field`,
        `bandPosition` = `bandPosition`,
        `formatType` = `formatType`,
        `bin` = `bin`,
        `aggregate` = `aggregate`,
        `timeUnit` = `timeUnit`,
        `title` = `title`,
        `type` = `type`,
      ))
    }

  def encode(j: ConditionalPredicateStringFieldDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`format`.map { x => "format" -> ConditionalPredicateStringFieldDefFormatCodec.encode(x) },
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> ConditionalPredicateStringFieldDefBandPositionCodec.encode(x) },
        j.`formatType`.map { x => "formatType" -> Json.toJson(x) },
        j.`bin`.map { x => "bin" -> ConditionalPredicateStringFieldDefBinCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> ConditionalPredicateStringFieldDefTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// MarkDefEllipsis (UnionType)
object MarkDefEllipsisCodec {
  def decode(j: JsValue): MarkDefEllipsis =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefEllipsis] =
    j.asOpt[String].map { MarkDefEllipsisAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefEllipsis): JsValue =
    j match {
      case MarkDefEllipsisAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigStrokeWidthAsNumber (ConstrainedType)
object RectConfigStrokeWidthAsNumberCodec {
  def decode(j: JsValue): RectConfigStrokeWidthAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RectConfigStrokeWidthAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { RectConfigStrokeWidthAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: RectConfigStrokeWidthAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AxisAria (UnionType)
object AxisAriaCodec {
  def decode(j: JsValue): AxisAria =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisAria] =
    j.asOpt[Boolean].map { AxisAriaAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisAria): JsValue =
    j match {
      case AxisAriaAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigLabelFont (UnionType)
object LegendConfigLabelFontCodec {
  def decode(j: JsValue): LegendConfigLabelFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigLabelFont] =
    j.asOpt[String].map { LegendConfigLabelFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigLabelFont): JsValue =
    j match {
      case LegendConfigLabelFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderTitleLimit (UnionType)
object HeaderTitleLimitCodec {
  def decode(j: JsValue): HeaderTitleLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderTitleLimit] =
    j.asOpt[JsNumber].map { HeaderTitleLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderTitleLimit): JsValue =
    j match {
      case HeaderTitleLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisLabelFontSizeAsNumber (ConstrainedType)
object AxisLabelFontSizeAsNumberCodec {
  def decode(j: JsValue): AxisLabelFontSizeAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AxisLabelFontSizeAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AxisLabelFontSizeAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AxisLabelFontSizeAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ProjectionFraction (UnionType)
object ProjectionFractionCodec {
  def decode(j: JsValue): ProjectionFraction =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionFraction] =
    j.asOpt[JsNumber].map { ProjectionFractionAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionFraction): JsValue =
    j match {
      case ProjectionFractionAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefHeight (UnionType)
object OverlayMarkDefHeightCodec {
  def decode(j: JsValue): OverlayMarkDefHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefHeight] =
    j.asOpt[JsNumber].map { OverlayMarkDefHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefHeight): JsValue =
    j match {
      case OverlayMarkDefHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ValueDefWithConditionStringFieldDefText (StructType)
object ValueDefWithConditionStringFieldDefTextCodec {
  def decode(j: JsValue): ValueDefWithConditionStringFieldDefText =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ValueDefWithConditionStringFieldDefText] =
    Some(ValueDefWithConditionStringFieldDefText(
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => ValueDefWithConditionStringFieldDefTextConditionCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => ValueDefWithConditionStringFieldDefTextValueCodec.decodeOpt(x) },
    ))

  def encode(j: ValueDefWithConditionStringFieldDefText): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`condition`.map { x => "condition" -> ValueDefWithConditionStringFieldDefTextConditionCodec.encode(x) },
        j.`value`.map { x => "value" -> ValueDefWithConditionStringFieldDefTextValueCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeWidthType (UnionType)
object SharedEncodingStrokeWidthTypeCodec {
  def decode(j: JsValue): SharedEncodingStrokeWidthType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeWidthType] =
    StandardTypeCodec.decodeOpt(j).orElse {
    TypeCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingStrokeWidthType): JsValue =
    j match {
      case x:StandardType /* TypeRef */ => StandardTypeCodec.encode(x)
      case x:Type /* TypeRef */ => TypeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetedEncodingYError2 (UnionType)
object FacetedEncodingYError2Codec {
  def decode(j: JsValue): FacetedEncodingYError2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetedEncodingYError2] =
    SecondaryFieldDefCodec.decodeOpt(j).orElse {
    ValueDefNumberCodec.decodeOpt(j) } 
  def encode(j: FacetedEncodingYError2): JsValue =
    j match {
      case x:SecondaryFieldDef /* TypeRef */ => SecondaryFieldDefCodec.encode(x)
      case x:ValueDefNumber /* TypeRef */ => ValueDefNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopoDataFormat (StructType)
object TopoDataFormatCodec {
  def decode(j: JsValue): TopoDataFormat =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TopoDataFormat] =
    Some(TopoDataFormat(
      `feature` = (j \ "feature").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `mesh` = (j \ "mesh").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `parse` = (j \ "parse").asOpt[JsValue].flatMap { x => DictOfParseValueCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => TopoDataFormatTypeCodec.decodeOpt(x) },
    ))

  def encode(j: TopoDataFormat): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`feature`.map { x => "feature" -> Json.toJson(x) },
        j.`mesh`.map { x => "mesh" -> Json.toJson(x) },
        j.`parse`.map { x => "parse" -> DictOfParseValueCodec.encode(x) },
        j.`type`.map { x => "type" -> TopoDataFormatTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// FacetedEncodingHref (UnionType)
object FacetedEncodingHrefCodec {
  def decode(j: JsValue): FacetedEncodingHref =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetedEncodingHref] =
    StringFieldDefWithConditionCodec.decodeOpt(j).orElse {
    StringValueDefWithConditionCodec.decodeOpt(j) } 
  def encode(j: FacetedEncodingHref): JsValue =
    j match {
      case x:StringFieldDefWithCondition /* TypeRef */ => StringFieldDefWithConditionCodec.encode(x)
      case x:StringValueDefWithCondition /* TypeRef */ => StringValueDefWithConditionCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingY (StructType)
object SharedEncodingYCodec {
  def decode(j: JsValue): SharedEncodingY =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingY] =
    Some(SharedEncodingY(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingYBandPositionCodec.decodeOpt(x) },
      `stack` = (j \ "stack").asOpt[JsValue].flatMap { x => SharedEncodingYStackCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingYBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingYValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingYTimeUnitCodec.decodeOpt(x) },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingYDatumCodec.decodeOpt(x) },
      `impute` = (j \ "impute").asOpt[JsValue].flatMap { x => ImputeParamsCodec.decodeOpt(x).map { Some(_) }.flatten },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `axis` = (j \ "axis").asOpt[JsValue].flatMap { x => AxisCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => SharedEncodingYTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingY): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingYBandPositionCodec.encode(x) },
        j.`stack`.map { x => "stack" -> SharedEncodingYStackCodec.encode(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingYBinCodec.encode(x) },
        j.`value`.map { x => "value" -> SharedEncodingYValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingYTimeUnitCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingYDatumCodec.encode(x) },
        j.`impute`.map { x => "impute" -> ImputeParamsCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`axis`.map { x => "axis" -> AxisCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> SharedEncodingYTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TickConfigStrokeOpacity (UnionType)
object TickConfigStrokeOpacityCodec {
  def decode(j: JsValue): TickConfigStrokeOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigStrokeOpacity] =
    TickConfigStrokeOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigStrokeOpacity): JsValue =
    j match {
      case x:TickConfigStrokeOpacityAsNumber /* TypeRef */ => TickConfigStrokeOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FilterTransform (StructType)
object FilterTransformCodec {
  def decode(j: JsValue): FilterTransform =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FilterTransform] =
    {
      val `filter` = (j \ "filter").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`filter`.isEmpty) { return None }
      return Some(FilterTransform(
        `filter` = `filter`.get,
      ))
    }

  def encode(j: FilterTransform): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("filter" -> PredicateCompositionCodec.encode(j.`filter`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConfigLineBreak (UnionType)
object ConfigLineBreakCodec {
  def decode(j: JsValue): ConfigLineBreak =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConfigLineBreak] =
    j.asOpt[String].map { ConfigLineBreakAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ConfigLineBreak): JsValue =
    j match {
      case ConfigLineBreakAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelVConcatSpecAutosize (UnionType)
object TopLevelVConcatSpecAutosizeCodec {
  def decode(j: JsValue): TopLevelVConcatSpecAutosize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelVConcatSpecAutosize] =
    AutosizeTypeCodec.decodeOpt(j).orElse {
    AutoSizeParamsCodec.decodeOpt(j) } 
  def encode(j: TopLevelVConcatSpecAutosize): JsValue =
    j match {
      case x:AutosizeType /* TypeRef */ => AutosizeTypeCodec.encode(x)
      case x:AutoSizeParams /* TypeRef */ => AutoSizeParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RegressionTransformExtent (ConstrainedType)
object RegressionTransformExtentCodec {
  def decode(j: JsValue): RegressionTransformExtent =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RegressionTransformExtent] =
    try {
      ArrayOfNumberCodec.decodeOpt(j)
        .map { RegressionTransformExtent(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: RegressionTransformExtent): JsValue =
    ArrayOfNumberCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkConfigTension (UnionType)
object MarkConfigTensionCodec {
  def decode(j: JsValue): MarkConfigTension =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigTension] =
    j.asOpt[JsNumber].map { MarkConfigTensionAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigTension): JsValue =
    j match {
      case MarkConfigTensionAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SelectionInitInterval (UnionType)
object SelectionInitIntervalCodec {
  def decode(j: JsValue): SelectionInitInterval =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SelectionInitInterval] =
    Vector2BooleanCodec.decodeOpt(j).orElse {
    Vector2NumberCodec.decodeOpt(j).orElse {
    Vector2StringCodec.decodeOpt(j).orElse {
    Vector2DateTimeCodec.decodeOpt(j) } } } 
  def encode(j: SelectionInitInterval): JsValue =
    j match {
      case x:Vector2Boolean /* TypeRef */ => Vector2BooleanCodec.encode(x)
      case x:Vector2Number /* TypeRef */ => Vector2NumberCodec.encode(x)
      case x:Vector2String /* TypeRef */ => Vector2StringCodec.encode(x)
      case x:Vector2DateTime /* TypeRef */ => Vector2DateTimeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigFont (UnionType)
object BarConfigFontCodec {
  def decode(j: JsValue): BarConfigFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigFont] =
    j.asOpt[String].map { BarConfigFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigFont): JsValue =
    j match {
      case BarConfigFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefOrder (UnionType)
object MarkDefOrderCodec {
  def decode(j: JsValue): MarkDefOrder =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefOrder] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => MarkDefOrderAsNull }.orElse {
    j.asOpt[Boolean].map { MarkDefOrderAsBool(_) } } 
  def encode(j: MarkDefOrder): JsValue =
    j match {
      case MarkDefOrderAsNull /* Global, NullType$ */ => JsNull
      case MarkDefOrderAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelFacetSpec (StructType)
object TopLevelFacetSpecCodec {
  def decode(j: JsValue): TopLevelFacetSpec =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TopLevelFacetSpec] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `description` = (j \ "description").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `params` = (j \ "params").asOpt[JsValue].flatMap { x => ArrayOfTopLevelFacetSpecParamsElementCodec.decodeOpt(x) }
      val `config` = (j \ "config").asOpt[JsValue].flatMap { x => ConfigCodec.decodeOpt(x) }
      val `bounds` = (j \ "bounds").asOpt[JsValue].flatMap { x => TopLevelFacetSpecBoundsCodec.decodeOpt(x) }
      val `datasets` = (j \ "datasets").asOpt[JsValue].flatMap { x => DictOfInlineDatasetCodec.decodeOpt(x) }
      val `usermeta` = (j \ "usermeta").asOpt[JsValue].flatMap { x => DictOfAnyCodec.decodeOpt(x) }
      val `columns` = (j \ "columns").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `resolve` = (j \ "resolve").asOpt[JsValue].flatMap { x => ResolveCodec.decodeOpt(x) }
      val `spec` = (j \ "spec").asOpt[JsValue].flatMap { x => TopLevelFacetSpecSpecCodec.decodeOpt(x) }
      if(`spec`.isEmpty) { return None }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => TopLevelFacetSpecTitleCodec.decodeOpt(x) }
      val `background` = (j \ "background").asOpt[JsValue].flatMap { x => TopLevelFacetSpecBackgroundCodec.decodeOpt(x) }
      val `center` = (j \ "center").asOpt[JsValue].flatMap { x => TopLevelFacetSpecCenterCodec.decodeOpt(x) }
      val `align` = (j \ "align").asOpt[JsValue].flatMap { x => TopLevelFacetSpecAlignCodec.decodeOpt(x) }
      val `data` = (j \ "data").asOpt[JsValue].flatMap { x => DataCodec.decodeOpt(x).map { Some(_) }.flatten }
      if(`data`.isEmpty) { return None }
      val `facet` = (j \ "facet").asOpt[JsValue].flatMap { x => TopLevelFacetSpecFacetCodec.decodeOpt(x) }
      if(`facet`.isEmpty) { return None }
      val `padding` = (j \ "padding").asOpt[JsValue].flatMap { x => TopLevelFacetSpecPaddingCodec.decodeOpt(x) }
      val `spacing` = (j \ "spacing").asOpt[JsValue].flatMap { x => TopLevelFacetSpecSpacingCodec.decodeOpt(x) }
      val `$schema` = (j \ "$schema").asOpt[JsValue].flatMap { x => UriCodec.decodeOpt(x) }
      val `autosize` = (j \ "autosize").asOpt[JsValue].flatMap { x => TopLevelFacetSpecAutosizeCodec.decodeOpt(x) }
      val `transform` = (j \ "transform").asOpt[JsValue].flatMap { x => ArrayOfTransformCodec.decodeOpt(x) }
      return Some(TopLevelFacetSpec(
        `name` = `name`,
        `description` = `description`,
        `params` = `params`,
        `config` = `config`,
        `bounds` = `bounds`,
        `datasets` = `datasets`,
        `usermeta` = `usermeta`,
        `columns` = `columns`,
        `resolve` = `resolve`,
        `spec` = `spec`.get,
        `title` = `title`,
        `background` = `background`,
        `center` = `center`,
        `align` = `align`,
        `data` = `data`,
        `facet` = `facet`.get,
        `padding` = `padding`,
        `spacing` = `spacing`,
        `$schema` = `$schema`,
        `autosize` = `autosize`,
        `transform` = `transform`,
      ))
    }

  def encode(j: TopLevelFacetSpec): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`description`.map { x => "description" -> Json.toJson(x) },
        j.`params`.map { x => "params" -> ArrayOfTopLevelFacetSpecParamsElementCodec.encode(x) },
        j.`config`.map { x => "config" -> ConfigCodec.encode(x) },
        j.`bounds`.map { x => "bounds" -> TopLevelFacetSpecBoundsCodec.encode(x) },
        j.`datasets`.map { x => "datasets" -> DictOfInlineDatasetCodec.encode(x) },
        j.`usermeta`.map { x => "usermeta" -> DictOfAnyCodec.encode(x) },
        j.`columns`.map { x => "columns" -> Json.toJson(x) },
        j.`resolve`.map { x => "resolve" -> ResolveCodec.encode(x) },
        Some("spec" -> TopLevelFacetSpecSpecCodec.encode(j.`spec`)),
        j.`title`.map { x => "title" -> TopLevelFacetSpecTitleCodec.encode(x) },
        j.`background`.map { x => "background" -> TopLevelFacetSpecBackgroundCodec.encode(x) },
        j.`center`.map { x => "center" -> TopLevelFacetSpecCenterCodec.encode(x) },
        j.`align`.map { x => "align" -> TopLevelFacetSpecAlignCodec.encode(x) },
        j.`data`.map { x => "data" -> DataCodec.encode(x) },
        Some("facet" -> TopLevelFacetSpecFacetCodec.encode(j.`facet`)),
        j.`padding`.map { x => "padding" -> TopLevelFacetSpecPaddingCodec.encode(x) },
        j.`spacing`.map { x => "spacing" -> TopLevelFacetSpecSpacingCodec.encode(x) },
        j.`$schema`.map { x => "$schema" -> UriCodec.encode(x) },
        j.`autosize`.map { x => "autosize" -> TopLevelFacetSpecAutosizeCodec.encode(x) },
        j.`transform`.map { x => "transform" -> ArrayOfTransformCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// OverlayMarkDefAria (UnionType)
object OverlayMarkDefAriaCodec {
  def decode(j: JsValue): OverlayMarkDefAria =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefAria] =
    j.asOpt[Boolean].map { OverlayMarkDefAriaAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefAria): JsValue =
    j match {
      case OverlayMarkDefAriaAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewBackgroundStrokeJoin (UnionType)
object ViewBackgroundStrokeJoinCodec {
  def decode(j: JsValue): ViewBackgroundStrokeJoin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewBackgroundStrokeJoin] =
    StrokeJoinCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ViewBackgroundStrokeJoin): JsValue =
    j match {
      case x:StrokeJoin /* TypeRef */ => StrokeJoinCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Uri (TypeRef)
object UriCodec {
  def decode(j: JsValue): Uri = j.as[Uri]
  def decodeOpt(j: JsValue): Option[Uri] = j.asOpt[Uri]
  def encode(j: Uri): JsValue = Json.toJson(j)
}

////////////////////////////////////////////////////////////////////////
// LayerSpec (StructType)
object LayerSpecCodec {
  def decode(j: JsValue): LayerSpec =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LayerSpec] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `projection` = (j \ "projection").asOpt[JsValue].flatMap { x => ProjectionCodec.decodeOpt(x) }
      val `description` = (j \ "description").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `data` = (j \ "data").asOpt[JsValue].flatMap { x => DataCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `height` = (j \ "height").asOpt[JsValue].flatMap { x => LayerSpecHeightCodec.decodeOpt(x) }
      val `encoding` = (j \ "encoding").asOpt[JsValue].flatMap { x => SharedEncodingCodec.decodeOpt(x) }
      val `layer` = (j \ "layer").asOpt[JsValue].flatMap { x => ArrayOfLayerSpecLayerElementCodec.decodeOpt(x) }
      if(`layer`.isEmpty) { return None }
      val `resolve` = (j \ "resolve").asOpt[JsValue].flatMap { x => ResolveCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => LayerSpecTitleCodec.decodeOpt(x) }
      val `view` = (j \ "view").asOpt[JsValue].flatMap { x => ViewBackgroundCodec.decodeOpt(x) }
      val `transform` = (j \ "transform").asOpt[JsValue].flatMap { x => ArrayOfTransformCodec.decodeOpt(x) }
      val `width` = (j \ "width").asOpt[JsValue].flatMap { x => LayerSpecWidthCodec.decodeOpt(x) }
      return Some(LayerSpec(
        `name` = `name`,
        `projection` = `projection`,
        `description` = `description`,
        `data` = `data`,
        `height` = `height`,
        `encoding` = `encoding`,
        `layer` = `layer`.get,
        `resolve` = `resolve`,
        `title` = `title`,
        `view` = `view`,
        `transform` = `transform`,
        `width` = `width`,
      ))
    }

  def encode(j: LayerSpec): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`projection`.map { x => "projection" -> ProjectionCodec.encode(x) },
        j.`description`.map { x => "description" -> Json.toJson(x) },
        j.`data`.map { x => "data" -> DataCodec.encode(x) },
        j.`height`.map { x => "height" -> LayerSpecHeightCodec.encode(x) },
        j.`encoding`.map { x => "encoding" -> SharedEncodingCodec.encode(x) },
        Some("layer" -> ArrayOfLayerSpecLayerElementCodec.encode(j.`layer`)),
        j.`resolve`.map { x => "resolve" -> ResolveCodec.encode(x) },
        j.`title`.map { x => "title" -> LayerSpecTitleCodec.encode(x) },
        j.`view`.map { x => "view" -> ViewBackgroundCodec.encode(x) },
        j.`transform`.map { x => "transform" -> ArrayOfTransformCodec.encode(x) },
        j.`width`.map { x => "width" -> LayerSpecWidthCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// BarConfigTheta (UnionType)
object BarConfigThetaCodec {
  def decode(j: JsValue): BarConfigTheta =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigTheta] =
    j.asOpt[JsNumber].map { BarConfigThetaAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigTheta): JsValue =
    j match {
      case BarConfigThetaAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingSize (StructType)
object SharedEncodingSizeCodec {
  def decode(j: JsValue): SharedEncodingSize =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingSize] =
    Some(SharedEncodingSize(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingSizeDatumCodec.decodeOpt(x) },
      `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingSizeBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => SharedEncodingSizeConditionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingSizeBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingSizeValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingSizeTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => SharedEncodingSizeTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingSize): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingSizeDatumCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingSizeBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> SharedEncodingSizeConditionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingSizeBinCodec.encode(x) },
        j.`value`.map { x => "value" -> SharedEncodingSizeValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingSizeTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> SharedEncodingSizeTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// EncodingXError (UnionType)
object EncodingXErrorCodec {
  def decode(j: JsValue): EncodingXError =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[EncodingXError] =
    SecondaryFieldDefCodec.decodeOpt(j).orElse {
    ValueDefNumberCodec.decodeOpt(j) } 
  def encode(j: EncodingXError): JsValue =
    j match {
      case x:SecondaryFieldDef /* TypeRef */ => SecondaryFieldDefCodec.encode(x)
      case x:ValueDefNumber /* TypeRef */ => ValueDefNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigBinSpacing (ConstrainedType)
object BarConfigBinSpacingCodec {
  def decode(j: JsValue): BarConfigBinSpacing =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BarConfigBinSpacing] =
    try {
      j.asOpt[JsNumber]
        .map { BarConfigBinSpacing(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: BarConfigBinSpacing): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefNumberNullExprRefAsObject1 (StructType)
object ConditionalPredicateValueDefNumberNullExprRefAsObject1Codec {
  def decode(j: JsValue): ConditionalPredicateValueDefNumberNullExprRefAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefNumberNullExprRefAsObject1] =
    {
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => ArrayOfNumberCodec.decodeOpt(x).map { Some(_) }.flatten }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalPredicateValueDefNumberNullExprRefAsObject1(
        `test` = `test`.get,
        `value` = `value`,
      ))
    }

  def encode(j: ConditionalPredicateValueDefNumberNullExprRefAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
        j.`value`.map { x => "value" -> ArrayOfNumberCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1BandPosition (ConstrainedType)
object ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1BandPositionCodec {
  def decode(j: JsValue): ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1BandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1BandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1BandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1BandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// UrlData (StructType)
object UrlDataCodec {
  def decode(j: JsValue): UrlData =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[UrlData] =
    {
      val `format` = (j \ "format").asOpt[JsValue].flatMap { x => DataFormatCodec.decodeOpt(x) }
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `url` = (j \ "url").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`url`.isEmpty) { return None }
      return Some(UrlData(
        `format` = `format`,
        `name` = `name`,
        `url` = `url`.get,
      ))
    }

  def encode(j: UrlData): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`format`.map { x => "format" -> DataFormatCodec.encode(x) },
        j.`name`.map { x => "name" -> Json.toJson(x) },
        Some("url" -> Json.toJson(j.`url`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// OverlayMarkDefXOffset (UnionType)
object OverlayMarkDefXOffsetCodec {
  def decode(j: JsValue): OverlayMarkDefXOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefXOffset] =
    j.asOpt[JsNumber].map { OverlayMarkDefXOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefXOffset): JsValue =
    j match {
      case OverlayMarkDefXOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TimeUnitParams (StructType)
object TimeUnitParamsCodec {
  def decode(j: JsValue): TimeUnitParams =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TimeUnitParams] =
    Some(TimeUnitParams(
      `maxbins` = (j \ "maxbins").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `step` = (j \ "step").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `unit` = (j \ "unit").asOpt[JsValue].flatMap { x => TimeUnitCodec.decodeOpt(x) },
      `utc` = (j \ "utc").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
    ))

  def encode(j: TimeUnitParams): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`maxbins`.map { x => "maxbins" -> Json.toJson(x) },
        j.`step`.map { x => "step" -> Json.toJson(x) },
        j.`unit`.map { x => "unit" -> TimeUnitCodec.encode(x) },
        j.`utc`.map { x => "utc" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LineTop (ConstantType)
object LineTopCodec {
  def decode(j: JsValue): LineTop =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LineTop] =
    j match {
      case JsString("line-top") => Some(LineTop())
      case _ => None
    }
  def encode(j: LineTop): JsValue =
    JsString("line-top")
}


////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionStringFieldDefTextFormat (UnionType)
object FieldOrDatumDefWithConditionStringFieldDefTextFormatCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionStringFieldDefTextFormat =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionStringFieldDefTextFormat] =
    j.asOpt[String].map { FieldOrDatumDefWithConditionStringFieldDefTextFormatAsString(_) }.orElse {
    DictOfAnyCodec.decodeOpt(j).map { FieldOrDatumDefWithConditionStringFieldDefTextFormatAsDictOfAny(_) } } 
  def encode(j: FieldOrDatumDefWithConditionStringFieldDefTextFormat): JsValue =
    j match {
      case FieldOrDatumDefWithConditionStringFieldDefTextFormatAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case FieldOrDatumDefWithConditionStringFieldDefTextFormatAsDictOfAny(x) /* Base, MapType */ => DictOfAnyCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigStrokeOpacityAsNumber (ConstrainedType)
object MarkConfigStrokeOpacityAsNumberCodec {
  def decode(j: JsValue): MarkConfigStrokeOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[MarkConfigStrokeOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { MarkConfigStrokeOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: MarkConfigStrokeOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingDescriptionBin (UnionType)
object SharedEncodingDescriptionBinCodec {
  def decode(j: JsValue): SharedEncodingDescriptionBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingDescriptionBin] =
    j.asOpt[Boolean].map { SharedEncodingDescriptionBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    BinnedCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingDescriptionBinAsNull } } } } 
  def encode(j: SharedEncodingDescriptionBin): JsValue =
    j match {
      case SharedEncodingDescriptionBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case x:Binned /* TypeRef */ => BinnedCodec.encode(x)
      case SharedEncodingDescriptionBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfVector2Number (ArrayType)
object ArrayOfVector2NumberCodec {
  def decode(j: JsValue): Seq[Vector2Number] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[Vector2Number]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      Vector2NumberCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[Vector2Number]): JsArray =
      JsArray(j.map { x => Vector2NumberCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeDashCondition (UnionType)
object SharedEncodingStrokeDashConditionCodec {
  def decode(j: JsValue): SharedEncodingStrokeDashCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeDashCondition] =
    ConditionalValueDefNumberExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefNumberExprRefCodec.decodeOpt(j).map { SharedEncodingStrokeDashConditionAsArrayOfConditionalValueDefNumberExprRef(_) }.orElse {
    ConditionalMarkPropFieldOrDatumDefCodec.decodeOpt(j) } } 
  def encode(j: SharedEncodingStrokeDashCondition): JsValue =
    j match {
      case x:ConditionalValueDefNumberExprRef /* TypeRef */ => ConditionalValueDefNumberExprRefCodec.encode(x)
      case SharedEncodingStrokeDashConditionAsArrayOfConditionalValueDefNumberExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefNumberExprRefCodec.encode(x)
      case x:ConditionalMarkPropFieldOrDatumDef /* TypeRef */ => ConditionalMarkPropFieldOrDatumDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ParameterPredicate (StructType)
object ParameterPredicateCodec {
  def decode(j: JsValue): ParameterPredicate =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ParameterPredicate] =
    {
      val `empty` = (j \ "empty").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `param` = (j \ "param").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`param`.isEmpty) { return None }
      return Some(ParameterPredicate(
        `empty` = `empty`,
        `param` = `param`.get,
      ))
    }

  def encode(j: ParameterPredicate): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`empty`.map { x => "empty" -> Json.toJson(x) },
        Some("param" -> Json.toJson(j.`param`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// RectConfigUrl (UnionType)
object RectConfigUrlCodec {
  def decode(j: JsValue): RectConfigUrl =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigUrl] =
    UriReferenceCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigUrl): JsValue =
    j match {
      case x:UriReference /* TypeRef */ => UriReferenceCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigPosition (UnionType)
object AxisConfigPositionCodec {
  def decode(j: JsValue): AxisConfigPosition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigPosition] =
    j.asOpt[JsNumber].map { AxisConfigPositionAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigPosition): JsValue =
    j match {
      case AxisConfigPositionAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingFillTimeUnit (UnionType)
object SharedEncodingFillTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingFillTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingFillTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingFillTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RepeatSpec (UnionType)
object RepeatSpecCodec {
  def decode(j: JsValue): RepeatSpec =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RepeatSpec] =
    NonLayerRepeatSpecCodec.decodeOpt(j).orElse {
    LayerRepeatSpecCodec.decodeOpt(j) } 
  def encode(j: RepeatSpec): JsValue =
    j match {
      case x:NonLayerRepeatSpec /* TypeRef */ => NonLayerRepeatSpecCodec.encode(x)
      case x:LayerRepeatSpec /* TypeRef */ => LayerRepeatSpecCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStroke (StructType)
object SharedEncodingStrokeCodec {
  def decode(j: JsValue): SharedEncodingStroke =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingStroke] =
    Some(SharedEncodingStroke(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingStrokeDatumCodec.decodeOpt(x) },
      `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingStrokeBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => SharedEncodingStrokeConditionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingStrokeBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingStrokeValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingStrokeTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => SharedEncodingStrokeTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingStroke): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingStrokeDatumCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingStrokeBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> SharedEncodingStrokeConditionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingStrokeBinCodec.encode(x) },
        j.`value`.map { x => "value" -> SharedEncodingStrokeValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingStrokeTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> SharedEncodingStrokeTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AxisConfigGridWidth (UnionType)
object AxisConfigGridWidthCodec {
  def decode(j: JsValue): AxisConfigGridWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigGridWidth] =
    AxisConfigGridWidthAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigGridWidth): JsValue =
    j match {
      case x:AxisConfigGridWidthAsNumber /* TypeRef */ => AxisConfigGridWidthAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTitleOpacity (UnionType)
object AxisTitleOpacityCodec {
  def decode(j: JsValue): AxisTitleOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTitleOpacity] =
    j.asOpt[JsNumber].map { AxisTitleOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisTitleOpacity): JsValue =
    j match {
      case AxisTitleOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigStrokeWidthAsNumber (ConstrainedType)
object MarkConfigStrokeWidthAsNumberCodec {
  def decode(j: JsValue): MarkConfigStrokeWidthAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[MarkConfigStrokeWidthAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { MarkConfigStrokeWidthAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: MarkConfigStrokeWidthAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// NonArgAggregateOp (EnumType)
object NonArgAggregateOpCodec {
  def decode(j: JsValue): NonArgAggregateOp =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[NonArgAggregateOp] =
    j match {
      case JsString("average") => Some(NonArgAggregateOpAverage)
      case JsString("count") => Some(NonArgAggregateOpCount)
      case JsString("distinct") => Some(NonArgAggregateOpDistinct)
      case JsString("max") => Some(NonArgAggregateOpMax)
      case JsString("mean") => Some(NonArgAggregateOpMean)
      case JsString("median") => Some(NonArgAggregateOpMedian)
      case JsString("min") => Some(NonArgAggregateOpMin)
      case JsString("missing") => Some(NonArgAggregateOpMissing)
      case JsString("product") => Some(NonArgAggregateOpProduct)
      case JsString("q1") => Some(NonArgAggregateOpQ1)
      case JsString("q3") => Some(NonArgAggregateOpQ3)
      case JsString("ci0") => Some(NonArgAggregateOpCi0)
      case JsString("ci1") => Some(NonArgAggregateOpCi1)
      case JsString("stderr") => Some(NonArgAggregateOpStderr)
      case JsString("stdev") => Some(NonArgAggregateOpStdev)
      case JsString("stdevp") => Some(NonArgAggregateOpStdevp)
      case JsString("sum") => Some(NonArgAggregateOpSum)
      case JsString("valid") => Some(NonArgAggregateOpValid)
      case JsString("values") => Some(NonArgAggregateOpValues)
      case JsString("variance") => Some(NonArgAggregateOpVariance)
      case JsString("variancep") => Some(NonArgAggregateOpVariancep)
      case _ => None
    }
  def encode(j: NonArgAggregateOp): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// IntervalSelectionConfigWithoutTypeTranslate (UnionType)
object IntervalSelectionConfigWithoutTypeTranslateCodec {
  def decode(j: JsValue): IntervalSelectionConfigWithoutTypeTranslate =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[IntervalSelectionConfigWithoutTypeTranslate] =
    j.asOpt[String].map { IntervalSelectionConfigWithoutTypeTranslateAsString(_) }.orElse {
    j.asOpt[Boolean].map { IntervalSelectionConfigWithoutTypeTranslateAsBool(_) } } 
  def encode(j: IntervalSelectionConfigWithoutTypeTranslate): JsValue =
    j match {
      case IntervalSelectionConfigWithoutTypeTranslateAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case IntervalSelectionConfigWithoutTypeTranslateAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Alphabetic (ConstantType)
object AlphabeticCodec {
  def decode(j: JsValue): Alphabetic =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Alphabetic] =
    j match {
      case JsString("alphabetic") => Some(Alphabetic())
      case _ => None
    }
  def encode(j: Alphabetic): JsValue =
    JsString("alphabetic")
}


////////////////////////////////////////////////////////////////////////
// ConditionalValueDefNumberExprRef (UnionType)
object ConditionalValueDefNumberExprRefCodec {
  def decode(j: JsValue): ConditionalValueDefNumberExprRef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalValueDefNumberExprRef] =
    ConditionalPredicateValueDefNumberExprRefCodec.decodeOpt(j).orElse {
    ConditionalParameterValueDefNumberExprRefCodec.decodeOpt(j) } 
  def encode(j: ConditionalValueDefNumberExprRef): JsValue =
    j match {
      case x:ConditionalPredicateValueDefNumberExprRef /* TypeRef */ => ConditionalPredicateValueDefNumberExprRefCodec.encode(x)
      case x:ConditionalParameterValueDefNumberExprRef /* TypeRef */ => ConditionalParameterValueDefNumberExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Color (UnionType)
object ColorCodec {
  def decode(j: JsValue): Color =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Color] =
    ColorNameCodec.decodeOpt(j).orElse {
    ColorHexCodec.decodeOpt(j).orElse {
    j.asOpt[String].map { ColorAsString(_) } } } 
  def encode(j: Color): JsValue =
    j match {
      case x:ColorName /* TypeRef */ => ColorNameCodec.encode(x)
      case x:ColorHex /* TypeRef */ => ColorHexCodec.encode(x)
      case ColorAsString(x) /* Base, StringType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionParallel (UnionType)
object ProjectionParallelCodec {
  def decode(j: JsValue): ProjectionParallel =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionParallel] =
    j.asOpt[JsNumber].map { ProjectionParallelAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionParallel): JsValue =
    j match {
      case ProjectionParallelAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2Datum (UnionType)
object ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2DatumCodec {
  def decode(j: JsValue): ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2Datum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2Datum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject2Datum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisLabelFontStyleAsObject1Condition (UnionType)
object ConditionalAxisLabelFontStyleAsObject1ConditionCodec {
  def decode(j: JsValue): ConditionalAxisLabelFontStyleAsObject1Condition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisLabelFontStyleAsObject1Condition] =
    ConditionalPredicateValueDefFontStyleNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalPredicateValueDefFontStyleNullExprRefCodec.decodeOpt(j).map { ConditionalAxisLabelFontStyleAsObject1ConditionAsArrayOfConditionalPredicateValueDefFontStyleNullExprRef(_) } } 
  def encode(j: ConditionalAxisLabelFontStyleAsObject1Condition): JsValue =
    j match {
      case x:ConditionalPredicateValueDefFontStyleNullExprRef /* TypeRef */ => ConditionalPredicateValueDefFontStyleNullExprRefCodec.encode(x)
      case ConditionalAxisLabelFontStyleAsObject1ConditionAsArrayOfConditionalPredicateValueDefFontStyleNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalPredicateValueDefFontStyleNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfConditionalPredicateValueDefFontStyleNullExprRef (ArrayType)
object ArrayOfConditionalPredicateValueDefFontStyleNullExprRefCodec {
  def decode(j: JsValue): Seq[ConditionalPredicateValueDefFontStyleNullExprRef] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[ConditionalPredicateValueDefFontStyleNullExprRef]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      ConditionalPredicateValueDefFontStyleNullExprRefCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[ConditionalPredicateValueDefFontStyleNullExprRef]): JsArray =
      JsArray(j.map { x => ConditionalPredicateValueDefFontStyleNullExprRefCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// TopLevelUnitSpecAutosize (UnionType)
object TopLevelUnitSpecAutosizeCodec {
  def decode(j: JsValue): TopLevelUnitSpecAutosize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelUnitSpecAutosize] =
    AutosizeTypeCodec.decodeOpt(j).orElse {
    AutoSizeParamsCodec.decodeOpt(j) } 
  def encode(j: TopLevelUnitSpecAutosize): JsValue =
    j match {
      case x:AutosizeType /* TypeRef */ => AutosizeTypeCodec.encode(x)
      case x:AutoSizeParams /* TypeRef */ => AutoSizeParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SortByEncoding (StructType)
object SortByEncodingCodec {
  def decode(j: JsValue): SortByEncoding =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SortByEncoding] =
    {
      val `encoding` = (j \ "encoding").asOpt[JsValue].flatMap { x => SortByChannelCodec.decodeOpt(x) }
      if(`encoding`.isEmpty) { return None }
      val `order` = (j \ "order").asOpt[JsValue].flatMap { x => SortOrderCodec.decodeOpt(x).map { Some(_) }.flatten }
      return Some(SortByEncoding(
        `encoding` = `encoding`.get,
        `order` = `order`,
      ))
    }

  def encode(j: SortByEncoding): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("encoding" -> SortByChannelCodec.encode(j.`encoding`)),
        j.`order`.map { x => "order" -> SortOrderCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullCondition (UnionType)
object FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullConditionCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullCondition] =
    ConditionalValueDefStringNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefStringNullExprRefCodec.decodeOpt(j).map { FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullConditionAsArrayOfConditionalValueDefStringNullExprRef(_) } } 
  def encode(j: FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullCondition): JsValue =
    j match {
      case x:ConditionalValueDefStringNullExprRef /* TypeRef */ => ConditionalValueDefStringNullExprRefCodec.encode(x)
      case FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullConditionAsArrayOfConditionalValueDefStringNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefStringNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigFormat (UnionType)
object AxisConfigFormatCodec {
  def decode(j: JsValue): AxisConfigFormat =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigFormat] =
    j.asOpt[String].map { AxisConfigFormatAsString(_) }.orElse {
    DictOfAnyCodec.decodeOpt(j).map { AxisConfigFormatAsDictOfAny(_) } } 
  def encode(j: AxisConfigFormat): JsValue =
    j match {
      case AxisConfigFormatAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case AxisConfigFormatAsDictOfAny(x) /* Base, MapType */ => DictOfAnyCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Quantitative (ConstantType)
object QuantitativeCodec {
  def decode(j: JsValue): Quantitative =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Quantitative] =
    j match {
      case JsString("quantitative") => Some(Quantitative())
      case _ => None
    }
  def encode(j: Quantitative): JsValue =
    JsString("quantitative")
}


////////////////////////////////////////////////////////////////////////
// ConditionalAxisNumberArray (UnionType)
object ConditionalAxisNumberArrayCodec {
  def decode(j: JsValue): ConditionalAxisNumberArray =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisNumberArray] =
    ConditionalAxisNumberArrayAsObject1Codec.decodeOpt(j).orElse {
    ConditionalAxisNumberArrayAsObject2Codec.decodeOpt(j) } 
  def encode(j: ConditionalAxisNumberArray): JsValue =
    j match {
      case x:ConditionalAxisNumberArrayAsObject1 /* TypeRef */ => ConditionalAxisNumberArrayAsObject1Codec.encode(x)
      case x:ConditionalAxisNumberArrayAsObject2 /* TypeRef */ => ConditionalAxisNumberArrayAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigY (UnionType)
object BarConfigYCodec {
  def decode(j: JsValue): BarConfigY =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigY] =
    j.asOpt[JsNumber].map { BarConfigYAsNumber(_) }.orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: BarConfigY): JsValue =
    j match {
      case BarConfigYAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTitleFontWeight (UnionType)
object AxisConfigTitleFontWeightCodec {
  def decode(j: JsValue): AxisConfigTitleFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTitleFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigTitleFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Position2Def (UnionType)
object Position2DefCodec {
  def decode(j: JsValue): Position2Def =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Position2Def] =
    SecondaryFieldDefCodec.decodeOpt(j).orElse {
    DatumDefCodec.decodeOpt(j).orElse {
    PositionValueDefCodec.decodeOpt(j) } } 
  def encode(j: Position2Def): JsValue =
    j match {
      case x:SecondaryFieldDef /* TypeRef */ => SecondaryFieldDefCodec.encode(x)
      case x:DatumDef /* TypeRef */ => DatumDefCodec.encode(x)
      case x:PositionValueDef /* TypeRef */ => PositionValueDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldGTPredicateGt (UnionType)
object FieldGTPredicateGtCodec {
  def decode(j: JsValue): FieldGTPredicateGt =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldGTPredicateGt] =
    j.asOpt[String].map { FieldGTPredicateGtAsString(_) }.orElse {
    j.asOpt[JsNumber].map { FieldGTPredicateGtAsNumber(_) }.orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: FieldGTPredicateGt): JsValue =
    j match {
      case FieldGTPredicateGtAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case FieldGTPredicateGtAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterStringFieldDef (StructType)
object ConditionalParameterStringFieldDefCodec {
  def decode(j: JsValue): ConditionalParameterStringFieldDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalParameterStringFieldDef] =
    {
      val `format` = (j \ "format").asOpt[JsValue].flatMap { x => ConditionalParameterStringFieldDefFormatCodec.decodeOpt(x) }
      val `empty` = (j \ "empty").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) }
      val `param` = (j \ "param").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`param`.isEmpty) { return None }
      val `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => ConditionalParameterStringFieldDefBandPositionCodec.decodeOpt(x) }
      val `formatType` = (j \ "formatType").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => ConditionalParameterStringFieldDefBinCodec.decodeOpt(x) }
      val `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) }
      val `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => ConditionalParameterStringFieldDefTimeUnitCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) }
      return Some(ConditionalParameterStringFieldDef(
        `format` = `format`,
        `empty` = `empty`,
        `field` = `field`,
        `param` = `param`.get,
        `bandPosition` = `bandPosition`,
        `formatType` = `formatType`,
        `bin` = `bin`,
        `aggregate` = `aggregate`,
        `timeUnit` = `timeUnit`,
        `title` = `title`,
        `type` = `type`,
      ))
    }

  def encode(j: ConditionalParameterStringFieldDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`format`.map { x => "format" -> ConditionalParameterStringFieldDefFormatCodec.encode(x) },
        j.`empty`.map { x => "empty" -> Json.toJson(x) },
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        Some("param" -> Json.toJson(j.`param`)),
        j.`bandPosition`.map { x => "bandPosition" -> ConditionalParameterStringFieldDefBandPositionCodec.encode(x) },
        j.`formatType`.map { x => "formatType" -> Json.toJson(x) },
        j.`bin`.map { x => "bin" -> ConditionalParameterStringFieldDefBinCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> ConditionalParameterStringFieldDefTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeBandPosition (ConstrainedType)
object SharedEncodingStrokeBandPositionCodec {
  def decode(j: JsValue): SharedEncodingStrokeBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingStrokeBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingStrokeBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// RectConfigCornerRadiusBottomRight (UnionType)
object RectConfigCornerRadiusBottomRightCodec {
  def decode(j: JsValue): RectConfigCornerRadiusBottomRight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigCornerRadiusBottomRight] =
    j.asOpt[JsNumber].map { RectConfigCornerRadiusBottomRightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigCornerRadiusBottomRight): JsValue =
    j match {
      case RectConfigCornerRadiusBottomRightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingHrefValue (UnionType)
object SharedEncodingHrefValueCodec {
  def decode(j: JsValue): SharedEncodingHrefValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingHrefValue] =
    j.asOpt[String].map { SharedEncodingHrefValueAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingHrefValueAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: SharedEncodingHrefValue): JsValue =
    j match {
      case SharedEncodingHrefValueAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case SharedEncodingHrefValueAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefColor (UnionType)
object MarkDefColorCodec {
  def decode(j: JsValue): MarkDefColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefColor] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: MarkDefColor): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisGridOpacityAsNumber (ConstrainedType)
object AxisGridOpacityAsNumberCodec {
  def decode(j: JsValue): AxisGridOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AxisGridOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AxisGridOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AxisGridOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ViewBackgroundStrokeDash (UnionType)
object ViewBackgroundStrokeDashCodec {
  def decode(j: JsValue): ViewBackgroundStrokeDash =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewBackgroundStrokeDash] =
    ArrayOfNumberCodec.decodeOpt(j).map { ViewBackgroundStrokeDashAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ViewBackgroundStrokeDash): JsValue =
    j match {
      case ViewBackgroundStrokeDashAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisLabelBaselineAsObject2 (StructType)
object ConditionalAxisLabelBaselineAsObject2Codec {
  def decode(j: JsValue): ConditionalAxisLabelBaselineAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalAxisLabelBaselineAsObject2] =
    {
      val `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => ConditionalAxisLabelBaselineAsObject2ConditionCodec.decodeOpt(x) }
      if(`condition`.isEmpty) { return None }
      val `expr` = (j \ "expr").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`expr`.isEmpty) { return None }
      return Some(ConditionalAxisLabelBaselineAsObject2(
        `condition` = `condition`.get,
        `expr` = `expr`.get,
      ))
    }

  def encode(j: ConditionalAxisLabelBaselineAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("condition" -> ConditionalAxisLabelBaselineAsObject2ConditionCodec.encode(j.`condition`)),
        Some("expr" -> Json.toJson(j.`expr`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// MarkDefY2Offset (UnionType)
object MarkDefY2OffsetCodec {
  def decode(j: JsValue): MarkDefY2Offset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefY2Offset] =
    j.asOpt[JsNumber].map { MarkDefY2OffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefY2Offset): JsValue =
    j match {
      case MarkDefY2OffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewConfigOpacity (UnionType)
object ViewConfigOpacityCodec {
  def decode(j: JsValue): ViewConfigOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewConfigOpacity] =
    j.asOpt[JsNumber].map { ViewConfigOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ViewConfigOpacity): JsValue =
    j match {
      case ViewConfigOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// DateTimeMonth (UnionType)
object DateTimeMonthCodec {
  def decode(j: JsValue): DateTimeMonth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[DateTimeMonth] =
    MonthCodec.decodeOpt(j).orElse {
    j.asOpt[String].map { DateTimeMonthAsString(_) } } 
  def encode(j: DateTimeMonth): JsValue =
    j match {
      case x:Month /* TypeRef */ => MonthCodec.encode(x)
      case DateTimeMonthAsString(x) /* Base, StringType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigStroke (UnionType)
object RectConfigStrokeCodec {
  def decode(j: JsValue): RectConfigStroke =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigStroke] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => RectConfigStrokeAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: RectConfigStroke): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case RectConfigStrokeAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldGTPredicateTimeUnit (UnionType)
object FieldGTPredicateTimeUnitCodec {
  def decode(j: JsValue): FieldGTPredicateTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldGTPredicateTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: FieldGTPredicateTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigShape (UnionType)
object RectConfigShapeCodec {
  def decode(j: JsValue): RectConfigShape =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigShape] =
    j.asOpt[String].map { RectConfigShapeAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigShape): JsValue =
    j match {
      case RectConfigShapeAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefTheta (ConstrainedType)
// see MarkDefTheta (UnionType)

////////////////////////////////////////////////////////////////////////
// ViewConfigStrokeJoin (UnionType)
object ViewConfigStrokeJoinCodec {
  def decode(j: JsValue): ViewConfigStrokeJoin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewConfigStrokeJoin] =
    StrokeJoinCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ViewConfigStrokeJoin): JsValue =
    j match {
      case x:StrokeJoin /* TypeRef */ => StrokeJoinCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigTitleLimitAsNumber (ConstrainedType)
object LegendConfigTitleLimitAsNumberCodec {
  def decode(j: JsValue): LegendConfigTitleLimitAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LegendConfigTitleLimitAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { LegendConfigTitleLimitAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: LegendConfigTitleLimitAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AxisConfigLabelSeparation (UnionType)
object AxisConfigLabelSeparationCodec {
  def decode(j: JsValue): AxisConfigLabelSeparation =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigLabelSeparation] =
    j.asOpt[JsNumber].map { AxisConfigLabelSeparationAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigLabelSeparation): JsValue =
    j match {
      case AxisConfigLabelSeparationAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefLine (UnionType)
object MarkDefLineCodec {
  def decode(j: JsValue): MarkDefLine =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefLine] =
    j.asOpt[Boolean].map { MarkDefLineAsBool(_) }.orElse {
    OverlayMarkDefCodec.decodeOpt(j) } 
  def encode(j: MarkDefLine): JsValue =
    j match {
      case MarkDefLineAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:OverlayMarkDef /* TypeRef */ => OverlayMarkDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigX2 (UnionType)
object RectConfigX2Codec {
  def decode(j: JsValue): RectConfigX2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigX2] =
    j.asOpt[JsNumber].map { RectConfigX2AsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: RectConfigX2): JsValue =
    j match {
      case RectConfigX2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingRadius (StructType)
object SharedEncodingRadiusCodec {
  def decode(j: JsValue): SharedEncodingRadius =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingRadius] =
    Some(SharedEncodingRadius(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingRadiusDatumCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingRadiusBandPositionCodec.decodeOpt(x) },
      `stack` = (j \ "stack").asOpt[JsValue].flatMap { x => SharedEncodingRadiusStackCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingRadiusBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingRadiusValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingRadiusTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => SharedEncodingRadiusTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingRadius): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingRadiusDatumCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingRadiusBandPositionCodec.encode(x) },
        j.`stack`.map { x => "stack" -> SharedEncodingRadiusStackCodec.encode(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingRadiusBinCodec.encode(x) },
        j.`value`.map { x => "value" -> SharedEncodingRadiusValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingRadiusTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> SharedEncodingRadiusTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConditionalAxisLabelBaselineAsObject1 (StructType)
object ConditionalAxisLabelBaselineAsObject1Codec {
  def decode(j: JsValue): ConditionalAxisLabelBaselineAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalAxisLabelBaselineAsObject1] =
    {
      val `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => ConditionalAxisLabelBaselineAsObject1ConditionCodec.decodeOpt(x) }
      if(`condition`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => TextBaselineCodec.decodeOpt(x).map { Some(_) }.flatten }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalAxisLabelBaselineAsObject1(
        `condition` = `condition`.get,
        `value` = `value`,
      ))
    }

  def encode(j: ConditionalAxisLabelBaselineAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("condition" -> ConditionalAxisLabelBaselineAsObject1ConditionCodec.encode(j.`condition`)),
        j.`value`.map { x => "value" -> TextBaselineCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LegendConfigTitleAlign (UnionType)
object LegendConfigTitleAlignCodec {
  def decode(j: JsValue): LegendConfigTitleAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigTitleAlign] =
    AlignCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigTitleAlign): JsValue =
    j match {
      case x:Align /* TypeRef */ => AlignCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefFillOpacityAsNumber (ConstrainedType)
object OverlayMarkDefFillOpacityAsNumberCodec {
  def decode(j: JsValue): OverlayMarkDefFillOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[OverlayMarkDefFillOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { OverlayMarkDefFillOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: OverlayMarkDefFillOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// LayerRepeatSpecBounds (EnumType)
object LayerRepeatSpecBoundsCodec {
  def decode(j: JsValue): LayerRepeatSpecBounds =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LayerRepeatSpecBounds] =
    j match {
      case JsString("full") => Some(LayerRepeatSpecBoundsFull)
      case JsString("flush") => Some(LayerRepeatSpecBoundsFlush)
      case _ => None
    }
  def encode(j: LayerRepeatSpecBounds): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// TickConfigOpacity (ConstrainedType)
// see TickConfigOpacity (UnionType)

////////////////////////////////////////////////////////////////////////
// BarConfigCornerRadiusEnd (UnionType)
object BarConfigCornerRadiusEndCodec {
  def decode(j: JsValue): BarConfigCornerRadiusEnd =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigCornerRadiusEnd] =
    j.asOpt[JsNumber].map { BarConfigCornerRadiusEndAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigCornerRadiusEnd): JsValue =
    j match {
      case BarConfigCornerRadiusEndAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigStroke (UnionType)
object MarkConfigStrokeCodec {
  def decode(j: JsValue): MarkConfigStroke =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigStroke] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => MarkConfigStrokeAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: MarkConfigStroke): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case MarkConfigStrokeAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ResolveMode (EnumType)
object ResolveModeCodec {
  def decode(j: JsValue): ResolveMode =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ResolveMode] =
    j match {
      case JsString("independent") => Some(ResolveModeIndependent)
      case JsString("shared") => Some(ResolveModeShared)
      case _ => None
    }
  def encode(j: ResolveMode): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// AreaConfigRadius (ConstrainedType)
// see AreaConfigRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// TitleConfigSubtitleFontStyle (UnionType)
object TitleConfigSubtitleFontStyleCodec {
  def decode(j: JsValue): TitleConfigSubtitleFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigSubtitleFontStyle] =
    j.asOpt[String].map { TitleConfigSubtitleFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleConfigSubtitleFontStyle): JsValue =
    j match {
      case TitleConfigSubtitleFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionClipExtent (UnionType)
object ProjectionClipExtentCodec {
  def decode(j: JsValue): ProjectionClipExtent =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionClipExtent] =
    Vector2Vector2NumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionClipExtent): JsValue =
    j match {
      case x:Vector2Vector2Number /* TypeRef */ => Vector2Vector2NumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingRadiusTimeUnit (UnionType)
object SharedEncodingRadiusTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingRadiusTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingRadiusTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingRadiusTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingShapeType (UnionType)
object SharedEncodingShapeTypeCodec {
  def decode(j: JsValue): SharedEncodingShapeType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingShapeType] =
    TypeForShapeCodec.decodeOpt(j).orElse {
    TypeCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingShapeType): JsValue =
    j match {
      case x:TypeForShape /* TypeRef */ => TypeForShapeCodec.encode(x)
      case x:Type /* TypeRef */ => TypeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigEndAngle (UnionType)
object BarConfigEndAngleCodec {
  def decode(j: JsValue): BarConfigEndAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigEndAngle] =
    j.asOpt[JsNumber].map { BarConfigEndAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigEndAngle): JsValue =
    j match {
      case BarConfigEndAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisStringAsObject1Condition (UnionType)
object ConditionalAxisStringAsObject1ConditionCodec {
  def decode(j: JsValue): ConditionalAxisStringAsObject1Condition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisStringAsObject1Condition] =
    ConditionalPredicateValueDefStringNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalPredicateValueDefStringNullExprRefCodec.decodeOpt(j).map { ConditionalAxisStringAsObject1ConditionAsArrayOfConditionalPredicateValueDefStringNullExprRef(_) } } 
  def encode(j: ConditionalAxisStringAsObject1Condition): JsValue =
    j match {
      case x:ConditionalPredicateValueDefStringNullExprRef /* TypeRef */ => ConditionalPredicateValueDefStringNullExprRefCodec.encode(x)
      case ConditionalAxisStringAsObject1ConditionAsArrayOfConditionalPredicateValueDefStringNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalPredicateValueDefStringNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigCornerRadius (UnionType)
object RectConfigCornerRadiusCodec {
  def decode(j: JsValue): RectConfigCornerRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigCornerRadius] =
    j.asOpt[JsNumber].map { RectConfigCornerRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigCornerRadius): JsValue =
    j match {
      case RectConfigCornerRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingFillOpacityType (UnionType)
object SharedEncodingFillOpacityTypeCodec {
  def decode(j: JsValue): SharedEncodingFillOpacityType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingFillOpacityType] =
    StandardTypeCodec.decodeOpt(j).orElse {
    TypeCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingFillOpacityType): JsValue =
    j match {
      case x:StandardType /* TypeRef */ => StandardTypeCodec.encode(x)
      case x:Type /* TypeRef */ => TypeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BindCheckbox (StructType)
object BindCheckboxCodec {
  def decode(j: JsValue): BindCheckbox =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BindCheckbox] =
    {
      val `debounce` = (j \ "debounce").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `element` = (j \ "element").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `input` = (j \ "input").asOpt[JsValue].flatMap { x => BindCheckboxInputCodec.decodeOpt(x) }
      if(`input`.isEmpty) { return None }
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      return Some(BindCheckbox(
        `debounce` = `debounce`,
        `element` = `element`,
        `input` = `input`.get,
        `name` = `name`,
      ))
    }

  def encode(j: BindCheckbox): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`debounce`.map { x => "debounce" -> Json.toJson(x) },
        j.`element`.map { x => "element" -> Json.toJson(x) },
        Some("input" -> BindCheckboxInputCodec.encode(j.`input`)),
        j.`name`.map { x => "name" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// FacetedUnitSpec (StructType)
object FacetedUnitSpecCodec {
  def decode(j: JsValue): FacetedUnitSpec =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FacetedUnitSpec] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `projection` = (j \ "projection").asOpt[JsValue].flatMap { x => ProjectionCodec.decodeOpt(x) }
      val `center` = (j \ "center").asOpt[JsValue].flatMap { x => FacetedUnitSpecCenterCodec.decodeOpt(x) }
      val `description` = (j \ "description").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `params` = (j \ "params").asOpt[JsValue].flatMap { x => ArrayOfFacetedUnitSpecParamsElementCodec.decodeOpt(x) }
      val `height` = (j \ "height").asOpt[JsValue].flatMap { x => FacetedUnitSpecHeightCodec.decodeOpt(x) }
      val `resolve` = (j \ "resolve").asOpt[JsValue].flatMap { x => ResolveCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => FacetedUnitSpecTitleCodec.decodeOpt(x) }
      val `mark` = (j \ "mark").asOpt[JsValue].flatMap { x => AnyMarkCodec.decodeOpt(x) }
      if(`mark`.isEmpty) { return None }
      val `view` = (j \ "view").asOpt[JsValue].flatMap { x => ViewBackgroundCodec.decodeOpt(x) }
      val `align` = (j \ "align").asOpt[JsValue].flatMap { x => FacetedUnitSpecAlignCodec.decodeOpt(x) }
      val `data` = (j \ "data").asOpt[JsValue].flatMap { x => DataCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `encoding` = (j \ "encoding").asOpt[JsValue].flatMap { x => FacetedEncodingCodec.decodeOpt(x) }
      val `bounds` = (j \ "bounds").asOpt[JsValue].flatMap { x => FacetedUnitSpecBoundsCodec.decodeOpt(x) }
      val `spacing` = (j \ "spacing").asOpt[JsValue].flatMap { x => FacetedUnitSpecSpacingCodec.decodeOpt(x) }
      val `transform` = (j \ "transform").asOpt[JsValue].flatMap { x => ArrayOfTransformCodec.decodeOpt(x) }
      val `width` = (j \ "width").asOpt[JsValue].flatMap { x => FacetedUnitSpecWidthCodec.decodeOpt(x) }
      return Some(FacetedUnitSpec(
        `name` = `name`,
        `projection` = `projection`,
        `center` = `center`,
        `description` = `description`,
        `params` = `params`,
        `height` = `height`,
        `resolve` = `resolve`,
        `title` = `title`,
        `mark` = `mark`.get,
        `view` = `view`,
        `align` = `align`,
        `data` = `data`,
        `encoding` = `encoding`,
        `bounds` = `bounds`,
        `spacing` = `spacing`,
        `transform` = `transform`,
        `width` = `width`,
      ))
    }

  def encode(j: FacetedUnitSpec): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`projection`.map { x => "projection" -> ProjectionCodec.encode(x) },
        j.`center`.map { x => "center" -> FacetedUnitSpecCenterCodec.encode(x) },
        j.`description`.map { x => "description" -> Json.toJson(x) },
        j.`params`.map { x => "params" -> ArrayOfFacetedUnitSpecParamsElementCodec.encode(x) },
        j.`height`.map { x => "height" -> FacetedUnitSpecHeightCodec.encode(x) },
        j.`resolve`.map { x => "resolve" -> ResolveCodec.encode(x) },
        j.`title`.map { x => "title" -> FacetedUnitSpecTitleCodec.encode(x) },
        Some("mark" -> AnyMarkCodec.encode(j.`mark`)),
        j.`view`.map { x => "view" -> ViewBackgroundCodec.encode(x) },
        j.`align`.map { x => "align" -> FacetedUnitSpecAlignCodec.encode(x) },
        j.`data`.map { x => "data" -> DataCodec.encode(x) },
        j.`encoding`.map { x => "encoding" -> FacetedEncodingCodec.encode(x) },
        j.`bounds`.map { x => "bounds" -> FacetedUnitSpecBoundsCodec.encode(x) },
        j.`spacing`.map { x => "spacing" -> FacetedUnitSpecSpacingCodec.encode(x) },
        j.`transform`.map { x => "transform" -> ArrayOfTransformCodec.encode(x) },
        j.`width`.map { x => "width" -> FacetedUnitSpecWidthCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TickConfigCornerRadiusBottomLeft (UnionType)
object TickConfigCornerRadiusBottomLeftCodec {
  def decode(j: JsValue): TickConfigCornerRadiusBottomLeft =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigCornerRadiusBottomLeft] =
    j.asOpt[JsNumber].map { TickConfigCornerRadiusBottomLeftAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigCornerRadiusBottomLeft): JsValue =
    j match {
      case TickConfigCornerRadiusBottomLeftAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigLegendX (UnionType)
object LegendConfigLegendXCodec {
  def decode(j: JsValue): LegendConfigLegendX =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigLegendX] =
    j.asOpt[JsNumber].map { LegendConfigLegendXAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigLegendX): JsValue =
    j match {
      case LegendConfigLegendXAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigOpacity (ConstrainedType)
// see MarkConfigOpacity (UnionType)

////////////////////////////////////////////////////////////////////////
// HeaderTitleLineHeight (UnionType)
object HeaderTitleLineHeightCodec {
  def decode(j: JsValue): HeaderTitleLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderTitleLineHeight] =
    j.asOpt[JsNumber].map { HeaderTitleLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderTitleLineHeight): JsValue =
    j match {
      case HeaderTitleLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelUnitSpecWidth (UnionType)
object TopLevelUnitSpecWidthCodec {
  def decode(j: JsValue): TopLevelUnitSpecWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelUnitSpecWidth] =
    j.asOpt[JsNumber].map { TopLevelUnitSpecWidthAsNumber(_) }.orElse {
    ContainerCodec.decodeOpt(j).orElse {
    StepCodec.decodeOpt(j) } } 
  def encode(j: TopLevelUnitSpecWidth): JsValue =
    j match {
      case TopLevelUnitSpecWidthAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Container /* TypeRef */ => ContainerCodec.encode(x)
      case x:Step /* TypeRef */ => StepCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigCornerRadiusTopRight (UnionType)
object AreaConfigCornerRadiusTopRightCodec {
  def decode(j: JsValue): AreaConfigCornerRadiusTopRight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigCornerRadiusTopRight] =
    j.asOpt[JsNumber].map { AreaConfigCornerRadiusTopRightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigCornerRadiusTopRight): JsValue =
    j match {
      case AreaConfigCornerRadiusTopRightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderConfigTitleLineHeight (UnionType)
object HeaderConfigTitleLineHeightCodec {
  def decode(j: JsValue): HeaderConfigTitleLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigTitleLineHeight] =
    j.asOpt[JsNumber].map { HeaderConfigTitleLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderConfigTitleLineHeight): JsValue =
    j match {
      case HeaderConfigTitleLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RadialGradientGradient (ConstantType)
object RadialGradientGradientCodec {
  def decode(j: JsValue): RadialGradientGradient =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RadialGradientGradient] =
    j match {
      case JsString("radial") => Some(RadialGradientGradient())
      case _ => None
    }
  def encode(j: RadialGradientGradient): JsValue =
    JsString("radial")
}


////////////////////////////////////////////////////////////////////////
// UnitSpecWithFrameTitle (UnionType)
object UnitSpecWithFrameTitleCodec {
  def decode(j: JsValue): UnitSpecWithFrameTitle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[UnitSpecWithFrameTitle] =
    TextCodec.decodeOpt(j).orElse {
    TitleParamsCodec.decodeOpt(j) } 
  def encode(j: UnitSpecWithFrameTitle): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:TitleParams /* TypeRef */ => TitleParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionDatumDefGradientStringNullDatum (UnionType)
object FieldOrDatumDefWithConditionDatumDefGradientStringNullDatumCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionDatumDefGradientStringNullDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionDatumDefGradientStringNullDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: FieldOrDatumDefWithConditionDatumDefGradientStringNullDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTickBandAsString (EnumType)
object AxisTickBandAsStringCodec {
  def decode(j: JsValue): AxisTickBandAsString =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTickBandAsString] =
    j match {
      case JsString("center") => Some(AxisTickBandAsStringCenter)
      case JsString("extent") => Some(AxisTickBandAsStringExtent)
      case _ => None
    }
  def encode(j: AxisTickBandAsString): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionStringFieldDefTextBin (UnionType)
object FieldOrDatumDefWithConditionStringFieldDefTextBinCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionStringFieldDefTextBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionStringFieldDefTextBin] =
    j.asOpt[Boolean].map { FieldOrDatumDefWithConditionStringFieldDefTextBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    BinnedCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => FieldOrDatumDefWithConditionStringFieldDefTextBinAsNull } } } } 
  def encode(j: FieldOrDatumDefWithConditionStringFieldDefTextBin): JsValue =
    j match {
      case FieldOrDatumDefWithConditionStringFieldDefTextBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case x:Binned /* TypeRef */ => BinnedCodec.encode(x)
      case FieldOrDatumDefWithConditionStringFieldDefTextBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// PositionValueDefValue (UnionType)
object PositionValueDefValueCodec {
  def decode(j: JsValue): PositionValueDefValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PositionValueDefValue] =
    j.asOpt[JsNumber].map { PositionValueDefValueAsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: PositionValueDefValue): JsValue =
    j match {
      case PositionValueDefValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefStringExprRef (StructType)
object ConditionalPredicateValueDefStringExprRefCodec {
  def decode(j: JsValue): ConditionalPredicateValueDefStringExprRef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefStringExprRef] =
    {
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => ConditionalPredicateValueDefStringExprRefValueCodec.decodeOpt(x) }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalPredicateValueDefStringExprRef(
        `test` = `test`.get,
        `value` = `value`.get,
      ))
    }

  def encode(j: ConditionalPredicateValueDefStringExprRef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
        Some("value" -> ConditionalPredicateValueDefStringExprRefValueCodec.encode(j.`value`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingYError2BandPosition (ConstrainedType)
object SharedEncodingYError2BandPositionCodec {
  def decode(j: JsValue): SharedEncodingYError2BandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingYError2BandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingYError2BandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingYError2BandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// TickConfigDir (UnionType)
object TickConfigDirCodec {
  def decode(j: JsValue): TickConfigDir =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigDir] =
    TextDirectionCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigDir): JsValue =
    j match {
      case x:TextDirection /* TypeRef */ => TextDirectionCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// QuantileTransformAs (ConstrainedType)
object QuantileTransformAsCodec {
  def decode(j: JsValue): QuantileTransformAs =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[QuantileTransformAs] =
    try {
      ArrayOfStringCodec.decodeOpt(j)
        .map { QuantileTransformAs(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: QuantileTransformAs): JsValue =
    ArrayOfStringCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// EncodingUrl (UnionType)
object EncodingUrlCodec {
  def decode(j: JsValue): EncodingUrl =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[EncodingUrl] =
    StringFieldDefWithConditionCodec.decodeOpt(j).orElse {
    StringValueDefWithConditionCodec.decodeOpt(j) } 
  def encode(j: EncodingUrl): JsValue =
    j match {
      case x:StringFieldDefWithCondition /* TypeRef */ => StringFieldDefWithConditionCodec.encode(x)
      case x:StringValueDefWithCondition /* TypeRef */ => StringValueDefWithConditionCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigRound (UnionType)
object ScaleConfigRoundCodec {
  def decode(j: JsValue): ScaleConfigRound =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleConfigRound] =
    j.asOpt[Boolean].map { ScaleConfigRoundAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleConfigRound): JsValue =
    j match {
      case ScaleConfigRoundAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingSizeCondition (UnionType)
object SharedEncodingSizeConditionCodec {
  def decode(j: JsValue): SharedEncodingSizeCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingSizeCondition] =
    ConditionalValueDefNumberExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefNumberExprRefCodec.decodeOpt(j).map { SharedEncodingSizeConditionAsArrayOfConditionalValueDefNumberExprRef(_) }.orElse {
    ConditionalMarkPropFieldOrDatumDefCodec.decodeOpt(j) } } 
  def encode(j: SharedEncodingSizeCondition): JsValue =
    j match {
      case x:ConditionalValueDefNumberExprRef /* TypeRef */ => ConditionalValueDefNumberExprRefCodec.encode(x)
      case SharedEncodingSizeConditionAsArrayOfConditionalValueDefNumberExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefNumberExprRefCodec.encode(x)
      case x:ConditionalMarkPropFieldOrDatumDef /* TypeRef */ => ConditionalMarkPropFieldOrDatumDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TooltipContent (StructType)
object TooltipContentCodec {
  def decode(j: JsValue): TooltipContent =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TooltipContent] =
    {
      val `content` = (j \ "content").asOpt[JsValue].flatMap { x => TooltipContentContentCodec.decodeOpt(x) }
      if(`content`.isEmpty) { return None }
      return Some(TooltipContent(
        `content` = `content`.get,
      ))
    }

  def encode(j: TooltipContent): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("content" -> TooltipContentContentCodec.encode(j.`content`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TickConfigFontStyle (UnionType)
object TickConfigFontStyleCodec {
  def decode(j: JsValue): TickConfigFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigFontStyle] =
    j.asOpt[String].map { TickConfigFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigFontStyle): JsValue =
    j match {
      case TickConfigFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigSmooth (UnionType)
object AreaConfigSmoothCodec {
  def decode(j: JsValue): AreaConfigSmooth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigSmooth] =
    j.asOpt[Boolean].map { AreaConfigSmoothAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigSmooth): JsValue =
    j match {
      case AreaConfigSmoothAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// EncodingOrder (UnionType)
object EncodingOrderCodec {
  def decode(j: JsValue): EncodingOrder =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[EncodingOrder] =
    OrderFieldDefCodec.decodeOpt(j).orElse {
    ArrayOfOrderFieldDefCodec.decodeOpt(j).map { EncodingOrderAsArrayOfOrderFieldDef(_) }.orElse {
    OrderValueDefCodec.decodeOpt(j) } } 
  def encode(j: EncodingOrder): JsValue =
    j match {
      case x:OrderFieldDef /* TypeRef */ => OrderFieldDefCodec.encode(x)
      case EncodingOrderAsArrayOfOrderFieldDef(x) /* Base, ArrayType */ => ArrayOfOrderFieldDefCodec.encode(x)
      case x:OrderValueDef /* TypeRef */ => OrderValueDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingYOffsetBin (UnionType)
object SharedEncodingYOffsetBinCodec {
  def decode(j: JsValue): SharedEncodingYOffsetBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingYOffsetBin] =
    j.asOpt[Boolean].map { SharedEncodingYOffsetBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingYOffsetBinAsNull } } } 
  def encode(j: SharedEncodingYOffsetBin): JsValue =
    j match {
      case SharedEncodingYOffsetBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case SharedEncodingYOffsetBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// FacetSpecBounds (EnumType)
object FacetSpecBoundsCodec {
  def decode(j: JsValue): FacetSpecBounds =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetSpecBounds] =
    j match {
      case JsString("full") => Some(FacetSpecBoundsFull)
      case JsString("flush") => Some(FacetSpecBoundsFlush)
      case _ => None
    }
  def encode(j: FacetSpecBounds): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// TitleParamsSubtitleFontStyle (UnionType)
object TitleParamsSubtitleFontStyleCodec {
  def decode(j: JsValue): TitleParamsSubtitleFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsSubtitleFontStyle] =
    j.asOpt[String].map { TitleParamsSubtitleFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleParamsSubtitleFontStyle): JsValue =
    j match {
      case TitleParamsSubtitleFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// DatumDefBandPosition (ConstrainedType)
object DatumDefBandPositionCodec {
  def decode(j: JsValue): DatumDefBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[DatumDefBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { DatumDefBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: DatumDefBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkDefStrokeOffset (UnionType)
object MarkDefStrokeOffsetCodec {
  def decode(j: JsValue): MarkDefStrokeOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefStrokeOffset] =
    j.asOpt[JsNumber].map { MarkDefStrokeOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefStrokeOffset): JsValue =
    j match {
      case MarkDefStrokeOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RelativeBandSize (StructType)
object RelativeBandSizeCodec {
  def decode(j: JsValue): RelativeBandSize =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RelativeBandSize] =
    {
      val `band` = (j \ "band").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      if(`band`.isEmpty) { return None }
      return Some(RelativeBandSize(
        `band` = `band`.get,
      ))
    }

  def encode(j: RelativeBandSize): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("band" -> Json.toJson(j.`band`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConditionalAxisLabelFontWeightAsObject2 (StructType)
object ConditionalAxisLabelFontWeightAsObject2Codec {
  def decode(j: JsValue): ConditionalAxisLabelFontWeightAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalAxisLabelFontWeightAsObject2] =
    {
      val `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => ConditionalAxisLabelFontWeightAsObject2ConditionCodec.decodeOpt(x) }
      if(`condition`.isEmpty) { return None }
      val `expr` = (j \ "expr").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`expr`.isEmpty) { return None }
      return Some(ConditionalAxisLabelFontWeightAsObject2(
        `condition` = `condition`.get,
        `expr` = `expr`.get,
      ))
    }

  def encode(j: ConditionalAxisLabelFontWeightAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("condition" -> ConditionalAxisLabelFontWeightAsObject2ConditionCodec.encode(j.`condition`)),
        Some("expr" -> Json.toJson(j.`expr`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2Datum (UnionType)
object ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2DatumCodec {
  def decode(j: JsValue): ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2Datum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2Datum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2Datum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalStringFieldDef (UnionType)
object ConditionalStringFieldDefCodec {
  def decode(j: JsValue): ConditionalStringFieldDef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalStringFieldDef] =
    ConditionalPredicateStringFieldDefCodec.decodeOpt(j).orElse {
    ConditionalParameterStringFieldDefCodec.decodeOpt(j) } 
  def encode(j: ConditionalStringFieldDef): JsValue =
    j match {
      case x:ConditionalPredicateStringFieldDef /* TypeRef */ => ConditionalPredicateStringFieldDefCodec.encode(x)
      case x:ConditionalParameterStringFieldDef /* TypeRef */ => ConditionalParameterStringFieldDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTickWidth (UnionType)
object AxisTickWidthCodec {
  def decode(j: JsValue): AxisTickWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTickWidth] =
    AxisTickWidthAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisTickWidth): JsValue =
    j match {
      case x:AxisTickWidthAsNumber /* TypeRef */ => AxisTickWidthAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefTextBaselineNullExprRef (UnionType)
object ConditionalPredicateValueDefTextBaselineNullExprRefCodec {
  def decode(j: JsValue): ConditionalPredicateValueDefTextBaselineNullExprRef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefTextBaselineNullExprRef] =
    ConditionalPredicateValueDefTextBaselineNullExprRefAsObject1Codec.decodeOpt(j).orElse {
    ConditionalPredicateValueDefTextBaselineNullExprRefAsObject2Codec.decodeOpt(j) } 
  def encode(j: ConditionalPredicateValueDefTextBaselineNullExprRef): JsValue =
    j match {
      case x:ConditionalPredicateValueDefTextBaselineNullExprRefAsObject1 /* TypeRef */ => ConditionalPredicateValueDefTextBaselineNullExprRefAsObject1Codec.encode(x)
      case x:ConditionalPredicateValueDefTextBaselineNullExprRefAsObject2 /* TypeRef */ => ConditionalPredicateValueDefTextBaselineNullExprRefAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigTheta (UnionType)
object LineConfigThetaCodec {
  def decode(j: JsValue): LineConfigTheta =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigTheta] =
    j.asOpt[JsNumber].map { LineConfigThetaAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigTheta): JsValue =
    j match {
      case LineConfigThetaAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigPadding (UnionType)
object LegendConfigPaddingCodec {
  def decode(j: JsValue): LegendConfigPadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigPadding] =
    j.asOpt[JsNumber].map { LegendConfigPaddingAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigPadding): JsValue =
    j match {
      case LegendConfigPaddingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Predicate (UnionType)
object PredicateCodec {
  def decode(j: JsValue): Predicate =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Predicate] =
    j.asOpt[String].map { PredicateAsString(_) }.orElse {
    FieldOneOfPredicateCodec.decodeOpt(j).orElse {
    FieldGTPredicateCodec.decodeOpt(j).orElse {
    FieldValidPredicateCodec.decodeOpt(j).orElse {
    FieldGTEPredicateCodec.decodeOpt(j).orElse {
    FieldLTPredicateCodec.decodeOpt(j).orElse {
    ParameterPredicateCodec.decodeOpt(j).orElse {
    FieldRangePredicateCodec.decodeOpt(j).orElse {
    FieldEqualPredicateCodec.decodeOpt(j).orElse {
    FieldLTEPredicateCodec.decodeOpt(j) } } } } } } } } } 
  def encode(j: Predicate): JsValue =
    j match {
      case PredicateAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:FieldOneOfPredicate /* TypeRef */ => FieldOneOfPredicateCodec.encode(x)
      case x:FieldGTPredicate /* TypeRef */ => FieldGTPredicateCodec.encode(x)
      case x:FieldValidPredicate /* TypeRef */ => FieldValidPredicateCodec.encode(x)
      case x:FieldGTEPredicate /* TypeRef */ => FieldGTEPredicateCodec.encode(x)
      case x:FieldLTPredicate /* TypeRef */ => FieldLTPredicateCodec.encode(x)
      case x:ParameterPredicate /* TypeRef */ => ParameterPredicateCodec.encode(x)
      case x:FieldRangePredicate /* TypeRef */ => FieldRangePredicateCodec.encode(x)
      case x:FieldEqualPredicate /* TypeRef */ => FieldEqualPredicateCodec.encode(x)
      case x:FieldLTEPredicate /* TypeRef */ => FieldLTEPredicateCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// EncodingYError2 (UnionType)
object EncodingYError2Codec {
  def decode(j: JsValue): EncodingYError2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[EncodingYError2] =
    SecondaryFieldDefCodec.decodeOpt(j).orElse {
    ValueDefNumberCodec.decodeOpt(j) } 
  def encode(j: EncodingYError2): JsValue =
    j match {
      case x:SecondaryFieldDef /* TypeRef */ => SecondaryFieldDefCodec.encode(x)
      case x:ValueDefNumber /* TypeRef */ => ValueDefNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigInvalid (EnumType)
object RectConfigInvalidCodec {
  def decode(j: JsValue): RectConfigInvalid =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigInvalid] =
    j match {
      case JsString("filter") => Some(RectConfigInvalidFilter)
      case JsNull => Some(RectConfigInvalidUndefined)
      case _ => None
    }
  def encode(j: RectConfigInvalid): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// TitleParamsLineHeight (UnionType)
object TitleParamsLineHeightCodec {
  def decode(j: JsValue): TitleParamsLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsLineHeight] =
    j.asOpt[JsNumber].map { TitleParamsLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleParamsLineHeight): JsValue =
    j match {
      case TitleParamsLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigY (UnionType)
object RectConfigYCodec {
  def decode(j: JsValue): RectConfigY =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigY] =
    j.asOpt[JsNumber].map { RectConfigYAsNumber(_) }.orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: RectConfigY): JsValue =
    j match {
      case RectConfigYAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigOffset (UnionType)
object AxisConfigOffsetCodec {
  def decode(j: JsValue): AxisConfigOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigOffset] =
    j.asOpt[JsNumber].map { AxisConfigOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigOffset): JsValue =
    j match {
      case AxisConfigOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfig (StructType)
object MarkConfigCodec {
  def decode(j: JsValue): MarkConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[MarkConfig] =
    Some(MarkConfig(
      `cornerRadiusBottomRight` = (j \ "cornerRadiusBottomRight").asOpt[JsValue].flatMap { x => MarkConfigCornerRadiusBottomRightCodec.decodeOpt(x) },
      `fillOpacity` = (j \ "fillOpacity").asOpt[JsValue].flatMap { x => MarkConfigFillOpacityCodec.decodeOpt(x) },
      `strokeMiterLimit` = (j \ "strokeMiterLimit").asOpt[JsValue].flatMap { x => MarkConfigStrokeMiterLimitCodec.decodeOpt(x) },
      `dir` = (j \ "dir").asOpt[JsValue].flatMap { x => MarkConfigDirCodec.decodeOpt(x) },
      `tooltip` = (j \ "tooltip").asOpt[JsValue].flatMap { x => MarkConfigTooltipCodec.decodeOpt(x) },
      `timeUnitBandPosition` = (j \ "timeUnitBandPosition").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `cornerRadiusTopRight` = (j \ "cornerRadiusTopRight").asOpt[JsValue].flatMap { x => MarkConfigCornerRadiusTopRightCodec.decodeOpt(x) },
      `outerRadius` = (j \ "outerRadius").asOpt[JsValue].flatMap { x => MarkConfigOuterRadiusCodec.decodeOpt(x) },
      `x` = (j \ "x").asOpt[JsValue].flatMap { x => MarkConfigXCodec.decodeOpt(x) },
      `dy` = (j \ "dy").asOpt[JsValue].flatMap { x => MarkConfigDyCodec.decodeOpt(x) },
      `size` = (j \ "size").asOpt[JsValue].flatMap { x => MarkConfigSizeCodec.decodeOpt(x) },
      `smooth` = (j \ "smooth").asOpt[JsValue].flatMap { x => MarkConfigSmoothCodec.decodeOpt(x) },
      `url` = (j \ "url").asOpt[JsValue].flatMap { x => MarkConfigUrlCodec.decodeOpt(x) },
      `y` = (j \ "y").asOpt[JsValue].flatMap { x => MarkConfigYCodec.decodeOpt(x) },
      `strokeOpacity` = (j \ "strokeOpacity").asOpt[JsValue].flatMap { x => MarkConfigStrokeOpacityCodec.decodeOpt(x) },
      `ellipsis` = (j \ "ellipsis").asOpt[JsValue].flatMap { x => MarkConfigEllipsisCodec.decodeOpt(x) },
      `description` = (j \ "description").asOpt[JsValue].flatMap { x => MarkConfigDescriptionCodec.decodeOpt(x) },
      `angle` = (j \ "angle").asOpt[JsValue].flatMap { x => MarkConfigAngleCodec.decodeOpt(x) },
      `lineBreak` = (j \ "lineBreak").asOpt[JsValue].flatMap { x => MarkConfigLineBreakCodec.decodeOpt(x) },
      `tension` = (j \ "tension").asOpt[JsValue].flatMap { x => MarkConfigTensionCodec.decodeOpt(x) },
      `cornerRadiusTopLeft` = (j \ "cornerRadiusTopLeft").asOpt[JsValue].flatMap { x => MarkConfigCornerRadiusTopLeftCodec.decodeOpt(x) },
      `stroke` = (j \ "stroke").asOpt[JsValue].flatMap { x => MarkConfigStrokeCodec.decodeOpt(x) },
      `strokeDashOffset` = (j \ "strokeDashOffset").asOpt[JsValue].flatMap { x => MarkConfigStrokeDashOffsetCodec.decodeOpt(x) },
      `align` = (j \ "align").asOpt[JsValue].flatMap { x => MarkConfigAlignCodec.decodeOpt(x) },
      `ariaRole` = (j \ "ariaRole").asOpt[JsValue].flatMap { x => MarkConfigAriaRoleCodec.decodeOpt(x) },
      `strokeCap` = (j \ "strokeCap").asOpt[JsValue].flatMap { x => MarkConfigStrokeCapCodec.decodeOpt(x) },
      `endAngle` = (j \ "endAngle").asOpt[JsValue].flatMap { x => MarkConfigEndAngleCodec.decodeOpt(x) },
      `strokeJoin` = (j \ "strokeJoin").asOpt[JsValue].flatMap { x => MarkConfigStrokeJoinCodec.decodeOpt(x) },
      `baseline` = (j \ "baseline").asOpt[JsValue].flatMap { x => MarkConfigBaselineCodec.decodeOpt(x) },
      `ariaRoleDescription` = (j \ "ariaRoleDescription").asOpt[JsValue].flatMap { x => MarkConfigAriaRoleDescriptionCodec.decodeOpt(x) },
      `aspect` = (j \ "aspect").asOpt[JsValue].flatMap { x => MarkConfigAspectCodec.decodeOpt(x) },
      `height` = (j \ "height").asOpt[JsValue].flatMap { x => MarkConfigHeightCodec.decodeOpt(x) },
      `fontStyle` = (j \ "fontStyle").asOpt[JsValue].flatMap { x => MarkConfigFontStyleCodec.decodeOpt(x) },
      `text` = (j \ "text").asOpt[JsValue].flatMap { x => MarkConfigTextCodec.decodeOpt(x) },
      `cornerRadius` = (j \ "cornerRadius").asOpt[JsValue].flatMap { x => MarkConfigCornerRadiusCodec.decodeOpt(x) },
      `color` = (j \ "color").asOpt[JsValue].flatMap { x => MarkConfigColorCodec.decodeOpt(x) },
      `x2` = (j \ "x2").asOpt[JsValue].flatMap { x => MarkConfigX2Codec.decodeOpt(x) },
      `padAngle` = (j \ "padAngle").asOpt[JsValue].flatMap { x => MarkConfigPadAngleCodec.decodeOpt(x) },
      `cursor` = (j \ "cursor").asOpt[JsValue].flatMap { x => MarkConfigCursorCodec.decodeOpt(x) },
      `radius` = (j \ "radius").asOpt[JsValue].flatMap { x => MarkConfigRadiusCodec.decodeOpt(x) },
      `timeUnitBandSize` = (j \ "timeUnitBandSize").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `startAngle` = (j \ "startAngle").asOpt[JsValue].flatMap { x => MarkConfigStartAngleCodec.decodeOpt(x) },
      `font` = (j \ "font").asOpt[JsValue].flatMap { x => MarkConfigFontCodec.decodeOpt(x) },
      `radius2` = (j \ "radius2").asOpt[JsValue].flatMap { x => MarkConfigRadius2Codec.decodeOpt(x) },
      `invalid` = (j \ "invalid").asOpt[JsValue].flatMap { x => MarkConfigInvalidCodec.decodeOpt(x) },
      `lineHeight` = (j \ "lineHeight").asOpt[JsValue].flatMap { x => MarkConfigLineHeightCodec.decodeOpt(x) },
      `order` = (j \ "order").asOpt[JsValue].flatMap { x => MarkConfigOrderCodec.decodeOpt(x) },
      `fill` = (j \ "fill").asOpt[JsValue].flatMap { x => MarkConfigFillCodec.decodeOpt(x) },
      `interpolate` = (j \ "interpolate").asOpt[JsValue].flatMap { x => MarkConfigInterpolateCodec.decodeOpt(x) },
      `theta` = (j \ "theta").asOpt[JsValue].flatMap { x => MarkConfigThetaCodec.decodeOpt(x) },
      `orient` = (j \ "orient").asOpt[JsValue].flatMap { x => OrientationCodec.decodeOpt(x) },
      `innerRadius` = (j \ "innerRadius").asOpt[JsValue].flatMap { x => MarkConfigInnerRadiusCodec.decodeOpt(x) },
      `fontSize` = (j \ "fontSize").asOpt[JsValue].flatMap { x => MarkConfigFontSizeCodec.decodeOpt(x) },
      `y2` = (j \ "y2").asOpt[JsValue].flatMap { x => MarkConfigY2Codec.decodeOpt(x) },
      `shape` = (j \ "shape").asOpt[JsValue].flatMap { x => MarkConfigShapeCodec.decodeOpt(x) },
      `aria` = (j \ "aria").asOpt[JsValue].flatMap { x => MarkConfigAriaCodec.decodeOpt(x) },
      `opacity` = (j \ "opacity").asOpt[JsValue].flatMap { x => MarkConfigOpacityCodec.decodeOpt(x) },
      `dx` = (j \ "dx").asOpt[JsValue].flatMap { x => MarkConfigDxCodec.decodeOpt(x) },
      `cornerRadiusBottomLeft` = (j \ "cornerRadiusBottomLeft").asOpt[JsValue].flatMap { x => MarkConfigCornerRadiusBottomLeftCodec.decodeOpt(x) },
      `href` = (j \ "href").asOpt[JsValue].flatMap { x => MarkConfigHrefCodec.decodeOpt(x) },
      `strokeDash` = (j \ "strokeDash").asOpt[JsValue].flatMap { x => MarkConfigStrokeDashCodec.decodeOpt(x) },
      `strokeOffset` = (j \ "strokeOffset").asOpt[JsValue].flatMap { x => MarkConfigStrokeOffsetCodec.decodeOpt(x) },
      `limit` = (j \ "limit").asOpt[JsValue].flatMap { x => MarkConfigLimitCodec.decodeOpt(x) },
      `width` = (j \ "width").asOpt[JsValue].flatMap { x => MarkConfigWidthCodec.decodeOpt(x) },
      `fontWeight` = (j \ "fontWeight").asOpt[JsValue].flatMap { x => MarkConfigFontWeightCodec.decodeOpt(x) },
      `filled` = (j \ "filled").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `blend` = (j \ "blend").asOpt[JsValue].flatMap { x => MarkConfigBlendCodec.decodeOpt(x) },
      `strokeWidth` = (j \ "strokeWidth").asOpt[JsValue].flatMap { x => MarkConfigStrokeWidthCodec.decodeOpt(x) },
      `theta2` = (j \ "theta2").asOpt[JsValue].flatMap { x => MarkConfigTheta2Codec.decodeOpt(x) },
    ))

  def encode(j: MarkConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`cornerRadiusBottomRight`.map { x => "cornerRadiusBottomRight" -> MarkConfigCornerRadiusBottomRightCodec.encode(x) },
        j.`fillOpacity`.map { x => "fillOpacity" -> MarkConfigFillOpacityCodec.encode(x) },
        j.`strokeMiterLimit`.map { x => "strokeMiterLimit" -> MarkConfigStrokeMiterLimitCodec.encode(x) },
        j.`dir`.map { x => "dir" -> MarkConfigDirCodec.encode(x) },
        j.`tooltip`.map { x => "tooltip" -> MarkConfigTooltipCodec.encode(x) },
        j.`timeUnitBandPosition`.map { x => "timeUnitBandPosition" -> Json.toJson(x) },
        j.`cornerRadiusTopRight`.map { x => "cornerRadiusTopRight" -> MarkConfigCornerRadiusTopRightCodec.encode(x) },
        j.`outerRadius`.map { x => "outerRadius" -> MarkConfigOuterRadiusCodec.encode(x) },
        j.`x`.map { x => "x" -> MarkConfigXCodec.encode(x) },
        j.`dy`.map { x => "dy" -> MarkConfigDyCodec.encode(x) },
        j.`size`.map { x => "size" -> MarkConfigSizeCodec.encode(x) },
        j.`smooth`.map { x => "smooth" -> MarkConfigSmoothCodec.encode(x) },
        j.`url`.map { x => "url" -> MarkConfigUrlCodec.encode(x) },
        j.`y`.map { x => "y" -> MarkConfigYCodec.encode(x) },
        j.`strokeOpacity`.map { x => "strokeOpacity" -> MarkConfigStrokeOpacityCodec.encode(x) },
        j.`ellipsis`.map { x => "ellipsis" -> MarkConfigEllipsisCodec.encode(x) },
        j.`description`.map { x => "description" -> MarkConfigDescriptionCodec.encode(x) },
        j.`angle`.map { x => "angle" -> MarkConfigAngleCodec.encode(x) },
        j.`lineBreak`.map { x => "lineBreak" -> MarkConfigLineBreakCodec.encode(x) },
        j.`tension`.map { x => "tension" -> MarkConfigTensionCodec.encode(x) },
        j.`cornerRadiusTopLeft`.map { x => "cornerRadiusTopLeft" -> MarkConfigCornerRadiusTopLeftCodec.encode(x) },
        j.`stroke`.map { x => "stroke" -> MarkConfigStrokeCodec.encode(x) },
        j.`strokeDashOffset`.map { x => "strokeDashOffset" -> MarkConfigStrokeDashOffsetCodec.encode(x) },
        j.`align`.map { x => "align" -> MarkConfigAlignCodec.encode(x) },
        j.`ariaRole`.map { x => "ariaRole" -> MarkConfigAriaRoleCodec.encode(x) },
        j.`strokeCap`.map { x => "strokeCap" -> MarkConfigStrokeCapCodec.encode(x) },
        j.`endAngle`.map { x => "endAngle" -> MarkConfigEndAngleCodec.encode(x) },
        j.`strokeJoin`.map { x => "strokeJoin" -> MarkConfigStrokeJoinCodec.encode(x) },
        j.`baseline`.map { x => "baseline" -> MarkConfigBaselineCodec.encode(x) },
        j.`ariaRoleDescription`.map { x => "ariaRoleDescription" -> MarkConfigAriaRoleDescriptionCodec.encode(x) },
        j.`aspect`.map { x => "aspect" -> MarkConfigAspectCodec.encode(x) },
        j.`height`.map { x => "height" -> MarkConfigHeightCodec.encode(x) },
        j.`fontStyle`.map { x => "fontStyle" -> MarkConfigFontStyleCodec.encode(x) },
        j.`text`.map { x => "text" -> MarkConfigTextCodec.encode(x) },
        j.`cornerRadius`.map { x => "cornerRadius" -> MarkConfigCornerRadiusCodec.encode(x) },
        j.`color`.map { x => "color" -> MarkConfigColorCodec.encode(x) },
        j.`x2`.map { x => "x2" -> MarkConfigX2Codec.encode(x) },
        j.`padAngle`.map { x => "padAngle" -> MarkConfigPadAngleCodec.encode(x) },
        j.`cursor`.map { x => "cursor" -> MarkConfigCursorCodec.encode(x) },
        j.`radius`.map { x => "radius" -> MarkConfigRadiusCodec.encode(x) },
        j.`timeUnitBandSize`.map { x => "timeUnitBandSize" -> Json.toJson(x) },
        j.`startAngle`.map { x => "startAngle" -> MarkConfigStartAngleCodec.encode(x) },
        j.`font`.map { x => "font" -> MarkConfigFontCodec.encode(x) },
        j.`radius2`.map { x => "radius2" -> MarkConfigRadius2Codec.encode(x) },
        j.`invalid`.map { x => "invalid" -> MarkConfigInvalidCodec.encode(x) },
        j.`lineHeight`.map { x => "lineHeight" -> MarkConfigLineHeightCodec.encode(x) },
        j.`order`.map { x => "order" -> MarkConfigOrderCodec.encode(x) },
        j.`fill`.map { x => "fill" -> MarkConfigFillCodec.encode(x) },
        j.`interpolate`.map { x => "interpolate" -> MarkConfigInterpolateCodec.encode(x) },
        j.`theta`.map { x => "theta" -> MarkConfigThetaCodec.encode(x) },
        j.`orient`.map { x => "orient" -> OrientationCodec.encode(x) },
        j.`innerRadius`.map { x => "innerRadius" -> MarkConfigInnerRadiusCodec.encode(x) },
        j.`fontSize`.map { x => "fontSize" -> MarkConfigFontSizeCodec.encode(x) },
        j.`y2`.map { x => "y2" -> MarkConfigY2Codec.encode(x) },
        j.`shape`.map { x => "shape" -> MarkConfigShapeCodec.encode(x) },
        j.`aria`.map { x => "aria" -> MarkConfigAriaCodec.encode(x) },
        j.`opacity`.map { x => "opacity" -> MarkConfigOpacityCodec.encode(x) },
        j.`dx`.map { x => "dx" -> MarkConfigDxCodec.encode(x) },
        j.`cornerRadiusBottomLeft`.map { x => "cornerRadiusBottomLeft" -> MarkConfigCornerRadiusBottomLeftCodec.encode(x) },
        j.`href`.map { x => "href" -> MarkConfigHrefCodec.encode(x) },
        j.`strokeDash`.map { x => "strokeDash" -> MarkConfigStrokeDashCodec.encode(x) },
        j.`strokeOffset`.map { x => "strokeOffset" -> MarkConfigStrokeOffsetCodec.encode(x) },
        j.`limit`.map { x => "limit" -> MarkConfigLimitCodec.encode(x) },
        j.`width`.map { x => "width" -> MarkConfigWidthCodec.encode(x) },
        j.`fontWeight`.map { x => "fontWeight" -> MarkConfigFontWeightCodec.encode(x) },
        j.`filled`.map { x => "filled" -> Json.toJson(x) },
        j.`blend`.map { x => "blend" -> MarkConfigBlendCodec.encode(x) },
        j.`strokeWidth`.map { x => "strokeWidth" -> MarkConfigStrokeWidthCodec.encode(x) },
        j.`theta2`.map { x => "theta2" -> MarkConfigTheta2Codec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LegendConfigTitlePadding (UnionType)
object LegendConfigTitlePaddingCodec {
  def decode(j: JsValue): LegendConfigTitlePadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigTitlePadding] =
    j.asOpt[JsNumber].map { LegendConfigTitlePaddingAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigTitlePadding): JsValue =
    j match {
      case LegendConfigTitlePaddingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetedEncodingUrl (UnionType)
object FacetedEncodingUrlCodec {
  def decode(j: JsValue): FacetedEncodingUrl =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetedEncodingUrl] =
    StringFieldDefWithConditionCodec.decodeOpt(j).orElse {
    StringValueDefWithConditionCodec.decodeOpt(j) } 
  def encode(j: FacetedEncodingUrl): JsValue =
    j match {
      case x:StringFieldDefWithCondition /* TypeRef */ => StringFieldDefWithConditionCodec.encode(x)
      case x:StringValueDefWithCondition /* TypeRef */ => StringValueDefWithConditionCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisColorAsObject2 (StructType)
object ConditionalAxisColorAsObject2Codec {
  def decode(j: JsValue): ConditionalAxisColorAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalAxisColorAsObject2] =
    {
      val `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => ConditionalAxisColorAsObject2ConditionCodec.decodeOpt(x) }
      if(`condition`.isEmpty) { return None }
      val `expr` = (j \ "expr").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`expr`.isEmpty) { return None }
      return Some(ConditionalAxisColorAsObject2(
        `condition` = `condition`.get,
        `expr` = `expr`.get,
      ))
    }

  def encode(j: ConditionalAxisColorAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("condition" -> ConditionalAxisColorAsObject2ConditionCodec.encode(j.`condition`)),
        Some("expr" -> Json.toJson(j.`expr`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AreaConfigLimit (UnionType)
object AreaConfigLimitCodec {
  def decode(j: JsValue): AreaConfigLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigLimit] =
    j.asOpt[JsNumber].map { AreaConfigLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigLimit): JsValue =
    j match {
      case AreaConfigLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisLabelPadding (UnionType)
object AxisLabelPaddingCodec {
  def decode(j: JsValue): AxisLabelPadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisLabelPadding] =
    j.asOpt[JsNumber].map { AxisLabelPaddingAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisLabelPadding): JsValue =
    j match {
      case AxisLabelPaddingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisNumber (UnionType)
object ConditionalAxisNumberCodec {
  def decode(j: JsValue): ConditionalAxisNumber =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisNumber] =
    ConditionalAxisNumberAsObject1Codec.decodeOpt(j).orElse {
    ConditionalAxisNumberAsObject2Codec.decodeOpt(j) } 
  def encode(j: ConditionalAxisNumber): JsValue =
    j match {
      case x:ConditionalAxisNumberAsObject1 /* TypeRef */ => ConditionalAxisNumberAsObject1Codec.encode(x)
      case x:ConditionalAxisNumberAsObject2 /* TypeRef */ => ConditionalAxisNumberAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefFontStyleNullExprRefAsObject1 (StructType)
object ConditionalPredicateValueDefFontStyleNullExprRefAsObject1Codec {
  def decode(j: JsValue): ConditionalPredicateValueDefFontStyleNullExprRefAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefFontStyleNullExprRefAsObject1] =
    {
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => x.asOpt[String].map { Some(_) }.flatten }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalPredicateValueDefFontStyleNullExprRefAsObject1(
        `test` = `test`.get,
        `value` = `value`,
      ))
    }

  def encode(j: ConditionalPredicateValueDefFontStyleNullExprRefAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
        j.`value`.map { x => "value" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TickConfigTheta (ConstrainedType)
// see TickConfigTheta (UnionType)

////////////////////////////////////////////////////////////////////////
// PolarDef (UnionType)
object PolarDefCodec {
  def decode(j: JsValue): PolarDef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PolarDef] =
    PositionFieldDefBaseCodec.decodeOpt(j).orElse {
    PositionDatumDefBaseCodec.decodeOpt(j).orElse {
    PositionValueDefCodec.decodeOpt(j) } } 
  def encode(j: PolarDef): JsValue =
    j match {
      case x:PositionFieldDefBase /* TypeRef */ => PositionFieldDefBaseCodec.encode(x)
      case x:PositionDatumDefBase /* TypeRef */ => PositionDatumDefBaseCodec.encode(x)
      case x:PositionValueDef /* TypeRef */ => PositionValueDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Date (ConstantType)
object DateCodec {
  def decode(j: JsValue): Date =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Date] =
    j match {
      case JsString("date") => Some(Date())
      case _ => None
    }
  def encode(j: Date): JsValue =
    JsString("date")
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingUrl (StructType)
object SharedEncodingUrlCodec {
  def decode(j: JsValue): SharedEncodingUrl =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingUrl] =
    Some(SharedEncodingUrl(
      `format` = (j \ "format").asOpt[JsValue].flatMap { x => SharedEncodingUrlFormatCodec.decodeOpt(x) },
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingUrlBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => SharedEncodingUrlConditionCodec.decodeOpt(x) },
      `formatType` = (j \ "formatType").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingUrlBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingUrlValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingUrlTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingUrl): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`format`.map { x => "format" -> SharedEncodingUrlFormatCodec.encode(x) },
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingUrlBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> SharedEncodingUrlConditionCodec.encode(x) },
        j.`formatType`.map { x => "formatType" -> Json.toJson(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingUrlBinCodec.encode(x) },
        j.`value`.map { x => "value" -> SharedEncodingUrlValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingUrlTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// BarConfigInterpolate (UnionType)
object BarConfigInterpolateCodec {
  def decode(j: JsValue): BarConfigInterpolate =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigInterpolate] =
    InterpolateCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigInterpolate): JsValue =
    j match {
      case x:Interpolate /* TypeRef */ => InterpolateCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OrderFieldDef (StructType)
object OrderFieldDefCodec {
  def decode(j: JsValue): OrderFieldDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[OrderFieldDef] =
    Some(OrderFieldDef(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => OrderFieldDefBandPositionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => OrderFieldDefBinCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => OrderFieldDefTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortOrderCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) },
    ))

  def encode(j: OrderFieldDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> OrderFieldDefBandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> OrderFieldDefBinCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> OrderFieldDefTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortOrderCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// DerivedStream (StructType)
object DerivedStreamCodec {
  def decode(j: JsValue): DerivedStream =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[DerivedStream] =
    {
      val `marktype` = (j \ "marktype").asOpt[JsValue].flatMap { x => MarkTypeCodec.decodeOpt(x) }
      val `filter` = (j \ "filter").asOpt[JsValue].flatMap { x => DerivedStreamFilterCodec.decodeOpt(x) }
      val `stream` = (j \ "stream").asOpt[JsValue].flatMap { x => StreamCodec.decodeOpt(x) }
      if(`stream`.isEmpty) { return None }
      val `markname` = (j \ "markname").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `consume` = (j \ "consume").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `debounce` = (j \ "debounce").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `between` = (j \ "between").asOpt[JsValue].flatMap { x => ArrayOfStreamCodec.decodeOpt(x) }
      val `throttle` = (j \ "throttle").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      return Some(DerivedStream(
        `marktype` = `marktype`,
        `filter` = `filter`,
        `stream` = `stream`.get,
        `markname` = `markname`,
        `consume` = `consume`,
        `debounce` = `debounce`,
        `between` = `between`,
        `throttle` = `throttle`,
      ))
    }

  def encode(j: DerivedStream): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`marktype`.map { x => "marktype" -> MarkTypeCodec.encode(x) },
        j.`filter`.map { x => "filter" -> DerivedStreamFilterCodec.encode(x) },
        Some("stream" -> StreamCodec.encode(j.`stream`)),
        j.`markname`.map { x => "markname" -> Json.toJson(x) },
        j.`consume`.map { x => "consume" -> Json.toJson(x) },
        j.`debounce`.map { x => "debounce" -> Json.toJson(x) },
        j.`between`.map { x => "between" -> ArrayOfStreamCodec.encode(x) },
        j.`throttle`.map { x => "throttle" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefNumberNullExprRef (UnionType)
object ConditionalPredicateValueDefNumberNullExprRefCodec {
  def decode(j: JsValue): ConditionalPredicateValueDefNumberNullExprRef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefNumberNullExprRef] =
    ConditionalPredicateValueDefNumberNullExprRefAsObject1Codec.decodeOpt(j).orElse {
    ConditionalPredicateValueDefNumberNullExprRefAsObject2Codec.decodeOpt(j) } 
  def encode(j: ConditionalPredicateValueDefNumberNullExprRef): JsValue =
    j match {
      case x:ConditionalPredicateValueDefNumberNullExprRefAsObject1 /* TypeRef */ => ConditionalPredicateValueDefNumberNullExprRefAsObject1Codec.encode(x)
      case x:ConditionalPredicateValueDefNumberNullExprRefAsObject2 /* TypeRef */ => ConditionalPredicateValueDefNumberNullExprRefAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeWidthDatum (UnionType)
object SharedEncodingStrokeWidthDatumCodec {
  def decode(j: JsValue): SharedEncodingStrokeWidthDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeWidthDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingStrokeWidthDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewBackgroundStrokeWidthAsNumber (ConstrainedType)
object ViewBackgroundStrokeWidthAsNumberCodec {
  def decode(j: JsValue): ViewBackgroundStrokeWidthAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ViewBackgroundStrokeWidthAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { ViewBackgroundStrokeWidthAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ViewBackgroundStrokeWidthAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AxisLabelFont (UnionType)
object AxisLabelFontCodec {
  def decode(j: JsValue): AxisLabelFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisLabelFont] =
    j.asOpt[String].map { AxisLabelFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisStringCodec.decodeOpt(j) } } 
  def encode(j: AxisLabelFont): JsValue =
    j match {
      case AxisLabelFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisString /* TypeRef */ => ConditionalAxisStringCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigDx (UnionType)
object RectConfigDxCodec {
  def decode(j: JsValue): RectConfigDx =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigDx] =
    j.asOpt[JsNumber].map { RectConfigDxAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigDx): JsValue =
    j match {
      case RectConfigDxAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigStrokeDash (UnionType)
object LineConfigStrokeDashCodec {
  def decode(j: JsValue): LineConfigStrokeDash =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigStrokeDash] =
    ArrayOfNumberCodec.decodeOpt(j).map { LineConfigStrokeDashAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigStrokeDash): JsValue =
    j match {
      case LineConfigStrokeDashAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNull (ConstrainedType)
// see ValueDefWithConditionMarkPropFieldOrDatumDefTypeForShapeStringNull (StructType)

////////////////////////////////////////////////////////////////////////
// SharedEncodingKey (StructType)
object SharedEncodingKeyCodec {
  def decode(j: JsValue): SharedEncodingKey =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingKey] =
    Some(SharedEncodingKey(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingKeyBandPositionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingKeyBinCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingKeyTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingKey): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingKeyBandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingKeyBinCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingKeyTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// OverlayMarkDefYOffset (UnionType)
object OverlayMarkDefYOffsetCodec {
  def decode(j: JsValue): OverlayMarkDefYOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefYOffset] =
    j.asOpt[JsNumber].map { OverlayMarkDefYOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefYOffset): JsValue =
    j match {
      case OverlayMarkDefYOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigSymbolDashOffset (UnionType)
object LegendConfigSymbolDashOffsetCodec {
  def decode(j: JsValue): LegendConfigSymbolDashOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigSymbolDashOffset] =
    j.asOpt[JsNumber].map { LegendConfigSymbolDashOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigSymbolDashOffset): JsValue =
    j match {
      case LegendConfigSymbolDashOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefLineBreak (UnionType)
object MarkDefLineBreakCodec {
  def decode(j: JsValue): MarkDefLineBreak =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefLineBreak] =
    j.asOpt[String].map { MarkDefLineBreakAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefLineBreak): JsValue =
    j match {
      case MarkDefLineBreakAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefDx (UnionType)
object MarkDefDxCodec {
  def decode(j: JsValue): MarkDefDx =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefDx] =
    j.asOpt[JsNumber].map { MarkDefDxAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefDx): JsValue =
    j match {
      case MarkDefDxAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigGradientLength (UnionType)
object LegendConfigGradientLengthCodec {
  def decode(j: JsValue): LegendConfigGradientLength =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigGradientLength] =
    LegendConfigGradientLengthAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigGradientLength): JsValue =
    j match {
      case x:LegendConfigGradientLengthAsNumber /* TypeRef */ => LegendConfigGradientLengthAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTickBandAsString (EnumType)
object AxisConfigTickBandAsStringCodec {
  def decode(j: JsValue): AxisConfigTickBandAsString =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTickBandAsString] =
    j match {
      case JsString("center") => Some(AxisConfigTickBandAsStringCenter)
      case JsString("extent") => Some(AxisConfigTickBandAsStringExtent)
      case _ => None
    }
  def encode(j: AxisConfigTickBandAsString): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// AreaConfigFillOpacityAsNumber (ConstrainedType)
object AreaConfigFillOpacityAsNumberCodec {
  def decode(j: JsValue): AreaConfigFillOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AreaConfigFillOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AreaConfigFillOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AreaConfigFillOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// TopLevelFacetSpecBounds (EnumType)
object TopLevelFacetSpecBoundsCodec {
  def decode(j: JsValue): TopLevelFacetSpecBounds =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelFacetSpecBounds] =
    j match {
      case JsString("full") => Some(TopLevelFacetSpecBoundsFull)
      case JsString("flush") => Some(TopLevelFacetSpecBoundsFlush)
      case _ => None
    }
  def encode(j: TopLevelFacetSpecBounds): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// AreaConfigAriaRole (UnionType)
object AreaConfigAriaRoleCodec {
  def decode(j: JsValue): AreaConfigAriaRole =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigAriaRole] =
    j.asOpt[String].map { AreaConfigAriaRoleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigAriaRole): JsValue =
    j match {
      case AreaConfigAriaRoleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleConfigColor (UnionType)
object TitleConfigColorCodec {
  def decode(j: JsValue): TitleConfigColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => TitleConfigColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: TitleConfigColor): JsValue =
    j match {
      case TitleConfigColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfOrderFieldDef (ArrayType)
object ArrayOfOrderFieldDefCodec {
  def decode(j: JsValue): Seq[OrderFieldDef] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[OrderFieldDef]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      OrderFieldDefCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[OrderFieldDef]): JsArray =
      JsArray(j.map { x => OrderFieldDefCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// FacetedUnitSpecWidth (UnionType)
object FacetedUnitSpecWidthCodec {
  def decode(j: JsValue): FacetedUnitSpecWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetedUnitSpecWidth] =
    j.asOpt[JsNumber].map { FacetedUnitSpecWidthAsNumber(_) }.orElse {
    ContainerCodec.decodeOpt(j).orElse {
    StepCodec.decodeOpt(j) } } 
  def encode(j: FacetedUnitSpecWidth): JsValue =
    j match {
      case FacetedUnitSpecWidthAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Container /* TypeRef */ => ContainerCodec.encode(x)
      case x:Step /* TypeRef */ => StepCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// UnitSpecWithFrameWidth (UnionType)
object UnitSpecWithFrameWidthCodec {
  def decode(j: JsValue): UnitSpecWithFrameWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[UnitSpecWithFrameWidth] =
    j.asOpt[JsNumber].map { UnitSpecWithFrameWidthAsNumber(_) }.orElse {
    ContainerCodec.decodeOpt(j).orElse {
    StepCodec.decodeOpt(j) } } 
  def encode(j: UnitSpecWithFrameWidth): JsValue =
    j match {
      case UnitSpecWithFrameWidthAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Container /* TypeRef */ => ContainerCodec.encode(x)
      case x:Step /* TypeRef */ => StepCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigMinBandSize (ConstrainedType)
object ScaleConfigMinBandSizeCodec {
  def decode(j: JsValue): ScaleConfigMinBandSize =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ScaleConfigMinBandSize] =
    try {
      j.asOpt[JsNumber]
        .map { ScaleConfigMinBandSize(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ScaleConfigMinBandSize): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingSizeDatum (UnionType)
object SharedEncodingSizeDatumCodec {
  def decode(j: JsValue): SharedEncodingSizeDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingSizeDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingSizeDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefStrokeWidth (UnionType)
object OverlayMarkDefStrokeWidthCodec {
  def decode(j: JsValue): OverlayMarkDefStrokeWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefStrokeWidth] =
    OverlayMarkDefStrokeWidthAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefStrokeWidth): JsValue =
    j match {
      case x:OverlayMarkDefStrokeWidthAsNumber /* TypeRef */ => OverlayMarkDefStrokeWidthAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigSymbolType (UnionType)
object LegendConfigSymbolTypeCodec {
  def decode(j: JsValue): LegendConfigSymbolType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigSymbolType] =
    j.asOpt[String].map { LegendConfigSymbolTypeAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigSymbolType): JsValue =
    j match {
      case LegendConfigSymbolTypeAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TextDef (UnionType)
object TextDefCodec {
  def decode(j: JsValue): TextDef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TextDef] =
    FieldOrDatumDefWithConditionStringFieldDefTextCodec.decodeOpt(j).orElse {
    FieldOrDatumDefWithConditionStringDatumDefTextCodec.decodeOpt(j).orElse {
    ValueDefWithConditionStringFieldDefTextCodec.decodeOpt(j) } } 
  def encode(j: TextDef): JsValue =
    j match {
      case x:FieldOrDatumDefWithConditionStringFieldDefText /* TypeRef */ => FieldOrDatumDefWithConditionStringFieldDefTextCodec.encode(x)
      case x:FieldOrDatumDefWithConditionStringDatumDefText /* TypeRef */ => FieldOrDatumDefWithConditionStringDatumDefTextCodec.encode(x)
      case x:ValueDefWithConditionStringFieldDefText /* TypeRef */ => ValueDefWithConditionStringFieldDefTextCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// EncodingYError (UnionType)
object EncodingYErrorCodec {
  def decode(j: JsValue): EncodingYError =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[EncodingYError] =
    SecondaryFieldDefCodec.decodeOpt(j).orElse {
    ValueDefNumberCodec.decodeOpt(j) } 
  def encode(j: EncodingYError): JsValue =
    j match {
      case x:SecondaryFieldDef /* TypeRef */ => SecondaryFieldDefCodec.encode(x)
      case x:ValueDefNumber /* TypeRef */ => ValueDefNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefSize (ConstrainedType)
// see OverlayMarkDefSize (UnionType)

////////////////////////////////////////////////////////////////////////
// RangeConfigOrdinal (UnionType)
object RangeConfigOrdinalCodec {
  def decode(j: JsValue): RangeConfigOrdinal =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RangeConfigOrdinal] =
    RangeSchemeCodec.decodeOpt(j).orElse {
    ArrayOfColorCodec.decodeOpt(j).map { RangeConfigOrdinalAsArrayOfColor(_) } } 
  def encode(j: RangeConfigOrdinal): JsValue =
    j match {
      case x:RangeScheme /* TypeRef */ => RangeSchemeCodec.encode(x)
      case RangeConfigOrdinalAsArrayOfColor(x) /* Base, ArrayType */ => ArrayOfColorCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefCornerRadiusBottomLeft (UnionType)
object MarkDefCornerRadiusBottomLeftCodec {
  def decode(j: JsValue): MarkDefCornerRadiusBottomLeft =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefCornerRadiusBottomLeft] =
    j.asOpt[JsNumber].map { MarkDefCornerRadiusBottomLeftAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefCornerRadiusBottomLeft): JsValue =
    j match {
      case MarkDefCornerRadiusBottomLeftAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BindCheckboxInput (ConstantType)
object BindCheckboxInputCodec {
  def decode(j: JsValue): BindCheckboxInput =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BindCheckboxInput] =
    j match {
      case JsString("checkbox") => Some(BindCheckboxInput())
      case _ => None
    }
  def encode(j: BindCheckboxInput): JsValue =
    JsString("checkbox")
}


////////////////////////////////////////////////////////////////////////
// TopLevelConcatSpec (StructType)
object TopLevelConcatSpecCodec {
  def decode(j: JsValue): TopLevelConcatSpec =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TopLevelConcatSpec] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `description` = (j \ "description").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `params` = (j \ "params").asOpt[JsValue].flatMap { x => ArrayOfTopLevelConcatSpecParamsElementCodec.decodeOpt(x) }
      val `concat` = (j \ "concat").asOpt[JsValue].flatMap { x => ArrayOfNonNormalizedSpecCodec.decodeOpt(x) }
      if(`concat`.isEmpty) { return None }
      val `config` = (j \ "config").asOpt[JsValue].flatMap { x => ConfigCodec.decodeOpt(x) }
      val `bounds` = (j \ "bounds").asOpt[JsValue].flatMap { x => TopLevelConcatSpecBoundsCodec.decodeOpt(x) }
      val `datasets` = (j \ "datasets").asOpt[JsValue].flatMap { x => DictOfInlineDatasetCodec.decodeOpt(x) }
      val `usermeta` = (j \ "usermeta").asOpt[JsValue].flatMap { x => DictOfAnyCodec.decodeOpt(x) }
      val `columns` = (j \ "columns").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `resolve` = (j \ "resolve").asOpt[JsValue].flatMap { x => ResolveCodec.decodeOpt(x) }
      val `padding` = (j \ "padding").asOpt[JsValue].flatMap { x => TopLevelConcatSpecPaddingCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => TopLevelConcatSpecTitleCodec.decodeOpt(x) }
      val `background` = (j \ "background").asOpt[JsValue].flatMap { x => TopLevelConcatSpecBackgroundCodec.decodeOpt(x) }
      val `center` = (j \ "center").asOpt[JsValue].flatMap { x => TopLevelConcatSpecCenterCodec.decodeOpt(x) }
      val `align` = (j \ "align").asOpt[JsValue].flatMap { x => TopLevelConcatSpecAlignCodec.decodeOpt(x) }
      val `data` = (j \ "data").asOpt[JsValue].flatMap { x => DataCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `spacing` = (j \ "spacing").asOpt[JsValue].flatMap { x => TopLevelConcatSpecSpacingCodec.decodeOpt(x) }
      val `$schema` = (j \ "$schema").asOpt[JsValue].flatMap { x => UriCodec.decodeOpt(x) }
      val `autosize` = (j \ "autosize").asOpt[JsValue].flatMap { x => TopLevelConcatSpecAutosizeCodec.decodeOpt(x) }
      val `transform` = (j \ "transform").asOpt[JsValue].flatMap { x => ArrayOfTransformCodec.decodeOpt(x) }
      return Some(TopLevelConcatSpec(
        `name` = `name`,
        `description` = `description`,
        `params` = `params`,
        `concat` = `concat`.get,
        `config` = `config`,
        `bounds` = `bounds`,
        `datasets` = `datasets`,
        `usermeta` = `usermeta`,
        `columns` = `columns`,
        `resolve` = `resolve`,
        `padding` = `padding`,
        `title` = `title`,
        `background` = `background`,
        `center` = `center`,
        `align` = `align`,
        `data` = `data`,
        `spacing` = `spacing`,
        `$schema` = `$schema`,
        `autosize` = `autosize`,
        `transform` = `transform`,
      ))
    }

  def encode(j: TopLevelConcatSpec): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`description`.map { x => "description" -> Json.toJson(x) },
        j.`params`.map { x => "params" -> ArrayOfTopLevelConcatSpecParamsElementCodec.encode(x) },
        Some("concat" -> ArrayOfNonNormalizedSpecCodec.encode(j.`concat`)),
        j.`config`.map { x => "config" -> ConfigCodec.encode(x) },
        j.`bounds`.map { x => "bounds" -> TopLevelConcatSpecBoundsCodec.encode(x) },
        j.`datasets`.map { x => "datasets" -> DictOfInlineDatasetCodec.encode(x) },
        j.`usermeta`.map { x => "usermeta" -> DictOfAnyCodec.encode(x) },
        j.`columns`.map { x => "columns" -> Json.toJson(x) },
        j.`resolve`.map { x => "resolve" -> ResolveCodec.encode(x) },
        j.`padding`.map { x => "padding" -> TopLevelConcatSpecPaddingCodec.encode(x) },
        j.`title`.map { x => "title" -> TopLevelConcatSpecTitleCodec.encode(x) },
        j.`background`.map { x => "background" -> TopLevelConcatSpecBackgroundCodec.encode(x) },
        j.`center`.map { x => "center" -> TopLevelConcatSpecCenterCodec.encode(x) },
        j.`align`.map { x => "align" -> TopLevelConcatSpecAlignCodec.encode(x) },
        j.`data`.map { x => "data" -> DataCodec.encode(x) },
        j.`spacing`.map { x => "spacing" -> TopLevelConcatSpecSpacingCodec.encode(x) },
        j.`$schema`.map { x => "$schema" -> UriCodec.encode(x) },
        j.`autosize`.map { x => "autosize" -> TopLevelConcatSpecAutosizeCodec.encode(x) },
        j.`transform`.map { x => "transform" -> ArrayOfTransformCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TickConfigSize (UnionType)
object TickConfigSizeCodec {
  def decode(j: JsValue): TickConfigSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigSize] =
    j.asOpt[JsNumber].map { TickConfigSizeAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigSize): JsValue =
    j match {
      case TickConfigSizeAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingYBandPosition (ConstrainedType)
object SharedEncodingYBandPositionCodec {
  def decode(j: JsValue): SharedEncodingYBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingYBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingYBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingYBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// TopLevelUnitSpec (StructType)
object TopLevelUnitSpecCodec {
  def decode(j: JsValue): TopLevelUnitSpec =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TopLevelUnitSpec] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `projection` = (j \ "projection").asOpt[JsValue].flatMap { x => ProjectionCodec.decodeOpt(x) }
      val `description` = (j \ "description").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `params` = (j \ "params").asOpt[JsValue].flatMap { x => ArrayOfTopLevelUnitSpecParamsElementCodec.decodeOpt(x) }
      val `height` = (j \ "height").asOpt[JsValue].flatMap { x => TopLevelUnitSpecHeightCodec.decodeOpt(x) }
      val `config` = (j \ "config").asOpt[JsValue].flatMap { x => ConfigCodec.decodeOpt(x) }
      val `datasets` = (j \ "datasets").asOpt[JsValue].flatMap { x => DictOfInlineDatasetCodec.decodeOpt(x) }
      val `usermeta` = (j \ "usermeta").asOpt[JsValue].flatMap { x => DictOfAnyCodec.decodeOpt(x) }
      val `resolve` = (j \ "resolve").asOpt[JsValue].flatMap { x => ResolveCodec.decodeOpt(x) }
      val `padding` = (j \ "padding").asOpt[JsValue].flatMap { x => TopLevelUnitSpecPaddingCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => TopLevelUnitSpecTitleCodec.decodeOpt(x) }
      val `mark` = (j \ "mark").asOpt[JsValue].flatMap { x => AnyMarkCodec.decodeOpt(x) }
      if(`mark`.isEmpty) { return None }
      val `view` = (j \ "view").asOpt[JsValue].flatMap { x => ViewBackgroundCodec.decodeOpt(x) }
      val `background` = (j \ "background").asOpt[JsValue].flatMap { x => TopLevelUnitSpecBackgroundCodec.decodeOpt(x) }
      val `center` = (j \ "center").asOpt[JsValue].flatMap { x => TopLevelUnitSpecCenterCodec.decodeOpt(x) }
      val `align` = (j \ "align").asOpt[JsValue].flatMap { x => TopLevelUnitSpecAlignCodec.decodeOpt(x) }
      val `data` = (j \ "data").asOpt[JsValue].flatMap { x => DataCodec.decodeOpt(x).map { Some(_) }.flatten }
      if(`data`.isEmpty) { return None }
      val `encoding` = (j \ "encoding").asOpt[JsValue].flatMap { x => FacetedEncodingCodec.decodeOpt(x) }
      val `bounds` = (j \ "bounds").asOpt[JsValue].flatMap { x => TopLevelUnitSpecBoundsCodec.decodeOpt(x) }
      val `spacing` = (j \ "spacing").asOpt[JsValue].flatMap { x => TopLevelUnitSpecSpacingCodec.decodeOpt(x) }
      val `$schema` = (j \ "$schema").asOpt[JsValue].flatMap { x => UriCodec.decodeOpt(x) }
      val `autosize` = (j \ "autosize").asOpt[JsValue].flatMap { x => TopLevelUnitSpecAutosizeCodec.decodeOpt(x) }
      val `transform` = (j \ "transform").asOpt[JsValue].flatMap { x => ArrayOfTransformCodec.decodeOpt(x) }
      val `width` = (j \ "width").asOpt[JsValue].flatMap { x => TopLevelUnitSpecWidthCodec.decodeOpt(x) }
      return Some(TopLevelUnitSpec(
        `name` = `name`,
        `projection` = `projection`,
        `description` = `description`,
        `params` = `params`,
        `height` = `height`,
        `config` = `config`,
        `datasets` = `datasets`,
        `usermeta` = `usermeta`,
        `resolve` = `resolve`,
        `padding` = `padding`,
        `title` = `title`,
        `mark` = `mark`.get,
        `view` = `view`,
        `background` = `background`,
        `center` = `center`,
        `align` = `align`,
        `data` = `data`,
        `encoding` = `encoding`,
        `bounds` = `bounds`,
        `spacing` = `spacing`,
        `$schema` = `$schema`,
        `autosize` = `autosize`,
        `transform` = `transform`,
        `width` = `width`,
      ))
    }

  def encode(j: TopLevelUnitSpec): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`projection`.map { x => "projection" -> ProjectionCodec.encode(x) },
        j.`description`.map { x => "description" -> Json.toJson(x) },
        j.`params`.map { x => "params" -> ArrayOfTopLevelUnitSpecParamsElementCodec.encode(x) },
        j.`height`.map { x => "height" -> TopLevelUnitSpecHeightCodec.encode(x) },
        j.`config`.map { x => "config" -> ConfigCodec.encode(x) },
        j.`datasets`.map { x => "datasets" -> DictOfInlineDatasetCodec.encode(x) },
        j.`usermeta`.map { x => "usermeta" -> DictOfAnyCodec.encode(x) },
        j.`resolve`.map { x => "resolve" -> ResolveCodec.encode(x) },
        j.`padding`.map { x => "padding" -> TopLevelUnitSpecPaddingCodec.encode(x) },
        j.`title`.map { x => "title" -> TopLevelUnitSpecTitleCodec.encode(x) },
        Some("mark" -> AnyMarkCodec.encode(j.`mark`)),
        j.`view`.map { x => "view" -> ViewBackgroundCodec.encode(x) },
        j.`background`.map { x => "background" -> TopLevelUnitSpecBackgroundCodec.encode(x) },
        j.`center`.map { x => "center" -> TopLevelUnitSpecCenterCodec.encode(x) },
        j.`align`.map { x => "align" -> TopLevelUnitSpecAlignCodec.encode(x) },
        j.`data`.map { x => "data" -> DataCodec.encode(x) },
        j.`encoding`.map { x => "encoding" -> FacetedEncodingCodec.encode(x) },
        j.`bounds`.map { x => "bounds" -> TopLevelUnitSpecBoundsCodec.encode(x) },
        j.`spacing`.map { x => "spacing" -> TopLevelUnitSpecSpacingCodec.encode(x) },
        j.`$schema`.map { x => "$schema" -> UriCodec.encode(x) },
        j.`autosize`.map { x => "autosize" -> TopLevelUnitSpecAutosizeCodec.encode(x) },
        j.`transform`.map { x => "transform" -> ArrayOfTransformCodec.encode(x) },
        j.`width`.map { x => "width" -> TopLevelUnitSpecWidthCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ErrorBandDefOpacity (ConstrainedType)
object ErrorBandDefOpacityCodec {
  def decode(j: JsValue): ErrorBandDefOpacity =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ErrorBandDefOpacity] =
    try {
      j.asOpt[JsNumber]
        .map { ErrorBandDefOpacity(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ErrorBandDefOpacity): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigBarBandPaddingInner (ConstrainedType)
// see ScaleConfigBarBandPaddingInner (UnionType)

////////////////////////////////////////////////////////////////////////
// DictOfBinding (MapType)
object DictOfBindingCodec {
  def decode(j: JsValue): Map[String,Binding] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Map[String,Binding]] =
    j.asOpt[Map[String,JsValue]].map { _.mapValues { x => 
      BindingCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Map[String,Binding]): JsObject =
      JsObject(j.mapValues { x => BindingCodec.encode(x) })
}


////////////////////////////////////////////////////////////////////////
// TopLevelSelectionParameterValue (UnionType)
object TopLevelSelectionParameterValueCodec {
  def decode(j: JsValue): TopLevelSelectionParameterValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelSelectionParameterValue] =
    SelectionInitCodec.decodeOpt(j).orElse {
    ArrayOfDictOfSelectionInitCodec.decodeOpt(j).map { TopLevelSelectionParameterValueAsArrayOfDictOfSelectionInit(_) }.orElse {
    DictOfSelectionInitIntervalCodec.decodeOpt(j).map { TopLevelSelectionParameterValueAsDictOfSelectionInitInterval(_) } } } 
  def encode(j: TopLevelSelectionParameterValue): JsValue =
    j match {
      case x:SelectionInit /* TypeRef */ => SelectionInitCodec.encode(x)
      case TopLevelSelectionParameterValueAsArrayOfDictOfSelectionInit(x) /* Base, ArrayType */ => ArrayOfDictOfSelectionInitCodec.encode(x)
      case TopLevelSelectionParameterValueAsDictOfSelectionInitInterval(x) /* Base, MapType */ => DictOfSelectionInitIntervalCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// StackTransform (StructType)
object StackTransformCodec {
  def decode(j: JsValue): StackTransform =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[StackTransform] =
    {
      val `as` = (j \ "as").asOpt[JsValue].flatMap { x => StackTransformAsCodec.decodeOpt(x) }
      if(`as`.isEmpty) { return None }
      val `offset` = (j \ "offset").asOpt[JsValue].flatMap { x => StackTransformOffsetCodec.decodeOpt(x) }
      val `stack` = (j \ "stack").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`stack`.isEmpty) { return None }
      val `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => ArrayOfSortFieldCodec.decodeOpt(x) }
      val `groupby` = (j \ "groupby").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) }
      if(`groupby`.isEmpty) { return None }
      return Some(StackTransform(
        `as` = `as`.get,
        `offset` = `offset`,
        `stack` = `stack`.get,
        `sort` = `sort`,
        `groupby` = `groupby`.get,
      ))
    }

  def encode(j: StackTransform): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("as" -> StackTransformAsCodec.encode(j.`as`)),
        j.`offset`.map { x => "offset" -> StackTransformOffsetCodec.encode(x) },
        Some("stack" -> Json.toJson(j.`stack`)),
        j.`sort`.map { x => "sort" -> ArrayOfSortFieldCodec.encode(x) },
        Some("groupby" -> ArrayOfStringCodec.encode(j.`groupby`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// RowColBoolean (StructType)
object RowColBooleanCodec {
  def decode(j: JsValue): RowColBoolean =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RowColBoolean] =
    Some(RowColBoolean(
      `column` = (j \ "column").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `row` = (j \ "row").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
    ))

  def encode(j: RowColBoolean): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`column`.map { x => "column" -> Json.toJson(x) },
        j.`row`.map { x => "row" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ArrayOfStream (ArrayType)
object ArrayOfStreamCodec {
  def decode(j: JsValue): Seq[Stream] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[Stream]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      StreamCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[Stream]): JsArray =
      JsArray(j.map { x => StreamCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingX2 (StructType)
object SharedEncodingX2Codec {
  def decode(j: JsValue): SharedEncodingX2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingX2] =
    Some(SharedEncodingX2(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingX2DatumCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingX2BandPositionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => x.asOpt[JsNull.type].map { _ => JsNull } },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingX2ValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingX2TimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingX2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingX2DatumCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingX2BandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> Json.toJson(x) },
        j.`value`.map { x => "value" -> SharedEncodingX2ValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingX2TimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// MarkConfigStrokeCap (UnionType)
object MarkConfigStrokeCapCodec {
  def decode(j: JsValue): MarkConfigStrokeCap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigStrokeCap] =
    StrokeCapCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigStrokeCap): JsValue =
    j match {
      case x:StrokeCap /* TypeRef */ => StrokeCapCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingUrlTimeUnit (UnionType)
object SharedEncodingUrlTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingUrlTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingUrlTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingUrlTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisString (UnionType)
object ConditionalAxisStringCodec {
  def decode(j: JsValue): ConditionalAxisString =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisString] =
    ConditionalAxisStringAsObject1Codec.decodeOpt(j).orElse {
    ConditionalAxisStringAsObject2Codec.decodeOpt(j) } 
  def encode(j: ConditionalAxisString): JsValue =
    j match {
      case x:ConditionalAxisStringAsObject1 /* TypeRef */ => ConditionalAxisStringAsObject1Codec.encode(x)
      case x:ConditionalAxisStringAsObject2 /* TypeRef */ => ConditionalAxisStringAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderTitlePadding (UnionType)
object HeaderTitlePaddingCodec {
  def decode(j: JsValue): HeaderTitlePadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderTitlePadding] =
    j.asOpt[JsNumber].map { HeaderTitlePaddingAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderTitlePadding): JsValue =
    j match {
      case HeaderTitlePaddingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigSymbolOpacity (UnionType)
object LegendConfigSymbolOpacityCodec {
  def decode(j: JsValue): LegendConfigSymbolOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigSymbolOpacity] =
    j.asOpt[JsNumber].map { LegendConfigSymbolOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigSymbolOpacity): JsValue =
    j match {
      case LegendConfigSymbolOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BoxPlotDefBox (UnionType)
object BoxPlotDefBoxCodec {
  def decode(j: JsValue): BoxPlotDefBox =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BoxPlotDefBox] =
    j.asOpt[Boolean].map { BoxPlotDefBoxAsBool(_) }.orElse {
    MarkConfigCodec.decodeOpt(j) } 
  def encode(j: BoxPlotDefBox): JsValue =
    j match {
      case BoxPlotDefBoxAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:MarkConfig /* TypeRef */ => MarkConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsSubtitleColor (UnionType)
object TitleParamsSubtitleColorCodec {
  def decode(j: JsValue): TitleParamsSubtitleColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsSubtitleColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => TitleParamsSubtitleColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: TitleParamsSubtitleColor): JsValue =
    j match {
      case TitleParamsSubtitleColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigOpacity (UnionType)
object TickConfigOpacityCodec {
  def decode(j: JsValue): TickConfigOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigOpacity] =
    j.asOpt[JsNumber].map { TickConfigOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigOpacity): JsValue =
    j match {
      case TickConfigOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// StringConst (ConstantType)
object StringConstCodec {
  def decode(j: JsValue): StringConst =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[StringConst] =
    j match {
      case JsString("string") => Some(StringConst())
      case _ => None
    }
  def encode(j: StringConst): JsValue =
    JsString("string")
}


////////////////////////////////////////////////////////////////////////
// TitleConfigFontStyle (UnionType)
object TitleConfigFontStyleCodec {
  def decode(j: JsValue): TitleConfigFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigFontStyle] =
    j.asOpt[String].map { TitleConfigFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleConfigFontStyle): JsValue =
    j match {
      case TitleConfigFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelConcatSpecBackground (UnionType)
object TopLevelConcatSpecBackgroundCodec {
  def decode(j: JsValue): TopLevelConcatSpecBackground =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelConcatSpecBackground] =
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TopLevelConcatSpecBackground): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigStrokeWidth (UnionType)
object LegendConfigStrokeWidthCodec {
  def decode(j: JsValue): LegendConfigStrokeWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigStrokeWidth] =
    j.asOpt[JsNumber].map { LegendConfigStrokeWidthAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigStrokeWidth): JsValue =
    j match {
      case LegendConfigStrokeWidthAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigRadius2 (UnionType)
object MarkConfigRadius2Codec {
  def decode(j: JsValue): MarkConfigRadius2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigRadius2] =
    j.asOpt[JsNumber].map { MarkConfigRadius2AsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigRadius2): JsValue =
    j match {
      case MarkConfigRadius2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfTransform (ArrayType)
object ArrayOfTransformCodec {
  def decode(j: JsValue): Seq[Transform] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[Transform]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      TransformCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[Transform]): JsArray =
      JsArray(j.map { x => TransformCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// StringValueDefWithConditionCondition (UnionType)
object StringValueDefWithConditionConditionCodec {
  def decode(j: JsValue): StringValueDefWithConditionCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[StringValueDefWithConditionCondition] =
    ConditionalMarkPropFieldOrDatumDefCodec.decodeOpt(j).orElse {
    ConditionalValueDefStringNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefStringNullExprRefCodec.decodeOpt(j).map { StringValueDefWithConditionConditionAsArrayOfConditionalValueDefStringNullExprRef(_) } } } 
  def encode(j: StringValueDefWithConditionCondition): JsValue =
    j match {
      case x:ConditionalMarkPropFieldOrDatumDef /* TypeRef */ => ConditionalMarkPropFieldOrDatumDefCodec.encode(x)
      case x:ConditionalValueDefStringNullExprRef /* TypeRef */ => ConditionalValueDefStringNullExprRefCodec.encode(x)
      case StringValueDefWithConditionConditionAsArrayOfConditionalValueDefStringNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefStringNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ErrorBand (ConstantType)
object ErrorBandCodec {
  def decode(j: JsValue): ErrorBand =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ErrorBand] =
    j match {
      case JsString("errorband") => Some(ErrorBand())
      case _ => None
    }
  def encode(j: ErrorBand): JsValue =
    JsString("errorband")
}


////////////////////////////////////////////////////////////////////////
// AxisConfigTickBand (UnionType)
object AxisConfigTickBandCodec {
  def decode(j: JsValue): AxisConfigTickBand =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTickBand] =
    AxisConfigTickBandAsStringCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigTickBand): JsValue =
    j match {
      case x:AxisConfigTickBandAsString /* TypeRef */ => AxisConfigTickBandAsStringCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// JoinAggregateFieldDef (StructType)
object JoinAggregateFieldDefCodec {
  def decode(j: JsValue): JoinAggregateFieldDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[JoinAggregateFieldDef] =
    {
      val `as` = (j \ "as").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`as`.isEmpty) { return None }
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `op` = (j \ "op").asOpt[JsValue].flatMap { x => AggregateOpCodec.decodeOpt(x) }
      if(`op`.isEmpty) { return None }
      return Some(JoinAggregateFieldDef(
        `as` = `as`.get,
        `field` = `field`,
        `op` = `op`.get,
      ))
    }

  def encode(j: JoinAggregateFieldDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("as" -> Json.toJson(j.`as`)),
        j.`field`.map { x => "field" -> Json.toJson(x) },
        Some("op" -> AggregateOpCodec.encode(j.`op`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ErrorBandDefBand (UnionType)
object ErrorBandDefBandCodec {
  def decode(j: JsValue): ErrorBandDefBand =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ErrorBandDefBand] =
    j.asOpt[Boolean].map { ErrorBandDefBandAsBool(_) }.orElse {
    MarkConfigCodec.decodeOpt(j) } 
  def encode(j: ErrorBandDefBand): JsValue =
    j match {
      case ErrorBandDefBandAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:MarkConfig /* TypeRef */ => MarkConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PaddingAsObject2 (StructType)
object PaddingAsObject2Codec {
  def decode(j: JsValue): PaddingAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[PaddingAsObject2] =
    Some(PaddingAsObject2(
      `bottom` = (j \ "bottom").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `left` = (j \ "left").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `right` = (j \ "right").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `top` = (j \ "top").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
    ))

  def encode(j: PaddingAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`bottom`.map { x => "bottom" -> Json.toJson(x) },
        j.`left`.map { x => "left" -> Json.toJson(x) },
        j.`right`.map { x => "right" -> Json.toJson(x) },
        j.`top`.map { x => "top" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AxisTitleAngle (UnionType)
object AxisTitleAngleCodec {
  def decode(j: JsValue): AxisTitleAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTitleAngle] =
    j.asOpt[JsNumber].map { AxisTitleAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisTitleAngle): JsValue =
    j match {
      case AxisTitleAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigLabelBaseline (UnionType)
object AxisConfigLabelBaselineCodec {
  def decode(j: JsValue): AxisConfigLabelBaseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigLabelBaseline] =
    TextBaselineCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisLabelBaselineCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigLabelBaseline): JsValue =
    j match {
      case x:TextBaseline /* TypeRef */ => TextBaselineCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisLabelBaseline /* TypeRef */ => ConditionalAxisLabelBaselineCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ParameterExtentAsObject2 (StructType)
object ParameterExtentAsObject2Codec {
  def decode(j: JsValue): ParameterExtentAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ParameterExtentAsObject2] =
    {
      val `encoding` = (j \ "encoding").asOpt[JsValue].flatMap { x => SingleDefUnitChannelCodec.decodeOpt(x) }
      val `param` = (j \ "param").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`param`.isEmpty) { return None }
      return Some(ParameterExtentAsObject2(
        `encoding` = `encoding`,
        `param` = `param`.get,
      ))
    }

  def encode(j: ParameterExtentAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`encoding`.map { x => "encoding" -> SingleDefUnitChannelCodec.encode(x) },
        Some("param" -> Json.toJson(j.`param`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// RangeConfigOptional (UnionType)
object RangeConfigOptionalCodec {
  def decode(j: JsValue): RangeConfigOptional =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RangeConfigOptional] =
    RangeSchemeCodec.decodeOpt(j).orElse {
    ArrayOfAnyCodec.decodeOpt(j).map { RangeConfigOptionalAsArrayOfAny(_) } } 
  def encode(j: RangeConfigOptional): JsValue =
    j match {
      case x:RangeScheme /* TypeRef */ => RangeSchemeCodec.encode(x)
      case RangeConfigOptionalAsArrayOfAny(x) /* Base, ArrayType */ => ArrayOfAnyCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// GraticuleGeneratorGraticule (UnionType)
object GraticuleGeneratorGraticuleCodec {
  def decode(j: JsValue): GraticuleGeneratorGraticule =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[GraticuleGeneratorGraticule] =
    TrueCodec.decodeOpt(j).orElse {
    GraticuleParamsCodec.decodeOpt(j) } 
  def encode(j: GraticuleGeneratorGraticule): JsValue =
    j match {
      case x:True /* TypeRef */ => TrueCodec.encode(x)
      case x:GraticuleParams /* TypeRef */ => GraticuleParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefFontSizeAsNumber (ConstrainedType)
object OverlayMarkDefFontSizeAsNumberCodec {
  def decode(j: JsValue): OverlayMarkDefFontSizeAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[OverlayMarkDefFontSizeAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { OverlayMarkDefFontSizeAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: OverlayMarkDefFontSizeAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingTextBandPosition (ConstrainedType)
object SharedEncodingTextBandPositionCodec {
  def decode(j: JsValue): SharedEncodingTextBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingTextBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingTextBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingTextBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkDefX (UnionType)
object MarkDefXCodec {
  def decode(j: JsValue): MarkDefX =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefX] =
    j.asOpt[JsNumber].map { MarkDefXAsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: MarkDefX): JsValue =
    j match {
      case MarkDefXAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// DateTimeQuarter (ConstrainedType)
object DateTimeQuarterCodec {
  def decode(j: JsValue): DateTimeQuarter =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[DateTimeQuarter] =
    try {
      j.asOpt[JsNumber]
        .map { DateTimeQuarter(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: DateTimeQuarter): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// RectConfigFont (UnionType)
object RectConfigFontCodec {
  def decode(j: JsValue): RectConfigFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigFont] =
    j.asOpt[String].map { RectConfigFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigFont): JsValue =
    j match {
      case RectConfigFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LatLongFieldDefTimeUnit (UnionType)
object LatLongFieldDefTimeUnitCodec {
  def decode(j: JsValue): LatLongFieldDefTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LatLongFieldDefTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: LatLongFieldDefTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldValidPredicate (StructType)
object FieldValidPredicateCodec {
  def decode(j: JsValue): FieldValidPredicate =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldValidPredicate] =
    {
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`field`.isEmpty) { return None }
      val `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => FieldValidPredicateTimeUnitCodec.decodeOpt(x) }
      val `valid` = (j \ "valid").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      if(`valid`.isEmpty) { return None }
      return Some(FieldValidPredicate(
        `field` = `field`.get,
        `timeUnit` = `timeUnit`,
        `valid` = `valid`.get,
      ))
    }

  def encode(j: FieldValidPredicate): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("field" -> Json.toJson(j.`field`)),
        j.`timeUnit`.map { x => "timeUnit" -> FieldValidPredicateTimeUnitCodec.encode(x) },
        Some("valid" -> Json.toJson(j.`valid`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// PositionFieldDefBandPosition (ConstrainedType)
object PositionFieldDefBandPositionCodec {
  def decode(j: JsValue): PositionFieldDefBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[PositionFieldDefBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { PositionFieldDefBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: PositionFieldDefBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AreaConfigOuterRadius (UnionType)
object AreaConfigOuterRadiusCodec {
  def decode(j: JsValue): AreaConfigOuterRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigOuterRadius] =
    j.asOpt[JsNumber].map { AreaConfigOuterRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigOuterRadius): JsValue =
    j match {
      case AreaConfigOuterRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigCornerRadiusBottomRight (UnionType)
object TickConfigCornerRadiusBottomRightCodec {
  def decode(j: JsValue): TickConfigCornerRadiusBottomRight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigCornerRadiusBottomRight] =
    j.asOpt[JsNumber].map { TickConfigCornerRadiusBottomRightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigCornerRadiusBottomRight): JsValue =
    j match {
      case TickConfigCornerRadiusBottomRightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// StyleConfigIndexOptional (UnionType)
object StyleConfigIndexOptionalCodec {
  def decode(j: JsValue): StyleConfigIndexOptional =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[StyleConfigIndexOptional] =
    AnyMarkConfigCodec.decodeOpt(j).orElse {
    AxisCodec.decodeOpt(j) } 
  def encode(j: StyleConfigIndexOptional): JsValue =
    j match {
      case x:AnyMarkConfig /* TypeRef */ => AnyMarkConfigCodec.encode(x)
      case x:Axis /* TypeRef */ => AxisCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigCornerRadius (UnionType)
object TickConfigCornerRadiusCodec {
  def decode(j: JsValue): TickConfigCornerRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigCornerRadius] =
    j.asOpt[JsNumber].map { TickConfigCornerRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigCornerRadius): JsValue =
    j match {
      case TickConfigCornerRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefOpacity (ConstrainedType)
// see MarkDefOpacity (UnionType)

////////////////////////////////////////////////////////////////////////
// BarConfigDiscreteBandSize (UnionType)
object BarConfigDiscreteBandSizeCodec {
  def decode(j: JsValue): BarConfigDiscreteBandSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigDiscreteBandSize] =
    j.asOpt[JsNumber].map { BarConfigDiscreteBandSizeAsNumber(_) }.orElse {
    RelativeBandSizeCodec.decodeOpt(j) } 
  def encode(j: BarConfigDiscreteBandSize): JsValue =
    j match {
      case BarConfigDiscreteBandSizeAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:RelativeBandSize /* TypeRef */ => RelativeBandSizeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleInterpolate (UnionType)
object ScaleInterpolateCodec {
  def decode(j: JsValue): ScaleInterpolate =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleInterpolate] =
    ScaleInterpolateEnumCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ScaleInterpolateParamsCodec.decodeOpt(j) } } 
  def encode(j: ScaleInterpolate): JsValue =
    j match {
      case x:ScaleInterpolateEnum /* TypeRef */ => ScaleInterpolateEnumCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ScaleInterpolateParams /* TypeRef */ => ScaleInterpolateParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigOuterRadius (UnionType)
object RectConfigOuterRadiusCodec {
  def decode(j: JsValue): RectConfigOuterRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigOuterRadius] =
    j.asOpt[JsNumber].map { RectConfigOuterRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigOuterRadius): JsValue =
    j match {
      case RectConfigOuterRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SphereGeneratorSphere (UnionType)
object SphereGeneratorSphereCodec {
  def decode(j: JsValue): SphereGeneratorSphere =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SphereGeneratorSphere] =
    TrueCodec.decodeOpt(j).orElse {
    j.asOpt[JsObject].map { _ => Json.obj() }.map { _ => SphereGeneratorSphereAsEmptyObject } } 
  def encode(j: SphereGeneratorSphere): JsValue =
    j match {
      case x:True /* TypeRef */ => TrueCodec.encode(x)
      case SphereGeneratorSphereAsEmptyObject /* Global, EmptyObject$ */ => Json.obj()
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigStrokeOpacity (UnionType)
object MarkConfigStrokeOpacityCodec {
  def decode(j: JsValue): MarkConfigStrokeOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigStrokeOpacity] =
    MarkConfigStrokeOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigStrokeOpacity): JsValue =
    j match {
      case x:MarkConfigStrokeOpacityAsNumber /* TypeRef */ => MarkConfigStrokeOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigHref (UnionType)
object RectConfigHrefCodec {
  def decode(j: JsValue): RectConfigHref =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigHref] =
    UriReferenceCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigHref): JsValue =
    j match {
      case x:UriReference /* TypeRef */ => UriReferenceCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldLTPredicate (StructType)
object FieldLTPredicateCodec {
  def decode(j: JsValue): FieldLTPredicate =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldLTPredicate] =
    {
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`field`.isEmpty) { return None }
      val `lt` = (j \ "lt").asOpt[JsValue].flatMap { x => FieldLTPredicateLtCodec.decodeOpt(x) }
      if(`lt`.isEmpty) { return None }
      val `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => FieldLTPredicateTimeUnitCodec.decodeOpt(x) }
      return Some(FieldLTPredicate(
        `field` = `field`.get,
        `lt` = `lt`.get,
        `timeUnit` = `timeUnit`,
      ))
    }

  def encode(j: FieldLTPredicate): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("field" -> Json.toJson(j.`field`)),
        Some("lt" -> FieldLTPredicateLtCodec.encode(j.`lt`)),
        j.`timeUnit`.map { x => "timeUnit" -> FieldLTPredicateTimeUnitCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LegendConfigSymbolFillColor (UnionType)
object LegendConfigSymbolFillColorCodec {
  def decode(j: JsValue): LegendConfigSymbolFillColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigSymbolFillColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => LegendConfigSymbolFillColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: LegendConfigSymbolFillColor): JsValue =
    j match {
      case LegendConfigSymbolFillColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingLongitude2TimeUnit (UnionType)
object SharedEncodingLongitude2TimeUnitCodec {
  def decode(j: JsValue): SharedEncodingLongitude2TimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingLongitude2TimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingLongitude2TimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewConfigStrokeWidth (UnionType)
object ViewConfigStrokeWidthCodec {
  def decode(j: JsValue): ViewConfigStrokeWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewConfigStrokeWidth] =
    ViewConfigStrokeWidthAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ViewConfigStrokeWidth): JsValue =
    j match {
      case x:ViewConfigStrokeWidthAsNumber /* TypeRef */ => ViewConfigStrokeWidthAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleConfigAria (UnionType)
object TitleConfigAriaCodec {
  def decode(j: JsValue): TitleConfigAria =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigAria] =
    j.asOpt[Boolean].map { TitleConfigAriaAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleConfigAria): JsValue =
    j match {
      case TitleConfigAriaAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfTopLevelUnitSpecParamsElement (ArrayType)
object ArrayOfTopLevelUnitSpecParamsElementCodec {
  def decode(j: JsValue): Seq[TopLevelUnitSpecParamsElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[TopLevelUnitSpecParamsElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      TopLevelUnitSpecParamsElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[TopLevelUnitSpecParamsElement]): JsArray =
      JsArray(j.map { x => TopLevelUnitSpecParamsElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeDatum (UnionType)
object SharedEncodingStrokeDatumCodec {
  def decode(j: JsValue): SharedEncodingStrokeDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingStrokeDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject2Center (UnionType)
object TopLevelRepeatSpecAsObject2CenterCodec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject2Center =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject2Center] =
    j.asOpt[Boolean].map { TopLevelRepeatSpecAsObject2CenterAsBool(_) }.orElse {
    RowColBooleanCodec.decodeOpt(j) } 
  def encode(j: TopLevelRepeatSpecAsObject2Center): JsValue =
    j match {
      case TopLevelRepeatSpecAsObject2CenterAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:RowColBoolean /* TypeRef */ => RowColBooleanCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfigParallels (UnionType)
object ProjectionConfigParallelsCodec {
  def decode(j: JsValue): ProjectionConfigParallels =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigParallels] =
    ArrayOfNumberCodec.decodeOpt(j).map { ProjectionConfigParallelsAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigParallels): JsValue =
    j match {
      case ProjectionConfigParallelsAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RangeConfigCategory (UnionType)
object RangeConfigCategoryCodec {
  def decode(j: JsValue): RangeConfigCategory =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RangeConfigCategory] =
    RangeSchemeCodec.decodeOpt(j).orElse {
    ArrayOfColorCodec.decodeOpt(j).map { RangeConfigCategoryAsArrayOfColor(_) } } 
  def encode(j: RangeConfigCategory): JsValue =
    j match {
      case x:RangeScheme /* TypeRef */ => RangeSchemeCodec.encode(x)
      case RangeConfigCategoryAsArrayOfColor(x) /* Base, ArrayType */ => ArrayOfColorCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefDiscreteBandSize (UnionType)
object MarkDefDiscreteBandSizeCodec {
  def decode(j: JsValue): MarkDefDiscreteBandSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefDiscreteBandSize] =
    j.asOpt[JsNumber].map { MarkDefDiscreteBandSizeAsNumber(_) }.orElse {
    RelativeBandSizeCodec.decodeOpt(j) } 
  def encode(j: MarkDefDiscreteBandSize): JsValue =
    j match {
      case MarkDefDiscreteBandSizeAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:RelativeBandSize /* TypeRef */ => RelativeBandSizeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefTextExprRefValue (UnionType)
object ConditionalPredicateValueDefTextExprRefValueCodec {
  def decode(j: JsValue): ConditionalPredicateValueDefTextExprRefValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefTextExprRefValue] =
    TextCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ConditionalPredicateValueDefTextExprRefValue): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetSpecTitle (UnionType)
object FacetSpecTitleCodec {
  def decode(j: JsValue): FacetSpecTitle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetSpecTitle] =
    TextCodec.decodeOpt(j).orElse {
    TitleParamsCodec.decodeOpt(j) } 
  def encode(j: FacetSpecTitle): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:TitleParams /* TypeRef */ => TitleParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingThetaDatum (UnionType)
object SharedEncodingThetaDatumCodec {
  def decode(j: JsValue): SharedEncodingThetaDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingThetaDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingThetaDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RowColumnEncodingFieldDefTimeUnit (UnionType)
object RowColumnEncodingFieldDefTimeUnitCodec {
  def decode(j: JsValue): RowColumnEncodingFieldDefTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RowColumnEncodingFieldDefTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: RowColumnEncodingFieldDefTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RangeScheme (UnionType)
object RangeSchemeCodec {
  def decode(j: JsValue): RangeScheme =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RangeScheme] =
    RangeEnumCodec.decodeOpt(j).orElse {
    ArrayOfRangeRawElementCodec.decodeOpt(j).map { RangeSchemeAsArrayOfRangeRawElement(_) }.orElse {
    RangeSchemeAsObject3Codec.decodeOpt(j) } } 
  def encode(j: RangeScheme): JsValue =
    j match {
      case x:RangeEnum /* TypeRef */ => RangeEnumCodec.encode(x)
      case RangeSchemeAsArrayOfRangeRawElement(x) /* Base, ArrayType */ => ArrayOfRangeRawElementCodec.encode(x)
      case x:RangeSchemeAsObject3 /* TypeRef */ => RangeSchemeAsObject3Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateMarkPropFieldOrDatumDefTypeForShape (UnionType)
object ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeCodec {
  def decode(j: JsValue): ConditionalPredicateMarkPropFieldOrDatumDefTypeForShape =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateMarkPropFieldOrDatumDefTypeForShape] =
    ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1Codec.decodeOpt(j).orElse {
    ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2Codec.decodeOpt(j) } 
  def encode(j: ConditionalPredicateMarkPropFieldOrDatumDefTypeForShape): JsValue =
    j match {
      case x:ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1 /* TypeRef */ => ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1Codec.encode(x)
      case x:ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2 /* TypeRef */ => ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PositionFieldDefBaseBandPosition (ConstrainedType)
object PositionFieldDefBaseBandPositionCodec {
  def decode(j: JsValue): PositionFieldDefBaseBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[PositionFieldDefBaseBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { PositionFieldDefBaseBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: PositionFieldDefBaseBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AxisLabelLineHeight (UnionType)
object AxisLabelLineHeightCodec {
  def decode(j: JsValue): AxisLabelLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisLabelLineHeight] =
    j.asOpt[JsNumber].map { AxisLabelLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisLabelLineHeight): JsValue =
    j match {
      case AxisLabelLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RowColLayoutAlign (StructType)
object RowColLayoutAlignCodec {
  def decode(j: JsValue): RowColLayoutAlign =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RowColLayoutAlign] =
    Some(RowColLayoutAlign(
      `column` = (j \ "column").asOpt[JsValue].flatMap { x => LayoutAlignCodec.decodeOpt(x) },
      `row` = (j \ "row").asOpt[JsValue].flatMap { x => LayoutAlignCodec.decodeOpt(x) },
    ))

  def encode(j: RowColLayoutAlign): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`column`.map { x => "column" -> LayoutAlignCodec.encode(x) },
        j.`row`.map { x => "row" -> LayoutAlignCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TickConfigAngleAsNumber (ConstrainedType)
object TickConfigAngleAsNumberCodec {
  def decode(j: JsValue): TickConfigAngleAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TickConfigAngleAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { TickConfigAngleAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: TickConfigAngleAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ImputeSequence (StructType)
object ImputeSequenceCodec {
  def decode(j: JsValue): ImputeSequence =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ImputeSequence] =
    {
      val `start` = (j \ "start").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `step` = (j \ "step").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `stop` = (j \ "stop").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      if(`stop`.isEmpty) { return None }
      return Some(ImputeSequence(
        `start` = `start`,
        `step` = `step`,
        `stop` = `stop`.get,
      ))
    }

  def encode(j: ImputeSequence): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`start`.map { x => "start" -> Json.toJson(x) },
        j.`step`.map { x => "step" -> Json.toJson(x) },
        Some("stop" -> Json.toJson(j.`stop`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TickConfigAriaRoleDescription (UnionType)
object TickConfigAriaRoleDescriptionCodec {
  def decode(j: JsValue): TickConfigAriaRoleDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigAriaRoleDescription] =
    j.asOpt[String].map { TickConfigAriaRoleDescriptionAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigAriaRoleDescription): JsValue =
    j match {
      case TickConfigAriaRoleDescriptionAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// StackTransformAs (UnionType)
object StackTransformAsCodec {
  def decode(j: JsValue): StackTransformAs =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[StackTransformAs] =
    j.asOpt[String].map { StackTransformAsAsString(_) }.orElse {
    StackTransformAsAsArrayCodec.decodeOpt(j) } 
  def encode(j: StackTransformAs): JsValue =
    j match {
      case StackTransformAsAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:StackTransformAsAsArray /* TypeRef */ => StackTransformAsAsArrayCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Gradient (UnionType)
object GradientCodec {
  def decode(j: JsValue): Gradient =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Gradient] =
    LinearGradientCodec.decodeOpt(j).orElse {
    RadialGradientCodec.decodeOpt(j) } 
  def encode(j: Gradient): JsValue =
    j match {
      case x:LinearGradient /* TypeRef */ => LinearGradientCodec.encode(x)
      case x:RadialGradient /* TypeRef */ => RadialGradientCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingFillOpacityTimeUnit (UnionType)
object SharedEncodingFillOpacityTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingFillOpacityTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingFillOpacityTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingFillOpacityTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeOpacityValue (UnionType)
object SharedEncodingStrokeOpacityValueCodec {
  def decode(j: JsValue): SharedEncodingStrokeOpacityValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeOpacityValue] =
    j.asOpt[JsNumber].map { SharedEncodingStrokeOpacityValueAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingStrokeOpacityValue): JsValue =
    j match {
      case SharedEncodingStrokeOpacityValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigStrokeOpacity (UnionType)
object AreaConfigStrokeOpacityCodec {
  def decode(j: JsValue): AreaConfigStrokeOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigStrokeOpacity] =
    AreaConfigStrokeOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigStrokeOpacity): JsValue =
    j match {
      case x:AreaConfigStrokeOpacityAsNumber /* TypeRef */ => AreaConfigStrokeOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefCornerRadius (UnionType)
object MarkDefCornerRadiusCodec {
  def decode(j: JsValue): MarkDefCornerRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefCornerRadius] =
    j.asOpt[JsNumber].map { MarkDefCornerRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefCornerRadius): JsValue =
    j match {
      case MarkDefCornerRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigRadius2 (ConstrainedType)
// see RectConfigRadius2 (UnionType)

////////////////////////////////////////////////////////////////////////
// AreaConfigFontWeight (UnionType)
object AreaConfigFontWeightCodec {
  def decode(j: JsValue): AreaConfigFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetedUnitSpecHeight (UnionType)
object FacetedUnitSpecHeightCodec {
  def decode(j: JsValue): FacetedUnitSpecHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetedUnitSpecHeight] =
    j.asOpt[JsNumber].map { FacetedUnitSpecHeightAsNumber(_) }.orElse {
    ContainerCodec.decodeOpt(j).orElse {
    StepCodec.decodeOpt(j) } } 
  def encode(j: FacetedUnitSpecHeight): JsValue =
    j match {
      case FacetedUnitSpecHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Container /* TypeRef */ => ContainerCodec.encode(x)
      case x:Step /* TypeRef */ => StepCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OrderFieldDefTimeUnit (UnionType)
object OrderFieldDefTimeUnitCodec {
  def decode(j: JsValue): OrderFieldDefTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OrderFieldDefTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: OrderFieldDefTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigY (UnionType)
object LineConfigYCodec {
  def decode(j: JsValue): LineConfigY =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigY] =
    j.asOpt[JsNumber].map { LineConfigYAsNumber(_) }.orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: LineConfigY): JsValue =
    j match {
      case LineConfigYAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelLayerSpecParamsElement (UnionType)
object TopLevelLayerSpecParamsElementCodec {
  def decode(j: JsValue): TopLevelLayerSpecParamsElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelLayerSpecParamsElement] =
    VariableParameterCodec.decodeOpt(j).orElse {
    TopLevelSelectionParameterCodec.decodeOpt(j) } 
  def encode(j: TopLevelLayerSpecParamsElement): JsValue =
    j match {
      case x:VariableParameter /* TypeRef */ => VariableParameterCodec.encode(x)
      case x:TopLevelSelectionParameter /* TypeRef */ => TopLevelSelectionParameterCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefPoint (UnionType)
object MarkDefPointCodec {
  def decode(j: JsValue): MarkDefPoint =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefPoint] =
    j.asOpt[Boolean].map { MarkDefPointAsBool(_) }.orElse {
    OverlayMarkDefCodec.decodeOpt(j).orElse {
    TransparentCodec.decodeOpt(j) } } 
  def encode(j: MarkDefPoint): JsValue =
    j match {
      case MarkDefPointAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:OverlayMarkDef /* TypeRef */ => OverlayMarkDefCodec.encode(x)
      case x:Transparent /* TypeRef */ => TransparentCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigStrokeDash (UnionType)
object LegendConfigStrokeDashCodec {
  def decode(j: JsValue): LegendConfigStrokeDash =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigStrokeDash] =
    ArrayOfNumberCodec.decodeOpt(j).map { LegendConfigStrokeDashAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigStrokeDash): JsValue =
    j match {
      case LegendConfigStrokeDashAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefBlend (UnionType)
object MarkDefBlendCodec {
  def decode(j: JsValue): MarkDefBlend =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefBlend] =
    BlendCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefBlend): JsValue =
    j match {
      case x:Blend /* TypeRef */ => BlendCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigBaseline (UnionType)
object MarkConfigBaselineCodec {
  def decode(j: JsValue): MarkConfigBaseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigBaseline] =
    TextBaselineCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigBaseline): JsValue =
    j match {
      case x:TextBaseline /* TypeRef */ => TextBaselineCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// EventType (EnumType)
object EventTypeCodec {
  def decode(j: JsValue): EventType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[EventType] =
    j match {
      case JsString("click") => Some(EventTypeClick)
      case JsString("dblclick") => Some(EventTypeDblclick)
      case JsString("dragenter") => Some(EventTypeDragenter)
      case JsString("dragleave") => Some(EventTypeDragleave)
      case JsString("dragover") => Some(EventTypeDragover)
      case JsString("keydown") => Some(EventTypeKeydown)
      case JsString("keypress") => Some(EventTypeKeypress)
      case JsString("keyup") => Some(EventTypeKeyup)
      case JsString("mousedown") => Some(EventTypeMousedown)
      case JsString("mousemove") => Some(EventTypeMousemove)
      case JsString("mouseout") => Some(EventTypeMouseout)
      case JsString("mouseover") => Some(EventTypeMouseover)
      case JsString("mouseup") => Some(EventTypeMouseup)
      case JsString("mousewheel") => Some(EventTypeMousewheel)
      case JsString("timer") => Some(EventTypeTimer)
      case JsString("touchend") => Some(EventTypeTouchend)
      case JsString("touchmove") => Some(EventTypeTouchmove)
      case JsString("touchstart") => Some(EventTypeTouchstart)
      case JsString("wheel") => Some(EventTypeWheel)
      case _ => None
    }
  def encode(j: EventType): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// ArrayOfConditionalValueDefStringNullExprRef (ArrayType)
object ArrayOfConditionalValueDefStringNullExprRefCodec {
  def decode(j: JsValue): Seq[ConditionalValueDefStringNullExprRef] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[ConditionalValueDefStringNullExprRef]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      ConditionalValueDefStringNullExprRefCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[ConditionalValueDefStringNullExprRef]): JsArray =
      JsArray(j.map { x => ConditionalValueDefStringNullExprRefCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// LineConfigUrl (UnionType)
object LineConfigUrlCodec {
  def decode(j: JsValue): LineConfigUrl =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigUrl] =
    UriReferenceCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigUrl): JsValue =
    j match {
      case x:UriReference /* TypeRef */ => UriReferenceCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelVConcatSpec (StructType)
object TopLevelVConcatSpecCodec {
  def decode(j: JsValue): TopLevelVConcatSpec =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TopLevelVConcatSpec] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `description` = (j \ "description").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `data` = (j \ "data").asOpt[JsValue].flatMap { x => DataCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `params` = (j \ "params").asOpt[JsValue].flatMap { x => ArrayOfTopLevelVConcatSpecParamsElementCodec.decodeOpt(x) }
      val `vconcat` = (j \ "vconcat").asOpt[JsValue].flatMap { x => ArrayOfNonNormalizedSpecCodec.decodeOpt(x) }
      if(`vconcat`.isEmpty) { return None }
      val `config` = (j \ "config").asOpt[JsValue].flatMap { x => ConfigCodec.decodeOpt(x) }
      val `bounds` = (j \ "bounds").asOpt[JsValue].flatMap { x => TopLevelVConcatSpecBoundsCodec.decodeOpt(x) }
      val `datasets` = (j \ "datasets").asOpt[JsValue].flatMap { x => DictOfInlineDatasetCodec.decodeOpt(x) }
      val `usermeta` = (j \ "usermeta").asOpt[JsValue].flatMap { x => DictOfAnyCodec.decodeOpt(x) }
      val `resolve` = (j \ "resolve").asOpt[JsValue].flatMap { x => ResolveCodec.decodeOpt(x) }
      val `padding` = (j \ "padding").asOpt[JsValue].flatMap { x => TopLevelVConcatSpecPaddingCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => TopLevelVConcatSpecTitleCodec.decodeOpt(x) }
      val `background` = (j \ "background").asOpt[JsValue].flatMap { x => TopLevelVConcatSpecBackgroundCodec.decodeOpt(x) }
      val `center` = (j \ "center").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `spacing` = (j \ "spacing").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `$schema` = (j \ "$schema").asOpt[JsValue].flatMap { x => UriCodec.decodeOpt(x) }
      val `autosize` = (j \ "autosize").asOpt[JsValue].flatMap { x => TopLevelVConcatSpecAutosizeCodec.decodeOpt(x) }
      val `transform` = (j \ "transform").asOpt[JsValue].flatMap { x => ArrayOfTransformCodec.decodeOpt(x) }
      return Some(TopLevelVConcatSpec(
        `name` = `name`,
        `description` = `description`,
        `data` = `data`,
        `params` = `params`,
        `vconcat` = `vconcat`.get,
        `config` = `config`,
        `bounds` = `bounds`,
        `datasets` = `datasets`,
        `usermeta` = `usermeta`,
        `resolve` = `resolve`,
        `padding` = `padding`,
        `title` = `title`,
        `background` = `background`,
        `center` = `center`,
        `spacing` = `spacing`,
        `$schema` = `$schema`,
        `autosize` = `autosize`,
        `transform` = `transform`,
      ))
    }

  def encode(j: TopLevelVConcatSpec): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`description`.map { x => "description" -> Json.toJson(x) },
        j.`data`.map { x => "data" -> DataCodec.encode(x) },
        j.`params`.map { x => "params" -> ArrayOfTopLevelVConcatSpecParamsElementCodec.encode(x) },
        Some("vconcat" -> ArrayOfNonNormalizedSpecCodec.encode(j.`vconcat`)),
        j.`config`.map { x => "config" -> ConfigCodec.encode(x) },
        j.`bounds`.map { x => "bounds" -> TopLevelVConcatSpecBoundsCodec.encode(x) },
        j.`datasets`.map { x => "datasets" -> DictOfInlineDatasetCodec.encode(x) },
        j.`usermeta`.map { x => "usermeta" -> DictOfAnyCodec.encode(x) },
        j.`resolve`.map { x => "resolve" -> ResolveCodec.encode(x) },
        j.`padding`.map { x => "padding" -> TopLevelVConcatSpecPaddingCodec.encode(x) },
        j.`title`.map { x => "title" -> TopLevelVConcatSpecTitleCodec.encode(x) },
        j.`background`.map { x => "background" -> TopLevelVConcatSpecBackgroundCodec.encode(x) },
        j.`center`.map { x => "center" -> Json.toJson(x) },
        j.`spacing`.map { x => "spacing" -> Json.toJson(x) },
        j.`$schema`.map { x => "$schema" -> UriCodec.encode(x) },
        j.`autosize`.map { x => "autosize" -> TopLevelVConcatSpecAutosizeCodec.encode(x) },
        j.`transform`.map { x => "transform" -> ArrayOfTransformCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// BarConfigDiscreteBandSize (ConstrainedType)
// see BarConfigDiscreteBandSize (UnionType)

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefText (UnionType)
object OverlayMarkDefTextCodec {
  def decode(j: JsValue): OverlayMarkDefText =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefText] =
    TextCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefText): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderConfigLabelFontWeight (UnionType)
object HeaderConfigLabelFontWeightCodec {
  def decode(j: JsValue): HeaderConfigLabelFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigLabelFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderConfigLabelFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigLabelAlign (UnionType)
object AxisConfigLabelAlignCodec {
  def decode(j: JsValue): AxisConfigLabelAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigLabelAlign] =
    AlignCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisLabelAlignCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigLabelAlign): JsValue =
    j match {
      case x:Align /* TypeRef */ => AlignCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisLabelAlign /* TypeRef */ => ConditionalAxisLabelAlignCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingSizeTimeUnit (UnionType)
object SharedEncodingSizeTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingSizeTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingSizeTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingSizeTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefTooltip (UnionType)
object MarkDefTooltipCodec {
  def decode(j: JsValue): MarkDefTooltip =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefTooltip] =
    j.asOpt[String].map { MarkDefTooltipAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => MarkDefTooltipAsNull }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    TooltipContentCodec.decodeOpt(j).orElse {
    j.asOpt[Boolean].map { MarkDefTooltipAsBool(_) }.orElse {
    j.asOpt[JsNumber].map { MarkDefTooltipAsNumber(_) } } } } } } 
  def encode(j: MarkDefTooltip): JsValue =
    j match {
      case MarkDefTooltipAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case MarkDefTooltipAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:TooltipContent /* TypeRef */ => TooltipContentCodec.encode(x)
      case MarkDefTooltipAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case MarkDefTooltipAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefStrokeDash (UnionType)
object MarkDefStrokeDashCodec {
  def decode(j: JsValue): MarkDefStrokeDash =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefStrokeDash] =
    ArrayOfNumberCodec.decodeOpt(j).map { MarkDefStrokeDashAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefStrokeDash): JsValue =
    j match {
      case MarkDefStrokeDashAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingXOffsetBin (UnionType)
object SharedEncodingXOffsetBinCodec {
  def decode(j: JsValue): SharedEncodingXOffsetBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingXOffsetBin] =
    j.asOpt[Boolean].map { SharedEncodingXOffsetBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingXOffsetBinAsNull } } } 
  def encode(j: SharedEncodingXOffsetBin): JsValue =
    j match {
      case SharedEncodingXOffsetBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case SharedEncodingXOffsetBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// ViewBackgroundStrokeOpacityAsNumber (ConstrainedType)
object ViewBackgroundStrokeOpacityAsNumberCodec {
  def decode(j: JsValue): ViewBackgroundStrokeOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ViewBackgroundStrokeOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { ViewBackgroundStrokeOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ViewBackgroundStrokeOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// StringFieldDefWithConditionTimeUnit (UnionType)
object StringFieldDefWithConditionTimeUnitCodec {
  def decode(j: JsValue): StringFieldDefWithConditionTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[StringFieldDefWithConditionTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: StringFieldDefWithConditionTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigMaxStrokeWidth (ConstrainedType)
object ScaleConfigMaxStrokeWidthCodec {
  def decode(j: JsValue): ScaleConfigMaxStrokeWidth =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ScaleConfigMaxStrokeWidth] =
    try {
      j.asOpt[JsNumber]
        .map { ScaleConfigMaxStrokeWidth(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ScaleConfigMaxStrokeWidth): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTitleColor (UnionType)
object AxisConfigTitleColorCodec {
  def decode(j: JsValue): AxisConfigTitleColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTitleColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => AxisConfigTitleColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigTitleColor): JsValue =
    j match {
      case AxisConfigTitleColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigX2 (UnionType)
object TickConfigX2Codec {
  def decode(j: JsValue): TickConfigX2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigX2] =
    j.asOpt[JsNumber].map { TickConfigX2AsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: TickConfigX2): JsValue =
    j match {
      case TickConfigX2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefCornerRadiusTopLeft (UnionType)
object OverlayMarkDefCornerRadiusTopLeftCodec {
  def decode(j: JsValue): OverlayMarkDefCornerRadiusTopLeft =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefCornerRadiusTopLeft] =
    j.asOpt[JsNumber].map { OverlayMarkDefCornerRadiusTopLeftAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefCornerRadiusTopLeft): JsValue =
    j match {
      case OverlayMarkDefCornerRadiusTopLeftAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingYTimeUnit (UnionType)
object SharedEncodingYTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingYTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingYTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingYTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SortByChannelDesc (EnumType)
object SortByChannelDescCodec {
  def decode(j: JsValue): SortByChannelDesc =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SortByChannelDesc] =
    j match {
      case JsString("-x") => Some(SortByChannelDescX)
      case JsString("-y") => Some(SortByChannelDescY)
      case JsString("-color") => Some(SortByChannelDescColor)
      case JsString("-fill") => Some(SortByChannelDescFill)
      case JsString("-stroke") => Some(SortByChannelDescStroke)
      case JsString("-strokeWidth") => Some(SortByChannelDescStrokeWidth)
      case JsString("-size") => Some(SortByChannelDescSize)
      case JsString("-shape") => Some(SortByChannelDescShape)
      case JsString("-fillOpacity") => Some(SortByChannelDescFillOpacity)
      case JsString("-strokeOpacity") => Some(SortByChannelDescStrokeOpacity)
      case JsString("-opacity") => Some(SortByChannelDescOpacity)
      case JsString("-text") => Some(SortByChannelDescText)
      case _ => None
    }
  def encode(j: SortByChannelDesc): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// TitleConfigDx (UnionType)
object TitleConfigDxCodec {
  def decode(j: JsValue): TitleConfigDx =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigDx] =
    j.asOpt[JsNumber].map { TitleConfigDxAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleConfigDx): JsValue =
    j match {
      case TitleConfigDxAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingXError (StructType)
object SharedEncodingXErrorCodec {
  def decode(j: JsValue): SharedEncodingXError =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingXError] =
    Some(SharedEncodingXError(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingXErrorBandPositionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => x.asOpt[JsNull.type].map { _ => JsNull } },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingXErrorTimeUnitCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingXError): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingXErrorBandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> Json.toJson(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`value`.map { x => "value" -> Json.toJson(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingXErrorTimeUnitCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// RectConfigTheta (ConstrainedType)
// see RectConfigTheta (UnionType)

////////////////////////////////////////////////////////////////////////
// SequenceGenerator (StructType)
object SequenceGeneratorCodec {
  def decode(j: JsValue): SequenceGenerator =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SequenceGenerator] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `sequence` = (j \ "sequence").asOpt[JsValue].flatMap { x => SequenceParamsCodec.decodeOpt(x) }
      if(`sequence`.isEmpty) { return None }
      return Some(SequenceGenerator(
        `name` = `name`,
        `sequence` = `sequence`.get,
      ))
    }

  def encode(j: SequenceGenerator): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        Some("sequence" -> SequenceParamsCodec.encode(j.`sequence`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ProjectionCoefficient (UnionType)
object ProjectionCoefficientCodec {
  def decode(j: JsValue): ProjectionCoefficient =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionCoefficient] =
    j.asOpt[JsNumber].map { ProjectionCoefficientAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionCoefficient): JsValue =
    j match {
      case ProjectionCoefficientAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigLabelAlign (UnionType)
object LegendConfigLabelAlignCodec {
  def decode(j: JsValue): LegendConfigLabelAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigLabelAlign] =
    AlignCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigLabelAlign): JsValue =
    j match {
      case x:Align /* TypeRef */ => AlignCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BoxPlotDefTicks (UnionType)
object BoxPlotDefTicksCodec {
  def decode(j: JsValue): BoxPlotDefTicks =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BoxPlotDefTicks] =
    j.asOpt[Boolean].map { BoxPlotDefTicksAsBool(_) }.orElse {
    MarkConfigCodec.decodeOpt(j) } 
  def encode(j: BoxPlotDefTicks): JsValue =
    j match {
      case BoxPlotDefTicksAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:MarkConfig /* TypeRef */ => MarkConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeOpacityTimeUnit (UnionType)
object SharedEncodingStrokeOpacityTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingStrokeOpacityTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeOpacityTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingStrokeOpacityTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigTooltip (UnionType)
object RectConfigTooltipCodec {
  def decode(j: JsValue): RectConfigTooltip =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigTooltip] =
    j.asOpt[String].map { RectConfigTooltipAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => RectConfigTooltipAsNull }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    TooltipContentCodec.decodeOpt(j).orElse {
    j.asOpt[Boolean].map { RectConfigTooltipAsBool(_) }.orElse {
    j.asOpt[JsNumber].map { RectConfigTooltipAsNumber(_) } } } } } } 
  def encode(j: RectConfigTooltip): JsValue =
    j match {
      case RectConfigTooltipAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case RectConfigTooltipAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:TooltipContent /* TypeRef */ => TooltipContentCodec.encode(x)
      case RectConfigTooltipAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case RectConfigTooltipAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeTimeUnit (UnionType)
object SharedEncodingStrokeTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingStrokeTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingStrokeTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigHeight (UnionType)
object BarConfigHeightCodec {
  def decode(j: JsValue): BarConfigHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigHeight] =
    j.asOpt[JsNumber].map { BarConfigHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigHeight): JsValue =
    j match {
      case BarConfigHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigStrokeWidth (UnionType)
object MarkConfigStrokeWidthCodec {
  def decode(j: JsValue): MarkConfigStrokeWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigStrokeWidth] =
    MarkConfigStrokeWidthAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigStrokeWidth): JsValue =
    j match {
      case x:MarkConfigStrokeWidthAsNumber /* TypeRef */ => MarkConfigStrokeWidthAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTickSize (UnionType)
object AxisConfigTickSizeCodec {
  def decode(j: JsValue): AxisConfigTickSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTickSize] =
    AxisConfigTickSizeAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigTickSize): JsValue =
    j match {
      case x:AxisConfigTickSizeAsNumber /* TypeRef */ => AxisConfigTickSizeAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigStrokeDashOffset (UnionType)
object TickConfigStrokeDashOffsetCodec {
  def decode(j: JsValue): TickConfigStrokeDashOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigStrokeDashOffset] =
    j.asOpt[JsNumber].map { TickConfigStrokeDashOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigStrokeDashOffset): JsValue =
    j match {
      case TickConfigStrokeDashOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigOuterRadius (ConstrainedType)
// see RectConfigOuterRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// TopLevelVConcatSpecParamsElement (UnionType)
object TopLevelVConcatSpecParamsElementCodec {
  def decode(j: JsValue): TopLevelVConcatSpecParamsElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelVConcatSpecParamsElement] =
    VariableParameterCodec.decodeOpt(j).orElse {
    TopLevelSelectionParameterCodec.decodeOpt(j) } 
  def encode(j: TopLevelVConcatSpecParamsElement): JsValue =
    j match {
      case x:VariableParameter /* TypeRef */ => VariableParameterCodec.encode(x)
      case x:TopLevelSelectionParameter /* TypeRef */ => TopLevelSelectionParameterCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Projection (StructType)
object ProjectionCodec {
  def decode(j: JsValue): Projection =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Projection] =
    Some(Projection(
      `fraction` = (j \ "fraction").asOpt[JsValue].flatMap { x => ProjectionFractionCodec.decodeOpt(x) },
      `extent` = (j \ "extent").asOpt[JsValue].flatMap { x => ProjectionExtentCodec.decodeOpt(x) },
      `center` = (j \ "center").asOpt[JsValue].flatMap { x => ProjectionCenterCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ProjectionScaleCodec.decodeOpt(x) },
      `fit` = (j \ "fit").asOpt[JsValue].flatMap { x => ProjectionFitCodec.decodeOpt(x) },
      `reflectX` = (j \ "reflectX").asOpt[JsValue].flatMap { x => ProjectionReflectXCodec.decodeOpt(x) },
      `rotate` = (j \ "rotate").asOpt[JsValue].flatMap { x => ProjectionRotateCodec.decodeOpt(x) },
      `clipAngle` = (j \ "clipAngle").asOpt[JsValue].flatMap { x => ProjectionClipAngleCodec.decodeOpt(x) },
      `lobes` = (j \ "lobes").asOpt[JsValue].flatMap { x => ProjectionLobesCodec.decodeOpt(x) },
      `parallels` = (j \ "parallels").asOpt[JsValue].flatMap { x => ProjectionParallelsCodec.decodeOpt(x) },
      `translate` = (j \ "translate").asOpt[JsValue].flatMap { x => ProjectionTranslateCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => ProjectionTypeCodec.decodeOpt(x) },
      `spacing` = (j \ "spacing").asOpt[JsValue].flatMap { x => ProjectionSpacingCodec.decodeOpt(x) },
      `clipExtent` = (j \ "clipExtent").asOpt[JsValue].flatMap { x => ProjectionClipExtentCodec.decodeOpt(x) },
      `coefficient` = (j \ "coefficient").asOpt[JsValue].flatMap { x => ProjectionCoefficientCodec.decodeOpt(x) },
      `precision` = (j \ "precision").asOpt[JsValue].flatMap { x => ProjectionPrecisionCodec.decodeOpt(x) },
      `size` = (j \ "size").asOpt[JsValue].flatMap { x => ProjectionSizeCodec.decodeOpt(x) },
      `reflectY` = (j \ "reflectY").asOpt[JsValue].flatMap { x => ProjectionReflectYCodec.decodeOpt(x) },
      `radius` = (j \ "radius").asOpt[JsValue].flatMap { x => ProjectionRadiusCodec.decodeOpt(x) },
      `tilt` = (j \ "tilt").asOpt[JsValue].flatMap { x => ProjectionTiltCodec.decodeOpt(x) },
      `pointRadius` = (j \ "pointRadius").asOpt[JsValue].flatMap { x => ProjectionPointRadiusCodec.decodeOpt(x) },
      `ratio` = (j \ "ratio").asOpt[JsValue].flatMap { x => ProjectionRatioCodec.decodeOpt(x) },
      `parallel` = (j \ "parallel").asOpt[JsValue].flatMap { x => ProjectionParallelCodec.decodeOpt(x) },
      `distance` = (j \ "distance").asOpt[JsValue].flatMap { x => ProjectionDistanceCodec.decodeOpt(x) },
    ))

  def encode(j: Projection): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`fraction`.map { x => "fraction" -> ProjectionFractionCodec.encode(x) },
        j.`extent`.map { x => "extent" -> ProjectionExtentCodec.encode(x) },
        j.`center`.map { x => "center" -> ProjectionCenterCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ProjectionScaleCodec.encode(x) },
        j.`fit`.map { x => "fit" -> ProjectionFitCodec.encode(x) },
        j.`reflectX`.map { x => "reflectX" -> ProjectionReflectXCodec.encode(x) },
        j.`rotate`.map { x => "rotate" -> ProjectionRotateCodec.encode(x) },
        j.`clipAngle`.map { x => "clipAngle" -> ProjectionClipAngleCodec.encode(x) },
        j.`lobes`.map { x => "lobes" -> ProjectionLobesCodec.encode(x) },
        j.`parallels`.map { x => "parallels" -> ProjectionParallelsCodec.encode(x) },
        j.`translate`.map { x => "translate" -> ProjectionTranslateCodec.encode(x) },
        j.`type`.map { x => "type" -> ProjectionTypeCodec.encode(x) },
        j.`spacing`.map { x => "spacing" -> ProjectionSpacingCodec.encode(x) },
        j.`clipExtent`.map { x => "clipExtent" -> ProjectionClipExtentCodec.encode(x) },
        j.`coefficient`.map { x => "coefficient" -> ProjectionCoefficientCodec.encode(x) },
        j.`precision`.map { x => "precision" -> ProjectionPrecisionCodec.encode(x) },
        j.`size`.map { x => "size" -> ProjectionSizeCodec.encode(x) },
        j.`reflectY`.map { x => "reflectY" -> ProjectionReflectYCodec.encode(x) },
        j.`radius`.map { x => "radius" -> ProjectionRadiusCodec.encode(x) },
        j.`tilt`.map { x => "tilt" -> ProjectionTiltCodec.encode(x) },
        j.`pointRadius`.map { x => "pointRadius" -> ProjectionPointRadiusCodec.encode(x) },
        j.`ratio`.map { x => "ratio" -> ProjectionRatioCodec.encode(x) },
        j.`parallel`.map { x => "parallel" -> ProjectionParallelCodec.encode(x) },
        j.`distance`.map { x => "distance" -> ProjectionDistanceCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// BinExtent (UnionType)
object BinExtentCodec {
  def decode(j: JsValue): BinExtent =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BinExtent] =
    BinExtentAsArrayCodec.decodeOpt(j).orElse {
    ParameterExtentCodec.decodeOpt(j) } 
  def encode(j: BinExtent): JsValue =
    j match {
      case x:BinExtentAsArray /* TypeRef */ => BinExtentAsArrayCodec.encode(x)
      case x:ParameterExtent /* TypeRef */ => ParameterExtentCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigDir (UnionType)
object MarkConfigDirCodec {
  def decode(j: JsValue): MarkConfigDir =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigDir] =
    TextDirectionCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigDir): JsValue =
    j match {
      case x:TextDirection /* TypeRef */ => TextDirectionCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelFacetSpecBackground (UnionType)
object TopLevelFacetSpecBackgroundCodec {
  def decode(j: JsValue): TopLevelFacetSpecBackground =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelFacetSpecBackground] =
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TopLevelFacetSpecBackground): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigGridColor (UnionType)
object AxisConfigGridColorCodec {
  def decode(j: JsValue): AxisConfigGridColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigGridColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => AxisConfigGridColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisColorCodec.decodeOpt(j) } } } 
  def encode(j: AxisConfigGridColor): JsValue =
    j match {
      case AxisConfigGridColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisColor /* TypeRef */ => ConditionalAxisColorCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterStringFieldDefBin (UnionType)
object ConditionalParameterStringFieldDefBinCodec {
  def decode(j: JsValue): ConditionalParameterStringFieldDefBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalParameterStringFieldDefBin] =
    j.asOpt[Boolean].map { ConditionalParameterStringFieldDefBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    BinnedCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ConditionalParameterStringFieldDefBinAsNull } } } } 
  def encode(j: ConditionalParameterStringFieldDefBin): JsValue =
    j match {
      case ConditionalParameterStringFieldDefBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case x:Binned /* TypeRef */ => BinnedCodec.encode(x)
      case ConditionalParameterStringFieldDefBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefHref (UnionType)
object MarkDefHrefCodec {
  def decode(j: JsValue): MarkDefHref =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefHref] =
    UriReferenceCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefHref): JsValue =
    j match {
      case x:UriReference /* TypeRef */ => UriReferenceCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderConfigLabelAlign (UnionType)
object HeaderConfigLabelAlignCodec {
  def decode(j: JsValue): HeaderConfigLabelAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigLabelAlign] =
    AlignCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderConfigLabelAlign): JsValue =
    j match {
      case x:Align /* TypeRef */ => AlignCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingYBin (UnionType)
object SharedEncodingYBinCodec {
  def decode(j: JsValue): SharedEncodingYBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingYBin] =
    j.asOpt[Boolean].map { SharedEncodingYBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    BinnedCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingYBinAsNull } } } } 
  def encode(j: SharedEncodingYBin): JsValue =
    j match {
      case SharedEncodingYBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case x:Binned /* TypeRef */ => BinnedCodec.encode(x)
      case SharedEncodingYBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// ViewBackgroundCornerRadius (UnionType)
object ViewBackgroundCornerRadiusCodec {
  def decode(j: JsValue): ViewBackgroundCornerRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewBackgroundCornerRadius] =
    j.asOpt[JsNumber].map { ViewBackgroundCornerRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ViewBackgroundCornerRadius): JsValue =
    j match {
      case ViewBackgroundCornerRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Resolve (StructType)
object ResolveCodec {
  def decode(j: JsValue): Resolve =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Resolve] =
    Some(Resolve(
      `axis` = (j \ "axis").asOpt[JsValue].flatMap { x => AxisResolveMapCodec.decodeOpt(x) },
      `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendResolveMapCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleResolveMapCodec.decodeOpt(x) },
    ))

  def encode(j: Resolve): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`axis`.map { x => "axis" -> AxisResolveMapCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendResolveMapCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleResolveMapCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingXOffsetBandPosition (ConstrainedType)
object SharedEncodingXOffsetBandPositionCodec {
  def decode(j: JsValue): SharedEncodingXOffsetBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingXOffsetBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingXOffsetBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingXOffsetBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// TopLevelVConcatSpecTitle (UnionType)
object TopLevelVConcatSpecTitleCodec {
  def decode(j: JsValue): TopLevelVConcatSpecTitle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelVConcatSpecTitle] =
    TextCodec.decodeOpt(j).orElse {
    TitleParamsCodec.decodeOpt(j) } 
  def encode(j: TopLevelVConcatSpecTitle): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:TitleParams /* TypeRef */ => TitleParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalValueDefNumber (UnionType)
object ConditionalValueDefNumberCodec {
  def decode(j: JsValue): ConditionalValueDefNumber =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalValueDefNumber] =
    ConditionalPredicateValueDefNumberCodec.decodeOpt(j).orElse {
    ConditionalParameterValueDefNumberCodec.decodeOpt(j) } 
  def encode(j: ConditionalValueDefNumber): JsValue =
    j match {
      case x:ConditionalPredicateValueDefNumber /* TypeRef */ => ConditionalPredicateValueDefNumberCodec.encode(x)
      case x:ConditionalParameterValueDefNumber /* TypeRef */ => ConditionalParameterValueDefNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Transform (UnionType)
object TransformCodec {
  def decode(j: JsValue): Transform =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Transform] =
    QuantileTransformCodec.decodeOpt(j).orElse {
    WindowTransformCodec.decodeOpt(j).orElse {
    FlattenTransformCodec.decodeOpt(j).orElse {
    CalculateTransformCodec.decodeOpt(j).orElse {
    DensityTransformCodec.decodeOpt(j).orElse {
    BinTransformCodec.decodeOpt(j).orElse {
    RegressionTransformCodec.decodeOpt(j).orElse {
    ImputeTransformCodec.decodeOpt(j).orElse {
    LookupTransformCodec.decodeOpt(j).orElse {
    SampleTransformCodec.decodeOpt(j).orElse {
    TimeUnitTransformCodec.decodeOpt(j).orElse {
    JoinAggregateTransformCodec.decodeOpt(j).orElse {
    StackTransformCodec.decodeOpt(j).orElse {
    FilterTransformCodec.decodeOpt(j).orElse {
    FoldTransformCodec.decodeOpt(j).orElse {
    PivotTransformCodec.decodeOpt(j).orElse {
    LoessTransformCodec.decodeOpt(j).orElse {
    AggregateTransformCodec.decodeOpt(j) } } } } } } } } } } } } } } } } } 
  def encode(j: Transform): JsValue =
    j match {
      case x:QuantileTransform /* TypeRef */ => QuantileTransformCodec.encode(x)
      case x:WindowTransform /* TypeRef */ => WindowTransformCodec.encode(x)
      case x:FlattenTransform /* TypeRef */ => FlattenTransformCodec.encode(x)
      case x:CalculateTransform /* TypeRef */ => CalculateTransformCodec.encode(x)
      case x:DensityTransform /* TypeRef */ => DensityTransformCodec.encode(x)
      case x:BinTransform /* TypeRef */ => BinTransformCodec.encode(x)
      case x:RegressionTransform /* TypeRef */ => RegressionTransformCodec.encode(x)
      case x:ImputeTransform /* TypeRef */ => ImputeTransformCodec.encode(x)
      case x:LookupTransform /* TypeRef */ => LookupTransformCodec.encode(x)
      case x:SampleTransform /* TypeRef */ => SampleTransformCodec.encode(x)
      case x:TimeUnitTransform /* TypeRef */ => TimeUnitTransformCodec.encode(x)
      case x:JoinAggregateTransform /* TypeRef */ => JoinAggregateTransformCodec.encode(x)
      case x:StackTransform /* TypeRef */ => StackTransformCodec.encode(x)
      case x:FilterTransform /* TypeRef */ => FilterTransformCodec.encode(x)
      case x:FoldTransform /* TypeRef */ => FoldTransformCodec.encode(x)
      case x:PivotTransform /* TypeRef */ => PivotTransformCodec.encode(x)
      case x:LoessTransform /* TypeRef */ => LoessTransformCodec.encode(x)
      case x:AggregateTransform /* TypeRef */ => AggregateTransformCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisGridDashOffset (UnionType)
object AxisGridDashOffsetCodec {
  def decode(j: JsValue): AxisGridDashOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisGridDashOffset] =
    j.asOpt[JsNumber].map { AxisGridDashOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisGridDashOffset): JsValue =
    j match {
      case AxisGridDashOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AutosizeType (EnumType)
object AutosizeTypeCodec {
  def decode(j: JsValue): AutosizeType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AutosizeType] =
    j match {
      case JsString("pad") => Some(AutosizeTypePad)
      case JsString("none") => Some(AutosizeTypeNone)
      case JsString("fit") => Some(AutosizeTypeFit)
      case JsString("fit-x") => Some(AutosizeTypeFitX)
      case JsString("fit-y") => Some(AutosizeTypeFitY)
      case _ => None
    }
  def encode(j: AutosizeType): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// NonNormalizedSpec (UnionType)
object NonNormalizedSpecCodec {
  def decode(j: JsValue): NonNormalizedSpec =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[NonNormalizedSpec] =
    FacetSpecCodec.decodeOpt(j).orElse {
    LayerSpecCodec.decodeOpt(j).orElse {
    HConcatSpecGenericSpecCodec.decodeOpt(j).orElse {
    FacetedUnitSpecCodec.decodeOpt(j).orElse {
    ConcatSpecGenericSpecCodec.decodeOpt(j).orElse {
    RepeatSpecCodec.decodeOpt(j).orElse {
    VConcatSpecGenericSpecCodec.decodeOpt(j) } } } } } } 
  def encode(j: NonNormalizedSpec): JsValue =
    j match {
      case x:FacetSpec /* TypeRef */ => FacetSpecCodec.encode(x)
      case x:LayerSpec /* TypeRef */ => LayerSpecCodec.encode(x)
      case x:HConcatSpecGenericSpec /* TypeRef */ => HConcatSpecGenericSpecCodec.encode(x)
      case x:FacetedUnitSpec /* TypeRef */ => FacetedUnitSpecCodec.encode(x)
      case x:ConcatSpecGenericSpec /* TypeRef */ => ConcatSpecGenericSpecCodec.encode(x)
      case x:RepeatSpec /* TypeRef */ => RepeatSpecCodec.encode(x)
      case x:VConcatSpecGenericSpec /* TypeRef */ => VConcatSpecGenericSpecCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScalePaddingOuter (UnionType)
object ScalePaddingOuterCodec {
  def decode(j: JsValue): ScalePaddingOuter =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScalePaddingOuter] =
    j.asOpt[JsNumber].map { ScalePaddingOuterAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScalePaddingOuter): JsValue =
    j match {
      case ScalePaddingOuterAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigLabelOpacity (UnionType)
object AxisConfigLabelOpacityCodec {
  def decode(j: JsValue): AxisConfigLabelOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigLabelOpacity] =
    j.asOpt[JsNumber].map { AxisConfigLabelOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigLabelOpacity): JsValue =
    j match {
      case AxisConfigLabelOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Binding (UnionType)
object BindingCodec {
  def decode(j: JsValue): Binding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Binding] =
    BindCheckboxCodec.decodeOpt(j).orElse {
    BindRadioSelectCodec.decodeOpt(j).orElse {
    BindInputCodec.decodeOpt(j).orElse {
    BindRangeCodec.decodeOpt(j).orElse {
    BindDirectCodec.decodeOpt(j) } } } } 
  def encode(j: Binding): JsValue =
    j match {
      case x:BindCheckbox /* TypeRef */ => BindCheckboxCodec.encode(x)
      case x:BindRadioSelect /* TypeRef */ => BindRadioSelectCodec.encode(x)
      case x:BindInput /* TypeRef */ => BindInputCodec.encode(x)
      case x:BindRange /* TypeRef */ => BindRangeCodec.encode(x)
      case x:BindDirect /* TypeRef */ => BindDirectCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PositionDatumDefBase (StructType)
object PositionDatumDefBaseCodec {
  def decode(j: JsValue): PositionDatumDefBase =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[PositionDatumDefBase] =
    Some(PositionDatumDefBase(
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => PositionDatumDefBaseDatumCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => PositionDatumDefBaseBandPositionCodec.decodeOpt(x) },
      `stack` = (j \ "stack").asOpt[JsValue].flatMap { x => PositionDatumDefBaseStackCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeCodec.decodeOpt(x) },
    ))

  def encode(j: PositionDatumDefBase): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> PositionDatumDefBaseDatumCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> PositionDatumDefBaseBandPositionCodec.encode(x) },
        j.`stack`.map { x => "stack" -> PositionDatumDefBaseStackCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingX (StructType)
object SharedEncodingXCodec {
  def decode(j: JsValue): SharedEncodingX =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingX] =
    Some(SharedEncodingX(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingXBandPositionCodec.decodeOpt(x) },
      `stack` = (j \ "stack").asOpt[JsValue].flatMap { x => SharedEncodingXStackCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingXBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingXValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingXTimeUnitCodec.decodeOpt(x) },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingXDatumCodec.decodeOpt(x) },
      `impute` = (j \ "impute").asOpt[JsValue].flatMap { x => ImputeParamsCodec.decodeOpt(x).map { Some(_) }.flatten },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `axis` = (j \ "axis").asOpt[JsValue].flatMap { x => AxisCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => SharedEncodingXTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingX): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingXBandPositionCodec.encode(x) },
        j.`stack`.map { x => "stack" -> SharedEncodingXStackCodec.encode(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingXBinCodec.encode(x) },
        j.`value`.map { x => "value" -> SharedEncodingXValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingXTimeUnitCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingXDatumCodec.encode(x) },
        j.`impute`.map { x => "impute" -> ImputeParamsCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`axis`.map { x => "axis" -> AxisCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> SharedEncodingXTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// StrokeJoin (EnumType)
object StrokeJoinCodec {
  def decode(j: JsValue): StrokeJoin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[StrokeJoin] =
    j match {
      case JsString("miter") => Some(StrokeJoinMiter)
      case JsString("round") => Some(StrokeJoinRound)
      case JsString("bevel") => Some(StrokeJoinBevel)
      case _ => None
    }
  def encode(j: StrokeJoin): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// ConditionalAxisColorAsObject1 (StructType)
object ConditionalAxisColorAsObject1Codec {
  def decode(j: JsValue): ConditionalAxisColorAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalAxisColorAsObject1] =
    {
      val `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => ConditionalAxisColorAsObject1ConditionCodec.decodeOpt(x) }
      if(`condition`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => ColorCodec.decodeOpt(x).map { Some(_) }.flatten }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalAxisColorAsObject1(
        `condition` = `condition`.get,
        `value` = `value`,
      ))
    }

  def encode(j: ConditionalAxisColorAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("condition" -> ConditionalAxisColorAsObject1ConditionCodec.encode(j.`condition`)),
        j.`value`.map { x => "value" -> ColorCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TitleConfigAnchor (UnionType)
object TitleConfigAnchorCodec {
  def decode(j: JsValue): TitleConfigAnchor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigAnchor] =
    TitleAnchorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleConfigAnchor): JsValue =
    j match {
      case x:TitleAnchor /* TypeRef */ => TitleAnchorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// StackTransformOffset (EnumType)
object StackTransformOffsetCodec {
  def decode(j: JsValue): StackTransformOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[StackTransformOffset] =
    j match {
      case JsString("zero") => Some(StackTransformOffsetZero)
      case JsString("center") => Some(StackTransformOffsetCenter)
      case JsString("normalize") => Some(StackTransformOffsetNormalize)
      case _ => None
    }
  def encode(j: StackTransformOffset): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// CalculateTransform (StructType)
object CalculateTransformCodec {
  def decode(j: JsValue): CalculateTransform =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[CalculateTransform] =
    {
      val `as` = (j \ "as").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`as`.isEmpty) { return None }
      val `calculate` = (j \ "calculate").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`calculate`.isEmpty) { return None }
      return Some(CalculateTransform(
        `as` = `as`.get,
        `calculate` = `calculate`.get,
      ))
    }

  def encode(j: CalculateTransform): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("as" -> Json.toJson(j.`as`)),
        Some("calculate" -> Json.toJson(j.`calculate`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// HeaderConfigLabelAngle (ConstrainedType)
object HeaderConfigLabelAngleCodec {
  def decode(j: JsValue): HeaderConfigLabelAngle =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[HeaderConfigLabelAngle] =
    try {
      j.asOpt[JsNumber]
        .map { HeaderConfigLabelAngle(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: HeaderConfigLabelAngle): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// HeaderConfigTitleAngle (ConstrainedType)
object HeaderConfigTitleAngleCodec {
  def decode(j: JsValue): HeaderConfigTitleAngle =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[HeaderConfigTitleAngle] =
    try {
      j.asOpt[JsNumber]
        .map { HeaderConfigTitleAngle(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: HeaderConfigTitleAngle): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MergedStreamFilter (UnionType)
object MergedStreamFilterCodec {
  def decode(j: JsValue): MergedStreamFilter =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MergedStreamFilter] =
    j.asOpt[String].map { MergedStreamFilterAsString(_) }.orElse {
    ArrayOfStringCodec.decodeOpt(j).map { MergedStreamFilterAsArrayOfString(_) } } 
  def encode(j: MergedStreamFilter): JsValue =
    j match {
      case MergedStreamFilterAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case MergedStreamFilterAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderLabelBaseline (UnionType)
object HeaderLabelBaselineCodec {
  def decode(j: JsValue): HeaderLabelBaseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderLabelBaseline] =
    TextBaselineCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderLabelBaseline): JsValue =
    j match {
      case x:TextBaseline /* TypeRef */ => TextBaselineCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BoxPlotConfigExtent (UnionType)
object BoxPlotConfigExtentCodec {
  def decode(j: JsValue): BoxPlotConfigExtent =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BoxPlotConfigExtent] =
    MinMaxCodec.decodeOpt(j).orElse {
    j.asOpt[JsNumber].map { BoxPlotConfigExtentAsNumber(_) } } 
  def encode(j: BoxPlotConfigExtent): JsValue =
    j match {
      case x:MinMax /* TypeRef */ => MinMaxCodec.encode(x)
      case BoxPlotConfigExtentAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigStrokeDashOffset (UnionType)
object AreaConfigStrokeDashOffsetCodec {
  def decode(j: JsValue): AreaConfigStrokeDashOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigStrokeDashOffset] =
    j.asOpt[JsNumber].map { AreaConfigStrokeDashOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigStrokeDashOffset): JsValue =
    j match {
      case AreaConfigStrokeDashOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisLabelFlush (UnionType)
object AxisLabelFlushCodec {
  def decode(j: JsValue): AxisLabelFlush =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisLabelFlush] =
    j.asOpt[Boolean].map { AxisLabelFlushAsBool(_) }.orElse {
    j.asOpt[JsNumber].map { AxisLabelFlushAsNumber(_) } } 
  def encode(j: AxisLabelFlush): JsValue =
    j match {
      case AxisLabelFlushAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case AxisLabelFlushAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTitleFontStyle (UnionType)
object AxisTitleFontStyleCodec {
  def decode(j: JsValue): AxisTitleFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTitleFontStyle] =
    j.asOpt[String].map { AxisTitleFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisTitleFontStyle): JsValue =
    j match {
      case AxisTitleFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingLatitude2 (StructType)
object SharedEncodingLatitude2Codec {
  def decode(j: JsValue): SharedEncodingLatitude2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingLatitude2] =
    Some(SharedEncodingLatitude2(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingLatitude2DatumCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingLatitude2BandPositionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => x.asOpt[JsNull.type].map { _ => JsNull } },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingLatitude2ValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingLatitude2TimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingLatitude2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingLatitude2DatumCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingLatitude2BandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> Json.toJson(x) },
        j.`value`.map { x => "value" -> SharedEncodingLatitude2ValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingLatitude2TimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AreaConfigAngleAsNumber (ConstrainedType)
object AreaConfigAngleAsNumberCodec {
  def decode(j: JsValue): AreaConfigAngleAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AreaConfigAngleAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AreaConfigAngleAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AreaConfigAngleAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AreaConfigY2 (UnionType)
object AreaConfigY2Codec {
  def decode(j: JsValue): AreaConfigY2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigY2] =
    j.asOpt[JsNumber].map { AreaConfigY2AsNumber(_) }.orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: AreaConfigY2): JsValue =
    j match {
      case AreaConfigY2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigLineHeight (UnionType)
object MarkConfigLineHeightCodec {
  def decode(j: JsValue): MarkConfigLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigLineHeight] =
    j.asOpt[JsNumber].map { MarkConfigLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigLineHeight): JsValue =
    j match {
      case MarkConfigLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisValues (UnionType)
object AxisValuesCodec {
  def decode(j: JsValue): AxisValues =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisValues] =
    ArrayOfNumberCodec.decodeOpt(j).map { AxisValuesAsArrayOfNumber(_) }.orElse {
    ArrayOfBoolCodec.decodeOpt(j).map { AxisValuesAsArrayOfBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ArrayOfDateTimeCodec.decodeOpt(j).map { AxisValuesAsArrayOfDateTime(_) }.orElse {
    ArrayOfStringCodec.decodeOpt(j).map { AxisValuesAsArrayOfString(_) } } } } } 
  def encode(j: AxisValues): JsValue =
    j match {
      case AxisValuesAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case AxisValuesAsArrayOfBool(x) /* Base, ArrayType */ => ArrayOfBoolCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case AxisValuesAsArrayOfDateTime(x) /* Base, ArrayType */ => ArrayOfDateTimeCodec.encode(x)
      case AxisValuesAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelSelectionParameterBind (UnionType)
object TopLevelSelectionParameterBindCodec {
  def decode(j: JsValue): TopLevelSelectionParameterBind =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelSelectionParameterBind] =
    BindingCodec.decodeOpt(j).orElse {
    DictOfBindingCodec.decodeOpt(j).map { TopLevelSelectionParameterBindAsDictOfBinding(_) }.orElse {
    LegendBindingCodec.decodeOpt(j).orElse {
    ScalesCodec.decodeOpt(j) } } } 
  def encode(j: TopLevelSelectionParameterBind): JsValue =
    j match {
      case x:Binding /* TypeRef */ => BindingCodec.encode(x)
      case TopLevelSelectionParameterBindAsDictOfBinding(x) /* Base, MapType */ => DictOfBindingCodec.encode(x)
      case x:LegendBinding /* TypeRef */ => LegendBindingCodec.encode(x)
      case x:Scales /* TypeRef */ => ScalesCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigX (UnionType)
object BarConfigXCodec {
  def decode(j: JsValue): BarConfigX =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigX] =
    j.asOpt[JsNumber].map { BarConfigXAsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: BarConfigX): JsValue =
    j match {
      case BarConfigXAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigColor (UnionType)
object LineConfigColorCodec {
  def decode(j: JsValue): LineConfigColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigColor] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: LineConfigColor): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigStrokeJoin (UnionType)
object MarkConfigStrokeJoinCodec {
  def decode(j: JsValue): MarkConfigStrokeJoin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigStrokeJoin] =
    StrokeJoinCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigStrokeJoin): JsValue =
    j match {
      case x:StrokeJoin /* TypeRef */ => StrokeJoinCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigDx (UnionType)
object MarkConfigDxCodec {
  def decode(j: JsValue): MarkConfigDx =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigDx] =
    j.asOpt[JsNumber].map { MarkConfigDxAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigDx): JsValue =
    j match {
      case MarkConfigDxAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefAriaRoleDescription (UnionType)
object OverlayMarkDefAriaRoleDescriptionCodec {
  def decode(j: JsValue): OverlayMarkDefAriaRoleDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefAriaRoleDescription] =
    j.asOpt[String].map { OverlayMarkDefAriaRoleDescriptionAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefAriaRoleDescription): JsValue =
    j match {
      case OverlayMarkDefAriaRoleDescriptionAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LookupTransformFrom (UnionType)
object LookupTransformFromCodec {
  def decode(j: JsValue): LookupTransformFrom =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LookupTransformFrom] =
    LookupDataCodec.decodeOpt(j).orElse {
    LookupSelectionCodec.decodeOpt(j) } 
  def encode(j: LookupTransformFrom): JsValue =
    j match {
      case x:LookupData /* TypeRef */ => LookupDataCodec.encode(x)
      case x:LookupSelection /* TypeRef */ => LookupSelectionCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Align (EnumType)
object AlignCodec {
  def decode(j: JsValue): Align =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Align] =
    j match {
      case JsString("left") => Some(AlignLeft)
      case JsString("center") => Some(AlignCenter)
      case JsString("right") => Some(AlignRight)
      case _ => None
    }
  def encode(j: Align): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// ProjectionConfigReflectX (UnionType)
object ProjectionConfigReflectXCodec {
  def decode(j: JsValue): ProjectionConfigReflectX =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigReflectX] =
    j.asOpt[Boolean].map { ProjectionConfigReflectXAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigReflectX): JsValue =
    j match {
      case ProjectionConfigReflectXAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingOpacityValue (UnionType)
object SharedEncodingOpacityValueCodec {
  def decode(j: JsValue): SharedEncodingOpacityValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingOpacityValue] =
    j.asOpt[JsNumber].map { SharedEncodingOpacityValueAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingOpacityValue): JsValue =
    j match {
      case SharedEncodingOpacityValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AnyMarkConfig (UnionType)
object AnyMarkConfigCodec {
  def decode(j: JsValue): AnyMarkConfig =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AnyMarkConfig] =
    LineConfigCodec.decodeOpt(j).orElse {
    TickConfigCodec.decodeOpt(j).orElse {
    AreaConfigCodec.decodeOpt(j).orElse {
    BarConfigCodec.decodeOpt(j).orElse {
    MarkConfigCodec.decodeOpt(j).orElse {
    RectConfigCodec.decodeOpt(j) } } } } } 
  def encode(j: AnyMarkConfig): JsValue =
    j match {
      case x:LineConfig /* TypeRef */ => LineConfigCodec.encode(x)
      case x:TickConfig /* TypeRef */ => TickConfigCodec.encode(x)
      case x:AreaConfig /* TypeRef */ => AreaConfigCodec.encode(x)
      case x:BarConfig /* TypeRef */ => BarConfigCodec.encode(x)
      case x:MarkConfig /* TypeRef */ => MarkConfigCodec.encode(x)
      case x:RectConfig /* TypeRef */ => RectConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigHref (UnionType)
object LineConfigHrefCodec {
  def decode(j: JsValue): LineConfigHref =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigHref] =
    UriReferenceCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigHref): JsValue =
    j match {
      case x:UriReference /* TypeRef */ => UriReferenceCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionMarkPropFieldDefNumber (StructType)
object FieldOrDatumDefWithConditionMarkPropFieldDefNumberCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionMarkPropFieldDefNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionMarkPropFieldDefNumber] =
    Some(FieldOrDatumDefWithConditionMarkPropFieldDefNumber(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionMarkPropFieldDefNumberBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionMarkPropFieldDefNumberConditionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionMarkPropFieldDefNumberBinCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionMarkPropFieldDefNumberTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) },
    ))

  def encode(j: FieldOrDatumDefWithConditionMarkPropFieldDefNumber): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> FieldOrDatumDefWithConditionMarkPropFieldDefNumberBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> FieldOrDatumDefWithConditionMarkPropFieldDefNumberConditionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> FieldOrDatumDefWithConditionMarkPropFieldDefNumberBinCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> FieldOrDatumDefWithConditionMarkPropFieldDefNumberTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// StackOffset (EnumType)
object StackOffsetCodec {
  def decode(j: JsValue): StackOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[StackOffset] =
    j match {
      case JsString("zero") => Some(StackOffsetZero)
      case JsString("center") => Some(StackOffsetCenter)
      case JsString("normalize") => Some(StackOffsetNormalize)
      case _ => None
    }
  def encode(j: StackOffset): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// LineConfigCornerRadius (UnionType)
object LineConfigCornerRadiusCodec {
  def decode(j: JsValue): LineConfigCornerRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigCornerRadius] =
    j.asOpt[JsNumber].map { LineConfigCornerRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigCornerRadius): JsValue =
    j match {
      case LineConfigCornerRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelHConcatSpecBounds (EnumType)
object TopLevelHConcatSpecBoundsCodec {
  def decode(j: JsValue): TopLevelHConcatSpecBounds =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelHConcatSpecBounds] =
    j match {
      case JsString("full") => Some(TopLevelHConcatSpecBoundsFull)
      case JsString("flush") => Some(TopLevelHConcatSpecBoundsFlush)
      case _ => None
    }
  def encode(j: TopLevelHConcatSpecBounds): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// AxisConfigTitlePadding (UnionType)
object AxisConfigTitlePaddingCodec {
  def decode(j: JsValue): AxisConfigTitlePadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTitlePadding] =
    j.asOpt[JsNumber].map { AxisConfigTitlePaddingAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigTitlePadding): JsValue =
    j match {
      case AxisConfigTitlePaddingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigDescription (UnionType)
object RectConfigDescriptionCodec {
  def decode(j: JsValue): RectConfigDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigDescription] =
    j.asOpt[String].map { RectConfigDescriptionAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigDescription): JsValue =
    j match {
      case RectConfigDescriptionAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfDateTime (ArrayType)
object ArrayOfDateTimeCodec {
  def decode(j: JsValue): Seq[DateTime] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[DateTime]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      DateTimeCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[DateTime]): JsArray =
      JsArray(j.map { x => DateTimeCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// IntervalSelectionConfigClear (UnionType)
object IntervalSelectionConfigClearCodec {
  def decode(j: JsValue): IntervalSelectionConfigClear =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[IntervalSelectionConfigClear] =
    StreamCodec.decodeOpt(j).orElse {
    j.asOpt[String].map { IntervalSelectionConfigClearAsString(_) }.orElse {
    j.asOpt[Boolean].map { IntervalSelectionConfigClearAsBool(_) } } } 
  def encode(j: IntervalSelectionConfigClear): JsValue =
    j match {
      case x:Stream /* TypeRef */ => StreamCodec.encode(x)
      case IntervalSelectionConfigClearAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case IntervalSelectionConfigClearAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingLatitude2TimeUnit (UnionType)
object SharedEncodingLatitude2TimeUnitCodec {
  def decode(j: JsValue): SharedEncodingLatitude2TimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingLatitude2TimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingLatitude2TimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTickCount (ConstrainedType)
// see AxisTickCount (UnionType)

////////////////////////////////////////////////////////////////////////
// Vector2Boolean (ConstrainedType)
object Vector2BooleanCodec {
  def decode(j: JsValue): Vector2Boolean =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Vector2Boolean] =
    try {
      ArrayOfBoolCodec.decodeOpt(j)
        .map { Vector2Boolean(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: Vector2Boolean): JsValue =
    ArrayOfBoolCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefFontStyleNullExprRefAsObject2 (StructType)
object ConditionalPredicateValueDefFontStyleNullExprRefAsObject2Codec {
  def decode(j: JsValue): ConditionalPredicateValueDefFontStyleNullExprRefAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefFontStyleNullExprRefAsObject2] =
    {
      val `expr` = (j \ "expr").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`expr`.isEmpty) { return None }
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      return Some(ConditionalPredicateValueDefFontStyleNullExprRefAsObject2(
        `expr` = `expr`.get,
        `test` = `test`.get,
      ))
    }

  def encode(j: ConditionalPredicateValueDefFontStyleNullExprRefAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("expr" -> Json.toJson(j.`expr`)),
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingFill (StructType)
object SharedEncodingFillCodec {
  def decode(j: JsValue): SharedEncodingFill =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingFill] =
    Some(SharedEncodingFill(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingFillDatumCodec.decodeOpt(x) },
      `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingFillBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => SharedEncodingFillConditionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingFillBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingFillValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingFillTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => SharedEncodingFillTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingFill): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingFillDatumCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingFillBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> SharedEncodingFillConditionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingFillBinCodec.encode(x) },
        j.`value`.map { x => "value" -> SharedEncodingFillValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingFillTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> SharedEncodingFillTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ArrayOfSpec (ArrayType)
object ArrayOfSpecCodec {
  def decode(j: JsValue): Seq[Spec] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[Spec]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      SpecCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[Spec]): JsArray =
      JsArray(j.map { x => SpecCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeDashType (UnionType)
object SharedEncodingStrokeDashTypeCodec {
  def decode(j: JsValue): SharedEncodingStrokeDashType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeDashType] =
    StandardTypeCodec.decodeOpt(j).orElse {
    TypeCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingStrokeDashType): JsValue =
    j match {
      case x:StandardType /* TypeRef */ => StandardTypeCodec.encode(x)
      case x:Type /* TypeRef */ => TypeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigHeight (UnionType)
object LineConfigHeightCodec {
  def decode(j: JsValue): LineConfigHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigHeight] =
    j.asOpt[JsNumber].map { LineConfigHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigHeight): JsValue =
    j match {
      case LineConfigHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingAngleBandPosition (ConstrainedType)
object SharedEncodingAngleBandPositionCodec {
  def decode(j: JsValue): SharedEncodingAngleBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingAngleBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingAngleBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingAngleBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefOuterRadius (UnionType)
object OverlayMarkDefOuterRadiusCodec {
  def decode(j: JsValue): OverlayMarkDefOuterRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefOuterRadius] =
    j.asOpt[JsNumber].map { OverlayMarkDefOuterRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefOuterRadius): JsValue =
    j match {
      case OverlayMarkDefOuterRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsDx (UnionType)
object TitleParamsDxCodec {
  def decode(j: JsValue): TitleParamsDx =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsDx] =
    j.asOpt[JsNumber].map { TitleParamsDxAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleParamsDx): JsValue =
    j match {
      case TitleParamsDxAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefAria (UnionType)
object MarkDefAriaCodec {
  def decode(j: JsValue): MarkDefAria =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefAria] =
    j.asOpt[Boolean].map { MarkDefAriaAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefAria): JsValue =
    j match {
      case MarkDefAriaAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleDatumDef (StructType)
object ScaleDatumDefCodec {
  def decode(j: JsValue): ScaleDatumDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ScaleDatumDef] =
    Some(ScaleDatumDef(
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => ScaleDatumDefDatumCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => ScaleDatumDefBandPositionCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeCodec.decodeOpt(x) },
    ))

  def encode(j: ScaleDatumDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> ScaleDatumDefDatumCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> ScaleDatumDefBandPositionCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// EventStreamAsObject2Source (ConstantType)
object EventStreamAsObject2SourceCodec {
  def decode(j: JsValue): EventStreamAsObject2Source =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[EventStreamAsObject2Source] =
    j match {
      case JsString("window") => Some(EventStreamAsObject2Source())
      case _ => None
    }
  def encode(j: EventStreamAsObject2Source): JsValue =
    JsString("window")
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingColor (StructType)
object SharedEncodingColorCodec {
  def decode(j: JsValue): SharedEncodingColor =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingColor] =
    Some(SharedEncodingColor(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingColorDatumCodec.decodeOpt(x) },
      `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingColorBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => SharedEncodingColorConditionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingColorBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingColorValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingColorTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => SharedEncodingColorTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingColor): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingColorDatumCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingColorBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> SharedEncodingColorConditionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingColorBinCodec.encode(x) },
        j.`value`.map { x => "value" -> SharedEncodingColorValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingColorTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> SharedEncodingColorTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ProjectionCenter (UnionType)
object ProjectionCenterCodec {
  def decode(j: JsValue): ProjectionCenter =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionCenter] =
    Vector2NumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionCenter): JsValue =
    j match {
      case x:Vector2Number /* TypeRef */ => Vector2NumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingColorBin (UnionType)
object SharedEncodingColorBinCodec {
  def decode(j: JsValue): SharedEncodingColorBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingColorBin] =
    j.asOpt[Boolean].map { SharedEncodingColorBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingColorBinAsNull } } } 
  def encode(j: SharedEncodingColorBin): JsValue =
    j match {
      case SharedEncodingColorBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case SharedEncodingColorBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionMarkPropFieldDefNumberCondition (UnionType)
object FieldOrDatumDefWithConditionMarkPropFieldDefNumberConditionCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionMarkPropFieldDefNumberCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionMarkPropFieldDefNumberCondition] =
    ConditionalValueDefNumberExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefNumberExprRefCodec.decodeOpt(j).map { FieldOrDatumDefWithConditionMarkPropFieldDefNumberConditionAsArrayOfConditionalValueDefNumberExprRef(_) } } 
  def encode(j: FieldOrDatumDefWithConditionMarkPropFieldDefNumberCondition): JsValue =
    j match {
      case x:ConditionalValueDefNumberExprRef /* TypeRef */ => ConditionalValueDefNumberExprRefCodec.encode(x)
      case FieldOrDatumDefWithConditionMarkPropFieldDefNumberConditionAsArrayOfConditionalValueDefNumberExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefNumberExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigBandWithNestedOffsetPaddingInner (ConstrainedType)
// see ScaleConfigBandWithNestedOffsetPaddingInner (UnionType)

////////////////////////////////////////////////////////////////////////
// LogicalAndPredicate (StructType)
object LogicalAndPredicateCodec {
  def decode(j: JsValue): LogicalAndPredicate =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LogicalAndPredicate] =
    {
      val `and` = (j \ "and").asOpt[JsValue].flatMap { x => ArrayOfPredicateCompositionCodec.decodeOpt(x) }
      if(`and`.isEmpty) { return None }
      return Some(LogicalAndPredicate(
        `and` = `and`.get,
      ))
    }

  def encode(j: LogicalAndPredicate): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("and" -> ArrayOfPredicateCompositionCodec.encode(j.`and`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// OverlayMarkDefStrokeMiterLimit (UnionType)
object OverlayMarkDefStrokeMiterLimitCodec {
  def decode(j: JsValue): OverlayMarkDefStrokeMiterLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefStrokeMiterLimit] =
    j.asOpt[JsNumber].map { OverlayMarkDefStrokeMiterLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefStrokeMiterLimit): JsValue =
    j match {
      case OverlayMarkDefStrokeMiterLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfigTranslate (UnionType)
object ProjectionConfigTranslateCodec {
  def decode(j: JsValue): ProjectionConfigTranslate =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigTranslate] =
    Vector2NumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigTranslate): JsValue =
    j match {
      case x:Vector2Number /* TypeRef */ => Vector2NumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisDomainDash (UnionType)
object AxisDomainDashCodec {
  def decode(j: JsValue): AxisDomainDash =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisDomainDash] =
    ArrayOfNumberCodec.decodeOpt(j).map { AxisDomainDashAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisDomainDash): JsValue =
    j match {
      case AxisDomainDashAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingXOffsetTimeUnit (UnionType)
object SharedEncodingXOffsetTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingXOffsetTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingXOffsetTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingXOffsetTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LayerSpecWidth (UnionType)
object LayerSpecWidthCodec {
  def decode(j: JsValue): LayerSpecWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LayerSpecWidth] =
    j.asOpt[JsNumber].map { LayerSpecWidthAsNumber(_) }.orElse {
    ContainerCodec.decodeOpt(j).orElse {
    StepCodec.decodeOpt(j) } } 
  def encode(j: LayerSpecWidth): JsValue =
    j match {
      case LayerSpecWidthAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Container /* TypeRef */ => ContainerCodec.encode(x)
      case x:Step /* TypeRef */ => StepCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleFieldDefTimeUnit (UnionType)
object ScaleFieldDefTimeUnitCodec {
  def decode(j: JsValue): ScaleFieldDefTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleFieldDefTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: ScaleFieldDefTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfigTilt (UnionType)
object ProjectionConfigTiltCodec {
  def decode(j: JsValue): ProjectionConfigTilt =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigTilt] =
    j.asOpt[JsNumber].map { ProjectionConfigTiltAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigTilt): JsValue =
    j match {
      case ProjectionConfigTiltAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisLabelFontStyleAsObject2Condition (UnionType)
object ConditionalAxisLabelFontStyleAsObject2ConditionCodec {
  def decode(j: JsValue): ConditionalAxisLabelFontStyleAsObject2Condition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisLabelFontStyleAsObject2Condition] =
    ConditionalPredicateValueDefFontStyleNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalPredicateValueDefFontStyleNullExprRefCodec.decodeOpt(j).map { ConditionalAxisLabelFontStyleAsObject2ConditionAsArrayOfConditionalPredicateValueDefFontStyleNullExprRef(_) } } 
  def encode(j: ConditionalAxisLabelFontStyleAsObject2Condition): JsValue =
    j match {
      case x:ConditionalPredicateValueDefFontStyleNullExprRef /* TypeRef */ => ConditionalPredicateValueDefFontStyleNullExprRefCodec.encode(x)
      case ConditionalAxisLabelFontStyleAsObject2ConditionAsArrayOfConditionalPredicateValueDefFontStyleNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalPredicateValueDefFontStyleNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// NonLayerRepeatSpecRepeat (UnionType)
object NonLayerRepeatSpecRepeatCodec {
  def decode(j: JsValue): NonLayerRepeatSpecRepeat =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[NonLayerRepeatSpecRepeat] =
    ArrayOfStringCodec.decodeOpt(j).map { NonLayerRepeatSpecRepeatAsArrayOfString(_) }.orElse {
    RepeatMappingCodec.decodeOpt(j) } 
  def encode(j: NonLayerRepeatSpecRepeat): JsValue =
    j match {
      case NonLayerRepeatSpecRepeatAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
      case x:RepeatMapping /* TypeRef */ => RepeatMappingCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigFill (UnionType)
object MarkConfigFillCodec {
  def decode(j: JsValue): MarkConfigFill =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigFill] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => MarkConfigFillAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: MarkConfigFill): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case MarkConfigFillAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfigCenter (UnionType)
object ProjectionConfigCenterCodec {
  def decode(j: JsValue): ProjectionConfigCenter =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigCenter] =
    Vector2NumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigCenter): JsValue =
    j match {
      case x:Vector2Number /* TypeRef */ => Vector2NumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LayerRepeatSpecSpacing (UnionType)
object LayerRepeatSpecSpacingCodec {
  def decode(j: JsValue): LayerRepeatSpecSpacing =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LayerRepeatSpecSpacing] =
    j.asOpt[JsNumber].map { LayerRepeatSpecSpacingAsNumber(_) }.orElse {
    RowColNumberCodec.decodeOpt(j) } 
  def encode(j: LayerRepeatSpecSpacing): JsValue =
    j match {
      case LayerRepeatSpecSpacingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:RowColNumber /* TypeRef */ => RowColNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionMarkPropFieldDefNumberTimeUnit (UnionType)
object FieldOrDatumDefWithConditionMarkPropFieldDefNumberTimeUnitCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionMarkPropFieldDefNumberTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionMarkPropFieldDefNumberTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: FieldOrDatumDefWithConditionMarkPropFieldDefNumberTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderConfigLabelLineHeight (UnionType)
object HeaderConfigLabelLineHeightCodec {
  def decode(j: JsValue): HeaderConfigLabelLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigLabelLineHeight] =
    j.asOpt[JsNumber].map { HeaderConfigLabelLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderConfigLabelLineHeight): JsValue =
    j match {
      case HeaderConfigLabelLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigFill (UnionType)
object BarConfigFillCodec {
  def decode(j: JsValue): BarConfigFill =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigFill] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => BarConfigFillAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: BarConfigFill): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case BarConfigFillAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RangeSchemeAsObject3 (StructType)
object RangeSchemeAsObject3Codec {
  def decode(j: JsValue): RangeSchemeAsObject3 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RangeSchemeAsObject3] =
    {
      val `count` = (j \ "count").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `extent` = (j \ "extent").asOpt[JsValue].flatMap { x => ArrayOfNumberCodec.decodeOpt(x) }
      val `scheme` = (j \ "scheme").asOpt[JsValue].flatMap { x => RangeSchemeAsObject3SchemeCodec.decodeOpt(x) }
      if(`scheme`.isEmpty) { return None }
      return Some(RangeSchemeAsObject3(
        `count` = `count`,
        `extent` = `extent`,
        `scheme` = `scheme`.get,
      ))
    }

  def encode(j: RangeSchemeAsObject3): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`count`.map { x => "count" -> Json.toJson(x) },
        j.`extent`.map { x => "extent" -> ArrayOfNumberCodec.encode(x) },
        Some("scheme" -> RangeSchemeAsObject3SchemeCodec.encode(j.`scheme`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConfigPadding (UnionType)
object ConfigPaddingCodec {
  def decode(j: JsValue): ConfigPadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConfigPadding] =
    PaddingCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ConfigPadding): JsValue =
    j match {
      case x:Padding /* TypeRef */ => PaddingCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigCornerRadiusBottomLeft (UnionType)
object RectConfigCornerRadiusBottomLeftCodec {
  def decode(j: JsValue): RectConfigCornerRadiusBottomLeft =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigCornerRadiusBottomLeft] =
    j.asOpt[JsNumber].map { RectConfigCornerRadiusBottomLeftAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigCornerRadiusBottomLeft): JsValue =
    j match {
      case RectConfigCornerRadiusBottomLeftAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingRadius2TimeUnit (UnionType)
object SharedEncodingRadius2TimeUnitCodec {
  def decode(j: JsValue): SharedEncodingRadius2TimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingRadius2TimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingRadius2TimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ErrorBandConfig (StructType)
object ErrorBandConfigCodec {
  def decode(j: JsValue): ErrorBandConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ErrorBandConfig] =
    Some(ErrorBandConfig(
      `extent` = (j \ "extent").asOpt[JsValue].flatMap { x => ErrorBarExtentCodec.decodeOpt(x) },
      `borders` = (j \ "borders").asOpt[JsValue].flatMap { x => ErrorBandConfigBordersCodec.decodeOpt(x) },
      `interpolate` = (j \ "interpolate").asOpt[JsValue].flatMap { x => InterpolateCodec.decodeOpt(x) },
      `tension` = (j \ "tension").asOpt[JsValue].flatMap { x => ErrorBandConfigTensionCodec.decodeOpt(x) },
      `band` = (j \ "band").asOpt[JsValue].flatMap { x => ErrorBandConfigBandCodec.decodeOpt(x) },
    ))

  def encode(j: ErrorBandConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`extent`.map { x => "extent" -> ErrorBarExtentCodec.encode(x) },
        j.`borders`.map { x => "borders" -> ErrorBandConfigBordersCodec.encode(x) },
        j.`interpolate`.map { x => "interpolate" -> InterpolateCodec.encode(x) },
        j.`tension`.map { x => "tension" -> ErrorBandConfigTensionCodec.encode(x) },
        j.`band`.map { x => "band" -> ErrorBandConfigBandCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SelectionConfig (StructType)
object SelectionConfigCodec {
  def decode(j: JsValue): SelectionConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SelectionConfig] =
    Some(SelectionConfig(
      `interval` = (j \ "interval").asOpt[JsValue].flatMap { x => IntervalSelectionConfigWithoutTypeCodec.decodeOpt(x) },
      `point` = (j \ "point").asOpt[JsValue].flatMap { x => PointSelectionConfigWithoutTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SelectionConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`interval`.map { x => "interval" -> IntervalSelectionConfigWithoutTypeCodec.encode(x) },
        j.`point`.map { x => "point" -> PointSelectionConfigWithoutTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// RangeConfigRamp (UnionType)
object RangeConfigRampCodec {
  def decode(j: JsValue): RangeConfigRamp =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RangeConfigRamp] =
    RangeSchemeCodec.decodeOpt(j).orElse {
    ArrayOfColorCodec.decodeOpt(j).map { RangeConfigRampAsArrayOfColor(_) } } 
  def encode(j: RangeConfigRamp): JsValue =
    j match {
      case x:RangeScheme /* TypeRef */ => RangeSchemeCodec.encode(x)
      case RangeConfigRampAsArrayOfColor(x) /* Base, ArrayType */ => ArrayOfColorCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigDescription (UnionType)
object BarConfigDescriptionCodec {
  def decode(j: JsValue): BarConfigDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigDescription] =
    j.asOpt[String].map { BarConfigDescriptionAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigDescription): JsValue =
    j match {
      case BarConfigDescriptionAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfConfigParamsElement (ArrayType)
object ArrayOfConfigParamsElementCodec {
  def decode(j: JsValue): Seq[ConfigParamsElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[ConfigParamsElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      ConfigParamsElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[ConfigParamsElement]): JsArray =
      JsArray(j.map { x => ConfigParamsElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// MarkDefRadius (UnionType)
object MarkDefRadiusCodec {
  def decode(j: JsValue): MarkDefRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefRadius] =
    j.asOpt[JsNumber].map { MarkDefRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefRadius): JsValue =
    j match {
      case MarkDefRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingXOffsetDatum (UnionType)
object SharedEncodingXOffsetDatumCodec {
  def decode(j: JsValue): SharedEncodingXOffsetDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingXOffsetDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingXOffsetDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigX2 (UnionType)
object BarConfigX2Codec {
  def decode(j: JsValue): BarConfigX2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigX2] =
    j.asOpt[JsNumber].map { BarConfigX2AsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: BarConfigX2): JsValue =
    j match {
      case BarConfigX2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingRadiusValue (UnionType)
object SharedEncodingRadiusValueCodec {
  def decode(j: JsValue): SharedEncodingRadiusValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingRadiusValue] =
    j.asOpt[JsNumber].map { SharedEncodingRadiusValueAsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingRadiusValue): JsValue =
    j match {
      case SharedEncodingRadiusValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Axis (StructType)
object AxisCodec {
  def decode(j: JsValue): Axis =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Axis] =
    Some(Axis(
      `labelOpacity` = (j \ "labelOpacity").asOpt[JsValue].flatMap { x => AxisLabelOpacityCodec.decodeOpt(x) },
      `domainCap` = (j \ "domainCap").asOpt[JsValue].flatMap { x => AxisDomainCapCodec.decodeOpt(x) },
      `domainColor` = (j \ "domainColor").asOpt[JsValue].flatMap { x => AxisDomainColorCodec.decodeOpt(x) },
      `style` = (j \ "style").asOpt[JsValue].flatMap { x => AxisStyleCodec.decodeOpt(x) },
      `domain` = (j \ "domain").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `offset` = (j \ "offset").asOpt[JsValue].flatMap { x => AxisOffsetCodec.decodeOpt(x) },
      `gridOpacity` = (j \ "gridOpacity").asOpt[JsValue].flatMap { x => AxisGridOpacityCodec.decodeOpt(x) },
      `labelFontSize` = (j \ "labelFontSize").asOpt[JsValue].flatMap { x => AxisLabelFontSizeCodec.decodeOpt(x) },
      `format` = (j \ "format").asOpt[JsValue].flatMap { x => AxisFormatCodec.decodeOpt(x) },
      `gridWidth` = (j \ "gridWidth").asOpt[JsValue].flatMap { x => AxisGridWidthCodec.decodeOpt(x) },
      `tickCount` = (j \ "tickCount").asOpt[JsValue].flatMap { x => AxisTickCountCodec.decodeOpt(x) },
      `gridCap` = (j \ "gridCap").asOpt[JsValue].flatMap { x => AxisGridCapCodec.decodeOpt(x) },
      `labelAngle` = (j \ "labelAngle").asOpt[JsValue].flatMap { x => AxisLabelAngleCodec.decodeOpt(x) },
      `domainOpacity` = (j \ "domainOpacity").asOpt[JsValue].flatMap { x => AxisDomainOpacityCodec.decodeOpt(x) },
      `description` = (j \ "description").asOpt[JsValue].flatMap { x => AxisDescriptionCodec.decodeOpt(x) },
      `titleFont` = (j \ "titleFont").asOpt[JsValue].flatMap { x => AxisTitleFontCodec.decodeOpt(x) },
      `titleFontStyle` = (j \ "titleFontStyle").asOpt[JsValue].flatMap { x => AxisTitleFontStyleCodec.decodeOpt(x) },
      `tickDashOffset` = (j \ "tickDashOffset").asOpt[JsValue].flatMap { x => AxisTickDashOffsetCodec.decodeOpt(x) },
      `labelColor` = (j \ "labelColor").asOpt[JsValue].flatMap { x => AxisLabelColorCodec.decodeOpt(x) },
      `domainDashOffset` = (j \ "domainDashOffset").asOpt[JsValue].flatMap { x => AxisDomainDashOffsetCodec.decodeOpt(x) },
      `labelFontWeight` = (j \ "labelFontWeight").asOpt[JsValue].flatMap { x => AxisLabelFontWeightCodec.decodeOpt(x) },
      `gridDash` = (j \ "gridDash").asOpt[JsValue].flatMap { x => AxisGridDashCodec.decodeOpt(x) },
      `minExtent` = (j \ "minExtent").asOpt[JsValue].flatMap { x => AxisMinExtentCodec.decodeOpt(x) },
      `titleLineHeight` = (j \ "titleLineHeight").asOpt[JsValue].flatMap { x => AxisTitleLineHeightCodec.decodeOpt(x) },
      `labelLineHeight` = (j \ "labelLineHeight").asOpt[JsValue].flatMap { x => AxisLabelLineHeightCodec.decodeOpt(x) },
      `tickCap` = (j \ "tickCap").asOpt[JsValue].flatMap { x => AxisTickCapCodec.decodeOpt(x) },
      `titleX` = (j \ "titleX").asOpt[JsValue].flatMap { x => AxisTitleXCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => AxisBandPositionCodec.decodeOpt(x) },
      `tickExtra` = (j \ "tickExtra").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `grid` = (j \ "grid").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `tickBand` = (j \ "tickBand").asOpt[JsValue].flatMap { x => AxisTickBandCodec.decodeOpt(x) },
      `titlePadding` = (j \ "titlePadding").asOpt[JsValue].flatMap { x => AxisTitlePaddingCodec.decodeOpt(x) },
      `tickMinStep` = (j \ "tickMinStep").asOpt[JsValue].flatMap { x => AxisTickMinStepCodec.decodeOpt(x) },
      `titleY` = (j \ "titleY").asOpt[JsValue].flatMap { x => AxisTitleYCodec.decodeOpt(x) },
      `labels` = (j \ "labels").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `labelFlush` = (j \ "labelFlush").asOpt[JsValue].flatMap { x => AxisLabelFlushCodec.decodeOpt(x) },
      `zindex` = (j \ "zindex").asOpt[JsValue].flatMap { x => AxisZindexCodec.decodeOpt(x) },
      `formatType` = (j \ "formatType").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `labelLimit` = (j \ "labelLimit").asOpt[JsValue].flatMap { x => AxisLabelLimitCodec.decodeOpt(x) },
      `gridDashOffset` = (j \ "gridDashOffset").asOpt[JsValue].flatMap { x => AxisGridDashOffsetCodec.decodeOpt(x) },
      `titleAnchor` = (j \ "titleAnchor").asOpt[JsValue].flatMap { x => AxisTitleAnchorCodec.decodeOpt(x) },
      `titleColor` = (j \ "titleColor").asOpt[JsValue].flatMap { x => AxisTitleColorCodec.decodeOpt(x) },
      `labelOverlap` = (j \ "labelOverlap").asOpt[JsValue].flatMap { x => AxisLabelOverlapCodec.decodeOpt(x) },
      `translate` = (j \ "translate").asOpt[JsValue].flatMap { x => AxisTranslateCodec.decodeOpt(x) },
      `labelFlushOffset` = (j \ "labelFlushOffset").asOpt[JsValue].flatMap { x => AxisLabelFlushOffsetCodec.decodeOpt(x) },
      `domainWidth` = (j \ "domainWidth").asOpt[JsValue].flatMap { x => AxisDomainWidthCodec.decodeOpt(x) },
      `tickRound` = (j \ "tickRound").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `labelOffset` = (j \ "labelOffset").asOpt[JsValue].flatMap { x => AxisLabelOffsetCodec.decodeOpt(x) },
      `ticks` = (j \ "ticks").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `orient` = (j \ "orient").asOpt[JsValue].flatMap { x => AxisOrientCodec.decodeOpt(x) },
      `domainDash` = (j \ "domainDash").asOpt[JsValue].flatMap { x => AxisDomainDashCodec.decodeOpt(x) },
      `labelAlign` = (j \ "labelAlign").asOpt[JsValue].flatMap { x => AxisLabelAlignCodec.decodeOpt(x) },
      `values` = (j \ "values").asOpt[JsValue].flatMap { x => AxisValuesCodec.decodeOpt(x) },
      `position` = (j \ "position").asOpt[JsValue].flatMap { x => AxisPositionCodec.decodeOpt(x) },
      `titleAngle` = (j \ "titleAngle").asOpt[JsValue].flatMap { x => AxisTitleAngleCodec.decodeOpt(x) },
      `labelPadding` = (j \ "labelPadding").asOpt[JsValue].flatMap { x => AxisLabelPaddingCodec.decodeOpt(x) },
      `aria` = (j \ "aria").asOpt[JsValue].flatMap { x => AxisAriaCodec.decodeOpt(x) },
      `labelExpr` = (j \ "labelExpr").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `tickWidth` = (j \ "tickWidth").asOpt[JsValue].flatMap { x => AxisTickWidthCodec.decodeOpt(x) },
      `tickOffset` = (j \ "tickOffset").asOpt[JsValue].flatMap { x => AxisTickOffsetCodec.decodeOpt(x) },
      `maxExtent` = (j \ "maxExtent").asOpt[JsValue].flatMap { x => AxisMaxExtentCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `tickDash` = (j \ "tickDash").asOpt[JsValue].flatMap { x => AxisTickDashCodec.decodeOpt(x) },
      `labelBound` = (j \ "labelBound").asOpt[JsValue].flatMap { x => AxisLabelBoundCodec.decodeOpt(x) },
      `gridColor` = (j \ "gridColor").asOpt[JsValue].flatMap { x => AxisGridColorCodec.decodeOpt(x) },
      `titleLimit` = (j \ "titleLimit").asOpt[JsValue].flatMap { x => AxisTitleLimitCodec.decodeOpt(x) },
      `labelFont` = (j \ "labelFont").asOpt[JsValue].flatMap { x => AxisLabelFontCodec.decodeOpt(x) },
      `labelFontStyle` = (j \ "labelFontStyle").asOpt[JsValue].flatMap { x => AxisLabelFontStyleCodec.decodeOpt(x) },
      `titleOpacity` = (j \ "titleOpacity").asOpt[JsValue].flatMap { x => AxisTitleOpacityCodec.decodeOpt(x) },
      `titleAlign` = (j \ "titleAlign").asOpt[JsValue].flatMap { x => AxisTitleAlignCodec.decodeOpt(x) },
      `labelSeparation` = (j \ "labelSeparation").asOpt[JsValue].flatMap { x => AxisLabelSeparationCodec.decodeOpt(x) },
      `titleBaseline` = (j \ "titleBaseline").asOpt[JsValue].flatMap { x => AxisTitleBaselineCodec.decodeOpt(x) },
      `tickColor` = (j \ "tickColor").asOpt[JsValue].flatMap { x => AxisTickColorCodec.decodeOpt(x) },
      `titleFontSize` = (j \ "titleFontSize").asOpt[JsValue].flatMap { x => AxisTitleFontSizeCodec.decodeOpt(x) },
      `titleFontWeight` = (j \ "titleFontWeight").asOpt[JsValue].flatMap { x => AxisTitleFontWeightCodec.decodeOpt(x) },
      `tickSize` = (j \ "tickSize").asOpt[JsValue].flatMap { x => AxisTickSizeCodec.decodeOpt(x) },
      `tickOpacity` = (j \ "tickOpacity").asOpt[JsValue].flatMap { x => AxisTickOpacityCodec.decodeOpt(x) },
      `labelBaseline` = (j \ "labelBaseline").asOpt[JsValue].flatMap { x => AxisLabelBaselineCodec.decodeOpt(x) },
    ))

  def encode(j: Axis): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`labelOpacity`.map { x => "labelOpacity" -> AxisLabelOpacityCodec.encode(x) },
        j.`domainCap`.map { x => "domainCap" -> AxisDomainCapCodec.encode(x) },
        j.`domainColor`.map { x => "domainColor" -> AxisDomainColorCodec.encode(x) },
        j.`style`.map { x => "style" -> AxisStyleCodec.encode(x) },
        j.`domain`.map { x => "domain" -> Json.toJson(x) },
        j.`offset`.map { x => "offset" -> AxisOffsetCodec.encode(x) },
        j.`gridOpacity`.map { x => "gridOpacity" -> AxisGridOpacityCodec.encode(x) },
        j.`labelFontSize`.map { x => "labelFontSize" -> AxisLabelFontSizeCodec.encode(x) },
        j.`format`.map { x => "format" -> AxisFormatCodec.encode(x) },
        j.`gridWidth`.map { x => "gridWidth" -> AxisGridWidthCodec.encode(x) },
        j.`tickCount`.map { x => "tickCount" -> AxisTickCountCodec.encode(x) },
        j.`gridCap`.map { x => "gridCap" -> AxisGridCapCodec.encode(x) },
        j.`labelAngle`.map { x => "labelAngle" -> AxisLabelAngleCodec.encode(x) },
        j.`domainOpacity`.map { x => "domainOpacity" -> AxisDomainOpacityCodec.encode(x) },
        j.`description`.map { x => "description" -> AxisDescriptionCodec.encode(x) },
        j.`titleFont`.map { x => "titleFont" -> AxisTitleFontCodec.encode(x) },
        j.`titleFontStyle`.map { x => "titleFontStyle" -> AxisTitleFontStyleCodec.encode(x) },
        j.`tickDashOffset`.map { x => "tickDashOffset" -> AxisTickDashOffsetCodec.encode(x) },
        j.`labelColor`.map { x => "labelColor" -> AxisLabelColorCodec.encode(x) },
        j.`domainDashOffset`.map { x => "domainDashOffset" -> AxisDomainDashOffsetCodec.encode(x) },
        j.`labelFontWeight`.map { x => "labelFontWeight" -> AxisLabelFontWeightCodec.encode(x) },
        j.`gridDash`.map { x => "gridDash" -> AxisGridDashCodec.encode(x) },
        j.`minExtent`.map { x => "minExtent" -> AxisMinExtentCodec.encode(x) },
        j.`titleLineHeight`.map { x => "titleLineHeight" -> AxisTitleLineHeightCodec.encode(x) },
        j.`labelLineHeight`.map { x => "labelLineHeight" -> AxisLabelLineHeightCodec.encode(x) },
        j.`tickCap`.map { x => "tickCap" -> AxisTickCapCodec.encode(x) },
        j.`titleX`.map { x => "titleX" -> AxisTitleXCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> AxisBandPositionCodec.encode(x) },
        j.`tickExtra`.map { x => "tickExtra" -> Json.toJson(x) },
        j.`grid`.map { x => "grid" -> Json.toJson(x) },
        j.`tickBand`.map { x => "tickBand" -> AxisTickBandCodec.encode(x) },
        j.`titlePadding`.map { x => "titlePadding" -> AxisTitlePaddingCodec.encode(x) },
        j.`tickMinStep`.map { x => "tickMinStep" -> AxisTickMinStepCodec.encode(x) },
        j.`titleY`.map { x => "titleY" -> AxisTitleYCodec.encode(x) },
        j.`labels`.map { x => "labels" -> Json.toJson(x) },
        j.`labelFlush`.map { x => "labelFlush" -> AxisLabelFlushCodec.encode(x) },
        j.`zindex`.map { x => "zindex" -> AxisZindexCodec.encode(x) },
        j.`formatType`.map { x => "formatType" -> Json.toJson(x) },
        j.`labelLimit`.map { x => "labelLimit" -> AxisLabelLimitCodec.encode(x) },
        j.`gridDashOffset`.map { x => "gridDashOffset" -> AxisGridDashOffsetCodec.encode(x) },
        j.`titleAnchor`.map { x => "titleAnchor" -> AxisTitleAnchorCodec.encode(x) },
        j.`titleColor`.map { x => "titleColor" -> AxisTitleColorCodec.encode(x) },
        j.`labelOverlap`.map { x => "labelOverlap" -> AxisLabelOverlapCodec.encode(x) },
        j.`translate`.map { x => "translate" -> AxisTranslateCodec.encode(x) },
        j.`labelFlushOffset`.map { x => "labelFlushOffset" -> AxisLabelFlushOffsetCodec.encode(x) },
        j.`domainWidth`.map { x => "domainWidth" -> AxisDomainWidthCodec.encode(x) },
        j.`tickRound`.map { x => "tickRound" -> Json.toJson(x) },
        j.`labelOffset`.map { x => "labelOffset" -> AxisLabelOffsetCodec.encode(x) },
        j.`ticks`.map { x => "ticks" -> Json.toJson(x) },
        j.`orient`.map { x => "orient" -> AxisOrientCodec.encode(x) },
        j.`domainDash`.map { x => "domainDash" -> AxisDomainDashCodec.encode(x) },
        j.`labelAlign`.map { x => "labelAlign" -> AxisLabelAlignCodec.encode(x) },
        j.`values`.map { x => "values" -> AxisValuesCodec.encode(x) },
        j.`position`.map { x => "position" -> AxisPositionCodec.encode(x) },
        j.`titleAngle`.map { x => "titleAngle" -> AxisTitleAngleCodec.encode(x) },
        j.`labelPadding`.map { x => "labelPadding" -> AxisLabelPaddingCodec.encode(x) },
        j.`aria`.map { x => "aria" -> AxisAriaCodec.encode(x) },
        j.`labelExpr`.map { x => "labelExpr" -> Json.toJson(x) },
        j.`tickWidth`.map { x => "tickWidth" -> AxisTickWidthCodec.encode(x) },
        j.`tickOffset`.map { x => "tickOffset" -> AxisTickOffsetCodec.encode(x) },
        j.`maxExtent`.map { x => "maxExtent" -> AxisMaxExtentCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`tickDash`.map { x => "tickDash" -> AxisTickDashCodec.encode(x) },
        j.`labelBound`.map { x => "labelBound" -> AxisLabelBoundCodec.encode(x) },
        j.`gridColor`.map { x => "gridColor" -> AxisGridColorCodec.encode(x) },
        j.`titleLimit`.map { x => "titleLimit" -> AxisTitleLimitCodec.encode(x) },
        j.`labelFont`.map { x => "labelFont" -> AxisLabelFontCodec.encode(x) },
        j.`labelFontStyle`.map { x => "labelFontStyle" -> AxisLabelFontStyleCodec.encode(x) },
        j.`titleOpacity`.map { x => "titleOpacity" -> AxisTitleOpacityCodec.encode(x) },
        j.`titleAlign`.map { x => "titleAlign" -> AxisTitleAlignCodec.encode(x) },
        j.`labelSeparation`.map { x => "labelSeparation" -> AxisLabelSeparationCodec.encode(x) },
        j.`titleBaseline`.map { x => "titleBaseline" -> AxisTitleBaselineCodec.encode(x) },
        j.`tickColor`.map { x => "tickColor" -> AxisTickColorCodec.encode(x) },
        j.`titleFontSize`.map { x => "titleFontSize" -> AxisTitleFontSizeCodec.encode(x) },
        j.`titleFontWeight`.map { x => "titleFontWeight" -> AxisTitleFontWeightCodec.encode(x) },
        j.`tickSize`.map { x => "tickSize" -> AxisTickSizeCodec.encode(x) },
        j.`tickOpacity`.map { x => "tickOpacity" -> AxisTickOpacityCodec.encode(x) },
        j.`labelBaseline`.map { x => "labelBaseline" -> AxisLabelBaselineCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TickConfigUrl (UnionType)
object TickConfigUrlCodec {
  def decode(j: JsValue): TickConfigUrl =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigUrl] =
    UriReferenceCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigUrl): JsValue =
    j match {
      case x:UriReference /* TypeRef */ => UriReferenceCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PointSelectionConfig (StructType)
object PointSelectionConfigCodec {
  def decode(j: JsValue): PointSelectionConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[PointSelectionConfig] =
    {
      val `nearest` = (j \ "nearest").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `clear` = (j \ "clear").asOpt[JsValue].flatMap { x => PointSelectionConfigClearCodec.decodeOpt(x) }
      val `toggle` = (j \ "toggle").asOpt[JsValue].flatMap { x => PointSelectionConfigToggleCodec.decodeOpt(x) }
      val `on` = (j \ "on").asOpt[JsValue].flatMap { x => PointSelectionConfigOnCodec.decodeOpt(x) }
      val `fields` = (j \ "fields").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) }
      val `resolve` = (j \ "resolve").asOpt[JsValue].flatMap { x => SelectionResolutionCodec.decodeOpt(x) }
      val `type` = (j \ "type").asOpt[JsValue].flatMap { x => PointSelectionConfigTypeCodec.decodeOpt(x) }
      if(`type`.isEmpty) { return None }
      val `encodings` = (j \ "encodings").asOpt[JsValue].flatMap { x => ArrayOfSingleDefUnitChannelCodec.decodeOpt(x) }
      return Some(PointSelectionConfig(
        `nearest` = `nearest`,
        `clear` = `clear`,
        `toggle` = `toggle`,
        `on` = `on`,
        `fields` = `fields`,
        `resolve` = `resolve`,
        `type` = `type`.get,
        `encodings` = `encodings`,
      ))
    }

  def encode(j: PointSelectionConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`nearest`.map { x => "nearest" -> Json.toJson(x) },
        j.`clear`.map { x => "clear" -> PointSelectionConfigClearCodec.encode(x) },
        j.`toggle`.map { x => "toggle" -> PointSelectionConfigToggleCodec.encode(x) },
        j.`on`.map { x => "on" -> PointSelectionConfigOnCodec.encode(x) },
        j.`fields`.map { x => "fields" -> ArrayOfStringCodec.encode(x) },
        j.`resolve`.map { x => "resolve" -> SelectionResolutionCodec.encode(x) },
        Some("type" -> PointSelectionConfigTypeCodec.encode(j.`type`)),
        j.`encodings`.map { x => "encodings" -> ArrayOfSingleDefUnitChannelCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TickConfigOuterRadius (ConstrainedType)
// see TickConfigOuterRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// OffsetDef (UnionType)
object OffsetDefCodec {
  def decode(j: JsValue): OffsetDef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OffsetDef] =
    ScaleFieldDefCodec.decodeOpt(j).orElse {
    ScaleDatumDefCodec.decodeOpt(j).orElse {
    ValueDefNumberCodec.decodeOpt(j) } } 
  def encode(j: OffsetDef): JsValue =
    j match {
      case x:ScaleFieldDef /* TypeRef */ => ScaleFieldDefCodec.encode(x)
      case x:ScaleDatumDef /* TypeRef */ => ScaleDatumDefCodec.encode(x)
      case x:ValueDefNumber /* TypeRef */ => ValueDefNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// EncodingHref (UnionType)
object EncodingHrefCodec {
  def decode(j: JsValue): EncodingHref =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[EncodingHref] =
    StringFieldDefWithConditionCodec.decodeOpt(j).orElse {
    StringValueDefWithConditionCodec.decodeOpt(j) } 
  def encode(j: EncodingHref): JsValue =
    j match {
      case x:StringFieldDefWithCondition /* TypeRef */ => StringFieldDefWithConditionCodec.encode(x)
      case x:StringValueDefWithCondition /* TypeRef */ => StringValueDefWithConditionCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigInterpolate (UnionType)
object TickConfigInterpolateCodec {
  def decode(j: JsValue): TickConfigInterpolate =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigInterpolate] =
    InterpolateCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigInterpolate): JsValue =
    j match {
      case x:Interpolate /* TypeRef */ => InterpolateCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigCornerRadiusTopRight (UnionType)
object RectConfigCornerRadiusTopRightCodec {
  def decode(j: JsValue): RectConfigCornerRadiusTopRight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigCornerRadiusTopRight] =
    j.asOpt[JsNumber].map { RectConfigCornerRadiusTopRightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigCornerRadiusTopRight): JsValue =
    j match {
      case RectConfigCornerRadiusTopRightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigStrokeDash (UnionType)
object MarkConfigStrokeDashCodec {
  def decode(j: JsValue): MarkConfigStrokeDash =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigStrokeDash] =
    ArrayOfNumberCodec.decodeOpt(j).map { MarkConfigStrokeDashAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigStrokeDash): JsValue =
    j match {
      case MarkConfigStrokeDashAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisLabelFontWeightAsObject1 (StructType)
object ConditionalAxisLabelFontWeightAsObject1Codec {
  def decode(j: JsValue): ConditionalAxisLabelFontWeightAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalAxisLabelFontWeightAsObject1] =
    {
      val `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => ConditionalAxisLabelFontWeightAsObject1ConditionCodec.decodeOpt(x) }
      if(`condition`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => FontWeightCodec.decodeOpt(x).map { Some(_) }.flatten }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalAxisLabelFontWeightAsObject1(
        `condition` = `condition`.get,
        `value` = `value`,
      ))
    }

  def encode(j: ConditionalAxisLabelFontWeightAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("condition" -> ConditionalAxisLabelFontWeightAsObject1ConditionCodec.encode(j.`condition`)),
        j.`value`.map { x => "value" -> FontWeightCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LineConfigStroke (UnionType)
object LineConfigStrokeCodec {
  def decode(j: JsValue): LineConfigStroke =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigStroke] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => LineConfigStrokeAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: LineConfigStroke): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case LineConfigStrokeAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfTopLevelLayerSpecParamsElement (ArrayType)
object ArrayOfTopLevelLayerSpecParamsElementCodec {
  def decode(j: JsValue): Seq[TopLevelLayerSpecParamsElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[TopLevelLayerSpecParamsElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      TopLevelLayerSpecParamsElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[TopLevelLayerSpecParamsElement]): JsArray =
      JsArray(j.map { x => TopLevelLayerSpecParamsElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// WindowTransform (StructType)
object WindowTransformCodec {
  def decode(j: JsValue): WindowTransform =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[WindowTransform] =
    {
      val `window` = (j \ "window").asOpt[JsValue].flatMap { x => ArrayOfWindowFieldDefCodec.decodeOpt(x) }
      if(`window`.isEmpty) { return None }
      val `frame` = (j \ "frame").asOpt[JsValue].flatMap { x => ArrayOfWindowTransformFrameElementCodec.decodeOpt(x) }
      val `groupby` = (j \ "groupby").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) }
      val `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => ArrayOfSortFieldCodec.decodeOpt(x) }
      val `ignorePeers` = (j \ "ignorePeers").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      return Some(WindowTransform(
        `window` = `window`.get,
        `frame` = `frame`,
        `groupby` = `groupby`,
        `sort` = `sort`,
        `ignorePeers` = `ignorePeers`,
      ))
    }

  def encode(j: WindowTransform): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("window" -> ArrayOfWindowFieldDefCodec.encode(j.`window`)),
        j.`frame`.map { x => "frame" -> ArrayOfWindowTransformFrameElementCodec.encode(x) },
        j.`groupby`.map { x => "groupby" -> ArrayOfStringCodec.encode(x) },
        j.`sort`.map { x => "sort" -> ArrayOfSortFieldCodec.encode(x) },
        j.`ignorePeers`.map { x => "ignorePeers" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// Container (ConstantType)
object ContainerCodec {
  def decode(j: JsValue): Container =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Container] =
    j match {
      case JsString("container") => Some(Container())
      case _ => None
    }
  def encode(j: Container): JsValue =
    JsString("container")
}


////////////////////////////////////////////////////////////////////////
// AxisTickOpacity (UnionType)
object AxisTickOpacityCodec {
  def decode(j: JsValue): AxisTickOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTickOpacity] =
    j.asOpt[JsNumber].map { AxisTickOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisTickOpacity): JsValue =
    j match {
      case AxisTickOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConfigAutosize (UnionType)
object ConfigAutosizeCodec {
  def decode(j: JsValue): ConfigAutosize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConfigAutosize] =
    AutosizeTypeCodec.decodeOpt(j).orElse {
    AutoSizeParamsCodec.decodeOpt(j) } 
  def encode(j: ConfigAutosize): JsValue =
    j match {
      case x:AutosizeType /* TypeRef */ => AutosizeTypeCodec.encode(x)
      case x:AutoSizeParams /* TypeRef */ => AutoSizeParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingOpacityDatum (UnionType)
object SharedEncodingOpacityDatumCodec {
  def decode(j: JsValue): SharedEncodingOpacityDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingOpacityDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingOpacityDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefHeight (UnionType)
object MarkDefHeightCodec {
  def decode(j: JsValue): MarkDefHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefHeight] =
    j.asOpt[JsNumber].map { MarkDefHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RelativeBandSizeCodec.decodeOpt(j) } } 
  def encode(j: MarkDefHeight): JsValue =
    j match {
      case MarkDefHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RelativeBandSize /* TypeRef */ => RelativeBandSizeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigStrokeMiterLimit (UnionType)
object BarConfigStrokeMiterLimitCodec {
  def decode(j: JsValue): BarConfigStrokeMiterLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigStrokeMiterLimit] =
    j.asOpt[JsNumber].map { BarConfigStrokeMiterLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigStrokeMiterLimit): JsValue =
    j match {
      case BarConfigStrokeMiterLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// CompositeMark (UnionType)
object CompositeMarkCodec {
  def decode(j: JsValue): CompositeMark =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[CompositeMark] =
    BoxPlotCodec.decodeOpt(j).orElse {
    ErrorBarCodec.decodeOpt(j).orElse {
    ErrorBandCodec.decodeOpt(j) } } 
  def encode(j: CompositeMark): JsValue =
    j match {
      case x:BoxPlot /* TypeRef */ => BoxPlotCodec.encode(x)
      case x:ErrorBar /* TypeRef */ => ErrorBarCodec.encode(x)
      case x:ErrorBand /* TypeRef */ => ErrorBandCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisLabelFontStyle (UnionType)
object ConditionalAxisLabelFontStyleCodec {
  def decode(j: JsValue): ConditionalAxisLabelFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisLabelFontStyle] =
    ConditionalAxisLabelFontStyleAsObject1Codec.decodeOpt(j).orElse {
    ConditionalAxisLabelFontStyleAsObject2Codec.decodeOpt(j) } 
  def encode(j: ConditionalAxisLabelFontStyle): JsValue =
    j match {
      case x:ConditionalAxisLabelFontStyleAsObject1 /* TypeRef */ => ConditionalAxisLabelFontStyleAsObject1Codec.encode(x)
      case x:ConditionalAxisLabelFontStyleAsObject2 /* TypeRef */ => ConditionalAxisLabelFontStyleAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConcatSpecGenericSpec (StructType)
object ConcatSpecGenericSpecCodec {
  def decode(j: JsValue): ConcatSpecGenericSpec =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConcatSpecGenericSpec] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `center` = (j \ "center").asOpt[JsValue].flatMap { x => ConcatSpecGenericSpecCenterCodec.decodeOpt(x) }
      val `description` = (j \ "description").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `concat` = (j \ "concat").asOpt[JsValue].flatMap { x => ArrayOfSpecCodec.decodeOpt(x) }
      if(`concat`.isEmpty) { return None }
      val `bounds` = (j \ "bounds").asOpt[JsValue].flatMap { x => ConcatSpecGenericSpecBoundsCodec.decodeOpt(x) }
      val `columns` = (j \ "columns").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `resolve` = (j \ "resolve").asOpt[JsValue].flatMap { x => ResolveCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => ConcatSpecGenericSpecTitleCodec.decodeOpt(x) }
      val `align` = (j \ "align").asOpt[JsValue].flatMap { x => ConcatSpecGenericSpecAlignCodec.decodeOpt(x) }
      val `data` = (j \ "data").asOpt[JsValue].flatMap { x => DataCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `spacing` = (j \ "spacing").asOpt[JsValue].flatMap { x => ConcatSpecGenericSpecSpacingCodec.decodeOpt(x) }
      val `transform` = (j \ "transform").asOpt[JsValue].flatMap { x => ArrayOfTransformCodec.decodeOpt(x) }
      return Some(ConcatSpecGenericSpec(
        `name` = `name`,
        `center` = `center`,
        `description` = `description`,
        `concat` = `concat`.get,
        `bounds` = `bounds`,
        `columns` = `columns`,
        `resolve` = `resolve`,
        `title` = `title`,
        `align` = `align`,
        `data` = `data`,
        `spacing` = `spacing`,
        `transform` = `transform`,
      ))
    }

  def encode(j: ConcatSpecGenericSpec): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`center`.map { x => "center" -> ConcatSpecGenericSpecCenterCodec.encode(x) },
        j.`description`.map { x => "description" -> Json.toJson(x) },
        Some("concat" -> ArrayOfSpecCodec.encode(j.`concat`)),
        j.`bounds`.map { x => "bounds" -> ConcatSpecGenericSpecBoundsCodec.encode(x) },
        j.`columns`.map { x => "columns" -> Json.toJson(x) },
        j.`resolve`.map { x => "resolve" -> ResolveCodec.encode(x) },
        j.`title`.map { x => "title" -> ConcatSpecGenericSpecTitleCodec.encode(x) },
        j.`align`.map { x => "align" -> ConcatSpecGenericSpecAlignCodec.encode(x) },
        j.`data`.map { x => "data" -> DataCodec.encode(x) },
        j.`spacing`.map { x => "spacing" -> ConcatSpecGenericSpecSpacingCodec.encode(x) },
        j.`transform`.map { x => "transform" -> ArrayOfTransformCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LegendConfigAria (UnionType)
object LegendConfigAriaCodec {
  def decode(j: JsValue): LegendConfigAria =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigAria] =
    j.asOpt[Boolean].map { LegendConfigAriaAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigAria): JsValue =
    j match {
      case LegendConfigAriaAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisLabelBaselineAsObject1Condition (UnionType)
object ConditionalAxisLabelBaselineAsObject1ConditionCodec {
  def decode(j: JsValue): ConditionalAxisLabelBaselineAsObject1Condition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisLabelBaselineAsObject1Condition] =
    ConditionalPredicateValueDefTextBaselineNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalPredicateValueDefTextBaselineNullExprRefCodec.decodeOpt(j).map { ConditionalAxisLabelBaselineAsObject1ConditionAsArrayOfConditionalPredicateValueDefTextBaselineNullExprRef(_) } } 
  def encode(j: ConditionalAxisLabelBaselineAsObject1Condition): JsValue =
    j match {
      case x:ConditionalPredicateValueDefTextBaselineNullExprRef /* TypeRef */ => ConditionalPredicateValueDefTextBaselineNullExprRefCodec.encode(x)
      case ConditionalAxisLabelBaselineAsObject1ConditionAsArrayOfConditionalPredicateValueDefTextBaselineNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalPredicateValueDefTextBaselineNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigTheta2 (UnionType)
object BarConfigTheta2Codec {
  def decode(j: JsValue): BarConfigTheta2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigTheta2] =
    j.asOpt[JsNumber].map { BarConfigTheta2AsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigTheta2): JsValue =
    j match {
      case BarConfigTheta2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderTitleBaseline (UnionType)
object HeaderTitleBaselineCodec {
  def decode(j: JsValue): HeaderTitleBaseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderTitleBaseline] =
    TextBaselineCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderTitleBaseline): JsValue =
    j match {
      case x:TextBaseline /* TypeRef */ => TextBaselineCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelConcatSpecAutosize (UnionType)
object TopLevelConcatSpecAutosizeCodec {
  def decode(j: JsValue): TopLevelConcatSpecAutosize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelConcatSpecAutosize] =
    AutosizeTypeCodec.decodeOpt(j).orElse {
    AutoSizeParamsCodec.decodeOpt(j) } 
  def encode(j: TopLevelConcatSpecAutosize): JsValue =
    j match {
      case x:AutosizeType /* TypeRef */ => AutosizeTypeCodec.encode(x)
      case x:AutoSizeParams /* TypeRef */ => AutoSizeParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject1 (StructType)
object TopLevelRepeatSpecAsObject1Codec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject1] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `description` = (j \ "description").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `params` = (j \ "params").asOpt[JsValue].flatMap { x => ArrayOfTopLevelRepeatSpecAsObject1ParamsElementCodec.decodeOpt(x) }
      val `config` = (j \ "config").asOpt[JsValue].flatMap { x => ConfigCodec.decodeOpt(x) }
      val `bounds` = (j \ "bounds").asOpt[JsValue].flatMap { x => TopLevelRepeatSpecAsObject1BoundsCodec.decodeOpt(x) }
      val `datasets` = (j \ "datasets").asOpt[JsValue].flatMap { x => DictOfInlineDatasetCodec.decodeOpt(x) }
      val `usermeta` = (j \ "usermeta").asOpt[JsValue].flatMap { x => DictOfAnyCodec.decodeOpt(x) }
      val `columns` = (j \ "columns").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `resolve` = (j \ "resolve").asOpt[JsValue].flatMap { x => ResolveCodec.decodeOpt(x) }
      val `spec` = (j \ "spec").asOpt[JsValue].flatMap { x => NonNormalizedSpecCodec.decodeOpt(x) }
      if(`spec`.isEmpty) { return None }
      val `padding` = (j \ "padding").asOpt[JsValue].flatMap { x => TopLevelRepeatSpecAsObject1PaddingCodec.decodeOpt(x) }
      val `background` = (j \ "background").asOpt[JsValue].flatMap { x => TopLevelRepeatSpecAsObject1BackgroundCodec.decodeOpt(x) }
      val `center` = (j \ "center").asOpt[JsValue].flatMap { x => TopLevelRepeatSpecAsObject1CenterCodec.decodeOpt(x) }
      val `align` = (j \ "align").asOpt[JsValue].flatMap { x => TopLevelRepeatSpecAsObject1AlignCodec.decodeOpt(x) }
      val `data` = (j \ "data").asOpt[JsValue].flatMap { x => DataCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `repeat` = (j \ "repeat").asOpt[JsValue].flatMap { x => TopLevelRepeatSpecAsObject1RepeatCodec.decodeOpt(x) }
      if(`repeat`.isEmpty) { return None }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => TopLevelRepeatSpecAsObject1TitleCodec.decodeOpt(x) }
      val `spacing` = (j \ "spacing").asOpt[JsValue].flatMap { x => TopLevelRepeatSpecAsObject1SpacingCodec.decodeOpt(x) }
      val `$schema` = (j \ "$schema").asOpt[JsValue].flatMap { x => UriCodec.decodeOpt(x) }
      val `autosize` = (j \ "autosize").asOpt[JsValue].flatMap { x => TopLevelRepeatSpecAsObject1AutosizeCodec.decodeOpt(x) }
      val `transform` = (j \ "transform").asOpt[JsValue].flatMap { x => ArrayOfTransformCodec.decodeOpt(x) }
      return Some(TopLevelRepeatSpecAsObject1(
        `name` = `name`,
        `description` = `description`,
        `params` = `params`,
        `config` = `config`,
        `bounds` = `bounds`,
        `datasets` = `datasets`,
        `usermeta` = `usermeta`,
        `columns` = `columns`,
        `resolve` = `resolve`,
        `spec` = `spec`.get,
        `padding` = `padding`,
        `background` = `background`,
        `center` = `center`,
        `align` = `align`,
        `data` = `data`,
        `repeat` = `repeat`.get,
        `title` = `title`,
        `spacing` = `spacing`,
        `$schema` = `$schema`,
        `autosize` = `autosize`,
        `transform` = `transform`,
      ))
    }

  def encode(j: TopLevelRepeatSpecAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`description`.map { x => "description" -> Json.toJson(x) },
        j.`params`.map { x => "params" -> ArrayOfTopLevelRepeatSpecAsObject1ParamsElementCodec.encode(x) },
        j.`config`.map { x => "config" -> ConfigCodec.encode(x) },
        j.`bounds`.map { x => "bounds" -> TopLevelRepeatSpecAsObject1BoundsCodec.encode(x) },
        j.`datasets`.map { x => "datasets" -> DictOfInlineDatasetCodec.encode(x) },
        j.`usermeta`.map { x => "usermeta" -> DictOfAnyCodec.encode(x) },
        j.`columns`.map { x => "columns" -> Json.toJson(x) },
        j.`resolve`.map { x => "resolve" -> ResolveCodec.encode(x) },
        Some("spec" -> NonNormalizedSpecCodec.encode(j.`spec`)),
        j.`padding`.map { x => "padding" -> TopLevelRepeatSpecAsObject1PaddingCodec.encode(x) },
        j.`background`.map { x => "background" -> TopLevelRepeatSpecAsObject1BackgroundCodec.encode(x) },
        j.`center`.map { x => "center" -> TopLevelRepeatSpecAsObject1CenterCodec.encode(x) },
        j.`align`.map { x => "align" -> TopLevelRepeatSpecAsObject1AlignCodec.encode(x) },
        j.`data`.map { x => "data" -> DataCodec.encode(x) },
        Some("repeat" -> TopLevelRepeatSpecAsObject1RepeatCodec.encode(j.`repeat`)),
        j.`title`.map { x => "title" -> TopLevelRepeatSpecAsObject1TitleCodec.encode(x) },
        j.`spacing`.map { x => "spacing" -> TopLevelRepeatSpecAsObject1SpacingCodec.encode(x) },
        j.`$schema`.map { x => "$schema" -> UriCodec.encode(x) },
        j.`autosize`.map { x => "autosize" -> TopLevelRepeatSpecAsObject1AutosizeCodec.encode(x) },
        j.`transform`.map { x => "transform" -> ArrayOfTransformCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// FieldRangePredicateTimeUnit (UnionType)
object FieldRangePredicateTimeUnitCodec {
  def decode(j: JsValue): FieldRangePredicateTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldRangePredicateTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: FieldRangePredicateTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigTitleFontSize (UnionType)
object LegendConfigTitleFontSizeCodec {
  def decode(j: JsValue): LegendConfigTitleFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigTitleFontSize] =
    j.asOpt[JsNumber].map { LegendConfigTitleFontSizeAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigTitleFontSize): JsValue =
    j match {
      case LegendConfigTitleFontSizeAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigDy (UnionType)
object TickConfigDyCodec {
  def decode(j: JsValue): TickConfigDy =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigDy] =
    j.asOpt[JsNumber].map { TickConfigDyAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigDy): JsValue =
    j match {
      case TickConfigDyAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigUrl (UnionType)
object BarConfigUrlCodec {
  def decode(j: JsValue): BarConfigUrl =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigUrl] =
    UriReferenceCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigUrl): JsValue =
    j match {
      case x:UriReference /* TypeRef */ => UriReferenceCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefStrokeOpacityAsNumber (ConstrainedType)
object OverlayMarkDefStrokeOpacityAsNumberCodec {
  def decode(j: JsValue): OverlayMarkDefStrokeOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[OverlayMarkDefStrokeOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { OverlayMarkDefStrokeOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: OverlayMarkDefStrokeOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// EncodingDetail (UnionType)
object EncodingDetailCodec {
  def decode(j: JsValue): EncodingDetail =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[EncodingDetail] =
    FieldDefWithoutScaleCodec.decodeOpt(j).orElse {
    ArrayOfFieldDefWithoutScaleCodec.decodeOpt(j).map { EncodingDetailAsArrayOfFieldDefWithoutScale(_) } } 
  def encode(j: EncodingDetail): JsValue =
    j match {
      case x:FieldDefWithoutScale /* TypeRef */ => FieldDefWithoutScaleCodec.encode(x)
      case EncodingDetailAsArrayOfFieldDefWithoutScale(x) /* Base, ArrayType */ => ArrayOfFieldDefWithoutScaleCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigLabelFontStyle (UnionType)
object LegendConfigLabelFontStyleCodec {
  def decode(j: JsValue): LegendConfigLabelFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigLabelFontStyle] =
    j.asOpt[String].map { LegendConfigLabelFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigLabelFontStyle): JsValue =
    j match {
      case LegendConfigLabelFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTitleFont (UnionType)
object AxisConfigTitleFontCodec {
  def decode(j: JsValue): AxisConfigTitleFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTitleFont] =
    j.asOpt[String].map { AxisConfigTitleFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigTitleFont): JsValue =
    j match {
      case AxisConfigTitleFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// StringFieldDefWithConditionBandPosition (ConstrainedType)
object StringFieldDefWithConditionBandPositionCodec {
  def decode(j: JsValue): StringFieldDefWithConditionBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[StringFieldDefWithConditionBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { StringFieldDefWithConditionBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: StringFieldDefWithConditionBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// RectConfigStrokeOpacityAsNumber (ConstrainedType)
object RectConfigStrokeOpacityAsNumberCodec {
  def decode(j: JsValue): RectConfigStrokeOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RectConfigStrokeOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { RectConfigStrokeOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: RectConfigStrokeOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfigReflectY (UnionType)
object ProjectionConfigReflectYCodec {
  def decode(j: JsValue): ProjectionConfigReflectY =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigReflectY] =
    j.asOpt[Boolean].map { ProjectionConfigReflectYAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigReflectY): JsValue =
    j match {
      case ProjectionConfigReflectYAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfig (StructType)
object TickConfigCodec {
  def decode(j: JsValue): TickConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TickConfig] =
    Some(TickConfig(
      `cornerRadiusBottomRight` = (j \ "cornerRadiusBottomRight").asOpt[JsValue].flatMap { x => TickConfigCornerRadiusBottomRightCodec.decodeOpt(x) },
      `fillOpacity` = (j \ "fillOpacity").asOpt[JsValue].flatMap { x => TickConfigFillOpacityCodec.decodeOpt(x) },
      `strokeMiterLimit` = (j \ "strokeMiterLimit").asOpt[JsValue].flatMap { x => TickConfigStrokeMiterLimitCodec.decodeOpt(x) },
      `dir` = (j \ "dir").asOpt[JsValue].flatMap { x => TickConfigDirCodec.decodeOpt(x) },
      `tooltip` = (j \ "tooltip").asOpt[JsValue].flatMap { x => TickConfigTooltipCodec.decodeOpt(x) },
      `timeUnitBandPosition` = (j \ "timeUnitBandPosition").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `cornerRadiusTopRight` = (j \ "cornerRadiusTopRight").asOpt[JsValue].flatMap { x => TickConfigCornerRadiusTopRightCodec.decodeOpt(x) },
      `outerRadius` = (j \ "outerRadius").asOpt[JsValue].flatMap { x => TickConfigOuterRadiusCodec.decodeOpt(x) },
      `x` = (j \ "x").asOpt[JsValue].flatMap { x => TickConfigXCodec.decodeOpt(x) },
      `dy` = (j \ "dy").asOpt[JsValue].flatMap { x => TickConfigDyCodec.decodeOpt(x) },
      `size` = (j \ "size").asOpt[JsValue].flatMap { x => TickConfigSizeCodec.decodeOpt(x) },
      `smooth` = (j \ "smooth").asOpt[JsValue].flatMap { x => TickConfigSmoothCodec.decodeOpt(x) },
      `url` = (j \ "url").asOpt[JsValue].flatMap { x => TickConfigUrlCodec.decodeOpt(x) },
      `y` = (j \ "y").asOpt[JsValue].flatMap { x => TickConfigYCodec.decodeOpt(x) },
      `strokeOpacity` = (j \ "strokeOpacity").asOpt[JsValue].flatMap { x => TickConfigStrokeOpacityCodec.decodeOpt(x) },
      `ellipsis` = (j \ "ellipsis").asOpt[JsValue].flatMap { x => TickConfigEllipsisCodec.decodeOpt(x) },
      `description` = (j \ "description").asOpt[JsValue].flatMap { x => TickConfigDescriptionCodec.decodeOpt(x) },
      `angle` = (j \ "angle").asOpt[JsValue].flatMap { x => TickConfigAngleCodec.decodeOpt(x) },
      `lineBreak` = (j \ "lineBreak").asOpt[JsValue].flatMap { x => TickConfigLineBreakCodec.decodeOpt(x) },
      `tension` = (j \ "tension").asOpt[JsValue].flatMap { x => TickConfigTensionCodec.decodeOpt(x) },
      `cornerRadiusTopLeft` = (j \ "cornerRadiusTopLeft").asOpt[JsValue].flatMap { x => TickConfigCornerRadiusTopLeftCodec.decodeOpt(x) },
      `stroke` = (j \ "stroke").asOpt[JsValue].flatMap { x => TickConfigStrokeCodec.decodeOpt(x) },
      `strokeDashOffset` = (j \ "strokeDashOffset").asOpt[JsValue].flatMap { x => TickConfigStrokeDashOffsetCodec.decodeOpt(x) },
      `align` = (j \ "align").asOpt[JsValue].flatMap { x => TickConfigAlignCodec.decodeOpt(x) },
      `ariaRole` = (j \ "ariaRole").asOpt[JsValue].flatMap { x => TickConfigAriaRoleCodec.decodeOpt(x) },
      `strokeCap` = (j \ "strokeCap").asOpt[JsValue].flatMap { x => TickConfigStrokeCapCodec.decodeOpt(x) },
      `endAngle` = (j \ "endAngle").asOpt[JsValue].flatMap { x => TickConfigEndAngleCodec.decodeOpt(x) },
      `strokeJoin` = (j \ "strokeJoin").asOpt[JsValue].flatMap { x => TickConfigStrokeJoinCodec.decodeOpt(x) },
      `baseline` = (j \ "baseline").asOpt[JsValue].flatMap { x => TickConfigBaselineCodec.decodeOpt(x) },
      `ariaRoleDescription` = (j \ "ariaRoleDescription").asOpt[JsValue].flatMap { x => TickConfigAriaRoleDescriptionCodec.decodeOpt(x) },
      `aspect` = (j \ "aspect").asOpt[JsValue].flatMap { x => TickConfigAspectCodec.decodeOpt(x) },
      `height` = (j \ "height").asOpt[JsValue].flatMap { x => TickConfigHeightCodec.decodeOpt(x) },
      `fontStyle` = (j \ "fontStyle").asOpt[JsValue].flatMap { x => TickConfigFontStyleCodec.decodeOpt(x) },
      `bandSize` = (j \ "bandSize").asOpt[JsValue].flatMap { x => TickConfigBandSizeCodec.decodeOpt(x) },
      `text` = (j \ "text").asOpt[JsValue].flatMap { x => TickConfigTextCodec.decodeOpt(x) },
      `cornerRadius` = (j \ "cornerRadius").asOpt[JsValue].flatMap { x => TickConfigCornerRadiusCodec.decodeOpt(x) },
      `color` = (j \ "color").asOpt[JsValue].flatMap { x => TickConfigColorCodec.decodeOpt(x) },
      `x2` = (j \ "x2").asOpt[JsValue].flatMap { x => TickConfigX2Codec.decodeOpt(x) },
      `padAngle` = (j \ "padAngle").asOpt[JsValue].flatMap { x => TickConfigPadAngleCodec.decodeOpt(x) },
      `cursor` = (j \ "cursor").asOpt[JsValue].flatMap { x => TickConfigCursorCodec.decodeOpt(x) },
      `thickness` = (j \ "thickness").asOpt[JsValue].flatMap { x => TickConfigThicknessCodec.decodeOpt(x) },
      `radius` = (j \ "radius").asOpt[JsValue].flatMap { x => TickConfigRadiusCodec.decodeOpt(x) },
      `timeUnitBandSize` = (j \ "timeUnitBandSize").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `startAngle` = (j \ "startAngle").asOpt[JsValue].flatMap { x => TickConfigStartAngleCodec.decodeOpt(x) },
      `font` = (j \ "font").asOpt[JsValue].flatMap { x => TickConfigFontCodec.decodeOpt(x) },
      `radius2` = (j \ "radius2").asOpt[JsValue].flatMap { x => TickConfigRadius2Codec.decodeOpt(x) },
      `invalid` = (j \ "invalid").asOpt[JsValue].flatMap { x => TickConfigInvalidCodec.decodeOpt(x) },
      `lineHeight` = (j \ "lineHeight").asOpt[JsValue].flatMap { x => TickConfigLineHeightCodec.decodeOpt(x) },
      `order` = (j \ "order").asOpt[JsValue].flatMap { x => TickConfigOrderCodec.decodeOpt(x) },
      `fill` = (j \ "fill").asOpt[JsValue].flatMap { x => TickConfigFillCodec.decodeOpt(x) },
      `interpolate` = (j \ "interpolate").asOpt[JsValue].flatMap { x => TickConfigInterpolateCodec.decodeOpt(x) },
      `theta` = (j \ "theta").asOpt[JsValue].flatMap { x => TickConfigThetaCodec.decodeOpt(x) },
      `orient` = (j \ "orient").asOpt[JsValue].flatMap { x => OrientationCodec.decodeOpt(x) },
      `innerRadius` = (j \ "innerRadius").asOpt[JsValue].flatMap { x => TickConfigInnerRadiusCodec.decodeOpt(x) },
      `fontSize` = (j \ "fontSize").asOpt[JsValue].flatMap { x => TickConfigFontSizeCodec.decodeOpt(x) },
      `y2` = (j \ "y2").asOpt[JsValue].flatMap { x => TickConfigY2Codec.decodeOpt(x) },
      `shape` = (j \ "shape").asOpt[JsValue].flatMap { x => TickConfigShapeCodec.decodeOpt(x) },
      `aria` = (j \ "aria").asOpt[JsValue].flatMap { x => TickConfigAriaCodec.decodeOpt(x) },
      `opacity` = (j \ "opacity").asOpt[JsValue].flatMap { x => TickConfigOpacityCodec.decodeOpt(x) },
      `dx` = (j \ "dx").asOpt[JsValue].flatMap { x => TickConfigDxCodec.decodeOpt(x) },
      `cornerRadiusBottomLeft` = (j \ "cornerRadiusBottomLeft").asOpt[JsValue].flatMap { x => TickConfigCornerRadiusBottomLeftCodec.decodeOpt(x) },
      `href` = (j \ "href").asOpt[JsValue].flatMap { x => TickConfigHrefCodec.decodeOpt(x) },
      `strokeDash` = (j \ "strokeDash").asOpt[JsValue].flatMap { x => TickConfigStrokeDashCodec.decodeOpt(x) },
      `strokeOffset` = (j \ "strokeOffset").asOpt[JsValue].flatMap { x => TickConfigStrokeOffsetCodec.decodeOpt(x) },
      `limit` = (j \ "limit").asOpt[JsValue].flatMap { x => TickConfigLimitCodec.decodeOpt(x) },
      `width` = (j \ "width").asOpt[JsValue].flatMap { x => TickConfigWidthCodec.decodeOpt(x) },
      `fontWeight` = (j \ "fontWeight").asOpt[JsValue].flatMap { x => TickConfigFontWeightCodec.decodeOpt(x) },
      `filled` = (j \ "filled").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `blend` = (j \ "blend").asOpt[JsValue].flatMap { x => TickConfigBlendCodec.decodeOpt(x) },
      `strokeWidth` = (j \ "strokeWidth").asOpt[JsValue].flatMap { x => TickConfigStrokeWidthCodec.decodeOpt(x) },
      `theta2` = (j \ "theta2").asOpt[JsValue].flatMap { x => TickConfigTheta2Codec.decodeOpt(x) },
    ))

  def encode(j: TickConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`cornerRadiusBottomRight`.map { x => "cornerRadiusBottomRight" -> TickConfigCornerRadiusBottomRightCodec.encode(x) },
        j.`fillOpacity`.map { x => "fillOpacity" -> TickConfigFillOpacityCodec.encode(x) },
        j.`strokeMiterLimit`.map { x => "strokeMiterLimit" -> TickConfigStrokeMiterLimitCodec.encode(x) },
        j.`dir`.map { x => "dir" -> TickConfigDirCodec.encode(x) },
        j.`tooltip`.map { x => "tooltip" -> TickConfigTooltipCodec.encode(x) },
        j.`timeUnitBandPosition`.map { x => "timeUnitBandPosition" -> Json.toJson(x) },
        j.`cornerRadiusTopRight`.map { x => "cornerRadiusTopRight" -> TickConfigCornerRadiusTopRightCodec.encode(x) },
        j.`outerRadius`.map { x => "outerRadius" -> TickConfigOuterRadiusCodec.encode(x) },
        j.`x`.map { x => "x" -> TickConfigXCodec.encode(x) },
        j.`dy`.map { x => "dy" -> TickConfigDyCodec.encode(x) },
        j.`size`.map { x => "size" -> TickConfigSizeCodec.encode(x) },
        j.`smooth`.map { x => "smooth" -> TickConfigSmoothCodec.encode(x) },
        j.`url`.map { x => "url" -> TickConfigUrlCodec.encode(x) },
        j.`y`.map { x => "y" -> TickConfigYCodec.encode(x) },
        j.`strokeOpacity`.map { x => "strokeOpacity" -> TickConfigStrokeOpacityCodec.encode(x) },
        j.`ellipsis`.map { x => "ellipsis" -> TickConfigEllipsisCodec.encode(x) },
        j.`description`.map { x => "description" -> TickConfigDescriptionCodec.encode(x) },
        j.`angle`.map { x => "angle" -> TickConfigAngleCodec.encode(x) },
        j.`lineBreak`.map { x => "lineBreak" -> TickConfigLineBreakCodec.encode(x) },
        j.`tension`.map { x => "tension" -> TickConfigTensionCodec.encode(x) },
        j.`cornerRadiusTopLeft`.map { x => "cornerRadiusTopLeft" -> TickConfigCornerRadiusTopLeftCodec.encode(x) },
        j.`stroke`.map { x => "stroke" -> TickConfigStrokeCodec.encode(x) },
        j.`strokeDashOffset`.map { x => "strokeDashOffset" -> TickConfigStrokeDashOffsetCodec.encode(x) },
        j.`align`.map { x => "align" -> TickConfigAlignCodec.encode(x) },
        j.`ariaRole`.map { x => "ariaRole" -> TickConfigAriaRoleCodec.encode(x) },
        j.`strokeCap`.map { x => "strokeCap" -> TickConfigStrokeCapCodec.encode(x) },
        j.`endAngle`.map { x => "endAngle" -> TickConfigEndAngleCodec.encode(x) },
        j.`strokeJoin`.map { x => "strokeJoin" -> TickConfigStrokeJoinCodec.encode(x) },
        j.`baseline`.map { x => "baseline" -> TickConfigBaselineCodec.encode(x) },
        j.`ariaRoleDescription`.map { x => "ariaRoleDescription" -> TickConfigAriaRoleDescriptionCodec.encode(x) },
        j.`aspect`.map { x => "aspect" -> TickConfigAspectCodec.encode(x) },
        j.`height`.map { x => "height" -> TickConfigHeightCodec.encode(x) },
        j.`fontStyle`.map { x => "fontStyle" -> TickConfigFontStyleCodec.encode(x) },
        j.`bandSize`.map { x => "bandSize" -> TickConfigBandSizeCodec.encode(x) },
        j.`text`.map { x => "text" -> TickConfigTextCodec.encode(x) },
        j.`cornerRadius`.map { x => "cornerRadius" -> TickConfigCornerRadiusCodec.encode(x) },
        j.`color`.map { x => "color" -> TickConfigColorCodec.encode(x) },
        j.`x2`.map { x => "x2" -> TickConfigX2Codec.encode(x) },
        j.`padAngle`.map { x => "padAngle" -> TickConfigPadAngleCodec.encode(x) },
        j.`cursor`.map { x => "cursor" -> TickConfigCursorCodec.encode(x) },
        j.`thickness`.map { x => "thickness" -> TickConfigThicknessCodec.encode(x) },
        j.`radius`.map { x => "radius" -> TickConfigRadiusCodec.encode(x) },
        j.`timeUnitBandSize`.map { x => "timeUnitBandSize" -> Json.toJson(x) },
        j.`startAngle`.map { x => "startAngle" -> TickConfigStartAngleCodec.encode(x) },
        j.`font`.map { x => "font" -> TickConfigFontCodec.encode(x) },
        j.`radius2`.map { x => "radius2" -> TickConfigRadius2Codec.encode(x) },
        j.`invalid`.map { x => "invalid" -> TickConfigInvalidCodec.encode(x) },
        j.`lineHeight`.map { x => "lineHeight" -> TickConfigLineHeightCodec.encode(x) },
        j.`order`.map { x => "order" -> TickConfigOrderCodec.encode(x) },
        j.`fill`.map { x => "fill" -> TickConfigFillCodec.encode(x) },
        j.`interpolate`.map { x => "interpolate" -> TickConfigInterpolateCodec.encode(x) },
        j.`theta`.map { x => "theta" -> TickConfigThetaCodec.encode(x) },
        j.`orient`.map { x => "orient" -> OrientationCodec.encode(x) },
        j.`innerRadius`.map { x => "innerRadius" -> TickConfigInnerRadiusCodec.encode(x) },
        j.`fontSize`.map { x => "fontSize" -> TickConfigFontSizeCodec.encode(x) },
        j.`y2`.map { x => "y2" -> TickConfigY2Codec.encode(x) },
        j.`shape`.map { x => "shape" -> TickConfigShapeCodec.encode(x) },
        j.`aria`.map { x => "aria" -> TickConfigAriaCodec.encode(x) },
        j.`opacity`.map { x => "opacity" -> TickConfigOpacityCodec.encode(x) },
        j.`dx`.map { x => "dx" -> TickConfigDxCodec.encode(x) },
        j.`cornerRadiusBottomLeft`.map { x => "cornerRadiusBottomLeft" -> TickConfigCornerRadiusBottomLeftCodec.encode(x) },
        j.`href`.map { x => "href" -> TickConfigHrefCodec.encode(x) },
        j.`strokeDash`.map { x => "strokeDash" -> TickConfigStrokeDashCodec.encode(x) },
        j.`strokeOffset`.map { x => "strokeOffset" -> TickConfigStrokeOffsetCodec.encode(x) },
        j.`limit`.map { x => "limit" -> TickConfigLimitCodec.encode(x) },
        j.`width`.map { x => "width" -> TickConfigWidthCodec.encode(x) },
        j.`fontWeight`.map { x => "fontWeight" -> TickConfigFontWeightCodec.encode(x) },
        j.`filled`.map { x => "filled" -> Json.toJson(x) },
        j.`blend`.map { x => "blend" -> TickConfigBlendCodec.encode(x) },
        j.`strokeWidth`.map { x => "strokeWidth" -> TickConfigStrokeWidthCodec.encode(x) },
        j.`theta2`.map { x => "theta2" -> TickConfigTheta2Codec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SecondaryFieldDefBandPosition (ConstrainedType)
object SecondaryFieldDefBandPositionCodec {
  def decode(j: JsValue): SecondaryFieldDefBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SecondaryFieldDefBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SecondaryFieldDefBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SecondaryFieldDefBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigBarBandPaddingInner (UnionType)
object ScaleConfigBarBandPaddingInnerCodec {
  def decode(j: JsValue): ScaleConfigBarBandPaddingInner =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleConfigBarBandPaddingInner] =
    j.asOpt[JsNumber].map { ScaleConfigBarBandPaddingInnerAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleConfigBarBandPaddingInner): JsValue =
    j match {
      case ScaleConfigBarBandPaddingInnerAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BindDirectElement (UnionType)
object BindDirectElementCodec {
  def decode(j: JsValue): BindDirectElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BindDirectElement] =
    j.asOpt[String].map { BindDirectElementAsString(_) }.orElse {
    j.asOpt[JsObject].map { _ => Json.obj() }.map { _ => BindDirectElementAsEmptyObject } } 
  def encode(j: BindDirectElement): JsValue =
    j match {
      case BindDirectElementAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case BindDirectElementAsEmptyObject /* Global, EmptyObject$ */ => Json.obj()
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderConfigLabelFontSize (ConstrainedType)
// see HeaderConfigLabelFontSize (UnionType)

////////////////////////////////////////////////////////////////////////
// FacetSpecCenter (UnionType)
object FacetSpecCenterCodec {
  def decode(j: JsValue): FacetSpecCenter =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetSpecCenter] =
    j.asOpt[Boolean].map { FacetSpecCenterAsBool(_) }.orElse {
    RowColBooleanCodec.decodeOpt(j) } 
  def encode(j: FacetSpecCenter): JsValue =
    j match {
      case FacetSpecCenterAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:RowColBoolean /* TypeRef */ => RowColBooleanCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigAria (UnionType)
object AreaConfigAriaCodec {
  def decode(j: JsValue): AreaConfigAria =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigAria] =
    j.asOpt[Boolean].map { AreaConfigAriaAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigAria): JsValue =
    j match {
      case AreaConfigAriaAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefFillOpacityAsNumber (ConstrainedType)
object MarkDefFillOpacityAsNumberCodec {
  def decode(j: JsValue): MarkDefFillOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[MarkDefFillOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { MarkDefFillOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: MarkDefFillOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisLabelAlign (UnionType)
object ConditionalAxisLabelAlignCodec {
  def decode(j: JsValue): ConditionalAxisLabelAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisLabelAlign] =
    ConditionalAxisLabelAlignAsObject1Codec.decodeOpt(j).orElse {
    ConditionalAxisLabelAlignAsObject2Codec.decodeOpt(j) } 
  def encode(j: ConditionalAxisLabelAlign): JsValue =
    j match {
      case x:ConditionalAxisLabelAlignAsObject1 /* TypeRef */ => ConditionalAxisLabelAlignAsObject1Codec.encode(x)
      case x:ConditionalAxisLabelAlignAsObject2 /* TypeRef */ => ConditionalAxisLabelAlignAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNull (StructType)
object FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNull =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNull] =
    Some(FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNull(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullConditionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullBinCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) },
    ))

  def encode(j: FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNull): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullConditionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullBinCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// FieldLTPredicateLt (UnionType)
object FieldLTPredicateLtCodec {
  def decode(j: JsValue): FieldLTPredicateLt =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldLTPredicateLt] =
    j.asOpt[String].map { FieldLTPredicateLtAsString(_) }.orElse {
    j.asOpt[JsNumber].map { FieldLTPredicateLtAsNumber(_) }.orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: FieldLTPredicateLt): JsValue =
    j match {
      case FieldLTPredicateLtAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case FieldLTPredicateLtAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTitleX (UnionType)
object AxisConfigTitleXCodec {
  def decode(j: JsValue): AxisConfigTitleX =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTitleX] =
    j.asOpt[JsNumber].map { AxisConfigTitleXAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigTitleX): JsValue =
    j match {
      case AxisConfigTitleXAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfConditionalValueDefGradientStringNullExprRef (ArrayType)
object ArrayOfConditionalValueDefGradientStringNullExprRefCodec {
  def decode(j: JsValue): Seq[ConditionalValueDefGradientStringNullExprRef] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[ConditionalValueDefGradientStringNullExprRef]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      ConditionalValueDefGradientStringNullExprRefCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[ConditionalValueDefGradientStringNullExprRef]): JsArray =
      JsArray(j.map { x => ConditionalValueDefGradientStringNullExprRefCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingAngleCondition (UnionType)
object SharedEncodingAngleConditionCodec {
  def decode(j: JsValue): SharedEncodingAngleCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingAngleCondition] =
    ConditionalValueDefNumberExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefNumberExprRefCodec.decodeOpt(j).map { SharedEncodingAngleConditionAsArrayOfConditionalValueDefNumberExprRef(_) }.orElse {
    ConditionalMarkPropFieldOrDatumDefCodec.decodeOpt(j) } } 
  def encode(j: SharedEncodingAngleCondition): JsValue =
    j match {
      case x:ConditionalValueDefNumberExprRef /* TypeRef */ => ConditionalValueDefNumberExprRefCodec.encode(x)
      case SharedEncodingAngleConditionAsArrayOfConditionalValueDefNumberExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefNumberExprRefCodec.encode(x)
      case x:ConditionalMarkPropFieldOrDatumDef /* TypeRef */ => ConditionalMarkPropFieldOrDatumDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisLabelAlign (UnionType)
object AxisLabelAlignCodec {
  def decode(j: JsValue): AxisLabelAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisLabelAlign] =
    AlignCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisLabelAlignCodec.decodeOpt(j) } } 
  def encode(j: AxisLabelAlign): JsValue =
    j match {
      case x:Align /* TypeRef */ => AlignCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisLabelAlign /* TypeRef */ => ConditionalAxisLabelAlignCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetMapping (StructType)
object FacetMappingCodec {
  def decode(j: JsValue): FacetMapping =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FacetMapping] =
    Some(FacetMapping(
      `column` = (j \ "column").asOpt[JsValue].flatMap { x => FacetFieldDefCodec.decodeOpt(x) },
      `row` = (j \ "row").asOpt[JsValue].flatMap { x => FacetFieldDefCodec.decodeOpt(x) },
    ))

  def encode(j: FacetMapping): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`column`.map { x => "column" -> FacetFieldDefCodec.encode(x) },
        j.`row`.map { x => "row" -> FacetFieldDefCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LegendConfigSymbolStrokeWidthAsNumber (ConstrainedType)
object LegendConfigSymbolStrokeWidthAsNumberCodec {
  def decode(j: JsValue): LegendConfigSymbolStrokeWidthAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LegendConfigSymbolStrokeWidthAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { LegendConfigSymbolStrokeWidthAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: LegendConfigSymbolStrokeWidthAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkDefStrokeMiterLimit (UnionType)
object MarkDefStrokeMiterLimitCodec {
  def decode(j: JsValue): MarkDefStrokeMiterLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefStrokeMiterLimit] =
    j.asOpt[JsNumber].map { MarkDefStrokeMiterLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefStrokeMiterLimit): JsValue =
    j match {
      case MarkDefStrokeMiterLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigPadAngle (UnionType)
object LineConfigPadAngleCodec {
  def decode(j: JsValue): LineConfigPadAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigPadAngle] =
    j.asOpt[JsNumber].map { LineConfigPadAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigPadAngle): JsValue =
    j match {
      case LineConfigPadAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// NonLayerRepeatSpecTitle (UnionType)
object NonLayerRepeatSpecTitleCodec {
  def decode(j: JsValue): NonLayerRepeatSpecTitle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[NonLayerRepeatSpecTitle] =
    TextCodec.decodeOpt(j).orElse {
    TitleParamsCodec.decodeOpt(j) } 
  def encode(j: NonLayerRepeatSpecTitle): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:TitleParams /* TypeRef */ => TitleParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsColor (UnionType)
object TitleParamsColorCodec {
  def decode(j: JsValue): TitleParamsColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => TitleParamsColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: TitleParamsColor): JsValue =
    j match {
      case TitleParamsColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// IntervalSelectionConfigWithoutTypeClear (UnionType)
object IntervalSelectionConfigWithoutTypeClearCodec {
  def decode(j: JsValue): IntervalSelectionConfigWithoutTypeClear =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[IntervalSelectionConfigWithoutTypeClear] =
    StreamCodec.decodeOpt(j).orElse {
    j.asOpt[String].map { IntervalSelectionConfigWithoutTypeClearAsString(_) }.orElse {
    j.asOpt[Boolean].map { IntervalSelectionConfigWithoutTypeClearAsBool(_) } } } 
  def encode(j: IntervalSelectionConfigWithoutTypeClear): JsValue =
    j match {
      case x:Stream /* TypeRef */ => StreamCodec.encode(x)
      case IntervalSelectionConfigWithoutTypeClearAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case IntervalSelectionConfigWithoutTypeClearAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigMaxSize (ConstrainedType)
object ScaleConfigMaxSizeCodec {
  def decode(j: JsValue): ScaleConfigMaxSize =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ScaleConfigMaxSize] =
    try {
      j.asOpt[JsNumber]
        .map { ScaleConfigMaxSize(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ScaleConfigMaxSize): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkConfigShape (UnionType)
object MarkConfigShapeCodec {
  def decode(j: JsValue): MarkConfigShape =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigShape] =
    j.asOpt[String].map { MarkConfigShapeAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigShape): JsValue =
    j match {
      case MarkConfigShapeAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingXErrorTimeUnit (UnionType)
object SharedEncodingXErrorTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingXErrorTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingXErrorTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingXErrorTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefBaseline (UnionType)
object OverlayMarkDefBaselineCodec {
  def decode(j: JsValue): OverlayMarkDefBaseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefBaseline] =
    TextBaselineCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefBaseline): JsValue =
    j match {
      case x:TextBaseline /* TypeRef */ => TextBaselineCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTitleY (UnionType)
object AxisTitleYCodec {
  def decode(j: JsValue): AxisTitleY =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTitleY] =
    j.asOpt[JsNumber].map { AxisTitleYAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisTitleY): JsValue =
    j match {
      case AxisTitleYAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingUrlBin (UnionType)
object SharedEncodingUrlBinCodec {
  def decode(j: JsValue): SharedEncodingUrlBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingUrlBin] =
    j.asOpt[Boolean].map { SharedEncodingUrlBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    BinnedCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingUrlBinAsNull } } } } 
  def encode(j: SharedEncodingUrlBin): JsValue =
    j match {
      case SharedEncodingUrlBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case x:Binned /* TypeRef */ => BinnedCodec.encode(x)
      case SharedEncodingUrlBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// FacetedUnitSpecTitle (UnionType)
object FacetedUnitSpecTitleCodec {
  def decode(j: JsValue): FacetedUnitSpecTitle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetedUnitSpecTitle] =
    TextCodec.decodeOpt(j).orElse {
    TitleParamsCodec.decodeOpt(j) } 
  def encode(j: FacetedUnitSpecTitle): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:TitleParams /* TypeRef */ => TitleParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingLatitude2Datum (UnionType)
object SharedEncodingLatitude2DatumCodec {
  def decode(j: JsValue): SharedEncodingLatitude2Datum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingLatitude2Datum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingLatitude2Datum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigStrokeDash (UnionType)
object TickConfigStrokeDashCodec {
  def decode(j: JsValue): TickConfigStrokeDash =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigStrokeDash] =
    ArrayOfNumberCodec.decodeOpt(j).map { TickConfigStrokeDashAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigStrokeDash): JsValue =
    j match {
      case TickConfigStrokeDashAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateMarkPropFieldOrDatumDefAsObject1BandPosition (ConstrainedType)
object ConditionalPredicateMarkPropFieldOrDatumDefAsObject1BandPositionCodec {
  def decode(j: JsValue): ConditionalPredicateMarkPropFieldOrDatumDefAsObject1BandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateMarkPropFieldOrDatumDefAsObject1BandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { ConditionalPredicateMarkPropFieldOrDatumDefAsObject1BandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ConditionalPredicateMarkPropFieldOrDatumDefAsObject1BandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// LineConfigStrokeCap (UnionType)
object LineConfigStrokeCapCodec {
  def decode(j: JsValue): LineConfigStrokeCap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigStrokeCap] =
    StrokeCapCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigStrokeCap): JsValue =
    j match {
      case x:StrokeCap /* TypeRef */ => StrokeCapCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingFillValue (UnionType)
object SharedEncodingFillValueCodec {
  def decode(j: JsValue): SharedEncodingFillValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingFillValue] =
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[String].map { SharedEncodingFillValueAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingFillValueAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingFillValue): JsValue =
    j match {
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case SharedEncodingFillValueAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case SharedEncodingFillValueAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisBandPosition (UnionType)
object AxisBandPositionCodec {
  def decode(j: JsValue): AxisBandPosition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisBandPosition] =
    j.asOpt[JsNumber].map { AxisBandPositionAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisBandPosition): JsValue =
    j match {
      case AxisBandPositionAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefTheta (UnionType)
object MarkDefThetaCodec {
  def decode(j: JsValue): MarkDefTheta =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefTheta] =
    j.asOpt[JsNumber].map { MarkDefThetaAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefTheta): JsValue =
    j match {
      case MarkDefThetaAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigOuterRadius (ConstrainedType)
// see AreaConfigOuterRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// LegendConfigSymbolSize (UnionType)
object LegendConfigSymbolSizeCodec {
  def decode(j: JsValue): LegendConfigSymbolSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigSymbolSize] =
    LegendConfigSymbolSizeAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigSymbolSize): JsValue =
    j match {
      case x:LegendConfigSymbolSizeAsNumber /* TypeRef */ => LegendConfigSymbolSizeAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigEllipsis (UnionType)
object TickConfigEllipsisCodec {
  def decode(j: JsValue): TickConfigEllipsis =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigEllipsis] =
    j.asOpt[String].map { TickConfigEllipsisAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigEllipsis): JsValue =
    j match {
      case TickConfigEllipsisAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// CsvDataFormatType (EnumType)
object CsvDataFormatTypeCodec {
  def decode(j: JsValue): CsvDataFormatType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[CsvDataFormatType] =
    j match {
      case JsString("csv") => Some(CsvDataFormatTypeCsv)
      case JsString("tsv") => Some(CsvDataFormatTypeTsv)
      case _ => None
    }
  def encode(j: CsvDataFormatType): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullBin (UnionType)
object FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullBinCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullBin] =
    j.asOpt[Boolean].map { FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullBinAsNull } } } 
  def encode(j: FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullBin): JsValue =
    j match {
      case FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalMarkPropFieldOrDatumDef (UnionType)
object ConditionalMarkPropFieldOrDatumDefCodec {
  def decode(j: JsValue): ConditionalMarkPropFieldOrDatumDef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalMarkPropFieldOrDatumDef] =
    ConditionalPredicateMarkPropFieldOrDatumDefCodec.decodeOpt(j).orElse {
    ConditionalParameterMarkPropFieldOrDatumDefCodec.decodeOpt(j) } 
  def encode(j: ConditionalMarkPropFieldOrDatumDef): JsValue =
    j match {
      case x:ConditionalPredicateMarkPropFieldOrDatumDef /* TypeRef */ => ConditionalPredicateMarkPropFieldOrDatumDefCodec.encode(x)
      case x:ConditionalParameterMarkPropFieldOrDatumDef /* TypeRef */ => ConditionalParameterMarkPropFieldOrDatumDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigFillOpacityAsNumber (ConstrainedType)
object MarkConfigFillOpacityAsNumberCodec {
  def decode(j: JsValue): MarkConfigFillOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[MarkConfigFillOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { MarkConfigFillOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: MarkConfigFillOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// BindRadioSelect (StructType)
object BindRadioSelectCodec {
  def decode(j: JsValue): BindRadioSelect =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BindRadioSelect] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `element` = (j \ "element").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `options` = (j \ "options").asOpt[JsValue].flatMap { x => ArrayOfAnyCodec.decodeOpt(x) }
      if(`options`.isEmpty) { return None }
      val `labels` = (j \ "labels").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) }
      val `input` = (j \ "input").asOpt[JsValue].flatMap { x => BindRadioSelectInputCodec.decodeOpt(x) }
      if(`input`.isEmpty) { return None }
      val `debounce` = (j \ "debounce").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      return Some(BindRadioSelect(
        `name` = `name`,
        `element` = `element`,
        `options` = `options`.get,
        `labels` = `labels`,
        `input` = `input`.get,
        `debounce` = `debounce`,
      ))
    }

  def encode(j: BindRadioSelect): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`element`.map { x => "element" -> Json.toJson(x) },
        Some("options" -> ArrayOfAnyCodec.encode(j.`options`)),
        j.`labels`.map { x => "labels" -> ArrayOfStringCodec.encode(x) },
        Some("input" -> BindRadioSelectInputCodec.encode(j.`input`)),
        j.`debounce`.map { x => "debounce" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LegendConfigTitleColor (UnionType)
object LegendConfigTitleColorCodec {
  def decode(j: JsValue): LegendConfigTitleColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigTitleColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => LegendConfigTitleColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: LegendConfigTitleColor): JsValue =
    j match {
      case LegendConfigTitleColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ImputeTransformFrame (ConstrainedType)
object ImputeTransformFrameCodec {
  def decode(j: JsValue): ImputeTransformFrame =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ImputeTransformFrame] =
    try {
      ArrayOfImputeTransformFrameElementCodec.decodeOpt(j)
        .map { ImputeTransformFrame(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ImputeTransformFrame): JsValue =
    ArrayOfImputeTransformFrameElementCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// LegendConfigGradientLabelOffset (UnionType)
object LegendConfigGradientLabelOffsetCodec {
  def decode(j: JsValue): LegendConfigGradientLabelOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigGradientLabelOffset] =
    j.asOpt[JsNumber].map { LegendConfigGradientLabelOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigGradientLabelOffset): JsValue =
    j match {
      case LegendConfigGradientLabelOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetEncodingFieldDefAlign (UnionType)
object FacetEncodingFieldDefAlignCodec {
  def decode(j: JsValue): FacetEncodingFieldDefAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetEncodingFieldDefAlign] =
    LayoutAlignCodec.decodeOpt(j).orElse {
    RowColLayoutAlignCodec.decodeOpt(j) } 
  def encode(j: FacetEncodingFieldDefAlign): JsValue =
    j match {
      case x:LayoutAlign /* TypeRef */ => LayoutAlignCodec.encode(x)
      case x:RowColLayoutAlign /* TypeRef */ => RowColLayoutAlignCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigText (UnionType)
object BarConfigTextCodec {
  def decode(j: JsValue): BarConfigText =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigText] =
    TextCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigText): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisLabelFontStyleAsObject2 (StructType)
object ConditionalAxisLabelFontStyleAsObject2Codec {
  def decode(j: JsValue): ConditionalAxisLabelFontStyleAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalAxisLabelFontStyleAsObject2] =
    {
      val `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => ConditionalAxisLabelFontStyleAsObject2ConditionCodec.decodeOpt(x) }
      if(`condition`.isEmpty) { return None }
      val `expr` = (j \ "expr").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`expr`.isEmpty) { return None }
      return Some(ConditionalAxisLabelFontStyleAsObject2(
        `condition` = `condition`.get,
        `expr` = `expr`.get,
      ))
    }

  def encode(j: ConditionalAxisLabelFontStyleAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("condition" -> ConditionalAxisLabelFontStyleAsObject2ConditionCodec.encode(j.`condition`)),
        Some("expr" -> Json.toJson(j.`expr`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TopLevelConcatSpecParamsElement (UnionType)
object TopLevelConcatSpecParamsElementCodec {
  def decode(j: JsValue): TopLevelConcatSpecParamsElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelConcatSpecParamsElement] =
    VariableParameterCodec.decodeOpt(j).orElse {
    TopLevelSelectionParameterCodec.decodeOpt(j) } 
  def encode(j: TopLevelConcatSpecParamsElement): JsValue =
    j match {
      case x:VariableParameter /* TypeRef */ => VariableParameterCodec.encode(x)
      case x:TopLevelSelectionParameter /* TypeRef */ => TopLevelSelectionParameterCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ExprRef (StructType)
object ExprRefCodec {
  def decode(j: JsValue): ExprRef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ExprRef] =
    {
      val `expr` = (j \ "expr").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`expr`.isEmpty) { return None }
      return Some(ExprRef(
        `expr` = `expr`.get,
      ))
    }

  def encode(j: ExprRef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("expr" -> Json.toJson(j.`expr`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// RectConfigStrokeDashOffset (UnionType)
object RectConfigStrokeDashOffsetCodec {
  def decode(j: JsValue): RectConfigStrokeDashOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigStrokeDashOffset] =
    j.asOpt[JsNumber].map { RectConfigStrokeDashOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigStrokeDashOffset): JsValue =
    j match {
      case RectConfigStrokeDashOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigSize (ConstrainedType)
// see AreaConfigSize (UnionType)

////////////////////////////////////////////////////////////////////////
// LineConfigShape (UnionType)
object LineConfigShapeCodec {
  def decode(j: JsValue): LineConfigShape =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigShape] =
    j.asOpt[String].map { LineConfigShapeAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigShape): JsValue =
    j match {
      case LineConfigShapeAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingUrlFormat (UnionType)
object SharedEncodingUrlFormatCodec {
  def decode(j: JsValue): SharedEncodingUrlFormat =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingUrlFormat] =
    j.asOpt[String].map { SharedEncodingUrlFormatAsString(_) }.orElse {
    DictOfAnyCodec.decodeOpt(j).map { SharedEncodingUrlFormatAsDictOfAny(_) } } 
  def encode(j: SharedEncodingUrlFormat): JsValue =
    j match {
      case SharedEncodingUrlFormatAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case SharedEncodingUrlFormatAsDictOfAny(x) /* Base, MapType */ => DictOfAnyCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingXBandPosition (ConstrainedType)
object SharedEncodingXBandPositionCodec {
  def decode(j: JsValue): SharedEncodingXBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingXBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingXBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingXBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// HeaderConfigLabelLimit (UnionType)
object HeaderConfigLabelLimitCodec {
  def decode(j: JsValue): HeaderConfigLabelLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigLabelLimit] =
    j.asOpt[JsNumber].map { HeaderConfigLabelLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderConfigLabelLimit): JsValue =
    j match {
      case HeaderConfigLabelLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConfigFieldTitle (EnumType)
object ConfigFieldTitleCodec {
  def decode(j: JsValue): ConfigFieldTitle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConfigFieldTitle] =
    j match {
      case JsString("verbal") => Some(ConfigFieldTitleVerbal)
      case JsString("functional") => Some(ConfigFieldTitleFunctional)
      case JsString("plain") => Some(ConfigFieldTitlePlain)
      case _ => None
    }
  def encode(j: ConfigFieldTitle): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// MarkConfigFontSizeAsNumber (ConstrainedType)
object MarkConfigFontSizeAsNumberCodec {
  def decode(j: JsValue): MarkConfigFontSizeAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[MarkConfigFontSizeAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { MarkConfigFontSizeAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: MarkConfigFontSizeAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionDatumDefGradientStringNullBandPosition (ConstrainedType)
object FieldOrDatumDefWithConditionDatumDefGradientStringNullBandPositionCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionDatumDefGradientStringNullBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionDatumDefGradientStringNullBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { FieldOrDatumDefWithConditionDatumDefGradientStringNullBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: FieldOrDatumDefWithConditionDatumDefGradientStringNullBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AxisTitleLineHeight (UnionType)
object AxisTitleLineHeightCodec {
  def decode(j: JsValue): AxisTitleLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTitleLineHeight] =
    j.asOpt[JsNumber].map { AxisTitleLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisTitleLineHeight): JsValue =
    j match {
      case AxisTitleLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigTitleOrient (UnionType)
object LegendConfigTitleOrientCodec {
  def decode(j: JsValue): LegendConfigTitleOrient =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigTitleOrient] =
    OrientCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigTitleOrient): JsValue =
    j match {
      case x:Orient /* TypeRef */ => OrientCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BoxPlotDef (StructType)
object BoxPlotDefCodec {
  def decode(j: JsValue): BoxPlotDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BoxPlotDef] =
    {
      val `size` = (j \ "size").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `extent` = (j \ "extent").asOpt[JsValue].flatMap { x => BoxPlotDefExtentCodec.decodeOpt(x) }
      val `rule` = (j \ "rule").asOpt[JsValue].flatMap { x => BoxPlotDefRuleCodec.decodeOpt(x) }
      val `color` = (j \ "color").asOpt[JsValue].flatMap { x => BoxPlotDefColorCodec.decodeOpt(x) }
      val `outliers` = (j \ "outliers").asOpt[JsValue].flatMap { x => BoxPlotDefOutliersCodec.decodeOpt(x) }
      val `median` = (j \ "median").asOpt[JsValue].flatMap { x => BoxPlotDefMedianCodec.decodeOpt(x) }
      val `ticks` = (j \ "ticks").asOpt[JsValue].flatMap { x => BoxPlotDefTicksCodec.decodeOpt(x) }
      val `orient` = (j \ "orient").asOpt[JsValue].flatMap { x => OrientationCodec.decodeOpt(x) }
      val `box` = (j \ "box").asOpt[JsValue].flatMap { x => BoxPlotDefBoxCodec.decodeOpt(x) }
      val `opacity` = (j \ "opacity").asOpt[JsValue].flatMap { x => BoxPlotDefOpacityCodec.decodeOpt(x) }
      val `type` = (j \ "type").asOpt[JsValue].flatMap { x => BoxPlotCodec.decodeOpt(x) }
      if(`type`.isEmpty) { return None }
      val `clip` = (j \ "clip").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      return Some(BoxPlotDef(
        `size` = `size`,
        `extent` = `extent`,
        `rule` = `rule`,
        `color` = `color`,
        `outliers` = `outliers`,
        `median` = `median`,
        `ticks` = `ticks`,
        `orient` = `orient`,
        `box` = `box`,
        `opacity` = `opacity`,
        `type` = `type`.get,
        `clip` = `clip`,
      ))
    }

  def encode(j: BoxPlotDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`size`.map { x => "size" -> Json.toJson(x) },
        j.`extent`.map { x => "extent" -> BoxPlotDefExtentCodec.encode(x) },
        j.`rule`.map { x => "rule" -> BoxPlotDefRuleCodec.encode(x) },
        j.`color`.map { x => "color" -> BoxPlotDefColorCodec.encode(x) },
        j.`outliers`.map { x => "outliers" -> BoxPlotDefOutliersCodec.encode(x) },
        j.`median`.map { x => "median" -> BoxPlotDefMedianCodec.encode(x) },
        j.`ticks`.map { x => "ticks" -> BoxPlotDefTicksCodec.encode(x) },
        j.`orient`.map { x => "orient" -> OrientationCodec.encode(x) },
        j.`box`.map { x => "box" -> BoxPlotDefBoxCodec.encode(x) },
        j.`opacity`.map { x => "opacity" -> BoxPlotDefOpacityCodec.encode(x) },
        Some("type" -> BoxPlotCodec.encode(j.`type`)),
        j.`clip`.map { x => "clip" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ViewConfigOpacity (ConstrainedType)
// see ViewConfigOpacity (UnionType)

////////////////////////////////////////////////////////////////////////
// RangeEnum (EnumType)
object RangeEnumCodec {
  def decode(j: JsValue): RangeEnum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RangeEnum] =
    j match {
      case JsString("width") => Some(RangeEnumWidth)
      case JsString("height") => Some(RangeEnumHeight)
      case JsString("symbol") => Some(RangeEnumSymbol)
      case JsString("category") => Some(RangeEnumCategory)
      case JsString("ordinal") => Some(RangeEnumOrdinal)
      case JsString("ramp") => Some(RangeEnumRamp)
      case JsString("diverging") => Some(RangeEnumDiverging)
      case JsString("heatmap") => Some(RangeEnumHeatmap)
      case _ => None
    }
  def encode(j: RangeEnum): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// BarConfigDir (UnionType)
object BarConfigDirCodec {
  def decode(j: JsValue): BarConfigDir =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigDir] =
    TextDirectionCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigDir): JsValue =
    j match {
      case x:TextDirection /* TypeRef */ => TextDirectionCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullBin (UnionType)
object FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullBinCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullBin] =
    j.asOpt[Boolean].map { FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullBinAsNull } } } 
  def encode(j: FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullBin): JsValue =
    j match {
      case FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case FieldOrDatumDefWithConditionMarkPropFieldDefTypeForShapeStringNullBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefWidth (UnionType)
object OverlayMarkDefWidthCodec {
  def decode(j: JsValue): OverlayMarkDefWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefWidth] =
    j.asOpt[JsNumber].map { OverlayMarkDefWidthAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefWidth): JsValue =
    j match {
      case OverlayMarkDefWidthAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigThickness (ConstrainedType)
object TickConfigThicknessCodec {
  def decode(j: JsValue): TickConfigThickness =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TickConfigThickness] =
    try {
      j.asOpt[JsNumber]
        .map { TickConfigThickness(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: TickConfigThickness): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// TitleConfigSubtitleColor (UnionType)
object TitleConfigSubtitleColorCodec {
  def decode(j: JsValue): TitleConfigSubtitleColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigSubtitleColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => TitleConfigSubtitleColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: TitleConfigSubtitleColor): JsValue =
    j match {
      case TitleConfigSubtitleColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigInvalid (EnumType)
object TickConfigInvalidCodec {
  def decode(j: JsValue): TickConfigInvalid =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigInvalid] =
    j match {
      case JsString("filter") => Some(TickConfigInvalidFilter)
      case JsNull => Some(TickConfigInvalidUndefined)
      case _ => None
    }
  def encode(j: TickConfigInvalid): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// LineConfigStrokeOffset (UnionType)
object LineConfigStrokeOffsetCodec {
  def decode(j: JsValue): LineConfigStrokeOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigStrokeOffset] =
    j.asOpt[JsNumber].map { LineConfigStrokeOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigStrokeOffset): JsValue =
    j match {
      case LineConfigStrokeOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LayoutAlign (EnumType)
object LayoutAlignCodec {
  def decode(j: JsValue): LayoutAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LayoutAlign] =
    j match {
      case JsString("all") => Some(LayoutAlignAll)
      case JsString("each") => Some(LayoutAlignEach)
      case JsString("none") => Some(LayoutAlignNone)
      case _ => None
    }
  def encode(j: LayoutAlign): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// LegendResolveMap (StructType)
object LegendResolveMapCodec {
  def decode(j: JsValue): LegendResolveMap =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LegendResolveMap] =
    Some(LegendResolveMap(
      `size` = (j \ "size").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `strokeOpacity` = (j \ "strokeOpacity").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `fillOpacity` = (j \ "fillOpacity").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `color` = (j \ "color").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `fill` = (j \ "fill").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `strokeDash` = (j \ "strokeDash").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `strokeWidth` = (j \ "strokeWidth").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `angle` = (j \ "angle").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `stroke` = (j \ "stroke").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `shape` = (j \ "shape").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
      `opacity` = (j \ "opacity").asOpt[JsValue].flatMap { x => ResolveModeCodec.decodeOpt(x) },
    ))

  def encode(j: LegendResolveMap): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`size`.map { x => "size" -> ResolveModeCodec.encode(x) },
        j.`strokeOpacity`.map { x => "strokeOpacity" -> ResolveModeCodec.encode(x) },
        j.`fillOpacity`.map { x => "fillOpacity" -> ResolveModeCodec.encode(x) },
        j.`color`.map { x => "color" -> ResolveModeCodec.encode(x) },
        j.`fill`.map { x => "fill" -> ResolveModeCodec.encode(x) },
        j.`strokeDash`.map { x => "strokeDash" -> ResolveModeCodec.encode(x) },
        j.`strokeWidth`.map { x => "strokeWidth" -> ResolveModeCodec.encode(x) },
        j.`angle`.map { x => "angle" -> ResolveModeCodec.encode(x) },
        j.`stroke`.map { x => "stroke" -> ResolveModeCodec.encode(x) },
        j.`shape`.map { x => "shape" -> ResolveModeCodec.encode(x) },
        j.`opacity`.map { x => "opacity" -> ResolveModeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TimeInterval (EnumType)
object TimeIntervalCodec {
  def decode(j: JsValue): TimeInterval =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TimeInterval] =
    j match {
      case JsString("millisecond") => Some(TimeIntervalMillisecond)
      case JsString("second") => Some(TimeIntervalSecond)
      case JsString("minute") => Some(TimeIntervalMinute)
      case JsString("hour") => Some(TimeIntervalHour)
      case JsString("day") => Some(TimeIntervalDay)
      case JsString("week") => Some(TimeIntervalWeek)
      case JsString("month") => Some(TimeIntervalMonth)
      case JsString("year") => Some(TimeIntervalYear)
      case _ => None
    }
  def encode(j: TimeInterval): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingLongitudeBandPosition (ConstrainedType)
object SharedEncodingLongitudeBandPositionCodec {
  def decode(j: JsValue): SharedEncodingLongitudeBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingLongitudeBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingLongitudeBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingLongitudeBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AxisDomainDashOffset (UnionType)
object AxisDomainDashOffsetCodec {
  def decode(j: JsValue): AxisDomainDashOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisDomainDashOffset] =
    j.asOpt[JsNumber].map { AxisDomainDashOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisDomainDashOffset): JsValue =
    j match {
      case AxisDomainDashOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateStringFieldDefBandPosition (ConstrainedType)
object ConditionalPredicateStringFieldDefBandPositionCodec {
  def decode(j: JsValue): ConditionalPredicateStringFieldDefBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateStringFieldDefBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { ConditionalPredicateStringFieldDefBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ConditionalPredicateStringFieldDefBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingFillOpacityBin (UnionType)
object SharedEncodingFillOpacityBinCodec {
  def decode(j: JsValue): SharedEncodingFillOpacityBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingFillOpacityBin] =
    j.asOpt[Boolean].map { SharedEncodingFillOpacityBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingFillOpacityBinAsNull } } } 
  def encode(j: SharedEncodingFillOpacityBin): JsValue =
    j match {
      case SharedEncodingFillOpacityBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case SharedEncodingFillOpacityBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject2Padding (UnionType)
object TopLevelRepeatSpecAsObject2PaddingCodec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject2Padding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject2Padding] =
    PaddingCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TopLevelRepeatSpecAsObject2Padding): JsValue =
    j match {
      case x:Padding /* TypeRef */ => PaddingCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigTitleAnchor (UnionType)
object LegendConfigTitleAnchorCodec {
  def decode(j: JsValue): LegendConfigTitleAnchor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigTitleAnchor] =
    TitleAnchorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigTitleAnchor): JsValue =
    j match {
      case x:TitleAnchor /* TypeRef */ => TitleAnchorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefAriaRole (UnionType)
object MarkDefAriaRoleCodec {
  def decode(j: JsValue): MarkDefAriaRole =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefAriaRole] =
    j.asOpt[String].map { MarkDefAriaRoleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefAriaRole): JsValue =
    j match {
      case MarkDefAriaRoleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleInterpolateEnum (EnumType)
object ScaleInterpolateEnumCodec {
  def decode(j: JsValue): ScaleInterpolateEnum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleInterpolateEnum] =
    j match {
      case JsString("rgb") => Some(ScaleInterpolateEnumRgb)
      case JsString("lab") => Some(ScaleInterpolateEnumLab)
      case JsString("hcl") => Some(ScaleInterpolateEnumHcl)
      case JsString("hsl") => Some(ScaleInterpolateEnumHsl)
      case JsString("hsl-long") => Some(ScaleInterpolateEnumHslLong)
      case JsString("hcl-long") => Some(ScaleInterpolateEnumHclLong)
      case JsString("cubehelix") => Some(ScaleInterpolateEnumCubehelix)
      case JsString("cubehelix-long") => Some(ScaleInterpolateEnumCubehelixLong)
      case _ => None
    }
  def encode(j: ScaleInterpolateEnum): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// ConditionalAxisNumberArrayAsObject1 (StructType)
object ConditionalAxisNumberArrayAsObject1Codec {
  def decode(j: JsValue): ConditionalAxisNumberArrayAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalAxisNumberArrayAsObject1] =
    {
      val `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => ConditionalAxisNumberArrayAsObject1ConditionCodec.decodeOpt(x) }
      if(`condition`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => ArrayOfNumberCodec.decodeOpt(x).map { Some(_) }.flatten }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalAxisNumberArrayAsObject1(
        `condition` = `condition`.get,
        `value` = `value`,
      ))
    }

  def encode(j: ConditionalAxisNumberArrayAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("condition" -> ConditionalAxisNumberArrayAsObject1ConditionCodec.encode(j.`condition`)),
        j.`value`.map { x => "value" -> ArrayOfNumberCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingOpacityCondition (UnionType)
object SharedEncodingOpacityConditionCodec {
  def decode(j: JsValue): SharedEncodingOpacityCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingOpacityCondition] =
    ConditionalValueDefNumberExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefNumberExprRefCodec.decodeOpt(j).map { SharedEncodingOpacityConditionAsArrayOfConditionalValueDefNumberExprRef(_) }.orElse {
    ConditionalMarkPropFieldOrDatumDefCodec.decodeOpt(j) } } 
  def encode(j: SharedEncodingOpacityCondition): JsValue =
    j match {
      case x:ConditionalValueDefNumberExprRef /* TypeRef */ => ConditionalValueDefNumberExprRefCodec.encode(x)
      case SharedEncodingOpacityConditionAsArrayOfConditionalValueDefNumberExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefNumberExprRefCodec.encode(x)
      case x:ConditionalMarkPropFieldOrDatumDef /* TypeRef */ => ConditionalMarkPropFieldOrDatumDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LookupData (StructType)
object LookupDataCodec {
  def decode(j: JsValue): LookupData =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LookupData] =
    {
      val `data` = (j \ "data").asOpt[JsValue].flatMap { x => DataCodec.decodeOpt(x) }
      if(`data`.isEmpty) { return None }
      val `fields` = (j \ "fields").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) }
      val `key` = (j \ "key").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`key`.isEmpty) { return None }
      return Some(LookupData(
        `data` = `data`.get,
        `fields` = `fields`,
        `key` = `key`.get,
      ))
    }

  def encode(j: LookupData): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("data" -> DataCodec.encode(j.`data`)),
        j.`fields`.map { x => "fields" -> ArrayOfStringCodec.encode(x) },
        Some("key" -> Json.toJson(j.`key`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TopoDataFormatType (ConstantType)
object TopoDataFormatTypeCodec {
  def decode(j: JsValue): TopoDataFormatType =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TopoDataFormatType] =
    j match {
      case JsString("topojson") => Some(TopoDataFormatType())
      case _ => None
    }
  def encode(j: TopoDataFormatType): JsValue =
    JsString("topojson")
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeWidthValue (UnionType)
object SharedEncodingStrokeWidthValueCodec {
  def decode(j: JsValue): SharedEncodingStrokeWidthValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeWidthValue] =
    j.asOpt[JsNumber].map { SharedEncodingStrokeWidthValueAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingStrokeWidthValue): JsValue =
    j match {
      case SharedEncodingStrokeWidthValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject1Repeat (UnionType)
object TopLevelRepeatSpecAsObject1RepeatCodec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject1Repeat =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject1Repeat] =
    ArrayOfStringCodec.decodeOpt(j).map { TopLevelRepeatSpecAsObject1RepeatAsArrayOfString(_) }.orElse {
    RepeatMappingCodec.decodeOpt(j) } 
  def encode(j: TopLevelRepeatSpecAsObject1Repeat): JsValue =
    j match {
      case TopLevelRepeatSpecAsObject1RepeatAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
      case x:RepeatMapping /* TypeRef */ => RepeatMappingCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LoessTransformAs (ConstrainedType)
object LoessTransformAsCodec {
  def decode(j: JsValue): LoessTransformAs =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LoessTransformAs] =
    try {
      ArrayOfStringCodec.decodeOpt(j)
        .map { LoessTransformAs(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: LoessTransformAs): JsValue =
    ArrayOfStringCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// BarConfigColor (UnionType)
object BarConfigColorCodec {
  def decode(j: JsValue): BarConfigColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigColor] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: BarConfigColor): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigCornerRadiusTopLeft (UnionType)
object LineConfigCornerRadiusTopLeftCodec {
  def decode(j: JsValue): LineConfigCornerRadiusTopLeft =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigCornerRadiusTopLeft] =
    j.asOpt[JsNumber].map { LineConfigCornerRadiusTopLeftAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigCornerRadiusTopLeft): JsValue =
    j match {
      case LineConfigCornerRadiusTopLeftAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigInnerRadius (UnionType)
object RectConfigInnerRadiusCodec {
  def decode(j: JsValue): RectConfigInnerRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigInnerRadius] =
    j.asOpt[JsNumber].map { RectConfigInnerRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigInnerRadius): JsValue =
    j match {
      case RectConfigInnerRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefInnerRadius (ConstrainedType)
// see MarkDefInnerRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// MarkConfigRadius (UnionType)
object MarkConfigRadiusCodec {
  def decode(j: JsValue): MarkConfigRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigRadius] =
    j.asOpt[JsNumber].map { MarkConfigRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigRadius): JsValue =
    j match {
      case MarkConfigRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ValueDefWithConditionStringFieldDefTextCondition (UnionType)
object ValueDefWithConditionStringFieldDefTextConditionCodec {
  def decode(j: JsValue): ValueDefWithConditionStringFieldDefTextCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ValueDefWithConditionStringFieldDefTextCondition] =
    ConditionalStringFieldDefCodec.decodeOpt(j).orElse {
    ConditionalValueDefTextExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefTextExprRefCodec.decodeOpt(j).map { ValueDefWithConditionStringFieldDefTextConditionAsArrayOfConditionalValueDefTextExprRef(_) } } } 
  def encode(j: ValueDefWithConditionStringFieldDefTextCondition): JsValue =
    j match {
      case x:ConditionalStringFieldDef /* TypeRef */ => ConditionalStringFieldDefCodec.encode(x)
      case x:ConditionalValueDefTextExprRef /* TypeRef */ => ConditionalValueDefTextExprRefCodec.encode(x)
      case ValueDefWithConditionStringFieldDefTextConditionAsArrayOfConditionalValueDefTextExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefTextExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisLabelAlignAsObject2 (StructType)
object ConditionalAxisLabelAlignAsObject2Codec {
  def decode(j: JsValue): ConditionalAxisLabelAlignAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalAxisLabelAlignAsObject2] =
    {
      val `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => ConditionalAxisLabelAlignAsObject2ConditionCodec.decodeOpt(x) }
      if(`condition`.isEmpty) { return None }
      val `expr` = (j \ "expr").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`expr`.isEmpty) { return None }
      return Some(ConditionalAxisLabelAlignAsObject2(
        `condition` = `condition`.get,
        `expr` = `expr`.get,
      ))
    }

  def encode(j: ConditionalAxisLabelAlignAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("condition" -> ConditionalAxisLabelAlignAsObject2ConditionCodec.encode(j.`condition`)),
        Some("expr" -> Json.toJson(j.`expr`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ScaleConfigMaxBandSize (ConstrainedType)
object ScaleConfigMaxBandSizeCodec {
  def decode(j: JsValue): ScaleConfigMaxBandSize =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ScaleConfigMaxBandSize] =
    try {
      j.asOpt[JsNumber]
        .map { ScaleConfigMaxBandSize(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ScaleConfigMaxBandSize): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionDatumDefStringNullDatum (UnionType)
object FieldOrDatumDefWithConditionDatumDefStringNullDatumCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionDatumDefStringNullDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionDatumDefStringNullDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: FieldOrDatumDefWithConditionDatumDefStringNullDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelLayerSpecAutosize (UnionType)
object TopLevelLayerSpecAutosizeCodec {
  def decode(j: JsValue): TopLevelLayerSpecAutosize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelLayerSpecAutosize] =
    AutosizeTypeCodec.decodeOpt(j).orElse {
    AutoSizeParamsCodec.decodeOpt(j) } 
  def encode(j: TopLevelLayerSpecAutosize): JsValue =
    j match {
      case x:AutosizeType /* TypeRef */ => AutosizeTypeCodec.encode(x)
      case x:AutoSizeParams /* TypeRef */ => AutoSizeParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfigExtent (UnionType)
object ProjectionConfigExtentCodec {
  def decode(j: JsValue): ProjectionConfigExtent =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigExtent] =
    Vector2Vector2NumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigExtent): JsValue =
    j match {
      case x:Vector2Vector2Number /* TypeRef */ => Vector2Vector2NumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// IntervalSelectionConfigOn (UnionType)
object IntervalSelectionConfigOnCodec {
  def decode(j: JsValue): IntervalSelectionConfigOn =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[IntervalSelectionConfigOn] =
    StreamCodec.decodeOpt(j).orElse {
    j.asOpt[String].map { IntervalSelectionConfigOnAsString(_) } } 
  def encode(j: IntervalSelectionConfigOn): JsValue =
    j match {
      case x:Stream /* TypeRef */ => StreamCodec.encode(x)
      case IntervalSelectionConfigOnAsString(x) /* Base, StringType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BoxPlotDefOpacity (ConstrainedType)
object BoxPlotDefOpacityCodec {
  def decode(j: JsValue): BoxPlotDefOpacity =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BoxPlotDefOpacity] =
    try {
      j.asOpt[JsNumber]
        .map { BoxPlotDefOpacity(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: BoxPlotDefOpacity): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDef (StructType)
object OverlayMarkDefCodec {
  def decode(j: JsValue): OverlayMarkDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[OverlayMarkDef] =
    Some(OverlayMarkDef(
      `x2Offset` = (j \ "x2Offset").asOpt[JsValue].flatMap { x => OverlayMarkDefX2OffsetCodec.decodeOpt(x) },
      `cornerRadiusBottomRight` = (j \ "cornerRadiusBottomRight").asOpt[JsValue].flatMap { x => OverlayMarkDefCornerRadiusBottomRightCodec.decodeOpt(x) },
      `fillOpacity` = (j \ "fillOpacity").asOpt[JsValue].flatMap { x => OverlayMarkDefFillOpacityCodec.decodeOpt(x) },
      `strokeMiterLimit` = (j \ "strokeMiterLimit").asOpt[JsValue].flatMap { x => OverlayMarkDefStrokeMiterLimitCodec.decodeOpt(x) },
      `dir` = (j \ "dir").asOpt[JsValue].flatMap { x => OverlayMarkDefDirCodec.decodeOpt(x) },
      `theta2Offset` = (j \ "theta2Offset").asOpt[JsValue].flatMap { x => OverlayMarkDefTheta2OffsetCodec.decodeOpt(x) },
      `tooltip` = (j \ "tooltip").asOpt[JsValue].flatMap { x => OverlayMarkDefTooltipCodec.decodeOpt(x) },
      `cornerRadiusTopRight` = (j \ "cornerRadiusTopRight").asOpt[JsValue].flatMap { x => OverlayMarkDefCornerRadiusTopRightCodec.decodeOpt(x) },
      `outerRadius` = (j \ "outerRadius").asOpt[JsValue].flatMap { x => OverlayMarkDefOuterRadiusCodec.decodeOpt(x) },
      `x` = (j \ "x").asOpt[JsValue].flatMap { x => OverlayMarkDefXCodec.decodeOpt(x) },
      `dy` = (j \ "dy").asOpt[JsValue].flatMap { x => OverlayMarkDefDyCodec.decodeOpt(x) },
      `xOffset` = (j \ "xOffset").asOpt[JsValue].flatMap { x => OverlayMarkDefXOffsetCodec.decodeOpt(x) },
      `size` = (j \ "size").asOpt[JsValue].flatMap { x => OverlayMarkDefSizeCodec.decodeOpt(x) },
      `smooth` = (j \ "smooth").asOpt[JsValue].flatMap { x => OverlayMarkDefSmoothCodec.decodeOpt(x) },
      `url` = (j \ "url").asOpt[JsValue].flatMap { x => OverlayMarkDefUrlCodec.decodeOpt(x) },
      `style` = (j \ "style").asOpt[JsValue].flatMap { x => OverlayMarkDefStyleCodec.decodeOpt(x) },
      `y` = (j \ "y").asOpt[JsValue].flatMap { x => OverlayMarkDefYCodec.decodeOpt(x) },
      `strokeOpacity` = (j \ "strokeOpacity").asOpt[JsValue].flatMap { x => OverlayMarkDefStrokeOpacityCodec.decodeOpt(x) },
      `ellipsis` = (j \ "ellipsis").asOpt[JsValue].flatMap { x => OverlayMarkDefEllipsisCodec.decodeOpt(x) },
      `description` = (j \ "description").asOpt[JsValue].flatMap { x => OverlayMarkDefDescriptionCodec.decodeOpt(x) },
      `angle` = (j \ "angle").asOpt[JsValue].flatMap { x => OverlayMarkDefAngleCodec.decodeOpt(x) },
      `lineBreak` = (j \ "lineBreak").asOpt[JsValue].flatMap { x => OverlayMarkDefLineBreakCodec.decodeOpt(x) },
      `tension` = (j \ "tension").asOpt[JsValue].flatMap { x => OverlayMarkDefTensionCodec.decodeOpt(x) },
      `cornerRadiusTopLeft` = (j \ "cornerRadiusTopLeft").asOpt[JsValue].flatMap { x => OverlayMarkDefCornerRadiusTopLeftCodec.decodeOpt(x) },
      `stroke` = (j \ "stroke").asOpt[JsValue].flatMap { x => OverlayMarkDefStrokeCodec.decodeOpt(x) },
      `strokeDashOffset` = (j \ "strokeDashOffset").asOpt[JsValue].flatMap { x => OverlayMarkDefStrokeDashOffsetCodec.decodeOpt(x) },
      `align` = (j \ "align").asOpt[JsValue].flatMap { x => OverlayMarkDefAlignCodec.decodeOpt(x) },
      `ariaRole` = (j \ "ariaRole").asOpt[JsValue].flatMap { x => OverlayMarkDefAriaRoleCodec.decodeOpt(x) },
      `strokeCap` = (j \ "strokeCap").asOpt[JsValue].flatMap { x => OverlayMarkDefStrokeCapCodec.decodeOpt(x) },
      `endAngle` = (j \ "endAngle").asOpt[JsValue].flatMap { x => OverlayMarkDefEndAngleCodec.decodeOpt(x) },
      `strokeJoin` = (j \ "strokeJoin").asOpt[JsValue].flatMap { x => OverlayMarkDefStrokeJoinCodec.decodeOpt(x) },
      `baseline` = (j \ "baseline").asOpt[JsValue].flatMap { x => OverlayMarkDefBaselineCodec.decodeOpt(x) },
      `ariaRoleDescription` = (j \ "ariaRoleDescription").asOpt[JsValue].flatMap { x => OverlayMarkDefAriaRoleDescriptionCodec.decodeOpt(x) },
      `aspect` = (j \ "aspect").asOpt[JsValue].flatMap { x => OverlayMarkDefAspectCodec.decodeOpt(x) },
      `height` = (j \ "height").asOpt[JsValue].flatMap { x => OverlayMarkDefHeightCodec.decodeOpt(x) },
      `fontStyle` = (j \ "fontStyle").asOpt[JsValue].flatMap { x => OverlayMarkDefFontStyleCodec.decodeOpt(x) },
      `text` = (j \ "text").asOpt[JsValue].flatMap { x => OverlayMarkDefTextCodec.decodeOpt(x) },
      `cornerRadius` = (j \ "cornerRadius").asOpt[JsValue].flatMap { x => OverlayMarkDefCornerRadiusCodec.decodeOpt(x) },
      `color` = (j \ "color").asOpt[JsValue].flatMap { x => OverlayMarkDefColorCodec.decodeOpt(x) },
      `x2` = (j \ "x2").asOpt[JsValue].flatMap { x => OverlayMarkDefX2Codec.decodeOpt(x) },
      `padAngle` = (j \ "padAngle").asOpt[JsValue].flatMap { x => OverlayMarkDefPadAngleCodec.decodeOpt(x) },
      `cursor` = (j \ "cursor").asOpt[JsValue].flatMap { x => OverlayMarkDefCursorCodec.decodeOpt(x) },
      `radius` = (j \ "radius").asOpt[JsValue].flatMap { x => OverlayMarkDefRadiusCodec.decodeOpt(x) },
      `timeUnitBandSize` = (j \ "timeUnitBandSize").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `startAngle` = (j \ "startAngle").asOpt[JsValue].flatMap { x => OverlayMarkDefStartAngleCodec.decodeOpt(x) },
      `font` = (j \ "font").asOpt[JsValue].flatMap { x => OverlayMarkDefFontCodec.decodeOpt(x) },
      `radius2` = (j \ "radius2").asOpt[JsValue].flatMap { x => OverlayMarkDefRadius2Codec.decodeOpt(x) },
      `invalid` = (j \ "invalid").asOpt[JsValue].flatMap { x => OverlayMarkDefInvalidCodec.decodeOpt(x) },
      `radius2Offset` = (j \ "radius2Offset").asOpt[JsValue].flatMap { x => OverlayMarkDefRadius2OffsetCodec.decodeOpt(x) },
      `lineHeight` = (j \ "lineHeight").asOpt[JsValue].flatMap { x => OverlayMarkDefLineHeightCodec.decodeOpt(x) },
      `order` = (j \ "order").asOpt[JsValue].flatMap { x => OverlayMarkDefOrderCodec.decodeOpt(x) },
      `fill` = (j \ "fill").asOpt[JsValue].flatMap { x => OverlayMarkDefFillCodec.decodeOpt(x) },
      `interpolate` = (j \ "interpolate").asOpt[JsValue].flatMap { x => OverlayMarkDefInterpolateCodec.decodeOpt(x) },
      `theta` = (j \ "theta").asOpt[JsValue].flatMap { x => OverlayMarkDefThetaCodec.decodeOpt(x) },
      `orient` = (j \ "orient").asOpt[JsValue].flatMap { x => OrientationCodec.decodeOpt(x) },
      `innerRadius` = (j \ "innerRadius").asOpt[JsValue].flatMap { x => OverlayMarkDefInnerRadiusCodec.decodeOpt(x) },
      `fontSize` = (j \ "fontSize").asOpt[JsValue].flatMap { x => OverlayMarkDefFontSizeCodec.decodeOpt(x) },
      `y2` = (j \ "y2").asOpt[JsValue].flatMap { x => OverlayMarkDefY2Codec.decodeOpt(x) },
      `shape` = (j \ "shape").asOpt[JsValue].flatMap { x => OverlayMarkDefShapeCodec.decodeOpt(x) },
      `aria` = (j \ "aria").asOpt[JsValue].flatMap { x => OverlayMarkDefAriaCodec.decodeOpt(x) },
      `opacity` = (j \ "opacity").asOpt[JsValue].flatMap { x => OverlayMarkDefOpacityCodec.decodeOpt(x) },
      `radiusOffset` = (j \ "radiusOffset").asOpt[JsValue].flatMap { x => OverlayMarkDefRadiusOffsetCodec.decodeOpt(x) },
      `dx` = (j \ "dx").asOpt[JsValue].flatMap { x => OverlayMarkDefDxCodec.decodeOpt(x) },
      `clip` = (j \ "clip").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `cornerRadiusBottomLeft` = (j \ "cornerRadiusBottomLeft").asOpt[JsValue].flatMap { x => OverlayMarkDefCornerRadiusBottomLeftCodec.decodeOpt(x) },
      `href` = (j \ "href").asOpt[JsValue].flatMap { x => OverlayMarkDefHrefCodec.decodeOpt(x) },
      `strokeDash` = (j \ "strokeDash").asOpt[JsValue].flatMap { x => OverlayMarkDefStrokeDashCodec.decodeOpt(x) },
      `strokeOffset` = (j \ "strokeOffset").asOpt[JsValue].flatMap { x => OverlayMarkDefStrokeOffsetCodec.decodeOpt(x) },
      `limit` = (j \ "limit").asOpt[JsValue].flatMap { x => OverlayMarkDefLimitCodec.decodeOpt(x) },
      `y2Offset` = (j \ "y2Offset").asOpt[JsValue].flatMap { x => OverlayMarkDefY2OffsetCodec.decodeOpt(x) },
      `thetaOffset` = (j \ "thetaOffset").asOpt[JsValue].flatMap { x => OverlayMarkDefThetaOffsetCodec.decodeOpt(x) },
      `width` = (j \ "width").asOpt[JsValue].flatMap { x => OverlayMarkDefWidthCodec.decodeOpt(x) },
      `fontWeight` = (j \ "fontWeight").asOpt[JsValue].flatMap { x => OverlayMarkDefFontWeightCodec.decodeOpt(x) },
      `timeUnitBandPosition` = (j \ "timeUnitBandPosition").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `yOffset` = (j \ "yOffset").asOpt[JsValue].flatMap { x => OverlayMarkDefYOffsetCodec.decodeOpt(x) },
      `filled` = (j \ "filled").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `blend` = (j \ "blend").asOpt[JsValue].flatMap { x => OverlayMarkDefBlendCodec.decodeOpt(x) },
      `strokeWidth` = (j \ "strokeWidth").asOpt[JsValue].flatMap { x => OverlayMarkDefStrokeWidthCodec.decodeOpt(x) },
      `theta2` = (j \ "theta2").asOpt[JsValue].flatMap { x => OverlayMarkDefTheta2Codec.decodeOpt(x) },
    ))

  def encode(j: OverlayMarkDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`x2Offset`.map { x => "x2Offset" -> OverlayMarkDefX2OffsetCodec.encode(x) },
        j.`cornerRadiusBottomRight`.map { x => "cornerRadiusBottomRight" -> OverlayMarkDefCornerRadiusBottomRightCodec.encode(x) },
        j.`fillOpacity`.map { x => "fillOpacity" -> OverlayMarkDefFillOpacityCodec.encode(x) },
        j.`strokeMiterLimit`.map { x => "strokeMiterLimit" -> OverlayMarkDefStrokeMiterLimitCodec.encode(x) },
        j.`dir`.map { x => "dir" -> OverlayMarkDefDirCodec.encode(x) },
        j.`theta2Offset`.map { x => "theta2Offset" -> OverlayMarkDefTheta2OffsetCodec.encode(x) },
        j.`tooltip`.map { x => "tooltip" -> OverlayMarkDefTooltipCodec.encode(x) },
        j.`cornerRadiusTopRight`.map { x => "cornerRadiusTopRight" -> OverlayMarkDefCornerRadiusTopRightCodec.encode(x) },
        j.`outerRadius`.map { x => "outerRadius" -> OverlayMarkDefOuterRadiusCodec.encode(x) },
        j.`x`.map { x => "x" -> OverlayMarkDefXCodec.encode(x) },
        j.`dy`.map { x => "dy" -> OverlayMarkDefDyCodec.encode(x) },
        j.`xOffset`.map { x => "xOffset" -> OverlayMarkDefXOffsetCodec.encode(x) },
        j.`size`.map { x => "size" -> OverlayMarkDefSizeCodec.encode(x) },
        j.`smooth`.map { x => "smooth" -> OverlayMarkDefSmoothCodec.encode(x) },
        j.`url`.map { x => "url" -> OverlayMarkDefUrlCodec.encode(x) },
        j.`style`.map { x => "style" -> OverlayMarkDefStyleCodec.encode(x) },
        j.`y`.map { x => "y" -> OverlayMarkDefYCodec.encode(x) },
        j.`strokeOpacity`.map { x => "strokeOpacity" -> OverlayMarkDefStrokeOpacityCodec.encode(x) },
        j.`ellipsis`.map { x => "ellipsis" -> OverlayMarkDefEllipsisCodec.encode(x) },
        j.`description`.map { x => "description" -> OverlayMarkDefDescriptionCodec.encode(x) },
        j.`angle`.map { x => "angle" -> OverlayMarkDefAngleCodec.encode(x) },
        j.`lineBreak`.map { x => "lineBreak" -> OverlayMarkDefLineBreakCodec.encode(x) },
        j.`tension`.map { x => "tension" -> OverlayMarkDefTensionCodec.encode(x) },
        j.`cornerRadiusTopLeft`.map { x => "cornerRadiusTopLeft" -> OverlayMarkDefCornerRadiusTopLeftCodec.encode(x) },
        j.`stroke`.map { x => "stroke" -> OverlayMarkDefStrokeCodec.encode(x) },
        j.`strokeDashOffset`.map { x => "strokeDashOffset" -> OverlayMarkDefStrokeDashOffsetCodec.encode(x) },
        j.`align`.map { x => "align" -> OverlayMarkDefAlignCodec.encode(x) },
        j.`ariaRole`.map { x => "ariaRole" -> OverlayMarkDefAriaRoleCodec.encode(x) },
        j.`strokeCap`.map { x => "strokeCap" -> OverlayMarkDefStrokeCapCodec.encode(x) },
        j.`endAngle`.map { x => "endAngle" -> OverlayMarkDefEndAngleCodec.encode(x) },
        j.`strokeJoin`.map { x => "strokeJoin" -> OverlayMarkDefStrokeJoinCodec.encode(x) },
        j.`baseline`.map { x => "baseline" -> OverlayMarkDefBaselineCodec.encode(x) },
        j.`ariaRoleDescription`.map { x => "ariaRoleDescription" -> OverlayMarkDefAriaRoleDescriptionCodec.encode(x) },
        j.`aspect`.map { x => "aspect" -> OverlayMarkDefAspectCodec.encode(x) },
        j.`height`.map { x => "height" -> OverlayMarkDefHeightCodec.encode(x) },
        j.`fontStyle`.map { x => "fontStyle" -> OverlayMarkDefFontStyleCodec.encode(x) },
        j.`text`.map { x => "text" -> OverlayMarkDefTextCodec.encode(x) },
        j.`cornerRadius`.map { x => "cornerRadius" -> OverlayMarkDefCornerRadiusCodec.encode(x) },
        j.`color`.map { x => "color" -> OverlayMarkDefColorCodec.encode(x) },
        j.`x2`.map { x => "x2" -> OverlayMarkDefX2Codec.encode(x) },
        j.`padAngle`.map { x => "padAngle" -> OverlayMarkDefPadAngleCodec.encode(x) },
        j.`cursor`.map { x => "cursor" -> OverlayMarkDefCursorCodec.encode(x) },
        j.`radius`.map { x => "radius" -> OverlayMarkDefRadiusCodec.encode(x) },
        j.`timeUnitBandSize`.map { x => "timeUnitBandSize" -> Json.toJson(x) },
        j.`startAngle`.map { x => "startAngle" -> OverlayMarkDefStartAngleCodec.encode(x) },
        j.`font`.map { x => "font" -> OverlayMarkDefFontCodec.encode(x) },
        j.`radius2`.map { x => "radius2" -> OverlayMarkDefRadius2Codec.encode(x) },
        j.`invalid`.map { x => "invalid" -> OverlayMarkDefInvalidCodec.encode(x) },
        j.`radius2Offset`.map { x => "radius2Offset" -> OverlayMarkDefRadius2OffsetCodec.encode(x) },
        j.`lineHeight`.map { x => "lineHeight" -> OverlayMarkDefLineHeightCodec.encode(x) },
        j.`order`.map { x => "order" -> OverlayMarkDefOrderCodec.encode(x) },
        j.`fill`.map { x => "fill" -> OverlayMarkDefFillCodec.encode(x) },
        j.`interpolate`.map { x => "interpolate" -> OverlayMarkDefInterpolateCodec.encode(x) },
        j.`theta`.map { x => "theta" -> OverlayMarkDefThetaCodec.encode(x) },
        j.`orient`.map { x => "orient" -> OrientationCodec.encode(x) },
        j.`innerRadius`.map { x => "innerRadius" -> OverlayMarkDefInnerRadiusCodec.encode(x) },
        j.`fontSize`.map { x => "fontSize" -> OverlayMarkDefFontSizeCodec.encode(x) },
        j.`y2`.map { x => "y2" -> OverlayMarkDefY2Codec.encode(x) },
        j.`shape`.map { x => "shape" -> OverlayMarkDefShapeCodec.encode(x) },
        j.`aria`.map { x => "aria" -> OverlayMarkDefAriaCodec.encode(x) },
        j.`opacity`.map { x => "opacity" -> OverlayMarkDefOpacityCodec.encode(x) },
        j.`radiusOffset`.map { x => "radiusOffset" -> OverlayMarkDefRadiusOffsetCodec.encode(x) },
        j.`dx`.map { x => "dx" -> OverlayMarkDefDxCodec.encode(x) },
        j.`clip`.map { x => "clip" -> Json.toJson(x) },
        j.`cornerRadiusBottomLeft`.map { x => "cornerRadiusBottomLeft" -> OverlayMarkDefCornerRadiusBottomLeftCodec.encode(x) },
        j.`href`.map { x => "href" -> OverlayMarkDefHrefCodec.encode(x) },
        j.`strokeDash`.map { x => "strokeDash" -> OverlayMarkDefStrokeDashCodec.encode(x) },
        j.`strokeOffset`.map { x => "strokeOffset" -> OverlayMarkDefStrokeOffsetCodec.encode(x) },
        j.`limit`.map { x => "limit" -> OverlayMarkDefLimitCodec.encode(x) },
        j.`y2Offset`.map { x => "y2Offset" -> OverlayMarkDefY2OffsetCodec.encode(x) },
        j.`thetaOffset`.map { x => "thetaOffset" -> OverlayMarkDefThetaOffsetCodec.encode(x) },
        j.`width`.map { x => "width" -> OverlayMarkDefWidthCodec.encode(x) },
        j.`fontWeight`.map { x => "fontWeight" -> OverlayMarkDefFontWeightCodec.encode(x) },
        j.`timeUnitBandPosition`.map { x => "timeUnitBandPosition" -> Json.toJson(x) },
        j.`yOffset`.map { x => "yOffset" -> OverlayMarkDefYOffsetCodec.encode(x) },
        j.`filled`.map { x => "filled" -> Json.toJson(x) },
        j.`blend`.map { x => "blend" -> OverlayMarkDefBlendCodec.encode(x) },
        j.`strokeWidth`.map { x => "strokeWidth" -> OverlayMarkDefStrokeWidthCodec.encode(x) },
        j.`theta2`.map { x => "theta2" -> OverlayMarkDefTheta2Codec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TopLevelFacetSpecFacet (UnionType)
object TopLevelFacetSpecFacetCodec {
  def decode(j: JsValue): TopLevelFacetSpecFacet =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelFacetSpecFacet] =
    FacetFieldDefCodec.decodeOpt(j).orElse {
    FacetMappingCodec.decodeOpt(j) } 
  def encode(j: TopLevelFacetSpecFacet): JsValue =
    j match {
      case x:FacetFieldDef /* TypeRef */ => FacetFieldDefCodec.encode(x)
      case x:FacetMapping /* TypeRef */ => FacetMappingCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BinTransformAs (UnionType)
object BinTransformAsCodec {
  def decode(j: JsValue): BinTransformAs =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BinTransformAs] =
    j.asOpt[String].map { BinTransformAsAsString(_) }.orElse {
    ArrayOfStringCodec.decodeOpt(j).map { BinTransformAsAsArrayOfString(_) } } 
  def encode(j: BinTransformAs): JsValue =
    j match {
      case BinTransformAsAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case BinTransformAsAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTickColor (UnionType)
object AxisConfigTickColorCodec {
  def decode(j: JsValue): AxisConfigTickColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTickColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => AxisConfigTickColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisColorCodec.decodeOpt(j) } } } 
  def encode(j: AxisConfigTickColor): JsValue =
    j match {
      case AxisConfigTickColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisColor /* TypeRef */ => ConditionalAxisColorCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefInvalid (EnumType)
object OverlayMarkDefInvalidCodec {
  def decode(j: JsValue): OverlayMarkDefInvalid =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefInvalid] =
    j match {
      case JsString("filter") => Some(OverlayMarkDefInvalidFilter)
      case JsNull => Some(OverlayMarkDefInvalidUndefined)
      case _ => None
    }
  def encode(j: OverlayMarkDefInvalid): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingXType (UnionType)
object SharedEncodingXTypeCodec {
  def decode(j: JsValue): SharedEncodingXType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingXType] =
    StandardTypeCodec.decodeOpt(j).orElse {
    TypeCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingXType): JsValue =
    j match {
      case x:StandardType /* TypeRef */ => StandardTypeCodec.encode(x)
      case x:Type /* TypeRef */ => TypeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefFillOpacity (UnionType)
object MarkDefFillOpacityCodec {
  def decode(j: JsValue): MarkDefFillOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefFillOpacity] =
    MarkDefFillOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefFillOpacity): JsValue =
    j match {
      case x:MarkDefFillOpacityAsNumber /* TypeRef */ => MarkDefFillOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigTitleFontStyle (UnionType)
object LegendConfigTitleFontStyleCodec {
  def decode(j: JsValue): LegendConfigTitleFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigTitleFontStyle] =
    j.asOpt[String].map { LegendConfigTitleFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigTitleFontStyle): JsValue =
    j match {
      case LegendConfigTitleFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RegressionTransformMethod (EnumType)
object RegressionTransformMethodCodec {
  def decode(j: JsValue): RegressionTransformMethod =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RegressionTransformMethod] =
    j match {
      case JsString("linear") => Some(RegressionTransformMethodLinear)
      case JsString("log") => Some(RegressionTransformMethodLog)
      case JsString("exp") => Some(RegressionTransformMethodExp)
      case JsString("pow") => Some(RegressionTransformMethodPow)
      case JsString("quad") => Some(RegressionTransformMethodQuad)
      case JsString("poly") => Some(RegressionTransformMethodPoly)
      case _ => None
    }
  def encode(j: RegressionTransformMethod): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// AxisConfigTickOpacity (UnionType)
object AxisConfigTickOpacityCodec {
  def decode(j: JsValue): AxisConfigTickOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTickOpacity] =
    j.asOpt[JsNumber].map { AxisConfigTickOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigTickOpacity): JsValue =
    j match {
      case AxisConfigTickOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigInnerRadius (UnionType)
object LineConfigInnerRadiusCodec {
  def decode(j: JsValue): LineConfigInnerRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigInnerRadius] =
    j.asOpt[JsNumber].map { LineConfigInnerRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigInnerRadius): JsValue =
    j match {
      case LineConfigInnerRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SampleTransform (StructType)
object SampleTransformCodec {
  def decode(j: JsValue): SampleTransform =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SampleTransform] =
    {
      val `sample` = (j \ "sample").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      if(`sample`.isEmpty) { return None }
      return Some(SampleTransform(
        `sample` = `sample`.get,
      ))
    }

  def encode(j: SampleTransform): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("sample" -> Json.toJson(j.`sample`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TopLevelUnitSpecHeight (UnionType)
object TopLevelUnitSpecHeightCodec {
  def decode(j: JsValue): TopLevelUnitSpecHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelUnitSpecHeight] =
    j.asOpt[JsNumber].map { TopLevelUnitSpecHeightAsNumber(_) }.orElse {
    ContainerCodec.decodeOpt(j).orElse {
    StepCodec.decodeOpt(j) } } 
  def encode(j: TopLevelUnitSpecHeight): JsValue =
    j match {
      case TopLevelUnitSpecHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Container /* TypeRef */ => ContainerCodec.encode(x)
      case x:Step /* TypeRef */ => StepCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefStrokeJoin (UnionType)
object MarkDefStrokeJoinCodec {
  def decode(j: JsValue): MarkDefStrokeJoin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefStrokeJoin] =
    StrokeJoinCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefStrokeJoin): JsValue =
    j match {
      case x:StrokeJoin /* TypeRef */ => StrokeJoinCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleConfigFontWeight (UnionType)
object TitleConfigFontWeightCodec {
  def decode(j: JsValue): TitleConfigFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleConfigFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefStyle (UnionType)
object OverlayMarkDefStyleCodec {
  def decode(j: JsValue): OverlayMarkDefStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefStyle] =
    j.asOpt[String].map { OverlayMarkDefStyleAsString(_) }.orElse {
    ArrayOfStringCodec.decodeOpt(j).map { OverlayMarkDefStyleAsArrayOfString(_) } } 
  def encode(j: OverlayMarkDefStyle): JsValue =
    j match {
      case OverlayMarkDefStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case OverlayMarkDefStyleAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionDatumDefGradientStringNull (StructType)
object FieldOrDatumDefWithConditionDatumDefGradientStringNullCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionDatumDefGradientStringNull =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionDatumDefGradientStringNull] =
    Some(FieldOrDatumDefWithConditionDatumDefGradientStringNull(
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionDatumDefGradientStringNullDatumCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionDatumDefGradientStringNullBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionDatumDefGradientStringNullConditionCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeCodec.decodeOpt(x) },
    ))

  def encode(j: FieldOrDatumDefWithConditionDatumDefGradientStringNull): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`datum`.map { x => "datum" -> FieldOrDatumDefWithConditionDatumDefGradientStringNullDatumCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> FieldOrDatumDefWithConditionDatumDefGradientStringNullBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> FieldOrDatumDefWithConditionDatumDefGradientStringNullConditionCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ScaleConfigBandPaddingInner (UnionType)
object ScaleConfigBandPaddingInnerCodec {
  def decode(j: JsValue): ScaleConfigBandPaddingInner =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleConfigBandPaddingInner] =
    j.asOpt[JsNumber].map { ScaleConfigBandPaddingInnerAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleConfigBandPaddingInner): JsValue =
    j match {
      case ScaleConfigBandPaddingInnerAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ErrorBarDefRule (UnionType)
object ErrorBarDefRuleCodec {
  def decode(j: JsValue): ErrorBarDefRule =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ErrorBarDefRule] =
    j.asOpt[Boolean].map { ErrorBarDefRuleAsBool(_) }.orElse {
    MarkConfigCodec.decodeOpt(j) } 
  def encode(j: ErrorBarDefRule): JsValue =
    j match {
      case ErrorBarDefRuleAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:MarkConfig /* TypeRef */ => MarkConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigCornerRadiusBottomLeft (UnionType)
object LineConfigCornerRadiusBottomLeftCodec {
  def decode(j: JsValue): LineConfigCornerRadiusBottomLeft =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigCornerRadiusBottomLeft] =
    j.asOpt[JsNumber].map { LineConfigCornerRadiusBottomLeftAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigCornerRadiusBottomLeft): JsValue =
    j match {
      case LineConfigCornerRadiusBottomLeftAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfConditionalPredicateValueDefColorNullExprRef (ArrayType)
object ArrayOfConditionalPredicateValueDefColorNullExprRefCodec {
  def decode(j: JsValue): Seq[ConditionalPredicateValueDefColorNullExprRef] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[ConditionalPredicateValueDefColorNullExprRef]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      ConditionalPredicateValueDefColorNullExprRefCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[ConditionalPredicateValueDefColorNullExprRef]): JsArray =
      JsArray(j.map { x => ConditionalPredicateValueDefColorNullExprRefCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingColorValue (UnionType)
object SharedEncodingColorValueCodec {
  def decode(j: JsValue): SharedEncodingColorValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingColorValue] =
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[String].map { SharedEncodingColorValueAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingColorValueAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingColorValue): JsValue =
    j match {
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case SharedEncodingColorValueAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case SharedEncodingColorValueAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisColor (UnionType)
object ConditionalAxisColorCodec {
  def decode(j: JsValue): ConditionalAxisColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisColor] =
    ConditionalAxisColorAsObject1Codec.decodeOpt(j).orElse {
    ConditionalAxisColorAsObject2Codec.decodeOpt(j) } 
  def encode(j: ConditionalAxisColor): JsValue =
    j match {
      case x:ConditionalAxisColorAsObject1 /* TypeRef */ => ConditionalAxisColorAsObject1Codec.encode(x)
      case x:ConditionalAxisColorAsObject2 /* TypeRef */ => ConditionalAxisColorAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigStrokeOffset (UnionType)
object BarConfigStrokeOffsetCodec {
  def decode(j: JsValue): BarConfigStrokeOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigStrokeOffset] =
    j.asOpt[JsNumber].map { BarConfigStrokeOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigStrokeOffset): JsValue =
    j match {
      case BarConfigStrokeOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigInterpolate (UnionType)
object AreaConfigInterpolateCodec {
  def decode(j: JsValue): AreaConfigInterpolate =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigInterpolate] =
    InterpolateCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigInterpolate): JsValue =
    j match {
      case x:Interpolate /* TypeRef */ => InterpolateCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfig (StructType)
object ScaleConfigCodec {
  def decode(j: JsValue): ScaleConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ScaleConfig] =
    Some(ScaleConfig(
      `minOpacity` = (j \ "minOpacity").asOpt[JsValue].flatMap { x => ScaleConfigMinOpacityCodec.decodeOpt(x) },
      `bandWithNestedOffsetPaddingInner` = (j \ "bandWithNestedOffsetPaddingInner").asOpt[JsValue].flatMap { x => ScaleConfigBandWithNestedOffsetPaddingInnerCodec.decodeOpt(x) },
      `quantizeCount` = (j \ "quantizeCount").asOpt[JsValue].flatMap { x => ScaleConfigQuantizeCountCodec.decodeOpt(x) },
      `clamp` = (j \ "clamp").asOpt[JsValue].flatMap { x => ScaleConfigClampCodec.decodeOpt(x) },
      `minBandSize` = (j \ "minBandSize").asOpt[JsValue].flatMap { x => ScaleConfigMinBandSizeCodec.decodeOpt(x) },
      `barBandPaddingInner` = (j \ "barBandPaddingInner").asOpt[JsValue].flatMap { x => ScaleConfigBarBandPaddingInnerCodec.decodeOpt(x) },
      `quantileCount` = (j \ "quantileCount").asOpt[JsValue].flatMap { x => ScaleConfigQuantileCountCodec.decodeOpt(x) },
      `useUnaggregatedDomain` = (j \ "useUnaggregatedDomain").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `maxBandSize` = (j \ "maxBandSize").asOpt[JsValue].flatMap { x => ScaleConfigMaxBandSizeCodec.decodeOpt(x) },
      `round` = (j \ "round").asOpt[JsValue].flatMap { x => ScaleConfigRoundCodec.decodeOpt(x) },
      `rectBandPaddingInner` = (j \ "rectBandPaddingInner").asOpt[JsValue].flatMap { x => ScaleConfigRectBandPaddingInnerCodec.decodeOpt(x) },
      `maxSize` = (j \ "maxSize").asOpt[JsValue].flatMap { x => ScaleConfigMaxSizeCodec.decodeOpt(x) },
      `minSize` = (j \ "minSize").asOpt[JsValue].flatMap { x => ScaleConfigMinSizeCodec.decodeOpt(x) },
      `bandPaddingInner` = (j \ "bandPaddingInner").asOpt[JsValue].flatMap { x => ScaleConfigBandPaddingInnerCodec.decodeOpt(x) },
      `minFontSize` = (j \ "minFontSize").asOpt[JsValue].flatMap { x => ScaleConfigMinFontSizeCodec.decodeOpt(x) },
      `maxOpacity` = (j \ "maxOpacity").asOpt[JsValue].flatMap { x => ScaleConfigMaxOpacityCodec.decodeOpt(x) },
      `offsetBandPaddingInner` = (j \ "offsetBandPaddingInner").asOpt[JsValue].flatMap { x => ScaleConfigOffsetBandPaddingInnerCodec.decodeOpt(x) },
      `minStrokeWidth` = (j \ "minStrokeWidth").asOpt[JsValue].flatMap { x => ScaleConfigMinStrokeWidthCodec.decodeOpt(x) },
      `bandWithNestedOffsetPaddingOuter` = (j \ "bandWithNestedOffsetPaddingOuter").asOpt[JsValue].flatMap { x => ScaleConfigBandWithNestedOffsetPaddingOuterCodec.decodeOpt(x) },
      `pointPadding` = (j \ "pointPadding").asOpt[JsValue].flatMap { x => ScaleConfigPointPaddingCodec.decodeOpt(x) },
      `maxStrokeWidth` = (j \ "maxStrokeWidth").asOpt[JsValue].flatMap { x => ScaleConfigMaxStrokeWidthCodec.decodeOpt(x) },
      `maxFontSize` = (j \ "maxFontSize").asOpt[JsValue].flatMap { x => ScaleConfigMaxFontSizeCodec.decodeOpt(x) },
      `xReverse` = (j \ "xReverse").asOpt[JsValue].flatMap { x => ScaleConfigXReverseCodec.decodeOpt(x) },
      `offsetBandPaddingOuter` = (j \ "offsetBandPaddingOuter").asOpt[JsValue].flatMap { x => ScaleConfigOffsetBandPaddingOuterCodec.decodeOpt(x) },
      `bandPaddingOuter` = (j \ "bandPaddingOuter").asOpt[JsValue].flatMap { x => ScaleConfigBandPaddingOuterCodec.decodeOpt(x) },
      `continuousPadding` = (j \ "continuousPadding").asOpt[JsValue].flatMap { x => ScaleConfigContinuousPaddingCodec.decodeOpt(x) },
    ))

  def encode(j: ScaleConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`minOpacity`.map { x => "minOpacity" -> ScaleConfigMinOpacityCodec.encode(x) },
        j.`bandWithNestedOffsetPaddingInner`.map { x => "bandWithNestedOffsetPaddingInner" -> ScaleConfigBandWithNestedOffsetPaddingInnerCodec.encode(x) },
        j.`quantizeCount`.map { x => "quantizeCount" -> ScaleConfigQuantizeCountCodec.encode(x) },
        j.`clamp`.map { x => "clamp" -> ScaleConfigClampCodec.encode(x) },
        j.`minBandSize`.map { x => "minBandSize" -> ScaleConfigMinBandSizeCodec.encode(x) },
        j.`barBandPaddingInner`.map { x => "barBandPaddingInner" -> ScaleConfigBarBandPaddingInnerCodec.encode(x) },
        j.`quantileCount`.map { x => "quantileCount" -> ScaleConfigQuantileCountCodec.encode(x) },
        j.`useUnaggregatedDomain`.map { x => "useUnaggregatedDomain" -> Json.toJson(x) },
        j.`maxBandSize`.map { x => "maxBandSize" -> ScaleConfigMaxBandSizeCodec.encode(x) },
        j.`round`.map { x => "round" -> ScaleConfigRoundCodec.encode(x) },
        j.`rectBandPaddingInner`.map { x => "rectBandPaddingInner" -> ScaleConfigRectBandPaddingInnerCodec.encode(x) },
        j.`maxSize`.map { x => "maxSize" -> ScaleConfigMaxSizeCodec.encode(x) },
        j.`minSize`.map { x => "minSize" -> ScaleConfigMinSizeCodec.encode(x) },
        j.`bandPaddingInner`.map { x => "bandPaddingInner" -> ScaleConfigBandPaddingInnerCodec.encode(x) },
        j.`minFontSize`.map { x => "minFontSize" -> ScaleConfigMinFontSizeCodec.encode(x) },
        j.`maxOpacity`.map { x => "maxOpacity" -> ScaleConfigMaxOpacityCodec.encode(x) },
        j.`offsetBandPaddingInner`.map { x => "offsetBandPaddingInner" -> ScaleConfigOffsetBandPaddingInnerCodec.encode(x) },
        j.`minStrokeWidth`.map { x => "minStrokeWidth" -> ScaleConfigMinStrokeWidthCodec.encode(x) },
        j.`bandWithNestedOffsetPaddingOuter`.map { x => "bandWithNestedOffsetPaddingOuter" -> ScaleConfigBandWithNestedOffsetPaddingOuterCodec.encode(x) },
        j.`pointPadding`.map { x => "pointPadding" -> ScaleConfigPointPaddingCodec.encode(x) },
        j.`maxStrokeWidth`.map { x => "maxStrokeWidth" -> ScaleConfigMaxStrokeWidthCodec.encode(x) },
        j.`maxFontSize`.map { x => "maxFontSize" -> ScaleConfigMaxFontSizeCodec.encode(x) },
        j.`xReverse`.map { x => "xReverse" -> ScaleConfigXReverseCodec.encode(x) },
        j.`offsetBandPaddingOuter`.map { x => "offsetBandPaddingOuter" -> ScaleConfigOffsetBandPaddingOuterCodec.encode(x) },
        j.`bandPaddingOuter`.map { x => "bandPaddingOuter" -> ScaleConfigBandPaddingOuterCodec.encode(x) },
        j.`continuousPadding`.map { x => "continuousPadding" -> ScaleConfigContinuousPaddingCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// RegressionTransformAs (ConstrainedType)
object RegressionTransformAsCodec {
  def decode(j: JsValue): RegressionTransformAs =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RegressionTransformAs] =
    try {
      ArrayOfStringCodec.decodeOpt(j)
        .map { RegressionTransformAs(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: RegressionTransformAs): JsValue =
    ArrayOfStringCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// TickConfigAria (UnionType)
object TickConfigAriaCodec {
  def decode(j: JsValue): TickConfigAria =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigAria] =
    j.asOpt[Boolean].map { TickConfigAriaAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigAria): JsValue =
    j match {
      case TickConfigAriaAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigClipHeight (UnionType)
object LegendConfigClipHeightCodec {
  def decode(j: JsValue): LegendConfigClipHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigClipHeight] =
    j.asOpt[JsNumber].map { LegendConfigClipHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigClipHeight): JsValue =
    j match {
      case LegendConfigClipHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewConfigStrokeOpacity (UnionType)
object ViewConfigStrokeOpacityCodec {
  def decode(j: JsValue): ViewConfigStrokeOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewConfigStrokeOpacity] =
    ViewConfigStrokeOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ViewConfigStrokeOpacity): JsValue =
    j match {
      case x:ViewConfigStrokeOpacityAsNumber /* TypeRef */ => ViewConfigStrokeOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigSize (UnionType)
object MarkConfigSizeCodec {
  def decode(j: JsValue): MarkConfigSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigSize] =
    j.asOpt[JsNumber].map { MarkConfigSizeAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigSize): JsValue =
    j match {
      case MarkConfigSizeAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTickOffset (UnionType)
object AxisTickOffsetCodec {
  def decode(j: JsValue): AxisTickOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTickOffset] =
    j.asOpt[JsNumber].map { AxisTickOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisTickOffset): JsValue =
    j match {
      case AxisTickOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTitleAnchor (UnionType)
object AxisConfigTitleAnchorCodec {
  def decode(j: JsValue): AxisConfigTitleAnchor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTitleAnchor] =
    TitleAnchorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigTitleAnchor): JsValue =
    j match {
      case x:TitleAnchor /* TypeRef */ => TitleAnchorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleConfigFontSize (UnionType)
object TitleConfigFontSizeCodec {
  def decode(j: JsValue): TitleConfigFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigFontSize] =
    TitleConfigFontSizeAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleConfigFontSize): JsValue =
    j match {
      case x:TitleConfigFontSizeAsNumber /* TypeRef */ => TitleConfigFontSizeAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RowColumnEncodingFieldDefBandPosition (ConstrainedType)
object RowColumnEncodingFieldDefBandPositionCodec {
  def decode(j: JsValue): RowColumnEncodingFieldDefBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RowColumnEncodingFieldDefBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { RowColumnEncodingFieldDefBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: RowColumnEncodingFieldDefBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// BrushConfig (StructType)
object BrushConfigCodec {
  def decode(j: JsValue): BrushConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BrushConfig] =
    Some(BrushConfig(
      `strokeOpacity` = (j \ "strokeOpacity").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `fillOpacity` = (j \ "fillOpacity").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `cursor` = (j \ "cursor").asOpt[JsValue].flatMap { x => CursorCodec.decodeOpt(x) },
      `fill` = (j \ "fill").asOpt[JsValue].flatMap { x => ColorCodec.decodeOpt(x) },
      `strokeDash` = (j \ "strokeDash").asOpt[JsValue].flatMap { x => ArrayOfNumberCodec.decodeOpt(x) },
      `strokeWidth` = (j \ "strokeWidth").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `stroke` = (j \ "stroke").asOpt[JsValue].flatMap { x => ColorCodec.decodeOpt(x) },
      `strokeDashOffset` = (j \ "strokeDashOffset").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
    ))

  def encode(j: BrushConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`strokeOpacity`.map { x => "strokeOpacity" -> Json.toJson(x) },
        j.`fillOpacity`.map { x => "fillOpacity" -> Json.toJson(x) },
        j.`cursor`.map { x => "cursor" -> CursorCodec.encode(x) },
        j.`fill`.map { x => "fill" -> ColorCodec.encode(x) },
        j.`strokeDash`.map { x => "strokeDash" -> ArrayOfNumberCodec.encode(x) },
        j.`strokeWidth`.map { x => "strokeWidth" -> Json.toJson(x) },
        j.`stroke`.map { x => "stroke" -> ColorCodec.encode(x) },
        j.`strokeDashOffset`.map { x => "strokeDashOffset" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ProjectionConfigScale (UnionType)
object ProjectionConfigScaleCodec {
  def decode(j: JsValue): ProjectionConfigScale =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigScale] =
    j.asOpt[JsNumber].map { ProjectionConfigScaleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigScale): JsValue =
    j match {
      case ProjectionConfigScaleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefStrokeOpacity (UnionType)
object OverlayMarkDefStrokeOpacityCodec {
  def decode(j: JsValue): OverlayMarkDefStrokeOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefStrokeOpacity] =
    OverlayMarkDefStrokeOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefStrokeOpacity): JsValue =
    j match {
      case x:OverlayMarkDefStrokeOpacityAsNumber /* TypeRef */ => OverlayMarkDefStrokeOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefOrder (UnionType)
object OverlayMarkDefOrderCodec {
  def decode(j: JsValue): OverlayMarkDefOrder =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefOrder] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => OverlayMarkDefOrderAsNull }.orElse {
    j.asOpt[Boolean].map { OverlayMarkDefOrderAsBool(_) } } 
  def encode(j: OverlayMarkDefOrder): JsValue =
    j match {
      case OverlayMarkDefOrderAsNull /* Global, NullType$ */ => JsNull
      case OverlayMarkDefOrderAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigLabelPadding (UnionType)
object LegendConfigLabelPaddingCodec {
  def decode(j: JsValue): LegendConfigLabelPadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigLabelPadding] =
    j.asOpt[JsNumber].map { LegendConfigLabelPaddingAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigLabelPadding): JsValue =
    j match {
      case LegendConfigLabelPaddingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingThetaStack (UnionType)
object SharedEncodingThetaStackCodec {
  def decode(j: JsValue): SharedEncodingThetaStack =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingThetaStack] =
    StackOffsetCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingThetaStackAsNull }.orElse {
    j.asOpt[Boolean].map { SharedEncodingThetaStackAsBool(_) } } } 
  def encode(j: SharedEncodingThetaStack): JsValue =
    j match {
      case x:StackOffset /* TypeRef */ => StackOffsetCodec.encode(x)
      case SharedEncodingThetaStackAsNull /* Global, NullType$ */ => JsNull
      case SharedEncodingThetaStackAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfig (StructType)
object LineConfigCodec {
  def decode(j: JsValue): LineConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LineConfig] =
    Some(LineConfig(
      `point` = (j \ "point").asOpt[JsValue].flatMap { x => LineConfigPointCodec.decodeOpt(x) },
      `cornerRadiusBottomRight` = (j \ "cornerRadiusBottomRight").asOpt[JsValue].flatMap { x => LineConfigCornerRadiusBottomRightCodec.decodeOpt(x) },
      `fillOpacity` = (j \ "fillOpacity").asOpt[JsValue].flatMap { x => LineConfigFillOpacityCodec.decodeOpt(x) },
      `strokeMiterLimit` = (j \ "strokeMiterLimit").asOpt[JsValue].flatMap { x => LineConfigStrokeMiterLimitCodec.decodeOpt(x) },
      `dir` = (j \ "dir").asOpt[JsValue].flatMap { x => LineConfigDirCodec.decodeOpt(x) },
      `tooltip` = (j \ "tooltip").asOpt[JsValue].flatMap { x => LineConfigTooltipCodec.decodeOpt(x) },
      `timeUnitBandPosition` = (j \ "timeUnitBandPosition").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `cornerRadiusTopRight` = (j \ "cornerRadiusTopRight").asOpt[JsValue].flatMap { x => LineConfigCornerRadiusTopRightCodec.decodeOpt(x) },
      `outerRadius` = (j \ "outerRadius").asOpt[JsValue].flatMap { x => LineConfigOuterRadiusCodec.decodeOpt(x) },
      `x` = (j \ "x").asOpt[JsValue].flatMap { x => LineConfigXCodec.decodeOpt(x) },
      `dy` = (j \ "dy").asOpt[JsValue].flatMap { x => LineConfigDyCodec.decodeOpt(x) },
      `size` = (j \ "size").asOpt[JsValue].flatMap { x => LineConfigSizeCodec.decodeOpt(x) },
      `smooth` = (j \ "smooth").asOpt[JsValue].flatMap { x => LineConfigSmoothCodec.decodeOpt(x) },
      `url` = (j \ "url").asOpt[JsValue].flatMap { x => LineConfigUrlCodec.decodeOpt(x) },
      `y` = (j \ "y").asOpt[JsValue].flatMap { x => LineConfigYCodec.decodeOpt(x) },
      `strokeOpacity` = (j \ "strokeOpacity").asOpt[JsValue].flatMap { x => LineConfigStrokeOpacityCodec.decodeOpt(x) },
      `ellipsis` = (j \ "ellipsis").asOpt[JsValue].flatMap { x => LineConfigEllipsisCodec.decodeOpt(x) },
      `description` = (j \ "description").asOpt[JsValue].flatMap { x => LineConfigDescriptionCodec.decodeOpt(x) },
      `angle` = (j \ "angle").asOpt[JsValue].flatMap { x => LineConfigAngleCodec.decodeOpt(x) },
      `lineBreak` = (j \ "lineBreak").asOpt[JsValue].flatMap { x => LineConfigLineBreakCodec.decodeOpt(x) },
      `tension` = (j \ "tension").asOpt[JsValue].flatMap { x => LineConfigTensionCodec.decodeOpt(x) },
      `cornerRadiusTopLeft` = (j \ "cornerRadiusTopLeft").asOpt[JsValue].flatMap { x => LineConfigCornerRadiusTopLeftCodec.decodeOpt(x) },
      `stroke` = (j \ "stroke").asOpt[JsValue].flatMap { x => LineConfigStrokeCodec.decodeOpt(x) },
      `strokeDashOffset` = (j \ "strokeDashOffset").asOpt[JsValue].flatMap { x => LineConfigStrokeDashOffsetCodec.decodeOpt(x) },
      `align` = (j \ "align").asOpt[JsValue].flatMap { x => LineConfigAlignCodec.decodeOpt(x) },
      `ariaRole` = (j \ "ariaRole").asOpt[JsValue].flatMap { x => LineConfigAriaRoleCodec.decodeOpt(x) },
      `strokeCap` = (j \ "strokeCap").asOpt[JsValue].flatMap { x => LineConfigStrokeCapCodec.decodeOpt(x) },
      `endAngle` = (j \ "endAngle").asOpt[JsValue].flatMap { x => LineConfigEndAngleCodec.decodeOpt(x) },
      `strokeJoin` = (j \ "strokeJoin").asOpt[JsValue].flatMap { x => LineConfigStrokeJoinCodec.decodeOpt(x) },
      `baseline` = (j \ "baseline").asOpt[JsValue].flatMap { x => LineConfigBaselineCodec.decodeOpt(x) },
      `ariaRoleDescription` = (j \ "ariaRoleDescription").asOpt[JsValue].flatMap { x => LineConfigAriaRoleDescriptionCodec.decodeOpt(x) },
      `aspect` = (j \ "aspect").asOpt[JsValue].flatMap { x => LineConfigAspectCodec.decodeOpt(x) },
      `height` = (j \ "height").asOpt[JsValue].flatMap { x => LineConfigHeightCodec.decodeOpt(x) },
      `fontStyle` = (j \ "fontStyle").asOpt[JsValue].flatMap { x => LineConfigFontStyleCodec.decodeOpt(x) },
      `text` = (j \ "text").asOpt[JsValue].flatMap { x => LineConfigTextCodec.decodeOpt(x) },
      `cornerRadius` = (j \ "cornerRadius").asOpt[JsValue].flatMap { x => LineConfigCornerRadiusCodec.decodeOpt(x) },
      `color` = (j \ "color").asOpt[JsValue].flatMap { x => LineConfigColorCodec.decodeOpt(x) },
      `x2` = (j \ "x2").asOpt[JsValue].flatMap { x => LineConfigX2Codec.decodeOpt(x) },
      `padAngle` = (j \ "padAngle").asOpt[JsValue].flatMap { x => LineConfigPadAngleCodec.decodeOpt(x) },
      `cursor` = (j \ "cursor").asOpt[JsValue].flatMap { x => LineConfigCursorCodec.decodeOpt(x) },
      `radius` = (j \ "radius").asOpt[JsValue].flatMap { x => LineConfigRadiusCodec.decodeOpt(x) },
      `timeUnitBandSize` = (j \ "timeUnitBandSize").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `startAngle` = (j \ "startAngle").asOpt[JsValue].flatMap { x => LineConfigStartAngleCodec.decodeOpt(x) },
      `font` = (j \ "font").asOpt[JsValue].flatMap { x => LineConfigFontCodec.decodeOpt(x) },
      `radius2` = (j \ "radius2").asOpt[JsValue].flatMap { x => LineConfigRadius2Codec.decodeOpt(x) },
      `invalid` = (j \ "invalid").asOpt[JsValue].flatMap { x => LineConfigInvalidCodec.decodeOpt(x) },
      `lineHeight` = (j \ "lineHeight").asOpt[JsValue].flatMap { x => LineConfigLineHeightCodec.decodeOpt(x) },
      `order` = (j \ "order").asOpt[JsValue].flatMap { x => LineConfigOrderCodec.decodeOpt(x) },
      `fill` = (j \ "fill").asOpt[JsValue].flatMap { x => LineConfigFillCodec.decodeOpt(x) },
      `interpolate` = (j \ "interpolate").asOpt[JsValue].flatMap { x => LineConfigInterpolateCodec.decodeOpt(x) },
      `theta` = (j \ "theta").asOpt[JsValue].flatMap { x => LineConfigThetaCodec.decodeOpt(x) },
      `orient` = (j \ "orient").asOpt[JsValue].flatMap { x => OrientationCodec.decodeOpt(x) },
      `innerRadius` = (j \ "innerRadius").asOpt[JsValue].flatMap { x => LineConfigInnerRadiusCodec.decodeOpt(x) },
      `fontSize` = (j \ "fontSize").asOpt[JsValue].flatMap { x => LineConfigFontSizeCodec.decodeOpt(x) },
      `y2` = (j \ "y2").asOpt[JsValue].flatMap { x => LineConfigY2Codec.decodeOpt(x) },
      `shape` = (j \ "shape").asOpt[JsValue].flatMap { x => LineConfigShapeCodec.decodeOpt(x) },
      `aria` = (j \ "aria").asOpt[JsValue].flatMap { x => LineConfigAriaCodec.decodeOpt(x) },
      `opacity` = (j \ "opacity").asOpt[JsValue].flatMap { x => LineConfigOpacityCodec.decodeOpt(x) },
      `dx` = (j \ "dx").asOpt[JsValue].flatMap { x => LineConfigDxCodec.decodeOpt(x) },
      `cornerRadiusBottomLeft` = (j \ "cornerRadiusBottomLeft").asOpt[JsValue].flatMap { x => LineConfigCornerRadiusBottomLeftCodec.decodeOpt(x) },
      `href` = (j \ "href").asOpt[JsValue].flatMap { x => LineConfigHrefCodec.decodeOpt(x) },
      `strokeDash` = (j \ "strokeDash").asOpt[JsValue].flatMap { x => LineConfigStrokeDashCodec.decodeOpt(x) },
      `strokeOffset` = (j \ "strokeOffset").asOpt[JsValue].flatMap { x => LineConfigStrokeOffsetCodec.decodeOpt(x) },
      `limit` = (j \ "limit").asOpt[JsValue].flatMap { x => LineConfigLimitCodec.decodeOpt(x) },
      `width` = (j \ "width").asOpt[JsValue].flatMap { x => LineConfigWidthCodec.decodeOpt(x) },
      `fontWeight` = (j \ "fontWeight").asOpt[JsValue].flatMap { x => LineConfigFontWeightCodec.decodeOpt(x) },
      `filled` = (j \ "filled").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `blend` = (j \ "blend").asOpt[JsValue].flatMap { x => LineConfigBlendCodec.decodeOpt(x) },
      `strokeWidth` = (j \ "strokeWidth").asOpt[JsValue].flatMap { x => LineConfigStrokeWidthCodec.decodeOpt(x) },
      `theta2` = (j \ "theta2").asOpt[JsValue].flatMap { x => LineConfigTheta2Codec.decodeOpt(x) },
    ))

  def encode(j: LineConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`point`.map { x => "point" -> LineConfigPointCodec.encode(x) },
        j.`cornerRadiusBottomRight`.map { x => "cornerRadiusBottomRight" -> LineConfigCornerRadiusBottomRightCodec.encode(x) },
        j.`fillOpacity`.map { x => "fillOpacity" -> LineConfigFillOpacityCodec.encode(x) },
        j.`strokeMiterLimit`.map { x => "strokeMiterLimit" -> LineConfigStrokeMiterLimitCodec.encode(x) },
        j.`dir`.map { x => "dir" -> LineConfigDirCodec.encode(x) },
        j.`tooltip`.map { x => "tooltip" -> LineConfigTooltipCodec.encode(x) },
        j.`timeUnitBandPosition`.map { x => "timeUnitBandPosition" -> Json.toJson(x) },
        j.`cornerRadiusTopRight`.map { x => "cornerRadiusTopRight" -> LineConfigCornerRadiusTopRightCodec.encode(x) },
        j.`outerRadius`.map { x => "outerRadius" -> LineConfigOuterRadiusCodec.encode(x) },
        j.`x`.map { x => "x" -> LineConfigXCodec.encode(x) },
        j.`dy`.map { x => "dy" -> LineConfigDyCodec.encode(x) },
        j.`size`.map { x => "size" -> LineConfigSizeCodec.encode(x) },
        j.`smooth`.map { x => "smooth" -> LineConfigSmoothCodec.encode(x) },
        j.`url`.map { x => "url" -> LineConfigUrlCodec.encode(x) },
        j.`y`.map { x => "y" -> LineConfigYCodec.encode(x) },
        j.`strokeOpacity`.map { x => "strokeOpacity" -> LineConfigStrokeOpacityCodec.encode(x) },
        j.`ellipsis`.map { x => "ellipsis" -> LineConfigEllipsisCodec.encode(x) },
        j.`description`.map { x => "description" -> LineConfigDescriptionCodec.encode(x) },
        j.`angle`.map { x => "angle" -> LineConfigAngleCodec.encode(x) },
        j.`lineBreak`.map { x => "lineBreak" -> LineConfigLineBreakCodec.encode(x) },
        j.`tension`.map { x => "tension" -> LineConfigTensionCodec.encode(x) },
        j.`cornerRadiusTopLeft`.map { x => "cornerRadiusTopLeft" -> LineConfigCornerRadiusTopLeftCodec.encode(x) },
        j.`stroke`.map { x => "stroke" -> LineConfigStrokeCodec.encode(x) },
        j.`strokeDashOffset`.map { x => "strokeDashOffset" -> LineConfigStrokeDashOffsetCodec.encode(x) },
        j.`align`.map { x => "align" -> LineConfigAlignCodec.encode(x) },
        j.`ariaRole`.map { x => "ariaRole" -> LineConfigAriaRoleCodec.encode(x) },
        j.`strokeCap`.map { x => "strokeCap" -> LineConfigStrokeCapCodec.encode(x) },
        j.`endAngle`.map { x => "endAngle" -> LineConfigEndAngleCodec.encode(x) },
        j.`strokeJoin`.map { x => "strokeJoin" -> LineConfigStrokeJoinCodec.encode(x) },
        j.`baseline`.map { x => "baseline" -> LineConfigBaselineCodec.encode(x) },
        j.`ariaRoleDescription`.map { x => "ariaRoleDescription" -> LineConfigAriaRoleDescriptionCodec.encode(x) },
        j.`aspect`.map { x => "aspect" -> LineConfigAspectCodec.encode(x) },
        j.`height`.map { x => "height" -> LineConfigHeightCodec.encode(x) },
        j.`fontStyle`.map { x => "fontStyle" -> LineConfigFontStyleCodec.encode(x) },
        j.`text`.map { x => "text" -> LineConfigTextCodec.encode(x) },
        j.`cornerRadius`.map { x => "cornerRadius" -> LineConfigCornerRadiusCodec.encode(x) },
        j.`color`.map { x => "color" -> LineConfigColorCodec.encode(x) },
        j.`x2`.map { x => "x2" -> LineConfigX2Codec.encode(x) },
        j.`padAngle`.map { x => "padAngle" -> LineConfigPadAngleCodec.encode(x) },
        j.`cursor`.map { x => "cursor" -> LineConfigCursorCodec.encode(x) },
        j.`radius`.map { x => "radius" -> LineConfigRadiusCodec.encode(x) },
        j.`timeUnitBandSize`.map { x => "timeUnitBandSize" -> Json.toJson(x) },
        j.`startAngle`.map { x => "startAngle" -> LineConfigStartAngleCodec.encode(x) },
        j.`font`.map { x => "font" -> LineConfigFontCodec.encode(x) },
        j.`radius2`.map { x => "radius2" -> LineConfigRadius2Codec.encode(x) },
        j.`invalid`.map { x => "invalid" -> LineConfigInvalidCodec.encode(x) },
        j.`lineHeight`.map { x => "lineHeight" -> LineConfigLineHeightCodec.encode(x) },
        j.`order`.map { x => "order" -> LineConfigOrderCodec.encode(x) },
        j.`fill`.map { x => "fill" -> LineConfigFillCodec.encode(x) },
        j.`interpolate`.map { x => "interpolate" -> LineConfigInterpolateCodec.encode(x) },
        j.`theta`.map { x => "theta" -> LineConfigThetaCodec.encode(x) },
        j.`orient`.map { x => "orient" -> OrientationCodec.encode(x) },
        j.`innerRadius`.map { x => "innerRadius" -> LineConfigInnerRadiusCodec.encode(x) },
        j.`fontSize`.map { x => "fontSize" -> LineConfigFontSizeCodec.encode(x) },
        j.`y2`.map { x => "y2" -> LineConfigY2Codec.encode(x) },
        j.`shape`.map { x => "shape" -> LineConfigShapeCodec.encode(x) },
        j.`aria`.map { x => "aria" -> LineConfigAriaCodec.encode(x) },
        j.`opacity`.map { x => "opacity" -> LineConfigOpacityCodec.encode(x) },
        j.`dx`.map { x => "dx" -> LineConfigDxCodec.encode(x) },
        j.`cornerRadiusBottomLeft`.map { x => "cornerRadiusBottomLeft" -> LineConfigCornerRadiusBottomLeftCodec.encode(x) },
        j.`href`.map { x => "href" -> LineConfigHrefCodec.encode(x) },
        j.`strokeDash`.map { x => "strokeDash" -> LineConfigStrokeDashCodec.encode(x) },
        j.`strokeOffset`.map { x => "strokeOffset" -> LineConfigStrokeOffsetCodec.encode(x) },
        j.`limit`.map { x => "limit" -> LineConfigLimitCodec.encode(x) },
        j.`width`.map { x => "width" -> LineConfigWidthCodec.encode(x) },
        j.`fontWeight`.map { x => "fontWeight" -> LineConfigFontWeightCodec.encode(x) },
        j.`filled`.map { x => "filled" -> Json.toJson(x) },
        j.`blend`.map { x => "blend" -> LineConfigBlendCodec.encode(x) },
        j.`strokeWidth`.map { x => "strokeWidth" -> LineConfigStrokeWidthCodec.encode(x) },
        j.`theta2`.map { x => "theta2" -> LineConfigTheta2Codec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// BarConfigLineBreak (UnionType)
object BarConfigLineBreakCodec {
  def decode(j: JsValue): BarConfigLineBreak =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigLineBreak] =
    j.asOpt[String].map { BarConfigLineBreakAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigLineBreak): JsValue =
    j match {
      case BarConfigLineBreakAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigLabelBound (UnionType)
object AxisConfigLabelBoundCodec {
  def decode(j: JsValue): AxisConfigLabelBound =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigLabelBound] =
    j.asOpt[JsNumber].map { AxisConfigLabelBoundAsNumber(_) }.orElse {
    j.asOpt[Boolean].map { AxisConfigLabelBoundAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigLabelBound): JsValue =
    j match {
      case AxisConfigLabelBoundAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case AxisConfigLabelBoundAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefOpacity (ConstrainedType)
// see OverlayMarkDefOpacity (UnionType)

////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject1Bounds (EnumType)
object TopLevelRepeatSpecAsObject1BoundsCodec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject1Bounds =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject1Bounds] =
    j match {
      case JsString("full") => Some(TopLevelRepeatSpecAsObject1BoundsFull)
      case JsString("flush") => Some(TopLevelRepeatSpecAsObject1BoundsFlush)
      case _ => None
    }
  def encode(j: TopLevelRepeatSpecAsObject1Bounds): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// DatumDefDatum (UnionType)
object DatumDefDatumCodec {
  def decode(j: JsValue): DatumDefDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[DatumDefDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: DatumDefDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefText (UnionType)
object MarkDefTextCodec {
  def decode(j: JsValue): MarkDefText =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefText] =
    TextCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefText): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefCornerRadiusTopLeft (UnionType)
object MarkDefCornerRadiusTopLeftCodec {
  def decode(j: JsValue): MarkDefCornerRadiusTopLeft =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefCornerRadiusTopLeft] =
    j.asOpt[JsNumber].map { MarkDefCornerRadiusTopLeftAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefCornerRadiusTopLeft): JsValue =
    j match {
      case MarkDefCornerRadiusTopLeftAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigStrokeMiterLimit (UnionType)
object TickConfigStrokeMiterLimitCodec {
  def decode(j: JsValue): TickConfigStrokeMiterLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigStrokeMiterLimit] =
    j.asOpt[JsNumber].map { TickConfigStrokeMiterLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigStrokeMiterLimit): JsValue =
    j match {
      case TickConfigStrokeMiterLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTitleFontSize (UnionType)
object AxisTitleFontSizeCodec {
  def decode(j: JsValue): AxisTitleFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTitleFontSize] =
    AxisTitleFontSizeAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisTitleFontSize): JsValue =
    j match {
      case x:AxisTitleFontSizeAsNumber /* TypeRef */ => AxisTitleFontSizeAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigAriaRole (UnionType)
object MarkConfigAriaRoleCodec {
  def decode(j: JsValue): MarkConfigAriaRole =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigAriaRole] =
    j.asOpt[String].map { MarkConfigAriaRoleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigAriaRole): JsValue =
    j match {
      case MarkConfigAriaRoleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// StringFieldDef (StructType)
object StringFieldDefCodec {
  def decode(j: JsValue): StringFieldDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[StringFieldDef] =
    Some(StringFieldDef(
      `format` = (j \ "format").asOpt[JsValue].flatMap { x => StringFieldDefFormatCodec.decodeOpt(x) },
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => StringFieldDefBandPositionCodec.decodeOpt(x) },
      `formatType` = (j \ "formatType").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => StringFieldDefBinCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => StringFieldDefTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) },
    ))

  def encode(j: StringFieldDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`format`.map { x => "format" -> StringFieldDefFormatCodec.encode(x) },
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> StringFieldDefBandPositionCodec.encode(x) },
        j.`formatType`.map { x => "formatType" -> Json.toJson(x) },
        j.`bin`.map { x => "bin" -> StringFieldDefBinCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> StringFieldDefTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConditionalParameterValueDefGradientStringNullExprRefValue (UnionType)
object ConditionalParameterValueDefGradientStringNullExprRefValueCodec {
  def decode(j: JsValue): ConditionalParameterValueDefGradientStringNullExprRefValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalParameterValueDefGradientStringNullExprRefValue] =
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[String].map { ConditionalParameterValueDefGradientStringNullExprRefValueAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ConditionalParameterValueDefGradientStringNullExprRefValueAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: ConditionalParameterValueDefGradientStringNullExprRefValue): JsValue =
    j match {
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case ConditionalParameterValueDefGradientStringNullExprRefValueAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case ConditionalParameterValueDefGradientStringNullExprRefValueAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigOrder (UnionType)
object BarConfigOrderCodec {
  def decode(j: JsValue): BarConfigOrder =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigOrder] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => BarConfigOrderAsNull }.orElse {
    j.asOpt[Boolean].map { BarConfigOrderAsBool(_) } } 
  def encode(j: BarConfigOrder): JsValue =
    j match {
      case BarConfigOrderAsNull /* Global, NullType$ */ => JsNull
      case BarConfigOrderAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Vector12String (ConstrainedType)
object Vector12StringCodec {
  def decode(j: JsValue): Vector12String =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Vector12String] =
    try {
      ArrayOfStringCodec.decodeOpt(j)
        .map { Vector12String(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: Vector12String): JsValue =
    ArrayOfStringCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// AreaConfigStrokeCap (UnionType)
object AreaConfigStrokeCapCodec {
  def decode(j: JsValue): AreaConfigStrokeCap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigStrokeCap] =
    StrokeCapCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigStrokeCap): JsValue =
    j match {
      case x:StrokeCap /* TypeRef */ => StrokeCapCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingFillOpacityDatum (UnionType)
object SharedEncodingFillOpacityDatumCodec {
  def decode(j: JsValue): SharedEncodingFillOpacityDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingFillOpacityDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingFillOpacityDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ImputeTransform (StructType)
object ImputeTransformCodec {
  def decode(j: JsValue): ImputeTransform =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ImputeTransform] =
    {
      val `method` = (j \ "method").asOpt[JsValue].flatMap { x => ImputeMethodCodec.decodeOpt(x) }
      val `impute` = (j \ "impute").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`impute`.isEmpty) { return None }
      val `frame` = (j \ "frame").asOpt[JsValue].flatMap { x => ImputeTransformFrameCodec.decodeOpt(x) }
      val `key` = (j \ "key").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`key`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => x.asOpt[JsValue] }
      val `groupby` = (j \ "groupby").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) }
      val `keyvals` = (j \ "keyvals").asOpt[JsValue].flatMap { x => ImputeTransformKeyvalsCodec.decodeOpt(x) }
      return Some(ImputeTransform(
        `method` = `method`,
        `impute` = `impute`.get,
        `frame` = `frame`,
        `key` = `key`.get,
        `value` = `value`,
        `groupby` = `groupby`,
        `keyvals` = `keyvals`,
      ))
    }

  def encode(j: ImputeTransform): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`method`.map { x => "method" -> ImputeMethodCodec.encode(x) },
        Some("impute" -> Json.toJson(j.`impute`)),
        j.`frame`.map { x => "frame" -> ImputeTransformFrameCodec.encode(x) },
        Some("key" -> Json.toJson(j.`key`)),
        j.`value`.map { x => "value" -> Json.toJson(x) },
        j.`groupby`.map { x => "groupby" -> ArrayOfStringCodec.encode(x) },
        j.`keyvals`.map { x => "keyvals" -> ImputeTransformKeyvalsCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TopLevelConcatSpecTitle (UnionType)
object TopLevelConcatSpecTitleCodec {
  def decode(j: JsValue): TopLevelConcatSpecTitle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelConcatSpecTitle] =
    TextCodec.decodeOpt(j).orElse {
    TitleParamsCodec.decodeOpt(j) } 
  def encode(j: TopLevelConcatSpecTitle): JsValue =
    j match {
      case x:Text /* TypeRef */ => TextCodec.encode(x)
      case x:TitleParams /* TypeRef */ => TitleParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigShape (UnionType)
object BarConfigShapeCodec {
  def decode(j: JsValue): BarConfigShape =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigShape] =
    j.asOpt[String].map { BarConfigShapeAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigShape): JsValue =
    j match {
      case BarConfigShapeAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfigCoefficient (UnionType)
object ProjectionConfigCoefficientCodec {
  def decode(j: JsValue): ProjectionConfigCoefficient =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigCoefficient] =
    j.asOpt[JsNumber].map { ProjectionConfigCoefficientAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigCoefficient): JsValue =
    j match {
      case ProjectionConfigCoefficientAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigTension (UnionType)
object RectConfigTensionCodec {
  def decode(j: JsValue): RectConfigTension =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigTension] =
    j.asOpt[JsNumber].map { RectConfigTensionAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigTension): JsValue =
    j match {
      case RectConfigTensionAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingXError2BandPosition (ConstrainedType)
object SharedEncodingXError2BandPositionCodec {
  def decode(j: JsValue): SharedEncodingXError2BandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingXError2BandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingXError2BandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingXError2BandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// DensityTransformAs (ConstrainedType)
object DensityTransformAsCodec {
  def decode(j: JsValue): DensityTransformAs =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[DensityTransformAs] =
    try {
      ArrayOfStringCodec.decodeOpt(j)
        .map { DensityTransformAs(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: DensityTransformAs): JsValue =
    ArrayOfStringCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// ErrorBar (ConstantType)
object ErrorBarCodec {
  def decode(j: JsValue): ErrorBar =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ErrorBar] =
    j match {
      case JsString("errorbar") => Some(ErrorBar())
      case _ => None
    }
  def encode(j: ErrorBar): JsValue =
    JsString("errorbar")
}


////////////////////////////////////////////////////////////////////////
// RectConfigBinSpacing (ConstrainedType)
object RectConfigBinSpacingCodec {
  def decode(j: JsValue): RectConfigBinSpacing =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RectConfigBinSpacing] =
    try {
      j.asOpt[JsNumber]
        .map { RectConfigBinSpacing(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: RectConfigBinSpacing): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefShape (UnionType)
object OverlayMarkDefShapeCodec {
  def decode(j: JsValue): OverlayMarkDefShape =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefShape] =
    j.asOpt[String].map { OverlayMarkDefShapeAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefShape): JsValue =
    j match {
      case OverlayMarkDefShapeAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PositionFieldDefBaseStack (UnionType)
object PositionFieldDefBaseStackCodec {
  def decode(j: JsValue): PositionFieldDefBaseStack =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PositionFieldDefBaseStack] =
    StackOffsetCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => PositionFieldDefBaseStackAsNull }.orElse {
    j.asOpt[Boolean].map { PositionFieldDefBaseStackAsBool(_) } } } 
  def encode(j: PositionFieldDefBaseStack): JsValue =
    j match {
      case x:StackOffset /* TypeRef */ => StackOffsetCodec.encode(x)
      case PositionFieldDefBaseStackAsNull /* Global, NullType$ */ => JsNull
      case PositionFieldDefBaseStackAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfWindowFieldDef (ArrayType)
object ArrayOfWindowFieldDefCodec {
  def decode(j: JsValue): Seq[WindowFieldDef] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[WindowFieldDef]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      WindowFieldDefCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[WindowFieldDef]): JsArray =
      JsArray(j.map { x => WindowFieldDefCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// LegendConfigGradientStrokeColor (UnionType)
object LegendConfigGradientStrokeColorCodec {
  def decode(j: JsValue): LegendConfigGradientStrokeColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigGradientStrokeColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => LegendConfigGradientStrokeColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: LegendConfigGradientStrokeColor): JsValue =
    j match {
      case LegendConfigGradientStrokeColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AllSortString (UnionType)
object AllSortStringCodec {
  def decode(j: JsValue): AllSortString =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AllSortString] =
    SortOrderCodec.decodeOpt(j).orElse {
    SortByChannelCodec.decodeOpt(j).orElse {
    SortByChannelDescCodec.decodeOpt(j) } } 
  def encode(j: AllSortString): JsValue =
    j match {
      case x:SortOrder /* TypeRef */ => SortOrderCodec.encode(x)
      case x:SortByChannel /* TypeRef */ => SortByChannelCodec.encode(x)
      case x:SortByChannelDesc /* TypeRef */ => SortByChannelDescCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullCondition (UnionType)
object ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullConditionCodec {
  def decode(j: JsValue): ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullCondition] =
    ConditionalMarkPropFieldOrDatumDefCodec.decodeOpt(j).orElse {
    ConditionalValueDefGradientStringNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefGradientStringNullExprRefCodec.decodeOpt(j).map { ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullConditionAsArrayOfConditionalValueDefGradientStringNullExprRef(_) } } } 
  def encode(j: ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullCondition): JsValue =
    j match {
      case x:ConditionalMarkPropFieldOrDatumDef /* TypeRef */ => ConditionalMarkPropFieldOrDatumDefCodec.encode(x)
      case x:ConditionalValueDefGradientStringNullExprRef /* TypeRef */ => ConditionalValueDefGradientStringNullExprRefCodec.encode(x)
      case ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullConditionAsArrayOfConditionalValueDefGradientStringNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefGradientStringNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// DerivedStreamFilter (UnionType)
object DerivedStreamFilterCodec {
  def decode(j: JsValue): DerivedStreamFilter =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[DerivedStreamFilter] =
    j.asOpt[String].map { DerivedStreamFilterAsString(_) }.orElse {
    ArrayOfStringCodec.decodeOpt(j).map { DerivedStreamFilterAsArrayOfString(_) } } 
  def encode(j: DerivedStreamFilter): JsValue =
    j match {
      case DerivedStreamFilterAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case DerivedStreamFilterAsArrayOfString(x) /* Base, ArrayType */ => ArrayOfStringCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisStringAsObject1Value (UnionType)
object ConditionalAxisStringAsObject1ValueCodec {
  def decode(j: JsValue): ConditionalAxisStringAsObject1Value =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisStringAsObject1Value] =
    j.asOpt[String].map { ConditionalAxisStringAsObject1ValueAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ConditionalAxisStringAsObject1ValueAsNull } } 
  def encode(j: ConditionalAxisStringAsObject1Value): JsValue =
    j match {
      case ConditionalAxisStringAsObject1ValueAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case ConditionalAxisStringAsObject1ValueAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigStrokeWidth (UnionType)
object LineConfigStrokeWidthCodec {
  def decode(j: JsValue): LineConfigStrokeWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigStrokeWidth] =
    LineConfigStrokeWidthAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigStrokeWidth): JsValue =
    j match {
      case x:LineConfigStrokeWidthAsNumber /* TypeRef */ => LineConfigStrokeWidthAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleConfigAngle (UnionType)
object TitleConfigAngleCodec {
  def decode(j: JsValue): TitleConfigAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigAngle] =
    j.asOpt[JsNumber].map { TitleConfigAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleConfigAngle): JsValue =
    j match {
      case TitleConfigAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BoxPlotConfig (StructType)
object BoxPlotConfigCodec {
  def decode(j: JsValue): BoxPlotConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BoxPlotConfig] =
    Some(BoxPlotConfig(
      `size` = (j \ "size").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `extent` = (j \ "extent").asOpt[JsValue].flatMap { x => BoxPlotConfigExtentCodec.decodeOpt(x) },
      `rule` = (j \ "rule").asOpt[JsValue].flatMap { x => BoxPlotConfigRuleCodec.decodeOpt(x) },
      `outliers` = (j \ "outliers").asOpt[JsValue].flatMap { x => BoxPlotConfigOutliersCodec.decodeOpt(x) },
      `median` = (j \ "median").asOpt[JsValue].flatMap { x => BoxPlotConfigMedianCodec.decodeOpt(x) },
      `ticks` = (j \ "ticks").asOpt[JsValue].flatMap { x => BoxPlotConfigTicksCodec.decodeOpt(x) },
      `box` = (j \ "box").asOpt[JsValue].flatMap { x => BoxPlotConfigBoxCodec.decodeOpt(x) },
    ))

  def encode(j: BoxPlotConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`size`.map { x => "size" -> Json.toJson(x) },
        j.`extent`.map { x => "extent" -> BoxPlotConfigExtentCodec.encode(x) },
        j.`rule`.map { x => "rule" -> BoxPlotConfigRuleCodec.encode(x) },
        j.`outliers`.map { x => "outliers" -> BoxPlotConfigOutliersCodec.encode(x) },
        j.`median`.map { x => "median" -> BoxPlotConfigMedianCodec.encode(x) },
        j.`ticks`.map { x => "ticks" -> BoxPlotConfigTicksCodec.encode(x) },
        j.`box`.map { x => "box" -> BoxPlotConfigBoxCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// Orient (EnumType)
object OrientCodec {
  def decode(j: JsValue): Orient =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Orient] =
    j match {
      case JsString("left") => Some(OrientLeft)
      case JsString("right") => Some(OrientRight)
      case JsString("top") => Some(OrientTop)
      case JsString("bottom") => Some(OrientBottom)
      case _ => None
    }
  def encode(j: Orient): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject1Background (UnionType)
object TopLevelRepeatSpecAsObject1BackgroundCodec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject1Background =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject1Background] =
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TopLevelRepeatSpecAsObject1Background): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PositionDatumDefStack (UnionType)
object PositionDatumDefStackCodec {
  def decode(j: JsValue): PositionDatumDefStack =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PositionDatumDefStack] =
    StackOffsetCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => PositionDatumDefStackAsNull }.orElse {
    j.asOpt[Boolean].map { PositionDatumDefStackAsBool(_) } } } 
  def encode(j: PositionDatumDefStack): JsValue =
    j match {
      case x:StackOffset /* TypeRef */ => StackOffsetCodec.encode(x)
      case PositionDatumDefStackAsNull /* Global, NullType$ */ => JsNull
      case PositionDatumDefStackAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// StackTransformAsAsArray (ConstrainedType)
object StackTransformAsAsArrayCodec {
  def decode(j: JsValue): StackTransformAsAsArray =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[StackTransformAsAsArray] =
    try {
      ArrayOfStringCodec.decodeOpt(j)
        .map { StackTransformAsAsArray(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: StackTransformAsAsArray): JsValue =
    ArrayOfStringCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// WindowTransformFrameElement (UnionType)
object WindowTransformFrameElementCodec {
  def decode(j: JsValue): WindowTransformFrameElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[WindowTransformFrameElement] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => WindowTransformFrameElementAsNull }.orElse {
    j.asOpt[JsNumber].map { WindowTransformFrameElementAsNumber(_) } } 
  def encode(j: WindowTransformFrameElement): JsValue =
    j match {
      case WindowTransformFrameElementAsNull /* Global, NullType$ */ => JsNull
      case WindowTransformFrameElementAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SelectionType (EnumType)
object SelectionTypeCodec {
  def decode(j: JsValue): SelectionType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SelectionType] =
    j match {
      case JsString("point") => Some(SelectionTypePoint)
      case JsString("interval") => Some(SelectionTypeInterval)
      case _ => None
    }
  def encode(j: SelectionType): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// Vector3Number (ConstrainedType)
object Vector3NumberCodec {
  def decode(j: JsValue): Vector3Number =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Vector3Number] =
    try {
      ArrayOfNumberCodec.decodeOpt(j)
        .map { Vector3Number(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: Vector3Number): JsValue =
    ArrayOfNumberCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// RectConfigCursor (UnionType)
object RectConfigCursorCodec {
  def decode(j: JsValue): RectConfigCursor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigCursor] =
    CursorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigCursor): JsValue =
    j match {
      case x:Cursor /* TypeRef */ => CursorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterValueDefNumberExprRefValue (UnionType)
object ConditionalParameterValueDefNumberExprRefValueCodec {
  def decode(j: JsValue): ConditionalParameterValueDefNumberExprRefValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalParameterValueDefNumberExprRefValue] =
    j.asOpt[JsNumber].map { ConditionalParameterValueDefNumberExprRefValueAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ConditionalParameterValueDefNumberExprRefValue): JsValue =
    j match {
      case ConditionalParameterValueDefNumberExprRefValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigFontWeight (UnionType)
object RectConfigFontWeightCodec {
  def decode(j: JsValue): RectConfigFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BoxPlotDefMedian (UnionType)
object BoxPlotDefMedianCodec {
  def decode(j: JsValue): BoxPlotDefMedian =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BoxPlotDefMedian] =
    j.asOpt[Boolean].map { BoxPlotDefMedianAsBool(_) }.orElse {
    MarkConfigCodec.decodeOpt(j) } 
  def encode(j: BoxPlotDefMedian): JsValue =
    j match {
      case BoxPlotDefMedianAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:MarkConfig /* TypeRef */ => MarkConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LayerRepeatSpecCenter (UnionType)
object LayerRepeatSpecCenterCodec {
  def decode(j: JsValue): LayerRepeatSpecCenter =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LayerRepeatSpecCenter] =
    j.asOpt[Boolean].map { LayerRepeatSpecCenterAsBool(_) }.orElse {
    RowColBooleanCodec.decodeOpt(j) } 
  def encode(j: LayerRepeatSpecCenter): JsValue =
    j match {
      case LayerRepeatSpecCenterAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:RowColBoolean /* TypeRef */ => RowColBooleanCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefFontStyle (UnionType)
object OverlayMarkDefFontStyleCodec {
  def decode(j: JsValue): OverlayMarkDefFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefFontStyle] =
    j.asOpt[String].map { OverlayMarkDefFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefFontStyle): JsValue =
    j match {
      case OverlayMarkDefFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTickWidth (UnionType)
object AxisConfigTickWidthCodec {
  def decode(j: JsValue): AxisConfigTickWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTickWidth] =
    AxisConfigTickWidthAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigTickWidth): JsValue =
    j match {
      case x:AxisConfigTickWidthAsNumber /* TypeRef */ => AxisConfigTickWidthAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullTimeUnit (UnionType)
object FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullTimeUnitCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfigFraction (UnionType)
object ProjectionConfigFractionCodec {
  def decode(j: JsValue): ProjectionConfigFraction =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigFraction] =
    j.asOpt[JsNumber].map { ProjectionConfigFractionAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigFraction): JsValue =
    j match {
      case ProjectionConfigFractionAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject1Align (UnionType)
object TopLevelRepeatSpecAsObject1AlignCodec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject1Align =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject1Align] =
    LayoutAlignCodec.decodeOpt(j).orElse {
    RowColLayoutAlignCodec.decodeOpt(j) } 
  def encode(j: TopLevelRepeatSpecAsObject1Align): JsValue =
    j match {
      case x:LayoutAlign /* TypeRef */ => LayoutAlignCodec.encode(x)
      case x:RowColLayoutAlign /* TypeRef */ => RowColLayoutAlignCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigHref (UnionType)
object AreaConfigHrefCodec {
  def decode(j: JsValue): AreaConfigHref =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigHref] =
    UriReferenceCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigHref): JsValue =
    j match {
      case x:UriReference /* TypeRef */ => UriReferenceCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1Bin (UnionType)
object ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1BinCodec {
  def decode(j: JsValue): ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1Bin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1Bin] =
    j.asOpt[Boolean].map { ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1BinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1BinAsNull } } } 
  def encode(j: ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1Bin): JsValue =
    j match {
      case ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1BinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case ConditionalPredicateMarkPropFieldOrDatumDefTypeForShapeAsObject1BinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigStrokeColor (UnionType)
object LegendConfigStrokeColorCodec {
  def decode(j: JsValue): LegendConfigStrokeColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigStrokeColor] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => LegendConfigStrokeColorAsNull }.orElse {
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: LegendConfigStrokeColor): JsValue =
    j match {
      case LegendConfigStrokeColorAsNull /* Global, NullType$ */ => JsNull
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldDefWithoutScaleBin (UnionType)
object FieldDefWithoutScaleBinCodec {
  def decode(j: JsValue): FieldDefWithoutScaleBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldDefWithoutScaleBin] =
    j.asOpt[Boolean].map { FieldDefWithoutScaleBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    BinnedCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => FieldDefWithoutScaleBinAsNull } } } } 
  def encode(j: FieldDefWithoutScaleBin): JsValue =
    j match {
      case FieldDefWithoutScaleBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case x:Binned /* TypeRef */ => BinnedCodec.encode(x)
      case FieldDefWithoutScaleBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigDomainWidth (UnionType)
object AxisConfigDomainWidthCodec {
  def decode(j: JsValue): AxisConfigDomainWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigDomainWidth] =
    j.asOpt[JsNumber].map { AxisConfigDomainWidthAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigDomainWidth): JsValue =
    j match {
      case AxisConfigDomainWidthAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OrderValueDefValue (UnionType)
object OrderValueDefValueCodec {
  def decode(j: JsValue): OrderValueDefValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OrderValueDefValue] =
    j.asOpt[JsNumber].map { OrderValueDefValueAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OrderValueDefValue): JsValue =
    j match {
      case OrderValueDefValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterValueDefStringExprRefValue (UnionType)
object ConditionalParameterValueDefStringExprRefValueCodec {
  def decode(j: JsValue): ConditionalParameterValueDefStringExprRefValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalParameterValueDefStringExprRefValue] =
    j.asOpt[String].map { ConditionalParameterValueDefStringExprRefValueAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ConditionalParameterValueDefStringExprRefValue): JsValue =
    j match {
      case ConditionalParameterValueDefStringExprRefValueAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigOpacity (UnionType)
object LineConfigOpacityCodec {
  def decode(j: JsValue): LineConfigOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigOpacity] =
    j.asOpt[JsNumber].map { LineConfigOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigOpacity): JsValue =
    j match {
      case LineConfigOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleConfigSubtitleFont (UnionType)
object TitleConfigSubtitleFontCodec {
  def decode(j: JsValue): TitleConfigSubtitleFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigSubtitleFont] =
    j.asOpt[String].map { TitleConfigSubtitleFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleConfigSubtitleFont): JsValue =
    j match {
      case TitleConfigSubtitleFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BooleanConst (ConstantType)
object BooleanConstCodec {
  def decode(j: JsValue): BooleanConst =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BooleanConst] =
    j match {
      case JsString("boolean") => Some(BooleanConst())
      case _ => None
    }
  def encode(j: BooleanConst): JsValue =
    JsString("boolean")
}


////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefFontStyleNullExprRef (UnionType)
object ConditionalPredicateValueDefFontStyleNullExprRefCodec {
  def decode(j: JsValue): ConditionalPredicateValueDefFontStyleNullExprRef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefFontStyleNullExprRef] =
    ConditionalPredicateValueDefFontStyleNullExprRefAsObject1Codec.decodeOpt(j).orElse {
    ConditionalPredicateValueDefFontStyleNullExprRefAsObject2Codec.decodeOpt(j) } 
  def encode(j: ConditionalPredicateValueDefFontStyleNullExprRef): JsValue =
    j match {
      case x:ConditionalPredicateValueDefFontStyleNullExprRefAsObject1 /* TypeRef */ => ConditionalPredicateValueDefFontStyleNullExprRefAsObject1Codec.encode(x)
      case x:ConditionalPredicateValueDefFontStyleNullExprRefAsObject2 /* TypeRef */ => ConditionalPredicateValueDefFontStyleNullExprRefAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigGradientLengthAsNumber (ConstrainedType)
object LegendConfigGradientLengthAsNumberCodec {
  def decode(j: JsValue): LegendConfigGradientLengthAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LegendConfigGradientLengthAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { LegendConfigGradientLengthAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: LegendConfigGradientLengthAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AxisLabelFontStyle (UnionType)
object AxisLabelFontStyleCodec {
  def decode(j: JsValue): AxisLabelFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisLabelFontStyle] =
    j.asOpt[String].map { AxisLabelFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisLabelFontStyleCodec.decodeOpt(j) } } 
  def encode(j: AxisLabelFontStyle): JsValue =
    j match {
      case AxisLabelFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisLabelFontStyle /* TypeRef */ => ConditionalAxisLabelFontStyleCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigStrokeOpacity (UnionType)
object RectConfigStrokeOpacityCodec {
  def decode(j: JsValue): RectConfigStrokeOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigStrokeOpacity] =
    RectConfigStrokeOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigStrokeOpacity): JsValue =
    j match {
      case x:RectConfigStrokeOpacityAsNumber /* TypeRef */ => RectConfigStrokeOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTickCap (UnionType)
object AxisConfigTickCapCodec {
  def decode(j: JsValue): AxisConfigTickCap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTickCap] =
    StrokeCapCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigTickCap): JsValue =
    j match {
      case x:StrokeCap /* TypeRef */ => StrokeCapCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PointSelectionConfigWithoutType (StructType)
object PointSelectionConfigWithoutTypeCodec {
  def decode(j: JsValue): PointSelectionConfigWithoutType =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[PointSelectionConfigWithoutType] =
    Some(PointSelectionConfigWithoutType(
      `nearest` = (j \ "nearest").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `clear` = (j \ "clear").asOpt[JsValue].flatMap { x => PointSelectionConfigWithoutTypeClearCodec.decodeOpt(x) },
      `toggle` = (j \ "toggle").asOpt[JsValue].flatMap { x => PointSelectionConfigWithoutTypeToggleCodec.decodeOpt(x) },
      `on` = (j \ "on").asOpt[JsValue].flatMap { x => PointSelectionConfigWithoutTypeOnCodec.decodeOpt(x) },
      `fields` = (j \ "fields").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) },
      `resolve` = (j \ "resolve").asOpt[JsValue].flatMap { x => SelectionResolutionCodec.decodeOpt(x) },
      `encodings` = (j \ "encodings").asOpt[JsValue].flatMap { x => ArrayOfSingleDefUnitChannelCodec.decodeOpt(x) },
    ))

  def encode(j: PointSelectionConfigWithoutType): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`nearest`.map { x => "nearest" -> Json.toJson(x) },
        j.`clear`.map { x => "clear" -> PointSelectionConfigWithoutTypeClearCodec.encode(x) },
        j.`toggle`.map { x => "toggle" -> PointSelectionConfigWithoutTypeToggleCodec.encode(x) },
        j.`on`.map { x => "on" -> PointSelectionConfigWithoutTypeOnCodec.encode(x) },
        j.`fields`.map { x => "fields" -> ArrayOfStringCodec.encode(x) },
        j.`resolve`.map { x => "resolve" -> SelectionResolutionCodec.encode(x) },
        j.`encodings`.map { x => "encodings" -> ArrayOfSingleDefUnitChannelCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingAngleType (UnionType)
object SharedEncodingAngleTypeCodec {
  def decode(j: JsValue): SharedEncodingAngleType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingAngleType] =
    StandardTypeCodec.decodeOpt(j).orElse {
    TypeCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingAngleType): JsValue =
    j match {
      case x:StandardType /* TypeRef */ => StandardTypeCodec.encode(x)
      case x:Type /* TypeRef */ => TypeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigWidth (UnionType)
object TickConfigWidthCodec {
  def decode(j: JsValue): TickConfigWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigWidth] =
    j.asOpt[JsNumber].map { TickConfigWidthAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigWidth): JsValue =
    j match {
      case TickConfigWidthAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleDomainMax (UnionType)
object ScaleDomainMaxCodec {
  def decode(j: JsValue): ScaleDomainMax =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleDomainMax] =
    j.asOpt[JsNumber].map { ScaleDomainMaxAsNumber(_) }.orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: ScaleDomainMax): JsValue =
    j match {
      case ScaleDomainMaxAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleParamsFontSizeAsNumber (ConstrainedType)
object TitleParamsFontSizeAsNumberCodec {
  def decode(j: JsValue): TitleParamsFontSizeAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TitleParamsFontSizeAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { TitleParamsFontSizeAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: TitleParamsFontSizeAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ArrayOfImputeTransformFrameElement (ArrayType)
object ArrayOfImputeTransformFrameElementCodec {
  def decode(j: JsValue): Seq[ImputeTransformFrameElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[ImputeTransformFrameElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      ImputeTransformFrameElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[ImputeTransformFrameElement]): JsArray =
      JsArray(j.map { x => ImputeTransformFrameElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// ScaleInterpolateParamsType (EnumType)
object ScaleInterpolateParamsTypeCodec {
  def decode(j: JsValue): ScaleInterpolateParamsType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleInterpolateParamsType] =
    j match {
      case JsString("rgb") => Some(ScaleInterpolateParamsTypeRgb)
      case JsString("cubehelix") => Some(ScaleInterpolateParamsTypeCubehelix)
      case JsString("cubehelix-long") => Some(ScaleInterpolateParamsTypeCubehelixLong)
      case _ => None
    }
  def encode(j: ScaleInterpolateParamsType): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// AreaConfigShape (UnionType)
object AreaConfigShapeCodec {
  def decode(j: JsValue): AreaConfigShape =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigShape] =
    j.asOpt[String].map { AreaConfigShapeAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigShape): JsValue =
    j match {
      case AreaConfigShapeAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// UriReference (ConstrainedType)
object UriReferenceCodec {
  def decode(j: JsValue): UriReference =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[UriReference] =
    try {
      UriCodec.decodeOpt(j)
        .map { UriReference(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: UriReference): JsValue =
    UriCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// AreaConfigBlend (UnionType)
object AreaConfigBlendCodec {
  def decode(j: JsValue): AreaConfigBlend =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigBlend] =
    BlendCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigBlend): JsValue =
    j match {
      case x:Blend /* TypeRef */ => BlendCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OrderFieldDefBin (UnionType)
object OrderFieldDefBinCodec {
  def decode(j: JsValue): OrderFieldDefBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OrderFieldDefBin] =
    j.asOpt[Boolean].map { OrderFieldDefBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    BinnedCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => OrderFieldDefBinAsNull } } } } 
  def encode(j: OrderFieldDefBin): JsValue =
    j match {
      case OrderFieldDefBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case x:Binned /* TypeRef */ => BinnedCodec.encode(x)
      case OrderFieldDefBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfEmptyObject (ArrayType)
object ArrayOfEmptyObjectCodec {
  def decode(j: JsValue): Seq[JsObject] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[JsObject]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      x.asOpt[JsObject].map { _ => Json.obj() }.getOrElse { return None } } }
  def encode(j: Seq[JsObject]): JsArray =
      JsArray(j.map { x => Json.toJson(x) })
}

////////////////////////////////////////////////////////////////////////
// LegendConfigSymbolSizeAsNumber (ConstrainedType)
object LegendConfigSymbolSizeAsNumberCodec {
  def decode(j: JsValue): LegendConfigSymbolSizeAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LegendConfigSymbolSizeAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { LegendConfigSymbolSizeAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: LegendConfigSymbolSizeAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// LineConfigStartAngle (UnionType)
object LineConfigStartAngleCodec {
  def decode(j: JsValue): LineConfigStartAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigStartAngle] =
    j.asOpt[JsNumber].map { LineConfigStartAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigStartAngle): JsValue =
    j match {
      case LineConfigStartAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefFont (UnionType)
object OverlayMarkDefFontCodec {
  def decode(j: JsValue): OverlayMarkDefFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefFont] =
    j.asOpt[String].map { OverlayMarkDefFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefFont): JsValue =
    j match {
      case OverlayMarkDefFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigStrokeJoin (UnionType)
object TickConfigStrokeJoinCodec {
  def decode(j: JsValue): TickConfigStrokeJoin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigStrokeJoin] =
    StrokeJoinCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigStrokeJoin): JsValue =
    j match {
      case x:StrokeJoin /* TypeRef */ => StrokeJoinCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpec (UnionType)
object TopLevelRepeatSpecCodec {
  def decode(j: JsValue): TopLevelRepeatSpec =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpec] =
    TopLevelRepeatSpecAsObject1Codec.decodeOpt(j).orElse {
    TopLevelRepeatSpecAsObject2Codec.decodeOpt(j) } 
  def encode(j: TopLevelRepeatSpec): JsValue =
    j match {
      case x:TopLevelRepeatSpecAsObject1 /* TypeRef */ => TopLevelRepeatSpecAsObject1Codec.encode(x)
      case x:TopLevelRepeatSpecAsObject2 /* TypeRef */ => TopLevelRepeatSpecAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionRotate (UnionType)
object ProjectionRotateCodec {
  def decode(j: JsValue): ProjectionRotate =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionRotate] =
    Vector2NumberCodec.decodeOpt(j).orElse {
    Vector3NumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: ProjectionRotate): JsValue =
    j match {
      case x:Vector2Number /* TypeRef */ => Vector2NumberCodec.encode(x)
      case x:Vector3Number /* TypeRef */ => Vector3NumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingLongitude2Value (UnionType)
object SharedEncodingLongitude2ValueCodec {
  def decode(j: JsValue): SharedEncodingLongitude2Value =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingLongitude2Value] =
    j.asOpt[JsNumber].map { SharedEncodingLongitude2ValueAsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingLongitude2Value): JsValue =
    j match {
      case SharedEncodingLongitude2ValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AutoSizeParams (StructType)
object AutoSizeParamsCodec {
  def decode(j: JsValue): AutoSizeParams =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AutoSizeParams] =
    Some(AutoSizeParams(
      `contains` = (j \ "contains").asOpt[JsValue].flatMap { x => AutoSizeParamsContainsCodec.decodeOpt(x) },
      `resize` = (j \ "resize").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => AutosizeTypeCodec.decodeOpt(x) },
    ))

  def encode(j: AutoSizeParams): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`contains`.map { x => "contains" -> AutoSizeParamsContainsCodec.encode(x) },
        j.`resize`.map { x => "resize" -> Json.toJson(x) },
        j.`type`.map { x => "type" -> AutosizeTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingDescriptionValue (UnionType)
object SharedEncodingDescriptionValueCodec {
  def decode(j: JsValue): SharedEncodingDescriptionValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingDescriptionValue] =
    j.asOpt[String].map { SharedEncodingDescriptionValueAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingDescriptionValueAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: SharedEncodingDescriptionValue): JsValue =
    j match {
      case SharedEncodingDescriptionValueAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case SharedEncodingDescriptionValueAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigAspect (UnionType)
object AreaConfigAspectCodec {
  def decode(j: JsValue): AreaConfigAspect =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigAspect] =
    j.asOpt[Boolean].map { AreaConfigAspectAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigAspect): JsValue =
    j match {
      case AreaConfigAspectAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisPosition (UnionType)
object AxisPositionCodec {
  def decode(j: JsValue): AxisPosition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisPosition] =
    j.asOpt[JsNumber].map { AxisPositionAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisPosition): JsValue =
    j match {
      case AxisPositionAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingRadiusType (UnionType)
object SharedEncodingRadiusTypeCodec {
  def decode(j: JsValue): SharedEncodingRadiusType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingRadiusType] =
    StandardTypeCodec.decodeOpt(j).orElse {
    TypeCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingRadiusType): JsValue =
    j match {
      case x:StandardType /* TypeRef */ => StandardTypeCodec.encode(x)
      case x:Type /* TypeRef */ => TypeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigDy (UnionType)
object AreaConfigDyCodec {
  def decode(j: JsValue): AreaConfigDy =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigDy] =
    j.asOpt[JsNumber].map { AreaConfigDyAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigDy): JsValue =
    j match {
      case AreaConfigDyAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingYError (StructType)
object SharedEncodingYErrorCodec {
  def decode(j: JsValue): SharedEncodingYError =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingYError] =
    Some(SharedEncodingYError(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingYErrorBandPositionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => x.asOpt[JsNull.type].map { _ => JsNull } },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingYErrorTimeUnitCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingYError): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingYErrorBandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> Json.toJson(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`value`.map { x => "value" -> Json.toJson(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingYErrorTimeUnitCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ProjectionTilt (UnionType)
object ProjectionTiltCodec {
  def decode(j: JsValue): ProjectionTilt =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionTilt] =
    j.asOpt[JsNumber].map { ProjectionTiltAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionTilt): JsValue =
    j match {
      case ProjectionTiltAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefLineBreak (UnionType)
object OverlayMarkDefLineBreakCodec {
  def decode(j: JsValue): OverlayMarkDefLineBreak =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefLineBreak] =
    j.asOpt[String].map { OverlayMarkDefLineBreakAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefLineBreak): JsValue =
    j match {
      case OverlayMarkDefLineBreakAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigInnerRadius (UnionType)
object AreaConfigInnerRadiusCodec {
  def decode(j: JsValue): AreaConfigInnerRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigInnerRadius] =
    j.asOpt[JsNumber].map { AreaConfigInnerRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigInnerRadius): JsValue =
    j match {
      case AreaConfigInnerRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionStringFieldDefText (StructType)
object FieldOrDatumDefWithConditionStringFieldDefTextCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionStringFieldDefText =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionStringFieldDefText] =
    Some(FieldOrDatumDefWithConditionStringFieldDefText(
      `format` = (j \ "format").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionStringFieldDefTextFormatCodec.decodeOpt(x) },
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionStringFieldDefTextBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionStringFieldDefTextConditionCodec.decodeOpt(x) },
      `formatType` = (j \ "formatType").asOpt[JsValue].flatMap { x => x.asOpt[String] },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionStringFieldDefTextBinCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => FieldOrDatumDefWithConditionStringFieldDefTextTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) },
    ))

  def encode(j: FieldOrDatumDefWithConditionStringFieldDefText): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`format`.map { x => "format" -> FieldOrDatumDefWithConditionStringFieldDefTextFormatCodec.encode(x) },
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> FieldOrDatumDefWithConditionStringFieldDefTextBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> FieldOrDatumDefWithConditionStringFieldDefTextConditionCodec.encode(x) },
        j.`formatType`.map { x => "formatType" -> Json.toJson(x) },
        j.`bin`.map { x => "bin" -> FieldOrDatumDefWithConditionStringFieldDefTextBinCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> FieldOrDatumDefWithConditionStringFieldDefTextTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LegendConfigLabelSeparation (UnionType)
object LegendConfigLabelSeparationCodec {
  def decode(j: JsValue): LegendConfigLabelSeparation =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigLabelSeparation] =
    j.asOpt[JsNumber].map { LegendConfigLabelSeparationAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigLabelSeparation): JsValue =
    j match {
      case LegendConfigLabelSeparationAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigFontSizeAsNumber (ConstrainedType)
object BarConfigFontSizeAsNumberCodec {
  def decode(j: JsValue): BarConfigFontSizeAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BarConfigFontSizeAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { BarConfigFontSizeAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: BarConfigFontSizeAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ScaleRange (UnionType)
object ScaleRangeCodec {
  def decode(j: JsValue): ScaleRange =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleRange] =
    RangeEnumCodec.decodeOpt(j).orElse {
    ArrayOfScaleRangeAsArrayElementCodec.decodeOpt(j).map { ScaleRangeAsArrayOfScaleRangeAsArrayElement(_) }.orElse {
    FieldRangeCodec.decodeOpt(j) } } 
  def encode(j: ScaleRange): JsValue =
    j match {
      case x:RangeEnum /* TypeRef */ => RangeEnumCodec.encode(x)
      case ScaleRangeAsArrayOfScaleRangeAsArrayElement(x) /* Base, ArrayType */ => ArrayOfScaleRangeAsArrayElementCodec.encode(x)
      case x:FieldRange /* TypeRef */ => FieldRangeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefFont (UnionType)
object MarkDefFontCodec {
  def decode(j: JsValue): MarkDefFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefFont] =
    j.asOpt[String].map { MarkDefFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefFont): JsValue =
    j match {
      case MarkDefFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfConditionalPredicateValueDefStringNullExprRef (ArrayType)
object ArrayOfConditionalPredicateValueDefStringNullExprRefCodec {
  def decode(j: JsValue): Seq[ConditionalPredicateValueDefStringNullExprRef] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[ConditionalPredicateValueDefStringNullExprRef]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      ConditionalPredicateValueDefStringNullExprRefCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[ConditionalPredicateValueDefStringNullExprRef]): JsArray =
      JsArray(j.map { x => ConditionalPredicateValueDefStringNullExprRefCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// MarkDef (StructType)
object MarkDefCodec {
  def decode(j: JsValue): MarkDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[MarkDef] =
    {
      val `x2Offset` = (j \ "x2Offset").asOpt[JsValue].flatMap { x => MarkDefX2OffsetCodec.decodeOpt(x) }
      val `cornerRadiusBottomRight` = (j \ "cornerRadiusBottomRight").asOpt[JsValue].flatMap { x => MarkDefCornerRadiusBottomRightCodec.decodeOpt(x) }
      val `fillOpacity` = (j \ "fillOpacity").asOpt[JsValue].flatMap { x => MarkDefFillOpacityCodec.decodeOpt(x) }
      val `strokeMiterLimit` = (j \ "strokeMiterLimit").asOpt[JsValue].flatMap { x => MarkDefStrokeMiterLimitCodec.decodeOpt(x) }
      val `dir` = (j \ "dir").asOpt[JsValue].flatMap { x => MarkDefDirCodec.decodeOpt(x) }
      val `theta2Offset` = (j \ "theta2Offset").asOpt[JsValue].flatMap { x => MarkDefTheta2OffsetCodec.decodeOpt(x) }
      val `tooltip` = (j \ "tooltip").asOpt[JsValue].flatMap { x => MarkDefTooltipCodec.decodeOpt(x) }
      val `cornerRadiusTopRight` = (j \ "cornerRadiusTopRight").asOpt[JsValue].flatMap { x => MarkDefCornerRadiusTopRightCodec.decodeOpt(x) }
      val `outerRadius` = (j \ "outerRadius").asOpt[JsValue].flatMap { x => MarkDefOuterRadiusCodec.decodeOpt(x) }
      val `x` = (j \ "x").asOpt[JsValue].flatMap { x => MarkDefXCodec.decodeOpt(x) }
      val `continuousBandSize` = (j \ "continuousBandSize").asOpt[JsValue].flatMap { x => MarkDefContinuousBandSizeCodec.decodeOpt(x) }
      val `point` = (j \ "point").asOpt[JsValue].flatMap { x => MarkDefPointCodec.decodeOpt(x) }
      val `dy` = (j \ "dy").asOpt[JsValue].flatMap { x => MarkDefDyCodec.decodeOpt(x) }
      val `xOffset` = (j \ "xOffset").asOpt[JsValue].flatMap { x => MarkDefXOffsetCodec.decodeOpt(x) }
      val `size` = (j \ "size").asOpt[JsValue].flatMap { x => MarkDefSizeCodec.decodeOpt(x) }
      val `smooth` = (j \ "smooth").asOpt[JsValue].flatMap { x => MarkDefSmoothCodec.decodeOpt(x) }
      val `url` = (j \ "url").asOpt[JsValue].flatMap { x => MarkDefUrlCodec.decodeOpt(x) }
      val `style` = (j \ "style").asOpt[JsValue].flatMap { x => MarkDefStyleCodec.decodeOpt(x) }
      val `y` = (j \ "y").asOpt[JsValue].flatMap { x => MarkDefYCodec.decodeOpt(x) }
      val `line` = (j \ "line").asOpt[JsValue].flatMap { x => MarkDefLineCodec.decodeOpt(x) }
      val `strokeOpacity` = (j \ "strokeOpacity").asOpt[JsValue].flatMap { x => MarkDefStrokeOpacityCodec.decodeOpt(x) }
      val `ellipsis` = (j \ "ellipsis").asOpt[JsValue].flatMap { x => MarkDefEllipsisCodec.decodeOpt(x) }
      val `description` = (j \ "description").asOpt[JsValue].flatMap { x => MarkDefDescriptionCodec.decodeOpt(x) }
      val `angle` = (j \ "angle").asOpt[JsValue].flatMap { x => MarkDefAngleCodec.decodeOpt(x) }
      val `lineBreak` = (j \ "lineBreak").asOpt[JsValue].flatMap { x => MarkDefLineBreakCodec.decodeOpt(x) }
      val `tension` = (j \ "tension").asOpt[JsValue].flatMap { x => MarkDefTensionCodec.decodeOpt(x) }
      val `cornerRadiusTopLeft` = (j \ "cornerRadiusTopLeft").asOpt[JsValue].flatMap { x => MarkDefCornerRadiusTopLeftCodec.decodeOpt(x) }
      val `stroke` = (j \ "stroke").asOpt[JsValue].flatMap { x => MarkDefStrokeCodec.decodeOpt(x) }
      val `strokeDashOffset` = (j \ "strokeDashOffset").asOpt[JsValue].flatMap { x => MarkDefStrokeDashOffsetCodec.decodeOpt(x) }
      val `align` = (j \ "align").asOpt[JsValue].flatMap { x => MarkDefAlignCodec.decodeOpt(x) }
      val `ariaRole` = (j \ "ariaRole").asOpt[JsValue].flatMap { x => MarkDefAriaRoleCodec.decodeOpt(x) }
      val `strokeCap` = (j \ "strokeCap").asOpt[JsValue].flatMap { x => MarkDefStrokeCapCodec.decodeOpt(x) }
      val `strokeJoin` = (j \ "strokeJoin").asOpt[JsValue].flatMap { x => MarkDefStrokeJoinCodec.decodeOpt(x) }
      val `baseline` = (j \ "baseline").asOpt[JsValue].flatMap { x => MarkDefBaselineCodec.decodeOpt(x) }
      val `ariaRoleDescription` = (j \ "ariaRoleDescription").asOpt[JsValue].flatMap { x => MarkDefAriaRoleDescriptionCodec.decodeOpt(x) }
      val `aspect` = (j \ "aspect").asOpt[JsValue].flatMap { x => MarkDefAspectCodec.decodeOpt(x) }
      val `height` = (j \ "height").asOpt[JsValue].flatMap { x => MarkDefHeightCodec.decodeOpt(x) }
      val `fontStyle` = (j \ "fontStyle").asOpt[JsValue].flatMap { x => MarkDefFontStyleCodec.decodeOpt(x) }
      val `bandSize` = (j \ "bandSize").asOpt[JsValue].flatMap { x => MarkDefBandSizeCodec.decodeOpt(x) }
      val `text` = (j \ "text").asOpt[JsValue].flatMap { x => MarkDefTextCodec.decodeOpt(x) }
      val `binSpacing` = (j \ "binSpacing").asOpt[JsValue].flatMap { x => MarkDefBinSpacingCodec.decodeOpt(x) }
      val `cornerRadius` = (j \ "cornerRadius").asOpt[JsValue].flatMap { x => MarkDefCornerRadiusCodec.decodeOpt(x) }
      val `color` = (j \ "color").asOpt[JsValue].flatMap { x => MarkDefColorCodec.decodeOpt(x) }
      val `x2` = (j \ "x2").asOpt[JsValue].flatMap { x => MarkDefX2Codec.decodeOpt(x) }
      val `padAngle` = (j \ "padAngle").asOpt[JsValue].flatMap { x => MarkDefPadAngleCodec.decodeOpt(x) }
      val `cursor` = (j \ "cursor").asOpt[JsValue].flatMap { x => MarkDefCursorCodec.decodeOpt(x) }
      val `thickness` = (j \ "thickness").asOpt[JsValue].flatMap { x => MarkDefThicknessCodec.decodeOpt(x) }
      val `radius` = (j \ "radius").asOpt[JsValue].flatMap { x => MarkDefRadiusCodec.decodeOpt(x) }
      val `timeUnitBandSize` = (j \ "timeUnitBandSize").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `font` = (j \ "font").asOpt[JsValue].flatMap { x => MarkDefFontCodec.decodeOpt(x) }
      val `radius2` = (j \ "radius2").asOpt[JsValue].flatMap { x => MarkDefRadius2Codec.decodeOpt(x) }
      val `invalid` = (j \ "invalid").asOpt[JsValue].flatMap { x => MarkDefInvalidCodec.decodeOpt(x) }
      val `radius2Offset` = (j \ "radius2Offset").asOpt[JsValue].flatMap { x => MarkDefRadius2OffsetCodec.decodeOpt(x) }
      val `lineHeight` = (j \ "lineHeight").asOpt[JsValue].flatMap { x => MarkDefLineHeightCodec.decodeOpt(x) }
      val `order` = (j \ "order").asOpt[JsValue].flatMap { x => MarkDefOrderCodec.decodeOpt(x) }
      val `fill` = (j \ "fill").asOpt[JsValue].flatMap { x => MarkDefFillCodec.decodeOpt(x) }
      val `interpolate` = (j \ "interpolate").asOpt[JsValue].flatMap { x => MarkDefInterpolateCodec.decodeOpt(x) }
      val `theta` = (j \ "theta").asOpt[JsValue].flatMap { x => MarkDefThetaCodec.decodeOpt(x) }
      val `innerRadius` = (j \ "innerRadius").asOpt[JsValue].flatMap { x => MarkDefInnerRadiusCodec.decodeOpt(x) }
      val `fontSize` = (j \ "fontSize").asOpt[JsValue].flatMap { x => MarkDefFontSizeCodec.decodeOpt(x) }
      val `y2` = (j \ "y2").asOpt[JsValue].flatMap { x => MarkDefY2Codec.decodeOpt(x) }
      val `orient` = (j \ "orient").asOpt[JsValue].flatMap { x => OrientationCodec.decodeOpt(x) }
      val `discreteBandSize` = (j \ "discreteBandSize").asOpt[JsValue].flatMap { x => MarkDefDiscreteBandSizeCodec.decodeOpt(x) }
      val `shape` = (j \ "shape").asOpt[JsValue].flatMap { x => MarkDefShapeCodec.decodeOpt(x) }
      val `aria` = (j \ "aria").asOpt[JsValue].flatMap { x => MarkDefAriaCodec.decodeOpt(x) }
      val `opacity` = (j \ "opacity").asOpt[JsValue].flatMap { x => MarkDefOpacityCodec.decodeOpt(x) }
      val `radiusOffset` = (j \ "radiusOffset").asOpt[JsValue].flatMap { x => MarkDefRadiusOffsetCodec.decodeOpt(x) }
      val `dx` = (j \ "dx").asOpt[JsValue].flatMap { x => MarkDefDxCodec.decodeOpt(x) }
      val `cornerRadiusBottomLeft` = (j \ "cornerRadiusBottomLeft").asOpt[JsValue].flatMap { x => MarkDefCornerRadiusBottomLeftCodec.decodeOpt(x) }
      val `cornerRadiusEnd` = (j \ "cornerRadiusEnd").asOpt[JsValue].flatMap { x => MarkDefCornerRadiusEndCodec.decodeOpt(x) }
      val `type` = (j \ "type").asOpt[JsValue].flatMap { x => MarkCodec.decodeOpt(x) }
      if(`type`.isEmpty) { return None }
      val `clip` = (j \ "clip").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `href` = (j \ "href").asOpt[JsValue].flatMap { x => MarkDefHrefCodec.decodeOpt(x) }
      val `strokeDash` = (j \ "strokeDash").asOpt[JsValue].flatMap { x => MarkDefStrokeDashCodec.decodeOpt(x) }
      val `strokeOffset` = (j \ "strokeOffset").asOpt[JsValue].flatMap { x => MarkDefStrokeOffsetCodec.decodeOpt(x) }
      val `limit` = (j \ "limit").asOpt[JsValue].flatMap { x => MarkDefLimitCodec.decodeOpt(x) }
      val `y2Offset` = (j \ "y2Offset").asOpt[JsValue].flatMap { x => MarkDefY2OffsetCodec.decodeOpt(x) }
      val `thetaOffset` = (j \ "thetaOffset").asOpt[JsValue].flatMap { x => MarkDefThetaOffsetCodec.decodeOpt(x) }
      val `width` = (j \ "width").asOpt[JsValue].flatMap { x => MarkDefWidthCodec.decodeOpt(x) }
      val `fontWeight` = (j \ "fontWeight").asOpt[JsValue].flatMap { x => MarkDefFontWeightCodec.decodeOpt(x) }
      val `timeUnitBandPosition` = (j \ "timeUnitBandPosition").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `yOffset` = (j \ "yOffset").asOpt[JsValue].flatMap { x => MarkDefYOffsetCodec.decodeOpt(x) }
      val `filled` = (j \ "filled").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `blend` = (j \ "blend").asOpt[JsValue].flatMap { x => MarkDefBlendCodec.decodeOpt(x) }
      val `strokeWidth` = (j \ "strokeWidth").asOpt[JsValue].flatMap { x => MarkDefStrokeWidthCodec.decodeOpt(x) }
      val `theta2` = (j \ "theta2").asOpt[JsValue].flatMap { x => MarkDefTheta2Codec.decodeOpt(x) }
      return Some(MarkDef(
        `x2Offset` = `x2Offset`,
        `cornerRadiusBottomRight` = `cornerRadiusBottomRight`,
        `fillOpacity` = `fillOpacity`,
        `strokeMiterLimit` = `strokeMiterLimit`,
        `dir` = `dir`,
        `theta2Offset` = `theta2Offset`,
        `tooltip` = `tooltip`,
        `cornerRadiusTopRight` = `cornerRadiusTopRight`,
        `outerRadius` = `outerRadius`,
        `x` = `x`,
        `continuousBandSize` = `continuousBandSize`,
        `point` = `point`,
        `dy` = `dy`,
        `xOffset` = `xOffset`,
        `size` = `size`,
        `smooth` = `smooth`,
        `url` = `url`,
        `style` = `style`,
        `y` = `y`,
        `line` = `line`,
        `strokeOpacity` = `strokeOpacity`,
        `ellipsis` = `ellipsis`,
        `description` = `description`,
        `angle` = `angle`,
        `lineBreak` = `lineBreak`,
        `tension` = `tension`,
        `cornerRadiusTopLeft` = `cornerRadiusTopLeft`,
        `stroke` = `stroke`,
        `strokeDashOffset` = `strokeDashOffset`,
        `align` = `align`,
        `ariaRole` = `ariaRole`,
        `strokeCap` = `strokeCap`,
        `strokeJoin` = `strokeJoin`,
        `baseline` = `baseline`,
        `ariaRoleDescription` = `ariaRoleDescription`,
        `aspect` = `aspect`,
        `height` = `height`,
        `fontStyle` = `fontStyle`,
        `bandSize` = `bandSize`,
        `text` = `text`,
        `binSpacing` = `binSpacing`,
        `cornerRadius` = `cornerRadius`,
        `color` = `color`,
        `x2` = `x2`,
        `padAngle` = `padAngle`,
        `cursor` = `cursor`,
        `thickness` = `thickness`,
        `radius` = `radius`,
        `timeUnitBandSize` = `timeUnitBandSize`,
        `font` = `font`,
        `radius2` = `radius2`,
        `invalid` = `invalid`,
        `radius2Offset` = `radius2Offset`,
        `lineHeight` = `lineHeight`,
        `order` = `order`,
        `fill` = `fill`,
        `interpolate` = `interpolate`,
        `theta` = `theta`,
        `innerRadius` = `innerRadius`,
        `fontSize` = `fontSize`,
        `y2` = `y2`,
        `orient` = `orient`,
        `discreteBandSize` = `discreteBandSize`,
        `shape` = `shape`,
        `aria` = `aria`,
        `opacity` = `opacity`,
        `radiusOffset` = `radiusOffset`,
        `dx` = `dx`,
        `cornerRadiusBottomLeft` = `cornerRadiusBottomLeft`,
        `cornerRadiusEnd` = `cornerRadiusEnd`,
        `type` = `type`.get,
        `clip` = `clip`,
        `href` = `href`,
        `strokeDash` = `strokeDash`,
        `strokeOffset` = `strokeOffset`,
        `limit` = `limit`,
        `y2Offset` = `y2Offset`,
        `thetaOffset` = `thetaOffset`,
        `width` = `width`,
        `fontWeight` = `fontWeight`,
        `timeUnitBandPosition` = `timeUnitBandPosition`,
        `yOffset` = `yOffset`,
        `filled` = `filled`,
        `blend` = `blend`,
        `strokeWidth` = `strokeWidth`,
        `theta2` = `theta2`,
      ))
    }

  def encode(j: MarkDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`x2Offset`.map { x => "x2Offset" -> MarkDefX2OffsetCodec.encode(x) },
        j.`cornerRadiusBottomRight`.map { x => "cornerRadiusBottomRight" -> MarkDefCornerRadiusBottomRightCodec.encode(x) },
        j.`fillOpacity`.map { x => "fillOpacity" -> MarkDefFillOpacityCodec.encode(x) },
        j.`strokeMiterLimit`.map { x => "strokeMiterLimit" -> MarkDefStrokeMiterLimitCodec.encode(x) },
        j.`dir`.map { x => "dir" -> MarkDefDirCodec.encode(x) },
        j.`theta2Offset`.map { x => "theta2Offset" -> MarkDefTheta2OffsetCodec.encode(x) },
        j.`tooltip`.map { x => "tooltip" -> MarkDefTooltipCodec.encode(x) },
        j.`cornerRadiusTopRight`.map { x => "cornerRadiusTopRight" -> MarkDefCornerRadiusTopRightCodec.encode(x) },
        j.`outerRadius`.map { x => "outerRadius" -> MarkDefOuterRadiusCodec.encode(x) },
        j.`x`.map { x => "x" -> MarkDefXCodec.encode(x) },
        j.`continuousBandSize`.map { x => "continuousBandSize" -> MarkDefContinuousBandSizeCodec.encode(x) },
        j.`point`.map { x => "point" -> MarkDefPointCodec.encode(x) },
        j.`dy`.map { x => "dy" -> MarkDefDyCodec.encode(x) },
        j.`xOffset`.map { x => "xOffset" -> MarkDefXOffsetCodec.encode(x) },
        j.`size`.map { x => "size" -> MarkDefSizeCodec.encode(x) },
        j.`smooth`.map { x => "smooth" -> MarkDefSmoothCodec.encode(x) },
        j.`url`.map { x => "url" -> MarkDefUrlCodec.encode(x) },
        j.`style`.map { x => "style" -> MarkDefStyleCodec.encode(x) },
        j.`y`.map { x => "y" -> MarkDefYCodec.encode(x) },
        j.`line`.map { x => "line" -> MarkDefLineCodec.encode(x) },
        j.`strokeOpacity`.map { x => "strokeOpacity" -> MarkDefStrokeOpacityCodec.encode(x) },
        j.`ellipsis`.map { x => "ellipsis" -> MarkDefEllipsisCodec.encode(x) },
        j.`description`.map { x => "description" -> MarkDefDescriptionCodec.encode(x) },
        j.`angle`.map { x => "angle" -> MarkDefAngleCodec.encode(x) },
        j.`lineBreak`.map { x => "lineBreak" -> MarkDefLineBreakCodec.encode(x) },
        j.`tension`.map { x => "tension" -> MarkDefTensionCodec.encode(x) },
        j.`cornerRadiusTopLeft`.map { x => "cornerRadiusTopLeft" -> MarkDefCornerRadiusTopLeftCodec.encode(x) },
        j.`stroke`.map { x => "stroke" -> MarkDefStrokeCodec.encode(x) },
        j.`strokeDashOffset`.map { x => "strokeDashOffset" -> MarkDefStrokeDashOffsetCodec.encode(x) },
        j.`align`.map { x => "align" -> MarkDefAlignCodec.encode(x) },
        j.`ariaRole`.map { x => "ariaRole" -> MarkDefAriaRoleCodec.encode(x) },
        j.`strokeCap`.map { x => "strokeCap" -> MarkDefStrokeCapCodec.encode(x) },
        j.`strokeJoin`.map { x => "strokeJoin" -> MarkDefStrokeJoinCodec.encode(x) },
        j.`baseline`.map { x => "baseline" -> MarkDefBaselineCodec.encode(x) },
        j.`ariaRoleDescription`.map { x => "ariaRoleDescription" -> MarkDefAriaRoleDescriptionCodec.encode(x) },
        j.`aspect`.map { x => "aspect" -> MarkDefAspectCodec.encode(x) },
        j.`height`.map { x => "height" -> MarkDefHeightCodec.encode(x) },
        j.`fontStyle`.map { x => "fontStyle" -> MarkDefFontStyleCodec.encode(x) },
        j.`bandSize`.map { x => "bandSize" -> MarkDefBandSizeCodec.encode(x) },
        j.`text`.map { x => "text" -> MarkDefTextCodec.encode(x) },
        j.`binSpacing`.map { x => "binSpacing" -> MarkDefBinSpacingCodec.encode(x) },
        j.`cornerRadius`.map { x => "cornerRadius" -> MarkDefCornerRadiusCodec.encode(x) },
        j.`color`.map { x => "color" -> MarkDefColorCodec.encode(x) },
        j.`x2`.map { x => "x2" -> MarkDefX2Codec.encode(x) },
        j.`padAngle`.map { x => "padAngle" -> MarkDefPadAngleCodec.encode(x) },
        j.`cursor`.map { x => "cursor" -> MarkDefCursorCodec.encode(x) },
        j.`thickness`.map { x => "thickness" -> MarkDefThicknessCodec.encode(x) },
        j.`radius`.map { x => "radius" -> MarkDefRadiusCodec.encode(x) },
        j.`timeUnitBandSize`.map { x => "timeUnitBandSize" -> Json.toJson(x) },
        j.`font`.map { x => "font" -> MarkDefFontCodec.encode(x) },
        j.`radius2`.map { x => "radius2" -> MarkDefRadius2Codec.encode(x) },
        j.`invalid`.map { x => "invalid" -> MarkDefInvalidCodec.encode(x) },
        j.`radius2Offset`.map { x => "radius2Offset" -> MarkDefRadius2OffsetCodec.encode(x) },
        j.`lineHeight`.map { x => "lineHeight" -> MarkDefLineHeightCodec.encode(x) },
        j.`order`.map { x => "order" -> MarkDefOrderCodec.encode(x) },
        j.`fill`.map { x => "fill" -> MarkDefFillCodec.encode(x) },
        j.`interpolate`.map { x => "interpolate" -> MarkDefInterpolateCodec.encode(x) },
        j.`theta`.map { x => "theta" -> MarkDefThetaCodec.encode(x) },
        j.`innerRadius`.map { x => "innerRadius" -> MarkDefInnerRadiusCodec.encode(x) },
        j.`fontSize`.map { x => "fontSize" -> MarkDefFontSizeCodec.encode(x) },
        j.`y2`.map { x => "y2" -> MarkDefY2Codec.encode(x) },
        j.`orient`.map { x => "orient" -> OrientationCodec.encode(x) },
        j.`discreteBandSize`.map { x => "discreteBandSize" -> MarkDefDiscreteBandSizeCodec.encode(x) },
        j.`shape`.map { x => "shape" -> MarkDefShapeCodec.encode(x) },
        j.`aria`.map { x => "aria" -> MarkDefAriaCodec.encode(x) },
        j.`opacity`.map { x => "opacity" -> MarkDefOpacityCodec.encode(x) },
        j.`radiusOffset`.map { x => "radiusOffset" -> MarkDefRadiusOffsetCodec.encode(x) },
        j.`dx`.map { x => "dx" -> MarkDefDxCodec.encode(x) },
        j.`cornerRadiusBottomLeft`.map { x => "cornerRadiusBottomLeft" -> MarkDefCornerRadiusBottomLeftCodec.encode(x) },
        j.`cornerRadiusEnd`.map { x => "cornerRadiusEnd" -> MarkDefCornerRadiusEndCodec.encode(x) },
        Some("type" -> MarkCodec.encode(j.`type`)),
        j.`clip`.map { x => "clip" -> Json.toJson(x) },
        j.`href`.map { x => "href" -> MarkDefHrefCodec.encode(x) },
        j.`strokeDash`.map { x => "strokeDash" -> MarkDefStrokeDashCodec.encode(x) },
        j.`strokeOffset`.map { x => "strokeOffset" -> MarkDefStrokeOffsetCodec.encode(x) },
        j.`limit`.map { x => "limit" -> MarkDefLimitCodec.encode(x) },
        j.`y2Offset`.map { x => "y2Offset" -> MarkDefY2OffsetCodec.encode(x) },
        j.`thetaOffset`.map { x => "thetaOffset" -> MarkDefThetaOffsetCodec.encode(x) },
        j.`width`.map { x => "width" -> MarkDefWidthCodec.encode(x) },
        j.`fontWeight`.map { x => "fontWeight" -> MarkDefFontWeightCodec.encode(x) },
        j.`timeUnitBandPosition`.map { x => "timeUnitBandPosition" -> Json.toJson(x) },
        j.`yOffset`.map { x => "yOffset" -> MarkDefYOffsetCodec.encode(x) },
        j.`filled`.map { x => "filled" -> Json.toJson(x) },
        j.`blend`.map { x => "blend" -> MarkDefBlendCodec.encode(x) },
        j.`strokeWidth`.map { x => "strokeWidth" -> MarkDefStrokeWidthCodec.encode(x) },
        j.`theta2`.map { x => "theta2" -> MarkDefTheta2Codec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// Number (ConstantType)
object NumberCodec {
  def decode(j: JsValue): Number =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Number] =
    j match {
      case JsString("number") => Some(Number())
      case _ => None
    }
  def encode(j: Number): JsValue =
    JsString("number")
}


////////////////////////////////////////////////////////////////////////
// TitleParamsLimitAsNumber (ConstrainedType)
object TitleParamsLimitAsNumberCodec {
  def decode(j: JsValue): TitleParamsLimitAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TitleParamsLimitAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { TitleParamsLimitAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: TitleParamsLimitAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingYOffsetType (UnionType)
object SharedEncodingYOffsetTypeCodec {
  def decode(j: JsValue): SharedEncodingYOffsetType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingYOffsetType] =
    StandardTypeCodec.decodeOpt(j).orElse {
    TypeCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingYOffsetType): JsValue =
    j match {
      case x:StandardType /* TypeRef */ => StandardTypeCodec.encode(x)
      case x:Type /* TypeRef */ => TypeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisGridOpacity (UnionType)
object AxisGridOpacityCodec {
  def decode(j: JsValue): AxisGridOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisGridOpacity] =
    AxisGridOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisGridOpacity): JsValue =
    j match {
      case x:AxisGridOpacityAsNumber /* TypeRef */ => AxisGridOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// DsvDataFormat (StructType)
object DsvDataFormatCodec {
  def decode(j: JsValue): DsvDataFormat =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[DsvDataFormat] =
    {
      val `delimiter` = (j \ "delimiter").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`delimiter`.isEmpty) { return None }
      val `parse` = (j \ "parse").asOpt[JsValue].flatMap { x => DictOfParseValueCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `type` = (j \ "type").asOpt[JsValue].flatMap { x => DsvDataFormatTypeCodec.decodeOpt(x) }
      return Some(DsvDataFormat(
        `delimiter` = `delimiter`.get,
        `parse` = `parse`,
        `type` = `type`,
      ))
    }

  def encode(j: DsvDataFormat): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("delimiter" -> Json.toJson(j.`delimiter`)),
        j.`parse`.map { x => "parse" -> DictOfParseValueCodec.encode(x) },
        j.`type`.map { x => "type" -> DsvDataFormatTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// HeaderConfigTitleFontSize (UnionType)
object HeaderConfigTitleFontSizeCodec {
  def decode(j: JsValue): HeaderConfigTitleFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderConfigTitleFontSize] =
    j.asOpt[JsNumber].map { HeaderConfigTitleFontSizeAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderConfigTitleFontSize): JsValue =
    j match {
      case HeaderConfigTitleFontSizeAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LogicalNotPredicate (StructType)
object LogicalNotPredicateCodec {
  def decode(j: JsValue): LogicalNotPredicate =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LogicalNotPredicate] =
    {
      val `not` = (j \ "not").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`not`.isEmpty) { return None }
      return Some(LogicalNotPredicate(
        `not` = `not`.get,
      ))
    }

  def encode(j: LogicalNotPredicate): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("not" -> PredicateCompositionCodec.encode(j.`not`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AreaConfigAlign (UnionType)
object AreaConfigAlignCodec {
  def decode(j: JsValue): AreaConfigAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigAlign] =
    AlignCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigAlign): JsValue =
    j match {
      case x:Align /* TypeRef */ => AlignCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigLabelFlushOffset (UnionType)
object AxisConfigLabelFlushOffsetCodec {
  def decode(j: JsValue): AxisConfigLabelFlushOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigLabelFlushOffset] =
    j.asOpt[JsNumber].map { AxisConfigLabelFlushOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigLabelFlushOffset): JsValue =
    j match {
      case AxisConfigLabelFlushOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigStrokeDashOffset (UnionType)
object MarkConfigStrokeDashOffsetCodec {
  def decode(j: JsValue): MarkConfigStrokeDashOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigStrokeDashOffset] =
    j.asOpt[JsNumber].map { MarkConfigStrokeDashOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigStrokeDashOffset): JsValue =
    j match {
      case MarkConfigStrokeDashOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleClamp (UnionType)
object ScaleClampCodec {
  def decode(j: JsValue): ScaleClamp =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleClamp] =
    j.asOpt[Boolean].map { ScaleClampAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleClamp): JsValue =
    j match {
      case ScaleClampAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigWidth (UnionType)
object RectConfigWidthCodec {
  def decode(j: JsValue): RectConfigWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigWidth] =
    j.asOpt[JsNumber].map { RectConfigWidthAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigWidth): JsValue =
    j match {
      case RectConfigWidthAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigFontStyle (UnionType)
object MarkConfigFontStyleCodec {
  def decode(j: JsValue): MarkConfigFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigFontStyle] =
    j.asOpt[String].map { MarkConfigFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigFontStyle): JsValue =
    j match {
      case MarkConfigFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderFormat (UnionType)
object HeaderFormatCodec {
  def decode(j: JsValue): HeaderFormat =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderFormat] =
    j.asOpt[String].map { HeaderFormatAsString(_) }.orElse {
    DictOfAnyCodec.decodeOpt(j).map { HeaderFormatAsDictOfAny(_) } } 
  def encode(j: HeaderFormat): JsValue =
    j match {
      case HeaderFormatAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case HeaderFormatAsDictOfAny(x) /* Base, MapType */ => DictOfAnyCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingShapeValue (UnionType)
object SharedEncodingShapeValueCodec {
  def decode(j: JsValue): SharedEncodingShapeValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingShapeValue] =
    j.asOpt[String].map { SharedEncodingShapeValueAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingShapeValueAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: SharedEncodingShapeValue): JsValue =
    j match {
      case SharedEncodingShapeValueAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case SharedEncodingShapeValueAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RepeatRef (StructType)
object RepeatRefCodec {
  def decode(j: JsValue): RepeatRef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RepeatRef] =
    {
      val `repeat` = (j \ "repeat").asOpt[JsValue].flatMap { x => RepeatRefRepeatCodec.decodeOpt(x) }
      if(`repeat`.isEmpty) { return None }
      return Some(RepeatRef(
        `repeat` = `repeat`.get,
      ))
    }

  def encode(j: RepeatRef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("repeat" -> RepeatRefRepeatCodec.encode(j.`repeat`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TitleParamsFontWeight (UnionType)
object TitleParamsFontWeightCodec {
  def decode(j: JsValue): TitleParamsFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleParamsFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleParamsFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigSmooth (UnionType)
object LineConfigSmoothCodec {
  def decode(j: JsValue): LineConfigSmooth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigSmooth] =
    j.asOpt[Boolean].map { LineConfigSmoothAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigSmooth): JsValue =
    j match {
      case LineConfigSmoothAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderTitleColor (UnionType)
object HeaderTitleColorCodec {
  def decode(j: JsValue): HeaderTitleColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderTitleColor] =
    ColorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderTitleColor): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PositionDatumDefBaseDatum (UnionType)
object PositionDatumDefBaseDatumCodec {
  def decode(j: JsValue): PositionDatumDefBaseDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PositionDatumDefBaseDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: PositionDatumDefBaseDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigOpacity (ConstrainedType)
// see AreaConfigOpacity (UnionType)

////////////////////////////////////////////////////////////////////////
// MarkDefOpacity (UnionType)
object MarkDefOpacityCodec {
  def decode(j: JsValue): MarkDefOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefOpacity] =
    j.asOpt[JsNumber].map { MarkDefOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefOpacity): JsValue =
    j match {
      case MarkDefOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigY2 (UnionType)
object LineConfigY2Codec {
  def decode(j: JsValue): LineConfigY2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigY2] =
    j.asOpt[JsNumber].map { LineConfigY2AsNumber(_) }.orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: LineConfigY2): JsValue =
    j match {
      case LineConfigY2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeOpacityBin (UnionType)
object SharedEncodingStrokeOpacityBinCodec {
  def decode(j: JsValue): SharedEncodingStrokeOpacityBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeOpacityBin] =
    j.asOpt[Boolean].map { SharedEncodingStrokeOpacityBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingStrokeOpacityBinAsNull } } } 
  def encode(j: SharedEncodingStrokeOpacityBin): JsValue =
    j match {
      case SharedEncodingStrokeOpacityBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case SharedEncodingStrokeOpacityBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigCornerRadiusTopLeft (UnionType)
object AreaConfigCornerRadiusTopLeftCodec {
  def decode(j: JsValue): AreaConfigCornerRadiusTopLeft =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigCornerRadiusTopLeft] =
    j.asOpt[JsNumber].map { AreaConfigCornerRadiusTopLeftAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigCornerRadiusTopLeft): JsValue =
    j match {
      case AreaConfigCornerRadiusTopLeftAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigHeight (UnionType)
object RectConfigHeightCodec {
  def decode(j: JsValue): RectConfigHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigHeight] =
    j.asOpt[JsNumber].map { RectConfigHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigHeight): JsValue =
    j match {
      case RectConfigHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefY2 (UnionType)
object MarkDefY2Codec {
  def decode(j: JsValue): MarkDefY2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefY2] =
    j.asOpt[JsNumber].map { MarkDefY2AsNumber(_) }.orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: MarkDefY2): JsValue =
    j match {
      case MarkDefY2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionStringDatumDefTextCondition (UnionType)
object FieldOrDatumDefWithConditionStringDatumDefTextConditionCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionStringDatumDefTextCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionStringDatumDefTextCondition] =
    ConditionalValueDefTextExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefTextExprRefCodec.decodeOpt(j).map { FieldOrDatumDefWithConditionStringDatumDefTextConditionAsArrayOfConditionalValueDefTextExprRef(_) } } 
  def encode(j: FieldOrDatumDefWithConditionStringDatumDefTextCondition): JsValue =
    j match {
      case x:ConditionalValueDefTextExprRef /* TypeRef */ => ConditionalValueDefTextExprRefCodec.encode(x)
      case FieldOrDatumDefWithConditionStringDatumDefTextConditionAsArrayOfConditionalValueDefTextExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefTextExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingHrefBin (UnionType)
object SharedEncodingHrefBinCodec {
  def decode(j: JsValue): SharedEncodingHrefBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingHrefBin] =
    j.asOpt[Boolean].map { SharedEncodingHrefBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    BinnedCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingHrefBinAsNull } } } } 
  def encode(j: SharedEncodingHrefBin): JsValue =
    j match {
      case SharedEncodingHrefBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case x:Binned /* TypeRef */ => BinnedCodec.encode(x)
      case SharedEncodingHrefBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigAngleAsNumber (ConstrainedType)
object LineConfigAngleAsNumberCodec {
  def decode(j: JsValue): LineConfigAngleAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LineConfigAngleAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { LineConfigAngleAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: LineConfigAngleAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// LegendConfigDescription (UnionType)
object LegendConfigDescriptionCodec {
  def decode(j: JsValue): LegendConfigDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigDescription] =
    j.asOpt[String].map { LegendConfigDescriptionAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigDescription): JsValue =
    j match {
      case LegendConfigDescriptionAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetedEncoding (StructType)
object FacetedEncodingCodec {
  def decode(j: JsValue): FacetedEncoding =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FacetedEncoding] =
    Some(FacetedEncoding(
      `x` = (j \ "x").asOpt[JsValue].flatMap { x => PositionDefCodec.decodeOpt(x) },
      `longitude2` = (j \ "longitude2").asOpt[JsValue].flatMap { x => Position2DefCodec.decodeOpt(x) },
      `url` = (j \ "url").asOpt[JsValue].flatMap { x => FacetedEncodingUrlCodec.decodeOpt(x) },
      `fillOpacity` = (j \ "fillOpacity").asOpt[JsValue].flatMap { x => NumericMarkPropDefCodec.decodeOpt(x) },
      `key` = (j \ "key").asOpt[JsValue].flatMap { x => FieldDefWithoutScaleCodec.decodeOpt(x) },
      `radius2` = (j \ "radius2").asOpt[JsValue].flatMap { x => Position2DefCodec.decodeOpt(x) },
      `yError2` = (j \ "yError2").asOpt[JsValue].flatMap { x => FacetedEncodingYError2Codec.decodeOpt(x) },
      `yError` = (j \ "yError").asOpt[JsValue].flatMap { x => FacetedEncodingYErrorCodec.decodeOpt(x) },
      `yOffset` = (j \ "yOffset").asOpt[JsValue].flatMap { x => OffsetDefCodec.decodeOpt(x) },
      `xOffset` = (j \ "xOffset").asOpt[JsValue].flatMap { x => OffsetDefCodec.decodeOpt(x) },
      `size` = (j \ "size").asOpt[JsValue].flatMap { x => NumericMarkPropDefCodec.decodeOpt(x) },
      `latitude` = (j \ "latitude").asOpt[JsValue].flatMap { x => LatLongDefCodec.decodeOpt(x) },
      `y` = (j \ "y").asOpt[JsValue].flatMap { x => PositionDefCodec.decodeOpt(x) },
      `strokeOpacity` = (j \ "strokeOpacity").asOpt[JsValue].flatMap { x => NumericMarkPropDefCodec.decodeOpt(x) },
      `description` = (j \ "description").asOpt[JsValue].flatMap { x => FacetedEncodingDescriptionCodec.decodeOpt(x) },
      `angle` = (j \ "angle").asOpt[JsValue].flatMap { x => NumericMarkPropDefCodec.decodeOpt(x) },
      `stroke` = (j \ "stroke").asOpt[JsValue].flatMap { x => ColorDefCodec.decodeOpt(x) },
      `text` = (j \ "text").asOpt[JsValue].flatMap { x => TextDefCodec.decodeOpt(x) },
      `row` = (j \ "row").asOpt[JsValue].flatMap { x => RowColumnEncodingFieldDefCodec.decodeOpt(x) },
      `color` = (j \ "color").asOpt[JsValue].flatMap { x => ColorDefCodec.decodeOpt(x) },
      `x2` = (j \ "x2").asOpt[JsValue].flatMap { x => Position2DefCodec.decodeOpt(x) },
      `radius` = (j \ "radius").asOpt[JsValue].flatMap { x => PolarDefCodec.decodeOpt(x) },
      `longitude` = (j \ "longitude").asOpt[JsValue].flatMap { x => LatLongDefCodec.decodeOpt(x) },
      `order` = (j \ "order").asOpt[JsValue].flatMap { x => FacetedEncodingOrderCodec.decodeOpt(x) },
      `fill` = (j \ "fill").asOpt[JsValue].flatMap { x => ColorDefCodec.decodeOpt(x) },
      `theta` = (j \ "theta").asOpt[JsValue].flatMap { x => PolarDefCodec.decodeOpt(x) },
      `y2` = (j \ "y2").asOpt[JsValue].flatMap { x => Position2DefCodec.decodeOpt(x) },
      `xError` = (j \ "xError").asOpt[JsValue].flatMap { x => FacetedEncodingXErrorCodec.decodeOpt(x) },
      `column` = (j \ "column").asOpt[JsValue].flatMap { x => RowColumnEncodingFieldDefCodec.decodeOpt(x) },
      `tooltip` = (j \ "tooltip").asOpt[JsValue].flatMap { x => FacetedEncodingTooltipCodec.decodeOpt(x) },
      `latitude2` = (j \ "latitude2").asOpt[JsValue].flatMap { x => Position2DefCodec.decodeOpt(x) },
      `detail` = (j \ "detail").asOpt[JsValue].flatMap { x => FacetedEncodingDetailCodec.decodeOpt(x) },
      `shape` = (j \ "shape").asOpt[JsValue].flatMap { x => ShapeDefCodec.decodeOpt(x) },
      `facet` = (j \ "facet").asOpt[JsValue].flatMap { x => FacetEncodingFieldDefCodec.decodeOpt(x) },
      `opacity` = (j \ "opacity").asOpt[JsValue].flatMap { x => NumericMarkPropDefCodec.decodeOpt(x) },
      `href` = (j \ "href").asOpt[JsValue].flatMap { x => FacetedEncodingHrefCodec.decodeOpt(x) },
      `strokeDash` = (j \ "strokeDash").asOpt[JsValue].flatMap { x => NumericArrayMarkPropDefCodec.decodeOpt(x) },
      `xError2` = (j \ "xError2").asOpt[JsValue].flatMap { x => FacetedEncodingXError2Codec.decodeOpt(x) },
      `strokeWidth` = (j \ "strokeWidth").asOpt[JsValue].flatMap { x => NumericMarkPropDefCodec.decodeOpt(x) },
      `theta2` = (j \ "theta2").asOpt[JsValue].flatMap { x => Position2DefCodec.decodeOpt(x) },
    ))

  def encode(j: FacetedEncoding): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`x`.map { x => "x" -> PositionDefCodec.encode(x) },
        j.`longitude2`.map { x => "longitude2" -> Position2DefCodec.encode(x) },
        j.`url`.map { x => "url" -> FacetedEncodingUrlCodec.encode(x) },
        j.`fillOpacity`.map { x => "fillOpacity" -> NumericMarkPropDefCodec.encode(x) },
        j.`key`.map { x => "key" -> FieldDefWithoutScaleCodec.encode(x) },
        j.`radius2`.map { x => "radius2" -> Position2DefCodec.encode(x) },
        j.`yError2`.map { x => "yError2" -> FacetedEncodingYError2Codec.encode(x) },
        j.`yError`.map { x => "yError" -> FacetedEncodingYErrorCodec.encode(x) },
        j.`yOffset`.map { x => "yOffset" -> OffsetDefCodec.encode(x) },
        j.`xOffset`.map { x => "xOffset" -> OffsetDefCodec.encode(x) },
        j.`size`.map { x => "size" -> NumericMarkPropDefCodec.encode(x) },
        j.`latitude`.map { x => "latitude" -> LatLongDefCodec.encode(x) },
        j.`y`.map { x => "y" -> PositionDefCodec.encode(x) },
        j.`strokeOpacity`.map { x => "strokeOpacity" -> NumericMarkPropDefCodec.encode(x) },
        j.`description`.map { x => "description" -> FacetedEncodingDescriptionCodec.encode(x) },
        j.`angle`.map { x => "angle" -> NumericMarkPropDefCodec.encode(x) },
        j.`stroke`.map { x => "stroke" -> ColorDefCodec.encode(x) },
        j.`text`.map { x => "text" -> TextDefCodec.encode(x) },
        j.`row`.map { x => "row" -> RowColumnEncodingFieldDefCodec.encode(x) },
        j.`color`.map { x => "color" -> ColorDefCodec.encode(x) },
        j.`x2`.map { x => "x2" -> Position2DefCodec.encode(x) },
        j.`radius`.map { x => "radius" -> PolarDefCodec.encode(x) },
        j.`longitude`.map { x => "longitude" -> LatLongDefCodec.encode(x) },
        j.`order`.map { x => "order" -> FacetedEncodingOrderCodec.encode(x) },
        j.`fill`.map { x => "fill" -> ColorDefCodec.encode(x) },
        j.`theta`.map { x => "theta" -> PolarDefCodec.encode(x) },
        j.`y2`.map { x => "y2" -> Position2DefCodec.encode(x) },
        j.`xError`.map { x => "xError" -> FacetedEncodingXErrorCodec.encode(x) },
        j.`column`.map { x => "column" -> RowColumnEncodingFieldDefCodec.encode(x) },
        j.`tooltip`.map { x => "tooltip" -> FacetedEncodingTooltipCodec.encode(x) },
        j.`latitude2`.map { x => "latitude2" -> Position2DefCodec.encode(x) },
        j.`detail`.map { x => "detail" -> FacetedEncodingDetailCodec.encode(x) },
        j.`shape`.map { x => "shape" -> ShapeDefCodec.encode(x) },
        j.`facet`.map { x => "facet" -> FacetEncodingFieldDefCodec.encode(x) },
        j.`opacity`.map { x => "opacity" -> NumericMarkPropDefCodec.encode(x) },
        j.`href`.map { x => "href" -> FacetedEncodingHrefCodec.encode(x) },
        j.`strokeDash`.map { x => "strokeDash" -> NumericArrayMarkPropDefCodec.encode(x) },
        j.`xError2`.map { x => "xError2" -> FacetedEncodingXError2Codec.encode(x) },
        j.`strokeWidth`.map { x => "strokeWidth" -> NumericMarkPropDefCodec.encode(x) },
        j.`theta2`.map { x => "theta2" -> Position2DefCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TopLevelHConcatSpecParamsElement (UnionType)
object TopLevelHConcatSpecParamsElementCodec {
  def decode(j: JsValue): TopLevelHConcatSpecParamsElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelHConcatSpecParamsElement] =
    VariableParameterCodec.decodeOpt(j).orElse {
    TopLevelSelectionParameterCodec.decodeOpt(j) } 
  def encode(j: TopLevelHConcatSpecParamsElement): JsValue =
    j match {
      case x:VariableParameter /* TypeRef */ => VariableParameterCodec.encode(x)
      case x:TopLevelSelectionParameter /* TypeRef */ => TopLevelSelectionParameterCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigStrokeDashOffset (UnionType)
object BarConfigStrokeDashOffsetCodec {
  def decode(j: JsValue): BarConfigStrokeDashOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigStrokeDashOffset] =
    j.asOpt[JsNumber].map { BarConfigStrokeDashOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigStrokeDashOffset): JsValue =
    j match {
      case BarConfigStrokeDashOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisLabelBaselineAsObject2Condition (UnionType)
object ConditionalAxisLabelBaselineAsObject2ConditionCodec {
  def decode(j: JsValue): ConditionalAxisLabelBaselineAsObject2Condition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisLabelBaselineAsObject2Condition] =
    ConditionalPredicateValueDefTextBaselineNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalPredicateValueDefTextBaselineNullExprRefCodec.decodeOpt(j).map { ConditionalAxisLabelBaselineAsObject2ConditionAsArrayOfConditionalPredicateValueDefTextBaselineNullExprRef(_) } } 
  def encode(j: ConditionalAxisLabelBaselineAsObject2Condition): JsValue =
    j match {
      case x:ConditionalPredicateValueDefTextBaselineNullExprRef /* TypeRef */ => ConditionalPredicateValueDefTextBaselineNullExprRefCodec.encode(x)
      case ConditionalAxisLabelBaselineAsObject2ConditionAsArrayOfConditionalPredicateValueDefTextBaselineNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalPredicateValueDefTextBaselineNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefOuterRadius (ConstrainedType)
// see MarkDefOuterRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// ColorDef (UnionType)
object ColorDefCodec {
  def decode(j: JsValue): ColorDef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ColorDef] =
    FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullCodec.decodeOpt(j).orElse {
    FieldOrDatumDefWithConditionDatumDefGradientStringNullCodec.decodeOpt(j).orElse {
    ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullCodec.decodeOpt(j) } } 
  def encode(j: ColorDef): JsValue =
    j match {
      case x:FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNull /* TypeRef */ => FieldOrDatumDefWithConditionMarkPropFieldDefGradientStringNullCodec.encode(x)
      case x:FieldOrDatumDefWithConditionDatumDefGradientStringNull /* TypeRef */ => FieldOrDatumDefWithConditionDatumDefGradientStringNullCodec.encode(x)
      case x:ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNull /* TypeRef */ => ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNullCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingRadius2 (StructType)
object SharedEncodingRadius2Codec {
  def decode(j: JsValue): SharedEncodingRadius2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingRadius2] =
    Some(SharedEncodingRadius2(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingRadius2DatumCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingRadius2BandPositionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => x.asOpt[JsNull.type].map { _ => JsNull } },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingRadius2ValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingRadius2TimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingRadius2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingRadius2DatumCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingRadius2BandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> Json.toJson(x) },
        j.`value`.map { x => "value" -> SharedEncodingRadius2ValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingRadius2TimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConcatSpecGenericSpecBounds (EnumType)
object ConcatSpecGenericSpecBoundsCodec {
  def decode(j: JsValue): ConcatSpecGenericSpecBounds =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConcatSpecGenericSpecBounds] =
    j match {
      case JsString("full") => Some(ConcatSpecGenericSpecBoundsFull)
      case JsString("flush") => Some(ConcatSpecGenericSpecBoundsFlush)
      case _ => None
    }
  def encode(j: ConcatSpecGenericSpecBounds): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// FacetedUnitSpecSpacing (UnionType)
object FacetedUnitSpecSpacingCodec {
  def decode(j: JsValue): FacetedUnitSpecSpacing =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetedUnitSpecSpacing] =
    j.asOpt[JsNumber].map { FacetedUnitSpecSpacingAsNumber(_) }.orElse {
    RowColNumberCodec.decodeOpt(j) } 
  def encode(j: FacetedUnitSpecSpacing): JsValue =
    j match {
      case FacetedUnitSpecSpacingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:RowColNumber /* TypeRef */ => RowColNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewConfigFill (UnionType)
object ViewConfigFillCodec {
  def decode(j: JsValue): ViewConfigFill =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewConfigFill] =
    ColorCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ViewConfigFillAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: ViewConfigFill): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case ViewConfigFillAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTickCap (UnionType)
object AxisTickCapCodec {
  def decode(j: JsValue): AxisTickCap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTickCap] =
    StrokeCapCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisTickCap): JsValue =
    j match {
      case x:StrokeCap /* TypeRef */ => StrokeCapCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HConcatSpecGenericSpec (StructType)
object HConcatSpecGenericSpecCodec {
  def decode(j: JsValue): HConcatSpecGenericSpec =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[HConcatSpecGenericSpec] =
    {
      val `hconcat` = (j \ "hconcat").asOpt[JsValue].flatMap { x => ArrayOfSpecCodec.decodeOpt(x) }
      if(`hconcat`.isEmpty) { return None }
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `center` = (j \ "center").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `description` = (j \ "description").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `data` = (j \ "data").asOpt[JsValue].flatMap { x => DataCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `bounds` = (j \ "bounds").asOpt[JsValue].flatMap { x => HConcatSpecGenericSpecBoundsCodec.decodeOpt(x) }
      val `resolve` = (j \ "resolve").asOpt[JsValue].flatMap { x => ResolveCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => HConcatSpecGenericSpecTitleCodec.decodeOpt(x) }
      val `spacing` = (j \ "spacing").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `transform` = (j \ "transform").asOpt[JsValue].flatMap { x => ArrayOfTransformCodec.decodeOpt(x) }
      return Some(HConcatSpecGenericSpec(
        `hconcat` = `hconcat`.get,
        `name` = `name`,
        `center` = `center`,
        `description` = `description`,
        `data` = `data`,
        `bounds` = `bounds`,
        `resolve` = `resolve`,
        `title` = `title`,
        `spacing` = `spacing`,
        `transform` = `transform`,
      ))
    }

  def encode(j: HConcatSpecGenericSpec): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("hconcat" -> ArrayOfSpecCodec.encode(j.`hconcat`)),
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`center`.map { x => "center" -> Json.toJson(x) },
        j.`description`.map { x => "description" -> Json.toJson(x) },
        j.`data`.map { x => "data" -> DataCodec.encode(x) },
        j.`bounds`.map { x => "bounds" -> HConcatSpecGenericSpecBoundsCodec.encode(x) },
        j.`resolve`.map { x => "resolve" -> ResolveCodec.encode(x) },
        j.`title`.map { x => "title" -> HConcatSpecGenericSpecTitleCodec.encode(x) },
        j.`spacing`.map { x => "spacing" -> Json.toJson(x) },
        j.`transform`.map { x => "transform" -> ArrayOfTransformCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// BarConfigAriaRoleDescription (UnionType)
object BarConfigAriaRoleDescriptionCodec {
  def decode(j: JsValue): BarConfigAriaRoleDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigAriaRoleDescription] =
    j.asOpt[String].map { BarConfigAriaRoleDescriptionAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigAriaRoleDescription): JsValue =
    j match {
      case BarConfigAriaRoleDescriptionAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigLineBreak (UnionType)
object TickConfigLineBreakCodec {
  def decode(j: JsValue): TickConfigLineBreak =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigLineBreak] =
    j.asOpt[String].map { TickConfigLineBreakAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigLineBreak): JsValue =
    j match {
      case TickConfigLineBreakAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingTheta2Value (UnionType)
object SharedEncodingTheta2ValueCodec {
  def decode(j: JsValue): SharedEncodingTheta2Value =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingTheta2Value] =
    j.asOpt[JsNumber].map { SharedEncodingTheta2ValueAsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingTheta2Value): JsValue =
    j match {
      case SharedEncodingTheta2ValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AnyMark (UnionType)
object AnyMarkCodec {
  def decode(j: JsValue): AnyMark =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AnyMark] =
    CompositeMarkCodec.decodeOpt(j).orElse {
    CompositeMarkDefCodec.decodeOpt(j).orElse {
    MarkCodec.decodeOpt(j).orElse {
    MarkDefCodec.decodeOpt(j) } } } 
  def encode(j: AnyMark): JsValue =
    j match {
      case x:CompositeMark /* TypeRef */ => CompositeMarkCodec.encode(x)
      case x:CompositeMarkDef /* TypeRef */ => CompositeMarkDefCodec.encode(x)
      case x:Mark /* TypeRef */ => MarkCodec.encode(x)
      case x:MarkDef /* TypeRef */ => MarkDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigAriaRole (UnionType)
object RectConfigAriaRoleCodec {
  def decode(j: JsValue): RectConfigAriaRole =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigAriaRole] =
    j.asOpt[String].map { RectConfigAriaRoleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigAriaRole): JsValue =
    j match {
      case RectConfigAriaRoleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefShape (UnionType)
object MarkDefShapeCodec {
  def decode(j: JsValue): MarkDefShape =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefShape] =
    j.asOpt[String].map { MarkDefShapeAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefShape): JsValue =
    j match {
      case MarkDefShapeAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// HeaderLabelFontStyle (UnionType)
object HeaderLabelFontStyleCodec {
  def decode(j: JsValue): HeaderLabelFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[HeaderLabelFontStyle] =
    j.asOpt[String].map { HeaderLabelFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: HeaderLabelFontStyle): JsValue =
    j match {
      case HeaderLabelFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigContinuousPadding (ConstrainedType)
// see ScaleConfigContinuousPadding (UnionType)

////////////////////////////////////////////////////////////////////////
// DatumDef (StructType)
object DatumDefCodec {
  def decode(j: JsValue): DatumDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[DatumDef] =
    Some(DatumDef(
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => DatumDefBandPositionCodec.decodeOpt(x) },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => DatumDefDatumCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeCodec.decodeOpt(x) },
    ))

  def encode(j: DatumDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`bandPosition`.map { x => "bandPosition" -> DatumDefBandPositionCodec.encode(x) },
        j.`datum`.map { x => "datum" -> DatumDefDatumCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingTheta2 (StructType)
object SharedEncodingTheta2Codec {
  def decode(j: JsValue): SharedEncodingTheta2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingTheta2] =
    Some(SharedEncodingTheta2(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingTheta2DatumCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingTheta2BandPositionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => x.asOpt[JsNull.type].map { _ => JsNull } },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingTheta2ValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingTheta2TimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => TypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingTheta2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingTheta2DatumCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingTheta2BandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> Json.toJson(x) },
        j.`value`.map { x => "value" -> SharedEncodingTheta2ValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingTheta2TimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`type`.map { x => "type" -> TypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LineConfigFillOpacity (UnionType)
object LineConfigFillOpacityCodec {
  def decode(j: JsValue): LineConfigFillOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigFillOpacity] =
    LineConfigFillOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigFillOpacity): JsValue =
    j match {
      case x:LineConfigFillOpacityAsNumber /* TypeRef */ => LineConfigFillOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefCornerRadius (UnionType)
object OverlayMarkDefCornerRadiusCodec {
  def decode(j: JsValue): OverlayMarkDefCornerRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefCornerRadius] =
    j.asOpt[JsNumber].map { OverlayMarkDefCornerRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefCornerRadius): JsValue =
    j match {
      case OverlayMarkDefCornerRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigStrokeOpacityAsNumber (ConstrainedType)
object BarConfigStrokeOpacityAsNumberCodec {
  def decode(j: JsValue): BarConfigStrokeOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BarConfigStrokeOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { BarConfigStrokeOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: BarConfigStrokeOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// FacetEncodingFieldDefSpacing (UnionType)
object FacetEncodingFieldDefSpacingCodec {
  def decode(j: JsValue): FacetEncodingFieldDefSpacing =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetEncodingFieldDefSpacing] =
    j.asOpt[JsNumber].map { FacetEncodingFieldDefSpacingAsNumber(_) }.orElse {
    RowColNumberCodec.decodeOpt(j) } 
  def encode(j: FacetEncodingFieldDefSpacing): JsValue =
    j match {
      case FacetEncodingFieldDefSpacingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:RowColNumber /* TypeRef */ => RowColNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigX (UnionType)
object TickConfigXCodec {
  def decode(j: JsValue): TickConfigX =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigX] =
    j.asOpt[JsNumber].map { TickConfigXAsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: TickConfigX): JsValue =
    j match {
      case TickConfigXAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OrderValueDefCondition (UnionType)
object OrderValueDefConditionCodec {
  def decode(j: JsValue): OrderValueDefCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OrderValueDefCondition] =
    ConditionalValueDefNumberCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefNumberCodec.decodeOpt(j).map { OrderValueDefConditionAsArrayOfConditionalValueDefNumber(_) } } 
  def encode(j: OrderValueDefCondition): JsValue =
    j match {
      case x:ConditionalValueDefNumber /* TypeRef */ => ConditionalValueDefNumberCodec.encode(x)
      case OrderValueDefConditionAsArrayOfConditionalValueDefNumber(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleFieldDefBandPosition (ConstrainedType)
object ScaleFieldDefBandPositionCodec {
  def decode(j: JsValue): ScaleFieldDefBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ScaleFieldDefBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { ScaleFieldDefBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ScaleFieldDefBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTickSizeAsNumber (ConstrainedType)
object AxisConfigTickSizeAsNumberCodec {
  def decode(j: JsValue): AxisConfigTickSizeAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AxisConfigTickSizeAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AxisConfigTickSizeAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AxisConfigTickSizeAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefUrl (UnionType)
object OverlayMarkDefUrlCodec {
  def decode(j: JsValue): OverlayMarkDefUrl =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefUrl] =
    UriReferenceCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefUrl): JsValue =
    j match {
      case x:UriReference /* TypeRef */ => UriReferenceCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject1Padding (UnionType)
object TopLevelRepeatSpecAsObject1PaddingCodec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject1Padding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject1Padding] =
    PaddingCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TopLevelRepeatSpecAsObject1Padding): JsValue =
    j match {
      case x:Padding /* TypeRef */ => PaddingCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Greedy (ConstantType)
object GreedyCodec {
  def decode(j: JsValue): Greedy =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Greedy] =
    j match {
      case JsString("greedy") => Some(Greedy())
      case _ => None
    }
  def encode(j: Greedy): JsValue =
    JsString("greedy")
}


////////////////////////////////////////////////////////////////////////
// RangeRawElement (UnionType)
object RangeRawElementCodec {
  def decode(j: JsValue): RangeRawElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RangeRawElement] =
    j.asOpt[String].map { RangeRawElementAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => RangeRawElementAsNull }.orElse {
    ArrayOfNumberCodec.decodeOpt(j).map { RangeRawElementAsArrayOfNumber(_) }.orElse {
    j.asOpt[Boolean].map { RangeRawElementAsBool(_) }.orElse {
    j.asOpt[JsNumber].map { RangeRawElementAsNumber(_) } } } } } 
  def encode(j: RangeRawElement): JsValue =
    j match {
      case RangeRawElementAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case RangeRawElementAsNull /* Global, NullType$ */ => JsNull
      case RangeRawElementAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case RangeRawElementAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case RangeRawElementAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeOpacityCondition (UnionType)
object SharedEncodingStrokeOpacityConditionCodec {
  def decode(j: JsValue): SharedEncodingStrokeOpacityCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeOpacityCondition] =
    ConditionalValueDefNumberExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefNumberExprRefCodec.decodeOpt(j).map { SharedEncodingStrokeOpacityConditionAsArrayOfConditionalValueDefNumberExprRef(_) }.orElse {
    ConditionalMarkPropFieldOrDatumDefCodec.decodeOpt(j) } } 
  def encode(j: SharedEncodingStrokeOpacityCondition): JsValue =
    j match {
      case x:ConditionalValueDefNumberExprRef /* TypeRef */ => ConditionalValueDefNumberExprRefCodec.encode(x)
      case SharedEncodingStrokeOpacityConditionAsArrayOfConditionalValueDefNumberExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefNumberExprRefCodec.encode(x)
      case x:ConditionalMarkPropFieldOrDatumDef /* TypeRef */ => ConditionalMarkPropFieldOrDatumDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigRadius (ConstrainedType)
// see BarConfigRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// SharedEncodingLatitude2Value (UnionType)
object SharedEncodingLatitude2ValueCodec {
  def decode(j: JsValue): SharedEncodingLatitude2Value =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingLatitude2Value] =
    j.asOpt[JsNumber].map { SharedEncodingLatitude2ValueAsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingLatitude2Value): JsValue =
    j match {
      case SharedEncodingLatitude2ValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisZindex (ConstrainedType)
object AxisZindexCodec {
  def decode(j: JsValue): AxisZindex =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AxisZindex] =
    try {
      j.asOpt[JsNumber]
        .map { AxisZindex(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AxisZindex): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// RectConfigOpacity (UnionType)
object RectConfigOpacityCodec {
  def decode(j: JsValue): RectConfigOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigOpacity] =
    j.asOpt[JsNumber].map { RectConfigOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigOpacity): JsValue =
    j match {
      case RectConfigOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingSizeBin (UnionType)
object SharedEncodingSizeBinCodec {
  def decode(j: JsValue): SharedEncodingSizeBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingSizeBin] =
    j.asOpt[Boolean].map { SharedEncodingSizeBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingSizeBinAsNull } } } 
  def encode(j: SharedEncodingSizeBin): JsValue =
    j match {
      case SharedEncodingSizeBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case SharedEncodingSizeBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigStrokeOpacityAsNumber (ConstrainedType)
object AreaConfigStrokeOpacityAsNumberCodec {
  def decode(j: JsValue): AreaConfigStrokeOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AreaConfigStrokeOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AreaConfigStrokeOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AreaConfigStrokeOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateMarkPropFieldOrDatumDefAsObject1 (StructType)
object ConditionalPredicateMarkPropFieldOrDatumDefAsObject1Codec {
  def decode(j: JsValue): ConditionalPredicateMarkPropFieldOrDatumDefAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateMarkPropFieldOrDatumDefAsObject1] =
    {
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) }
      val `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => ConditionalPredicateMarkPropFieldOrDatumDefAsObject1BandPositionCodec.decodeOpt(x) }
      val `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => ConditionalPredicateMarkPropFieldOrDatumDefAsObject1BinCodec.decodeOpt(x) }
      val `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) }
      val `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => ConditionalPredicateMarkPropFieldOrDatumDefAsObject1TimeUnitCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) }
      val `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) }
      return Some(ConditionalPredicateMarkPropFieldOrDatumDefAsObject1(
        `test` = `test`.get,
        `field` = `field`,
        `scale` = `scale`,
        `legend` = `legend`,
        `bandPosition` = `bandPosition`,
        `bin` = `bin`,
        `aggregate` = `aggregate`,
        `timeUnit` = `timeUnit`,
        `title` = `title`,
        `sort` = `sort`,
        `type` = `type`,
      ))
    }

  def encode(j: ConditionalPredicateMarkPropFieldOrDatumDefAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> ConditionalPredicateMarkPropFieldOrDatumDefAsObject1BandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> ConditionalPredicateMarkPropFieldOrDatumDefAsObject1BinCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> ConditionalPredicateMarkPropFieldOrDatumDefAsObject1TimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// OverlayMarkDefTheta2Offset (UnionType)
object OverlayMarkDefTheta2OffsetCodec {
  def decode(j: JsValue): OverlayMarkDefTheta2Offset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefTheta2Offset] =
    j.asOpt[JsNumber].map { OverlayMarkDefTheta2OffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefTheta2Offset): JsValue =
    j match {
      case OverlayMarkDefTheta2OffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MergedStream (StructType)
object MergedStreamCodec {
  def decode(j: JsValue): MergedStream =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[MergedStream] =
    {
      val `marktype` = (j \ "marktype").asOpt[JsValue].flatMap { x => MarkTypeCodec.decodeOpt(x) }
      val `filter` = (j \ "filter").asOpt[JsValue].flatMap { x => MergedStreamFilterCodec.decodeOpt(x) }
      val `merge` = (j \ "merge").asOpt[JsValue].flatMap { x => ArrayOfStreamCodec.decodeOpt(x) }
      if(`merge`.isEmpty) { return None }
      val `markname` = (j \ "markname").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `consume` = (j \ "consume").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `debounce` = (j \ "debounce").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `between` = (j \ "between").asOpt[JsValue].flatMap { x => ArrayOfStreamCodec.decodeOpt(x) }
      val `throttle` = (j \ "throttle").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      return Some(MergedStream(
        `marktype` = `marktype`,
        `filter` = `filter`,
        `merge` = `merge`.get,
        `markname` = `markname`,
        `consume` = `consume`,
        `debounce` = `debounce`,
        `between` = `between`,
        `throttle` = `throttle`,
      ))
    }

  def encode(j: MergedStream): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`marktype`.map { x => "marktype" -> MarkTypeCodec.encode(x) },
        j.`filter`.map { x => "filter" -> MergedStreamFilterCodec.encode(x) },
        Some("merge" -> ArrayOfStreamCodec.encode(j.`merge`)),
        j.`markname`.map { x => "markname" -> Json.toJson(x) },
        j.`consume`.map { x => "consume" -> Json.toJson(x) },
        j.`debounce`.map { x => "debounce" -> Json.toJson(x) },
        j.`between`.map { x => "between" -> ArrayOfStreamCodec.encode(x) },
        j.`throttle`.map { x => "throttle" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// BinTransformBin (UnionType)
object BinTransformBinCodec {
  def decode(j: JsValue): BinTransformBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BinTransformBin] =
    TrueCodec.decodeOpt(j).orElse {
    BinParamsCodec.decodeOpt(j) } 
  def encode(j: BinTransformBin): JsValue =
    j match {
      case x:True /* TypeRef */ => TrueCodec.encode(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewBackgroundFillOpacityAsNumber (ConstrainedType)
object ViewBackgroundFillOpacityAsNumberCodec {
  def decode(j: JsValue): ViewBackgroundFillOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ViewBackgroundFillOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { ViewBackgroundFillOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ViewBackgroundFillOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// RectConfigX (UnionType)
object RectConfigXCodec {
  def decode(j: JsValue): RectConfigX =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigX] =
    j.asOpt[JsNumber].map { RectConfigXAsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: RectConfigX): JsValue =
    j match {
      case RectConfigXAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingXError2TimeUnit (UnionType)
object SharedEncodingXError2TimeUnitCodec {
  def decode(j: JsValue): SharedEncodingXError2TimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingXError2TimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingXError2TimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigRadius2 (UnionType)
object BarConfigRadius2Codec {
  def decode(j: JsValue): BarConfigRadius2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigRadius2] =
    j.asOpt[JsNumber].map { BarConfigRadius2AsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigRadius2): JsValue =
    j match {
      case BarConfigRadius2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// CompositeMarkDef (UnionType)
object CompositeMarkDefCodec {
  def decode(j: JsValue): CompositeMarkDef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[CompositeMarkDef] =
    BoxPlotDefCodec.decodeOpt(j).orElse {
    ErrorBarDefCodec.decodeOpt(j).orElse {
    ErrorBandDefCodec.decodeOpt(j) } } 
  def encode(j: CompositeMarkDef): JsValue =
    j match {
      case x:BoxPlotDef /* TypeRef */ => BoxPlotDefCodec.encode(x)
      case x:ErrorBarDef /* TypeRef */ => ErrorBarDefCodec.encode(x)
      case x:ErrorBandDef /* TypeRef */ => ErrorBandDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefCornerRadiusTopRight (UnionType)
object OverlayMarkDefCornerRadiusTopRightCodec {
  def decode(j: JsValue): OverlayMarkDefCornerRadiusTopRight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefCornerRadiusTopRight] =
    j.asOpt[JsNumber].map { OverlayMarkDefCornerRadiusTopRightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefCornerRadiusTopRight): JsValue =
    j match {
      case OverlayMarkDefCornerRadiusTopRightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigLimit (UnionType)
object RectConfigLimitCodec {
  def decode(j: JsValue): RectConfigLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigLimit] =
    j.asOpt[JsNumber].map { RectConfigLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigLimit): JsValue =
    j match {
      case RectConfigLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigAriaRoleDescription (UnionType)
object LineConfigAriaRoleDescriptionCodec {
  def decode(j: JsValue): LineConfigAriaRoleDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigAriaRoleDescription] =
    j.asOpt[String].map { LineConfigAriaRoleDescriptionAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigAriaRoleDescription): JsValue =
    j match {
      case LineConfigAriaRoleDescriptionAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LinearGradient (StructType)
object LinearGradientCodec {
  def decode(j: JsValue): LinearGradient =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LinearGradient] =
    {
      val `gradient` = (j \ "gradient").asOpt[JsValue].flatMap { x => LinearGradientGradientCodec.decodeOpt(x) }
      if(`gradient`.isEmpty) { return None }
      val `x2` = (j \ "x2").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `id` = (j \ "id").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `y1` = (j \ "y1").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `stops` = (j \ "stops").asOpt[JsValue].flatMap { x => ArrayOfGradientStopCodec.decodeOpt(x) }
      if(`stops`.isEmpty) { return None }
      val `y2` = (j \ "y2").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `x1` = (j \ "x1").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      return Some(LinearGradient(
        `gradient` = `gradient`.get,
        `x2` = `x2`,
        `id` = `id`,
        `y1` = `y1`,
        `stops` = `stops`.get,
        `y2` = `y2`,
        `x1` = `x1`,
      ))
    }

  def encode(j: LinearGradient): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("gradient" -> LinearGradientGradientCodec.encode(j.`gradient`)),
        j.`x2`.map { x => "x2" -> Json.toJson(x) },
        j.`id`.map { x => "id" -> Json.toJson(x) },
        j.`y1`.map { x => "y1" -> Json.toJson(x) },
        Some("stops" -> ArrayOfGradientStopCodec.encode(j.`stops`)),
        j.`y2`.map { x => "y2" -> Json.toJson(x) },
        j.`x1`.map { x => "x1" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// MarkConfigTheta (ConstrainedType)
// see MarkConfigTheta (UnionType)

////////////////////////////////////////////////////////////////////////
// AreaConfigY (UnionType)
object AreaConfigYCodec {
  def decode(j: JsValue): AreaConfigY =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigY] =
    j.asOpt[JsNumber].map { AreaConfigYAsNumber(_) }.orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: AreaConfigY): JsValue =
    j match {
      case AreaConfigYAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalValueDefTextExprRef (UnionType)
object ConditionalValueDefTextExprRefCodec {
  def decode(j: JsValue): ConditionalValueDefTextExprRef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalValueDefTextExprRef] =
    ConditionalPredicateValueDefTextExprRefCodec.decodeOpt(j).orElse {
    ConditionalParameterValueDefTextExprRefCodec.decodeOpt(j) } 
  def encode(j: ConditionalValueDefTextExprRef): JsValue =
    j match {
      case x:ConditionalPredicateValueDefTextExprRef /* TypeRef */ => ConditionalPredicateValueDefTextExprRefCodec.encode(x)
      case x:ConditionalParameterValueDefTextExprRef /* TypeRef */ => ConditionalParameterValueDefTextExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject2ParamsElement (UnionType)
object TopLevelRepeatSpecAsObject2ParamsElementCodec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject2ParamsElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject2ParamsElement] =
    VariableParameterCodec.decodeOpt(j).orElse {
    TopLevelSelectionParameterCodec.decodeOpt(j) } 
  def encode(j: TopLevelRepeatSpecAsObject2ParamsElement): JsValue =
    j match {
      case x:VariableParameter /* TypeRef */ => VariableParameterCodec.encode(x)
      case x:TopLevelSelectionParameter /* TypeRef */ => TopLevelSelectionParameterCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigBandWithNestedOffsetPaddingOuter (UnionType)
object ScaleConfigBandWithNestedOffsetPaddingOuterCodec {
  def decode(j: JsValue): ScaleConfigBandWithNestedOffsetPaddingOuter =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleConfigBandWithNestedOffsetPaddingOuter] =
    j.asOpt[JsNumber].map { ScaleConfigBandWithNestedOffsetPaddingOuterAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleConfigBandWithNestedOffsetPaddingOuter): JsValue =
    j match {
      case ScaleConfigBandWithNestedOffsetPaddingOuterAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingTheta2BandPosition (ConstrainedType)
object SharedEncodingTheta2BandPositionCodec {
  def decode(j: JsValue): SharedEncodingTheta2BandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingTheta2BandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingTheta2BandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingTheta2BandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// LineConfigTension (UnionType)
object LineConfigTensionCodec {
  def decode(j: JsValue): LineConfigTension =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigTension] =
    j.asOpt[JsNumber].map { LineConfigTensionAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigTension): JsValue =
    j match {
      case LineConfigTensionAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewConfigStroke (UnionType)
object ViewConfigStrokeCodec {
  def decode(j: JsValue): ViewConfigStroke =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewConfigStroke] =
    ColorCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ViewConfigStrokeAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: ViewConfigStroke): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case ViewConfigStrokeAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkType (EnumType)
object MarkTypeCodec {
  def decode(j: JsValue): MarkType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkType] =
    j match {
      case JsString("arc") => Some(MarkTypeArc)
      case JsString("area") => Some(MarkTypeArea)
      case JsString("image") => Some(MarkTypeImage)
      case JsString("group") => Some(MarkTypeGroup)
      case JsString("line") => Some(MarkTypeLine)
      case JsString("path") => Some(MarkTypePath)
      case JsString("rect") => Some(MarkTypeRect)
      case JsString("rule") => Some(MarkTypeRule)
      case JsString("shape") => Some(MarkTypeShape)
      case JsString("symbol") => Some(MarkTypeSymbol)
      case JsString("text") => Some(MarkTypeText)
      case JsString("trail") => Some(MarkTypeTrail)
      case _ => None
    }
  def encode(j: MarkType): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingThetaValue (UnionType)
object SharedEncodingThetaValueCodec {
  def decode(j: JsValue): SharedEncodingThetaValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingThetaValue] =
    j.asOpt[JsNumber].map { SharedEncodingThetaValueAsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingThetaValue): JsValue =
    j match {
      case SharedEncodingThetaValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterStringFieldDefFormat (UnionType)
object ConditionalParameterStringFieldDefFormatCodec {
  def decode(j: JsValue): ConditionalParameterStringFieldDefFormat =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalParameterStringFieldDefFormat] =
    j.asOpt[String].map { ConditionalParameterStringFieldDefFormatAsString(_) }.orElse {
    DictOfAnyCodec.decodeOpt(j).map { ConditionalParameterStringFieldDefFormatAsDictOfAny(_) } } 
  def encode(j: ConditionalParameterStringFieldDefFormat): JsValue =
    j match {
      case ConditionalParameterStringFieldDefFormatAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case ConditionalParameterStringFieldDefFormatAsDictOfAny(x) /* Base, MapType */ => DictOfAnyCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigTheta2 (UnionType)
object LineConfigTheta2Codec {
  def decode(j: JsValue): LineConfigTheta2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigTheta2] =
    j.asOpt[JsNumber].map { LineConfigTheta2AsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigTheta2): JsValue =
    j match {
      case LineConfigTheta2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingOpacityType (UnionType)
object SharedEncodingOpacityTypeCodec {
  def decode(j: JsValue): SharedEncodingOpacityType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingOpacityType] =
    StandardTypeCodec.decodeOpt(j).orElse {
    TypeCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingOpacityType): JsValue =
    j match {
      case x:StandardType /* TypeRef */ => StandardTypeCodec.encode(x)
      case x:Type /* TypeRef */ => TypeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigStrokeDashOffset (UnionType)
object LineConfigStrokeDashOffsetCodec {
  def decode(j: JsValue): LineConfigStrokeDashOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigStrokeDashOffset] =
    j.asOpt[JsNumber].map { LineConfigStrokeDashOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigStrokeDashOffset): JsValue =
    j match {
      case LineConfigStrokeDashOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisColorAsObject2Condition (UnionType)
object ConditionalAxisColorAsObject2ConditionCodec {
  def decode(j: JsValue): ConditionalAxisColorAsObject2Condition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisColorAsObject2Condition] =
    ConditionalPredicateValueDefColorNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalPredicateValueDefColorNullExprRefCodec.decodeOpt(j).map { ConditionalAxisColorAsObject2ConditionAsArrayOfConditionalPredicateValueDefColorNullExprRef(_) } } 
  def encode(j: ConditionalAxisColorAsObject2Condition): JsValue =
    j match {
      case x:ConditionalPredicateValueDefColorNullExprRef /* TypeRef */ => ConditionalPredicateValueDefColorNullExprRefCodec.encode(x)
      case ConditionalAxisColorAsObject2ConditionAsArrayOfConditionalPredicateValueDefColorNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalPredicateValueDefColorNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigOuterRadius (UnionType)
object MarkConfigOuterRadiusCodec {
  def decode(j: JsValue): MarkConfigOuterRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigOuterRadius] =
    j.asOpt[JsNumber].map { MarkConfigOuterRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigOuterRadius): JsValue =
    j match {
      case MarkConfigOuterRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PositionFieldDefTimeUnit (UnionType)
object PositionFieldDefTimeUnitCodec {
  def decode(j: JsValue): PositionFieldDefTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PositionFieldDefTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: PositionFieldDefTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefStringExprRefValue (UnionType)
object ConditionalPredicateValueDefStringExprRefValueCodec {
  def decode(j: JsValue): ConditionalPredicateValueDefStringExprRefValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefStringExprRefValue] =
    j.asOpt[String].map { ConditionalPredicateValueDefStringExprRefValueAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ConditionalPredicateValueDefStringExprRefValue): JsValue =
    j match {
      case ConditionalPredicateValueDefStringExprRefValueAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefLimit (UnionType)
object MarkDefLimitCodec {
  def decode(j: JsValue): MarkDefLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefLimit] =
    j.asOpt[JsNumber].map { MarkDefLimitAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefLimit): JsValue =
    j match {
      case MarkDefLimitAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// UnitSpecWithFrameParamsElement (UnionType)
object UnitSpecWithFrameParamsElementCodec {
  def decode(j: JsValue): UnitSpecWithFrameParamsElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[UnitSpecWithFrameParamsElement] =
    VariableParameterCodec.decodeOpt(j).orElse {
    SelectionParameterCodec.decodeOpt(j) } 
  def encode(j: UnitSpecWithFrameParamsElement): JsValue =
    j match {
      case x:VariableParameter /* TypeRef */ => VariableParameterCodec.encode(x)
      case x:SelectionParameter /* TypeRef */ => SelectionParameterCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefFontSizeAsNumber (ConstrainedType)
object MarkDefFontSizeAsNumberCodec {
  def decode(j: JsValue): MarkDefFontSizeAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[MarkDefFontSizeAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { MarkDefFontSizeAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: MarkDefFontSizeAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// BindRangeInput (ConstantType)
object BindRangeInputCodec {
  def decode(j: JsValue): BindRangeInput =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BindRangeInput] =
    j match {
      case JsString("range") => Some(BindRangeInput())
      case _ => None
    }
  def encode(j: BindRangeInput): JsValue =
    JsString("range")
}


////////////////////////////////////////////////////////////////////////
// SharedEncodingOpacity (StructType)
object SharedEncodingOpacityCodec {
  def decode(j: JsValue): SharedEncodingOpacity =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingOpacity] =
    Some(SharedEncodingOpacity(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingOpacityDatumCodec.decodeOpt(x) },
      `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingOpacityBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => SharedEncodingOpacityConditionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingOpacityBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingOpacityValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingOpacityTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => SharedEncodingOpacityTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingOpacity): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingOpacityDatumCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingOpacityBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> SharedEncodingOpacityConditionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingOpacityBinCodec.encode(x) },
        j.`value`.map { x => "value" -> SharedEncodingOpacityValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingOpacityTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> SharedEncodingOpacityTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// FieldRangePredicate (StructType)
object FieldRangePredicateCodec {
  def decode(j: JsValue): FieldRangePredicate =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldRangePredicate] =
    {
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`field`.isEmpty) { return None }
      val `range` = (j \ "range").asOpt[JsValue].flatMap { x => FieldRangePredicateRangeCodec.decodeOpt(x) }
      if(`range`.isEmpty) { return None }
      val `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => FieldRangePredicateTimeUnitCodec.decodeOpt(x) }
      return Some(FieldRangePredicate(
        `field` = `field`.get,
        `range` = `range`.get,
        `timeUnit` = `timeUnit`,
      ))
    }

  def encode(j: FieldRangePredicate): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("field" -> Json.toJson(j.`field`)),
        Some("range" -> FieldRangePredicateRangeCodec.encode(j.`range`)),
        j.`timeUnit`.map { x => "timeUnit" -> FieldRangePredicateTimeUnitCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConditionalValueDefStringNullExprRef (UnionType)
object ConditionalValueDefStringNullExprRefCodec {
  def decode(j: JsValue): ConditionalValueDefStringNullExprRef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalValueDefStringNullExprRef] =
    ConditionalPredicateValueDefStringNullExprRefCodec.decodeOpt(j).orElse {
    ConditionalParameterValueDefStringNullExprRefCodec.decodeOpt(j) } 
  def encode(j: ConditionalValueDefStringNullExprRef): JsValue =
    j match {
      case x:ConditionalPredicateValueDefStringNullExprRef /* TypeRef */ => ConditionalPredicateValueDefStringNullExprRefCodec.encode(x)
      case x:ConditionalParameterValueDefStringNullExprRef /* TypeRef */ => ConditionalParameterValueDefStringNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigOrder (UnionType)
object LineConfigOrderCodec {
  def decode(j: JsValue): LineConfigOrder =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigOrder] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => LineConfigOrderAsNull }.orElse {
    j.asOpt[Boolean].map { LineConfigOrderAsBool(_) } } 
  def encode(j: LineConfigOrder): JsValue =
    j match {
      case LineConfigOrderAsNull /* Global, NullType$ */ => JsNull
      case LineConfigOrderAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeWidthBandPosition (ConstrainedType)
object SharedEncodingStrokeWidthBandPositionCodec {
  def decode(j: JsValue): SharedEncodingStrokeWidthBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeWidthBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingStrokeWidthBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingStrokeWidthBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingLatitudeType (UnionType)
object SharedEncodingLatitudeTypeCodec {
  def decode(j: JsValue): SharedEncodingLatitudeType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingLatitudeType] =
    QuantitativeCodec.decodeOpt(j).orElse {
    TypeCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingLatitudeType): JsValue =
    j match {
      case x:Quantitative /* TypeRef */ => QuantitativeCodec.encode(x)
      case x:Type /* TypeRef */ => TypeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigGridWidthAsNumber (ConstrainedType)
object AxisConfigGridWidthAsNumberCodec {
  def decode(j: JsValue): AxisConfigGridWidthAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AxisConfigGridWidthAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AxisConfigGridWidthAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AxisConfigGridWidthAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkConfigFont (UnionType)
object MarkConfigFontCodec {
  def decode(j: JsValue): MarkConfigFont =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigFont] =
    j.asOpt[String].map { MarkConfigFontAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigFont): JsValue =
    j match {
      case MarkConfigFontAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigCornerRadius (UnionType)
object AreaConfigCornerRadiusCodec {
  def decode(j: JsValue): AreaConfigCornerRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigCornerRadius] =
    j.asOpt[JsNumber].map { AreaConfigCornerRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigCornerRadius): JsValue =
    j match {
      case AreaConfigCornerRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisLabelAngleAsNumber (ConstrainedType)
object AxisLabelAngleAsNumberCodec {
  def decode(j: JsValue): AxisLabelAngleAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AxisLabelAngleAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AxisLabelAngleAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AxisLabelAngleAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// Field (UnionType)
object FieldCodec {
  def decode(j: JsValue): Field =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Field] =
    j.asOpt[String].map { FieldAsString(_) }.orElse {
    RepeatRefCodec.decodeOpt(j) } 
  def encode(j: Field): JsValue =
    j match {
      case FieldAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTitleFontSizeAsNumber (ConstrainedType)
object AxisConfigTitleFontSizeAsNumberCodec {
  def decode(j: JsValue): AxisConfigTitleFontSizeAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AxisConfigTitleFontSizeAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AxisConfigTitleFontSizeAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AxisConfigTitleFontSizeAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionDatumDefStringNullCondition (UnionType)
object FieldOrDatumDefWithConditionDatumDefStringNullConditionCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionDatumDefStringNullCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionDatumDefStringNullCondition] =
    ConditionalValueDefStringNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefStringNullExprRefCodec.decodeOpt(j).map { FieldOrDatumDefWithConditionDatumDefStringNullConditionAsArrayOfConditionalValueDefStringNullExprRef(_) } } 
  def encode(j: FieldOrDatumDefWithConditionDatumDefStringNullCondition): JsValue =
    j match {
      case x:ConditionalValueDefStringNullExprRef /* TypeRef */ => ConditionalValueDefStringNullExprRefCodec.encode(x)
      case FieldOrDatumDefWithConditionDatumDefStringNullConditionAsArrayOfConditionalValueDefStringNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefStringNullExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefFontWeight (UnionType)
object MarkDefFontWeightCodec {
  def decode(j: JsValue): MarkDefFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigTitleBaseline (UnionType)
object LegendConfigTitleBaselineCodec {
  def decode(j: JsValue): LegendConfigTitleBaseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigTitleBaseline] =
    TextBaselineCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigTitleBaseline): JsValue =
    j match {
      case x:TextBaseline /* TypeRef */ => TextBaselineCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigEndAngle (UnionType)
object AreaConfigEndAngleCodec {
  def decode(j: JsValue): AreaConfigEndAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigEndAngle] =
    j.asOpt[JsNumber].map { AreaConfigEndAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigEndAngle): JsValue =
    j match {
      case AreaConfigEndAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConcatSpecGenericSpecSpacing (UnionType)
object ConcatSpecGenericSpecSpacingCodec {
  def decode(j: JsValue): ConcatSpecGenericSpecSpacing =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConcatSpecGenericSpecSpacing] =
    j.asOpt[JsNumber].map { ConcatSpecGenericSpecSpacingAsNumber(_) }.orElse {
    RowColNumberCodec.decodeOpt(j) } 
  def encode(j: ConcatSpecGenericSpecSpacing): JsValue =
    j match {
      case ConcatSpecGenericSpecSpacingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:RowColNumber /* TypeRef */ => RowColNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleDatumDefBandPosition (ConstrainedType)
object ScaleDatumDefBandPositionCodec {
  def decode(j: JsValue): ScaleDatumDefBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ScaleDatumDefBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { ScaleDatumDefBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ScaleDatumDefBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkConfigX (UnionType)
object MarkConfigXCodec {
  def decode(j: JsValue): MarkConfigX =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigX] =
    j.asOpt[JsNumber].map { MarkConfigXAsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: MarkConfigX): JsValue =
    j match {
      case MarkConfigXAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigFillOpacity (UnionType)
object BarConfigFillOpacityCodec {
  def decode(j: JsValue): BarConfigFillOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigFillOpacity] =
    BarConfigFillOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigFillOpacity): JsValue =
    j match {
      case x:BarConfigFillOpacityAsNumber /* TypeRef */ => BarConfigFillOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewBackgroundStroke (UnionType)
object ViewBackgroundStrokeCodec {
  def decode(j: JsValue): ViewBackgroundStroke =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ViewBackgroundStroke] =
    ColorCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ViewBackgroundStrokeAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: ViewBackgroundStroke): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case ViewBackgroundStrokeAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefRadius2 (UnionType)
object OverlayMarkDefRadius2Codec {
  def decode(j: JsValue): OverlayMarkDefRadius2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefRadius2] =
    j.asOpt[JsNumber].map { OverlayMarkDefRadius2AsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefRadius2): JsValue =
    j match {
      case OverlayMarkDefRadius2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SortByChannel (EnumType)
object SortByChannelCodec {
  def decode(j: JsValue): SortByChannel =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SortByChannel] =
    j match {
      case JsString("x") => Some(SortByChannelX)
      case JsString("y") => Some(SortByChannelY)
      case JsString("color") => Some(SortByChannelColor)
      case JsString("fill") => Some(SortByChannelFill)
      case JsString("stroke") => Some(SortByChannelStroke)
      case JsString("strokeWidth") => Some(SortByChannelStrokeWidth)
      case JsString("size") => Some(SortByChannelSize)
      case JsString("shape") => Some(SortByChannelShape)
      case JsString("fillOpacity") => Some(SortByChannelFillOpacity)
      case JsString("strokeOpacity") => Some(SortByChannelStrokeOpacity)
      case JsString("opacity") => Some(SortByChannelOpacity)
      case JsString("text") => Some(SortByChannelText)
      case _ => None
    }
  def encode(j: SortByChannel): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// ProjectionLobes (UnionType)
object ProjectionLobesCodec {
  def decode(j: JsValue): ProjectionLobes =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionLobes] =
    j.asOpt[JsNumber].map { ProjectionLobesAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionLobes): JsValue =
    j match {
      case ProjectionLobesAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigInvalid (EnumType)
object AreaConfigInvalidCodec {
  def decode(j: JsValue): AreaConfigInvalid =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigInvalid] =
    j match {
      case JsString("filter") => Some(AreaConfigInvalidFilter)
      case JsNull => Some(AreaConfigInvalidUndefined)
      case _ => None
    }
  def encode(j: AreaConfigInvalid): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// ProjectionRadius (UnionType)
object ProjectionRadiusCodec {
  def decode(j: JsValue): ProjectionRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionRadius] =
    j.asOpt[JsNumber].map { ProjectionRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionRadius): JsValue =
    j match {
      case ProjectionRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionReflectY (UnionType)
object ProjectionReflectYCodec {
  def decode(j: JsValue): ProjectionReflectY =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionReflectY] =
    j.asOpt[Boolean].map { ProjectionReflectYAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionReflectY): JsValue =
    j match {
      case ProjectionReflectYAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefSize (ConstrainedType)
// see MarkDefSize (UnionType)

////////////////////////////////////////////////////////////////////////
// SharedEncodingRadiusDatum (UnionType)
object SharedEncodingRadiusDatumCodec {
  def decode(j: JsValue): SharedEncodingRadiusDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingRadiusDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingRadiusDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionType (EnumType)
object ProjectionTypeCodec {
  def decode(j: JsValue): ProjectionType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionType] =
    j match {
      case JsString("albers") => Some(ProjectionTypeAlbers)
      case JsString("albersUsa") => Some(ProjectionTypeAlbersUsa)
      case JsString("azimuthalEqualArea") => Some(ProjectionTypeAzimuthalEqualArea)
      case JsString("azimuthalEquidistant") => Some(ProjectionTypeAzimuthalEquidistant)
      case JsString("conicConformal") => Some(ProjectionTypeConicConformal)
      case JsString("conicEqualArea") => Some(ProjectionTypeConicEqualArea)
      case JsString("conicEquidistant") => Some(ProjectionTypeConicEquidistant)
      case JsString("equalEarth") => Some(ProjectionTypeEqualEarth)
      case JsString("equirectangular") => Some(ProjectionTypeEquirectangular)
      case JsString("gnomonic") => Some(ProjectionTypeGnomonic)
      case JsString("identity") => Some(ProjectionTypeIdentity)
      case JsString("mercator") => Some(ProjectionTypeMercator)
      case JsString("naturalEarth1") => Some(ProjectionTypeNaturalEarth1)
      case JsString("orthographic") => Some(ProjectionTypeOrthographic)
      case JsString("stereographic") => Some(ProjectionTypeStereographic)
      case JsString("transverseMercator") => Some(ProjectionTypeTransverseMercator)
      case _ => None
    }
  def encode(j: ProjectionType): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// RectConfigRadius2 (UnionType)
object RectConfigRadius2Codec {
  def decode(j: JsValue): RectConfigRadius2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigRadius2] =
    j.asOpt[JsNumber].map { RectConfigRadius2AsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigRadius2): JsValue =
    j match {
      case RectConfigRadius2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigRadius (UnionType)
object RectConfigRadiusCodec {
  def decode(j: JsValue): RectConfigRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigRadius] =
    j.asOpt[JsNumber].map { RectConfigRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigRadius): JsValue =
    j match {
      case RectConfigRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionParallels (UnionType)
object ProjectionParallelsCodec {
  def decode(j: JsValue): ProjectionParallels =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionParallels] =
    ArrayOfNumberCodec.decodeOpt(j).map { ProjectionParallelsAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionParallels): JsValue =
    j match {
      case ProjectionParallelsAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SequenceParams (StructType)
object SequenceParamsCodec {
  def decode(j: JsValue): SequenceParams =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SequenceParams] =
    {
      val `as` = (j \ "as").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `start` = (j \ "start").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      if(`start`.isEmpty) { return None }
      val `step` = (j \ "step").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `stop` = (j \ "stop").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      if(`stop`.isEmpty) { return None }
      return Some(SequenceParams(
        `as` = `as`,
        `start` = `start`.get,
        `step` = `step`,
        `stop` = `stop`.get,
      ))
    }

  def encode(j: SequenceParams): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`as`.map { x => "as" -> Json.toJson(x) },
        Some("start" -> Json.toJson(j.`start`)),
        j.`step`.map { x => "step" -> Json.toJson(x) },
        Some("stop" -> Json.toJson(j.`stop`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefFontWeightNullExprRefAsObject2 (StructType)
object ConditionalPredicateValueDefFontWeightNullExprRefAsObject2Codec {
  def decode(j: JsValue): ConditionalPredicateValueDefFontWeightNullExprRefAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefFontWeightNullExprRefAsObject2] =
    {
      val `expr` = (j \ "expr").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`expr`.isEmpty) { return None }
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      return Some(ConditionalPredicateValueDefFontWeightNullExprRefAsObject2(
        `expr` = `expr`.get,
        `test` = `test`.get,
      ))
    }

  def encode(j: ConditionalPredicateValueDefFontWeightNullExprRefAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("expr" -> Json.toJson(j.`expr`)),
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ScaleExponent (UnionType)
object ScaleExponentCodec {
  def decode(j: JsValue): ScaleExponent =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleExponent] =
    j.asOpt[JsNumber].map { ScaleExponentAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleExponent): JsValue =
    j match {
      case ScaleExponentAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// NonLayerRepeatSpec (StructType)
object NonLayerRepeatSpecCodec {
  def decode(j: JsValue): NonLayerRepeatSpec =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[NonLayerRepeatSpec] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `center` = (j \ "center").asOpt[JsValue].flatMap { x => NonLayerRepeatSpecCenterCodec.decodeOpt(x) }
      val `description` = (j \ "description").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `bounds` = (j \ "bounds").asOpt[JsValue].flatMap { x => NonLayerRepeatSpecBoundsCodec.decodeOpt(x) }
      val `columns` = (j \ "columns").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `resolve` = (j \ "resolve").asOpt[JsValue].flatMap { x => ResolveCodec.decodeOpt(x) }
      val `spec` = (j \ "spec").asOpt[JsValue].flatMap { x => NonNormalizedSpecCodec.decodeOpt(x) }
      if(`spec`.isEmpty) { return None }
      val `align` = (j \ "align").asOpt[JsValue].flatMap { x => NonLayerRepeatSpecAlignCodec.decodeOpt(x) }
      val `data` = (j \ "data").asOpt[JsValue].flatMap { x => DataCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `repeat` = (j \ "repeat").asOpt[JsValue].flatMap { x => NonLayerRepeatSpecRepeatCodec.decodeOpt(x) }
      if(`repeat`.isEmpty) { return None }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => NonLayerRepeatSpecTitleCodec.decodeOpt(x) }
      val `spacing` = (j \ "spacing").asOpt[JsValue].flatMap { x => NonLayerRepeatSpecSpacingCodec.decodeOpt(x) }
      val `transform` = (j \ "transform").asOpt[JsValue].flatMap { x => ArrayOfTransformCodec.decodeOpt(x) }
      return Some(NonLayerRepeatSpec(
        `name` = `name`,
        `center` = `center`,
        `description` = `description`,
        `bounds` = `bounds`,
        `columns` = `columns`,
        `resolve` = `resolve`,
        `spec` = `spec`.get,
        `align` = `align`,
        `data` = `data`,
        `repeat` = `repeat`.get,
        `title` = `title`,
        `spacing` = `spacing`,
        `transform` = `transform`,
      ))
    }

  def encode(j: NonLayerRepeatSpec): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`center`.map { x => "center" -> NonLayerRepeatSpecCenterCodec.encode(x) },
        j.`description`.map { x => "description" -> Json.toJson(x) },
        j.`bounds`.map { x => "bounds" -> NonLayerRepeatSpecBoundsCodec.encode(x) },
        j.`columns`.map { x => "columns" -> Json.toJson(x) },
        j.`resolve`.map { x => "resolve" -> ResolveCodec.encode(x) },
        Some("spec" -> NonNormalizedSpecCodec.encode(j.`spec`)),
        j.`align`.map { x => "align" -> NonLayerRepeatSpecAlignCodec.encode(x) },
        j.`data`.map { x => "data" -> DataCodec.encode(x) },
        Some("repeat" -> NonLayerRepeatSpecRepeatCodec.encode(j.`repeat`)),
        j.`title`.map { x => "title" -> NonLayerRepeatSpecTitleCodec.encode(x) },
        j.`spacing`.map { x => "spacing" -> NonLayerRepeatSpecSpacingCodec.encode(x) },
        j.`transform`.map { x => "transform" -> ArrayOfTransformCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LineConfigStrokeOpacity (UnionType)
object LineConfigStrokeOpacityCodec {
  def decode(j: JsValue): LineConfigStrokeOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigStrokeOpacity] =
    LineConfigStrokeOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigStrokeOpacity): JsValue =
    j match {
      case x:LineConfigStrokeOpacityAsNumber /* TypeRef */ => LineConfigStrokeOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionDatumDefNumberDatum (UnionType)
object FieldOrDatumDefWithConditionDatumDefNumberDatumCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionDatumDefNumberDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionDatumDefNumberDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: FieldOrDatumDefWithConditionDatumDefNumberDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefTheta (UnionType)
object OverlayMarkDefThetaCodec {
  def decode(j: JsValue): OverlayMarkDefTheta =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefTheta] =
    j.asOpt[JsNumber].map { OverlayMarkDefThetaAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefTheta): JsValue =
    j match {
      case OverlayMarkDefThetaAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingColorCondition (UnionType)
object SharedEncodingColorConditionCodec {
  def decode(j: JsValue): SharedEncodingColorCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingColorCondition] =
    ConditionalValueDefGradientStringNullExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefGradientStringNullExprRefCodec.decodeOpt(j).map { SharedEncodingColorConditionAsArrayOfConditionalValueDefGradientStringNullExprRef(_) }.orElse {
    ConditionalMarkPropFieldOrDatumDefCodec.decodeOpt(j) } } 
  def encode(j: SharedEncodingColorCondition): JsValue =
    j match {
      case x:ConditionalValueDefGradientStringNullExprRef /* TypeRef */ => ConditionalValueDefGradientStringNullExprRefCodec.encode(x)
      case SharedEncodingColorConditionAsArrayOfConditionalValueDefGradientStringNullExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefGradientStringNullExprRefCodec.encode(x)
      case x:ConditionalMarkPropFieldOrDatumDef /* TypeRef */ => ConditionalMarkPropFieldOrDatumDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelSelectionParameterSelect (UnionType)
object TopLevelSelectionParameterSelectCodec {
  def decode(j: JsValue): TopLevelSelectionParameterSelect =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelSelectionParameterSelect] =
    SelectionTypeCodec.decodeOpt(j).orElse {
    PointSelectionConfigCodec.decodeOpt(j).orElse {
    IntervalSelectionConfigCodec.decodeOpt(j) } } 
  def encode(j: TopLevelSelectionParameterSelect): JsValue =
    j match {
      case x:SelectionType /* TypeRef */ => SelectionTypeCodec.encode(x)
      case x:PointSelectionConfig /* TypeRef */ => PointSelectionConfigCodec.encode(x)
      case x:IntervalSelectionConfig /* TypeRef */ => IntervalSelectionConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FoldTransformAs (ConstrainedType)
object FoldTransformAsCodec {
  def decode(j: JsValue): FoldTransformAs =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FoldTransformAs] =
    try {
      ArrayOfStringCodec.decodeOpt(j)
        .map { FoldTransformAs(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: FoldTransformAs): JsValue =
    ArrayOfStringCodec.encode(j.value)
}

////////////////////////////////////////////////////////////////////////
// LineConfigDx (UnionType)
object LineConfigDxCodec {
  def decode(j: JsValue): LineConfigDx =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigDx] =
    j.asOpt[JsNumber].map { LineConfigDxAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigDx): JsValue =
    j match {
      case LineConfigDxAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingYOffset (StructType)
object SharedEncodingYOffsetCodec {
  def decode(j: JsValue): SharedEncodingYOffset =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingYOffset] =
    Some(SharedEncodingYOffset(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingYOffsetDatumCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingYOffsetBandPositionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingYOffsetBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingYOffsetTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => SharedEncodingYOffsetTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingYOffset): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingYOffsetDatumCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingYOffsetBandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingYOffsetBinCodec.encode(x) },
        j.`value`.map { x => "value" -> Json.toJson(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingYOffsetTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> SharedEncodingYOffsetTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TopLevelUnitSpecAlign (UnionType)
object TopLevelUnitSpecAlignCodec {
  def decode(j: JsValue): TopLevelUnitSpecAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelUnitSpecAlign] =
    LayoutAlignCodec.decodeOpt(j).orElse {
    RowColLayoutAlignCodec.decodeOpt(j) } 
  def encode(j: TopLevelUnitSpecAlign): JsValue =
    j match {
      case x:LayoutAlign /* TypeRef */ => LayoutAlignCodec.encode(x)
      case x:RowColLayoutAlign /* TypeRef */ => RowColLayoutAlignCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// DateTimeDay (UnionType)
object DateTimeDayCodec {
  def decode(j: JsValue): DateTimeDay =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[DateTimeDay] =
    DayCodec.decodeOpt(j).orElse {
    j.asOpt[String].map { DateTimeDayAsString(_) } } 
  def encode(j: DateTimeDay): JsValue =
    j match {
      case x:Day /* TypeRef */ => DayCodec.encode(x)
      case DateTimeDayAsString(x) /* Base, StringType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// StyleConfigIndex (StructType)
object StyleConfigIndexCodec {
  def decode(j: JsValue): StyleConfigIndex =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[StyleConfigIndex] =
    Some(StyleConfigIndex(
      `rect` = (j \ "rect").asOpt[JsValue].flatMap { x => RectConfigCodec.decodeOpt(x) },
      `circle` = (j \ "circle").asOpt[JsValue].flatMap { x => MarkConfigCodec.decodeOpt(x) },
      `trail` = (j \ "trail").asOpt[JsValue].flatMap { x => LineConfigCodec.decodeOpt(x) },
      `guide-title` = (j \ "guide-title").asOpt[JsValue].flatMap { x => MarkConfigCodec.decodeOpt(x) },
      `rule` = (j \ "rule").asOpt[JsValue].flatMap { x => MarkConfigCodec.decodeOpt(x) },
      `square` = (j \ "square").asOpt[JsValue].flatMap { x => MarkConfigCodec.decodeOpt(x) },
      `arc` = (j \ "arc").asOpt[JsValue].flatMap { x => RectConfigCodec.decodeOpt(x) },
      `bar` = (j \ "bar").asOpt[JsValue].flatMap { x => BarConfigCodec.decodeOpt(x) },
      `mark` = (j \ "mark").asOpt[JsValue].flatMap { x => MarkConfigCodec.decodeOpt(x) },
      `area` = (j \ "area").asOpt[JsValue].flatMap { x => AreaConfigCodec.decodeOpt(x) },
      `point` = (j \ "point").asOpt[JsValue].flatMap { x => MarkConfigCodec.decodeOpt(x) },
      `image` = (j \ "image").asOpt[JsValue].flatMap { x => RectConfigCodec.decodeOpt(x) },
      `line` = (j \ "line").asOpt[JsValue].flatMap { x => LineConfigCodec.decodeOpt(x) },
      `group-subtitle` = (j \ "group-subtitle").asOpt[JsValue].flatMap { x => MarkConfigCodec.decodeOpt(x) },
      `text` = (j \ "text").asOpt[JsValue].flatMap { x => MarkConfigCodec.decodeOpt(x) },
      `geoshape` = (j \ "geoshape").asOpt[JsValue].flatMap { x => MarkConfigCodec.decodeOpt(x) },
      `tick` = (j \ "tick").asOpt[JsValue].flatMap { x => TickConfigCodec.decodeOpt(x) },
      `guide-label` = (j \ "guide-label").asOpt[JsValue].flatMap { x => MarkConfigCodec.decodeOpt(x) },
      `group-title` = (j \ "group-title").asOpt[JsValue].flatMap { x => MarkConfigCodec.decodeOpt(x) },
    optionalFields = j.as[Map[String, JsValue]].toSeq.filterNot {
        x => StyleConfigIndex.definedFields(x._1)
      }.flatMap { case (name, value) =>
        StyleConfigIndexOptionalCodec.decodeOpt(value).map { name -> _ }
      }.toMap
    ))

  def encode(j: StyleConfigIndex): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`rect`.map { x => "rect" -> RectConfigCodec.encode(x) },
        j.`circle`.map { x => "circle" -> MarkConfigCodec.encode(x) },
        j.`trail`.map { x => "trail" -> LineConfigCodec.encode(x) },
        j.`guide-title`.map { x => "guide-title" -> MarkConfigCodec.encode(x) },
        j.`rule`.map { x => "rule" -> MarkConfigCodec.encode(x) },
        j.`square`.map { x => "square" -> MarkConfigCodec.encode(x) },
        j.`arc`.map { x => "arc" -> RectConfigCodec.encode(x) },
        j.`bar`.map { x => "bar" -> BarConfigCodec.encode(x) },
        j.`mark`.map { x => "mark" -> MarkConfigCodec.encode(x) },
        j.`area`.map { x => "area" -> AreaConfigCodec.encode(x) },
        j.`point`.map { x => "point" -> MarkConfigCodec.encode(x) },
        j.`image`.map { x => "image" -> RectConfigCodec.encode(x) },
        j.`line`.map { x => "line" -> LineConfigCodec.encode(x) },
        j.`group-subtitle`.map { x => "group-subtitle" -> MarkConfigCodec.encode(x) },
        j.`text`.map { x => "text" -> MarkConfigCodec.encode(x) },
        j.`geoshape`.map { x => "geoshape" -> MarkConfigCodec.encode(x) },
        j.`tick`.map { x => "tick" -> TickConfigCodec.encode(x) },
        j.`guide-label`.map { x => "guide-label" -> MarkConfigCodec.encode(x) },
        j.`group-title`.map { x => "group-title" -> MarkConfigCodec.encode(x) },
      ).flatten.toMap
      ++j.optionalFields.mapValues { x => StyleConfigIndexOptionalCodec.encode(x) }
    )
}


////////////////////////////////////////////////////////////////////////
// FacetFieldDefTimeUnit (UnionType)
object FacetFieldDefTimeUnitCodec {
  def decode(j: JsValue): FacetFieldDefTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetFieldDefTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: FacetFieldDefTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigCornerRadiusTopRight (UnionType)
object BarConfigCornerRadiusTopRightCodec {
  def decode(j: JsValue): BarConfigCornerRadiusTopRight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigCornerRadiusTopRight] =
    j.asOpt[JsNumber].map { BarConfigCornerRadiusTopRightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigCornerRadiusTopRight): JsValue =
    j match {
      case BarConfigCornerRadiusTopRightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleConfigSubtitleLineHeight (UnionType)
object TitleConfigSubtitleLineHeightCodec {
  def decode(j: JsValue): TitleConfigSubtitleLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigSubtitleLineHeight] =
    j.asOpt[JsNumber].map { TitleConfigSubtitleLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleConfigSubtitleLineHeight): JsValue =
    j match {
      case TitleConfigSubtitleLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleConfigClamp (UnionType)
object ScaleConfigClampCodec {
  def decode(j: JsValue): ScaleConfigClamp =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleConfigClamp] =
    j.asOpt[Boolean].map { ScaleConfigClampAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ScaleConfigClamp): JsValue =
    j match {
      case ScaleConfigClampAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefNumberNullExprRefAsObject2 (StructType)
object ConditionalPredicateValueDefNumberNullExprRefAsObject2Codec {
  def decode(j: JsValue): ConditionalPredicateValueDefNumberNullExprRefAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefNumberNullExprRefAsObject2] =
    {
      val `expr` = (j \ "expr").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`expr`.isEmpty) { return None }
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      return Some(ConditionalPredicateValueDefNumberNullExprRefAsObject2(
        `expr` = `expr`.get,
        `test` = `test`.get,
      ))
    }

  def encode(j: ConditionalPredicateValueDefNumberNullExprRefAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("expr" -> Json.toJson(j.`expr`)),
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TitleConfigDy (UnionType)
object TitleConfigDyCodec {
  def decode(j: JsValue): TitleConfigDy =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigDy] =
    j.asOpt[JsNumber].map { TitleConfigDyAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleConfigDy): JsValue =
    j match {
      case TitleConfigDyAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PointSelectionConfigWithoutTypeToggle (UnionType)
object PointSelectionConfigWithoutTypeToggleCodec {
  def decode(j: JsValue): PointSelectionConfigWithoutTypeToggle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PointSelectionConfigWithoutTypeToggle] =
    j.asOpt[String].map { PointSelectionConfigWithoutTypeToggleAsString(_) }.orElse {
    j.asOpt[Boolean].map { PointSelectionConfigWithoutTypeToggleAsBool(_) } } 
  def encode(j: PointSelectionConfigWithoutTypeToggle): JsValue =
    j match {
      case PointSelectionConfigWithoutTypeToggleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case PointSelectionConfigWithoutTypeToggleAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ViewConfigFillOpacityAsNumber (ConstrainedType)
object ViewConfigFillOpacityAsNumberCodec {
  def decode(j: JsValue): ViewConfigFillOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ViewConfigFillOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { ViewConfigFillOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ViewConfigFillOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// LegendConfigGradientStrokeWidthAsNumber (ConstrainedType)
object LegendConfigGradientStrokeWidthAsNumberCodec {
  def decode(j: JsValue): LegendConfigGradientStrokeWidthAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LegendConfigGradientStrokeWidthAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { LegendConfigGradientStrokeWidthAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: LegendConfigGradientStrokeWidthAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// FacetedEncodingOrder (UnionType)
object FacetedEncodingOrderCodec {
  def decode(j: JsValue): FacetedEncodingOrder =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetedEncodingOrder] =
    OrderFieldDefCodec.decodeOpt(j).orElse {
    ArrayOfOrderFieldDefCodec.decodeOpt(j).map { FacetedEncodingOrderAsArrayOfOrderFieldDef(_) }.orElse {
    OrderValueDefCodec.decodeOpt(j) } } 
  def encode(j: FacetedEncodingOrder): JsValue =
    j match {
      case x:OrderFieldDef /* TypeRef */ => OrderFieldDefCodec.encode(x)
      case FacetedEncodingOrderAsArrayOfOrderFieldDef(x) /* Base, ArrayType */ => ArrayOfOrderFieldDefCodec.encode(x)
      case x:OrderValueDef /* TypeRef */ => OrderValueDefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfTopLevelConcatSpecParamsElement (ArrayType)
object ArrayOfTopLevelConcatSpecParamsElementCodec {
  def decode(j: JsValue): Seq[TopLevelConcatSpecParamsElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[TopLevelConcatSpecParamsElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      TopLevelConcatSpecParamsElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[TopLevelConcatSpecParamsElement]): JsArray =
      JsArray(j.map { x => TopLevelConcatSpecParamsElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingThetaTimeUnit (UnionType)
object SharedEncodingThetaTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingThetaTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingThetaTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingThetaTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefBandSize (ConstrainedType)
object MarkDefBandSizeCodec {
  def decode(j: JsValue): MarkDefBandSize =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[MarkDefBandSize] =
    try {
      j.asOpt[JsNumber]
        .map { MarkDefBandSize(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: MarkDefBandSize): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// FacetedUnitSpecParamsElement (UnionType)
object FacetedUnitSpecParamsElementCodec {
  def decode(j: JsValue): FacetedUnitSpecParamsElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetedUnitSpecParamsElement] =
    VariableParameterCodec.decodeOpt(j).orElse {
    SelectionParameterCodec.decodeOpt(j) } 
  def encode(j: FacetedUnitSpecParamsElement): JsValue =
    j match {
      case x:VariableParameter /* TypeRef */ => VariableParameterCodec.encode(x)
      case x:SelectionParameter /* TypeRef */ => SelectionParameterCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// DataSource (UnionType)
object DataSourceCodec {
  def decode(j: JsValue): DataSource =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[DataSource] =
    UrlDataCodec.decodeOpt(j).orElse {
    InlineDataCodec.decodeOpt(j).orElse {
    NamedDataCodec.decodeOpt(j) } } 
  def encode(j: DataSource): JsValue =
    j match {
      case x:UrlData /* TypeRef */ => UrlDataCodec.encode(x)
      case x:InlineData /* TypeRef */ => InlineDataCodec.encode(x)
      case x:NamedData /* TypeRef */ => NamedDataCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigTitleFontWeight (UnionType)
object LegendConfigTitleFontWeightCodec {
  def decode(j: JsValue): LegendConfigTitleFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigTitleFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigTitleFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// EventStreamAsObject1 (StructType)
object EventStreamAsObject1Codec {
  def decode(j: JsValue): EventStreamAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[EventStreamAsObject1] =
    {
      val `source` = (j \ "source").asOpt[JsValue].flatMap { x => EventStreamAsObject1SourceCodec.decodeOpt(x) }
      val `marktype` = (j \ "marktype").asOpt[JsValue].flatMap { x => MarkTypeCodec.decodeOpt(x) }
      val `filter` = (j \ "filter").asOpt[JsValue].flatMap { x => EventStreamAsObject1FilterCodec.decodeOpt(x) }
      val `markname` = (j \ "markname").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `consume` = (j \ "consume").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `type` = (j \ "type").asOpt[JsValue].flatMap { x => EventTypeCodec.decodeOpt(x) }
      if(`type`.isEmpty) { return None }
      val `debounce` = (j \ "debounce").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `between` = (j \ "between").asOpt[JsValue].flatMap { x => ArrayOfStreamCodec.decodeOpt(x) }
      val `throttle` = (j \ "throttle").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      return Some(EventStreamAsObject1(
        `source` = `source`,
        `marktype` = `marktype`,
        `filter` = `filter`,
        `markname` = `markname`,
        `consume` = `consume`,
        `type` = `type`.get,
        `debounce` = `debounce`,
        `between` = `between`,
        `throttle` = `throttle`,
      ))
    }

  def encode(j: EventStreamAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`source`.map { x => "source" -> EventStreamAsObject1SourceCodec.encode(x) },
        j.`marktype`.map { x => "marktype" -> MarkTypeCodec.encode(x) },
        j.`filter`.map { x => "filter" -> EventStreamAsObject1FilterCodec.encode(x) },
        j.`markname`.map { x => "markname" -> Json.toJson(x) },
        j.`consume`.map { x => "consume" -> Json.toJson(x) },
        Some("type" -> EventTypeCodec.encode(j.`type`)),
        j.`debounce`.map { x => "debounce" -> Json.toJson(x) },
        j.`between`.map { x => "between" -> ArrayOfStreamCodec.encode(x) },
        j.`throttle`.map { x => "throttle" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AreaConfigStrokeWidthAsNumber (ConstrainedType)
object AreaConfigStrokeWidthAsNumberCodec {
  def decode(j: JsValue): AreaConfigStrokeWidthAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AreaConfigStrokeWidthAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AreaConfigStrokeWidthAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AreaConfigStrokeWidthAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkDefDescription (UnionType)
object MarkDefDescriptionCodec {
  def decode(j: JsValue): MarkDefDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefDescription] =
    j.asOpt[String].map { MarkDefDescriptionAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefDescription): JsValue =
    j match {
      case MarkDefDescriptionAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetedEncodingXError (UnionType)
object FacetedEncodingXErrorCodec {
  def decode(j: JsValue): FacetedEncodingXError =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetedEncodingXError] =
    SecondaryFieldDefCodec.decodeOpt(j).orElse {
    ValueDefNumberCodec.decodeOpt(j) } 
  def encode(j: FacetedEncodingXError): JsValue =
    j match {
      case x:SecondaryFieldDef /* TypeRef */ => SecondaryFieldDefCodec.encode(x)
      case x:ValueDefNumber /* TypeRef */ => ValueDefNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingColorBandPosition (ConstrainedType)
object SharedEncodingColorBandPositionCodec {
  def decode(j: JsValue): SharedEncodingColorBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingColorBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingColorBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingColorBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// BarConfigAspect (UnionType)
object BarConfigAspectCodec {
  def decode(j: JsValue): BarConfigAspect =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigAspect] =
    j.asOpt[Boolean].map { BarConfigAspectAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigAspect): JsValue =
    j match {
      case BarConfigAspectAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigSymbolDash (UnionType)
object LegendConfigSymbolDashCodec {
  def decode(j: JsValue): LegendConfigSymbolDash =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigSymbolDash] =
    ArrayOfNumberCodec.decodeOpt(j).map { LegendConfigSymbolDashAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigSymbolDash): JsValue =
    j match {
      case LegendConfigSymbolDashAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingLongitudeType (UnionType)
object SharedEncodingLongitudeTypeCodec {
  def decode(j: JsValue): SharedEncodingLongitudeType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingLongitudeType] =
    QuantitativeCodec.decodeOpt(j).orElse {
    TypeCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingLongitudeType): JsValue =
    j match {
      case x:Quantitative /* TypeRef */ => QuantitativeCodec.encode(x)
      case x:Type /* TypeRef */ => TypeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingYOffsetDatum (UnionType)
object SharedEncodingYOffsetDatumCodec {
  def decode(j: JsValue): SharedEncodingYOffsetDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingYOffsetDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: SharedEncodingYOffsetDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelFacetSpecAlign (UnionType)
object TopLevelFacetSpecAlignCodec {
  def decode(j: JsValue): TopLevelFacetSpecAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelFacetSpecAlign] =
    LayoutAlignCodec.decodeOpt(j).orElse {
    RowColLayoutAlignCodec.decodeOpt(j) } 
  def encode(j: TopLevelFacetSpecAlign): JsValue =
    j match {
      case x:LayoutAlign /* TypeRef */ => LayoutAlignCodec.encode(x)
      case x:RowColLayoutAlign /* TypeRef */ => RowColLayoutAlignCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigFontWeight (UnionType)
object MarkConfigFontWeightCodec {
  def decode(j: JsValue): MarkConfigFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelFacetSpecSpec (UnionType)
object TopLevelFacetSpecSpecCodec {
  def decode(j: JsValue): TopLevelFacetSpecSpec =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelFacetSpecSpec] =
    LayerSpecCodec.decodeOpt(j).orElse {
    UnitSpecWithFrameCodec.decodeOpt(j) } 
  def encode(j: TopLevelFacetSpecSpec): JsValue =
    j match {
      case x:LayerSpec /* TypeRef */ => LayerSpecCodec.encode(x)
      case x:UnitSpecWithFrame /* TypeRef */ => UnitSpecWithFrameCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionPrecision (UnionType)
object ProjectionPrecisionCodec {
  def decode(j: JsValue): ProjectionPrecision =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionPrecision] =
    j.asOpt[JsNumber].map { ProjectionPrecisionAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionPrecision): JsValue =
    j match {
      case ProjectionPrecisionAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefThetaOffset (UnionType)
object MarkDefThetaOffsetCodec {
  def decode(j: JsValue): MarkDefThetaOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefThetaOffset] =
    j.asOpt[JsNumber].map { MarkDefThetaOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefThetaOffset): JsValue =
    j match {
      case MarkDefThetaOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefTooltip (UnionType)
object OverlayMarkDefTooltipCodec {
  def decode(j: JsValue): OverlayMarkDefTooltip =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefTooltip] =
    j.asOpt[String].map { OverlayMarkDefTooltipAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => OverlayMarkDefTooltipAsNull }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    TooltipContentCodec.decodeOpt(j).orElse {
    j.asOpt[Boolean].map { OverlayMarkDefTooltipAsBool(_) }.orElse {
    j.asOpt[JsNumber].map { OverlayMarkDefTooltipAsNumber(_) } } } } } } 
  def encode(j: OverlayMarkDefTooltip): JsValue =
    j match {
      case OverlayMarkDefTooltipAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case OverlayMarkDefTooltipAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:TooltipContent /* TypeRef */ => TooltipContentCodec.encode(x)
      case OverlayMarkDefTooltipAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case OverlayMarkDefTooltipAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfConditionalValueDefStringExprRef (ArrayType)
object ArrayOfConditionalValueDefStringExprRefCodec {
  def decode(j: JsValue): Seq[ConditionalValueDefStringExprRef] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[ConditionalValueDefStringExprRef]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      ConditionalValueDefStringExprRefCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[ConditionalValueDefStringExprRef]): JsArray =
      JsArray(j.map { x => ConditionalValueDefStringExprRefCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefCursor (UnionType)
object OverlayMarkDefCursorCodec {
  def decode(j: JsValue): OverlayMarkDefCursor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefCursor] =
    CursorCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefCursor): JsValue =
    j match {
      case x:Cursor /* TypeRef */ => CursorCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigInterpolate (UnionType)
object RectConfigInterpolateCodec {
  def decode(j: JsValue): RectConfigInterpolate =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigInterpolate] =
    InterpolateCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigInterpolate): JsValue =
    j match {
      case x:Interpolate /* TypeRef */ => InterpolateCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Stream (UnionType)
object StreamCodec {
  def decode(j: JsValue): Stream =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Stream] =
    EventStreamCodec.decodeOpt(j).orElse {
    DerivedStreamCodec.decodeOpt(j).orElse {
    MergedStreamCodec.decodeOpt(j) } } 
  def encode(j: Stream): JsValue =
    j match {
      case x:EventStream /* TypeRef */ => EventStreamCodec.encode(x)
      case x:DerivedStream /* TypeRef */ => DerivedStreamCodec.encode(x)
      case x:MergedStream /* TypeRef */ => MergedStreamCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigLineHeight (UnionType)
object AreaConfigLineHeightCodec {
  def decode(j: JsValue): AreaConfigLineHeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigLineHeight] =
    j.asOpt[JsNumber].map { AreaConfigLineHeightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigLineHeight): JsValue =
    j match {
      case AreaConfigLineHeightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigColor (UnionType)
object TickConfigColorCodec {
  def decode(j: JsValue): TickConfigColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigColor] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: TickConfigColor): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelFacetSpecCenter (UnionType)
object TopLevelFacetSpecCenterCodec {
  def decode(j: JsValue): TopLevelFacetSpecCenter =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelFacetSpecCenter] =
    j.asOpt[Boolean].map { TopLevelFacetSpecCenterAsBool(_) }.orElse {
    RowColBooleanCodec.decodeOpt(j) } 
  def encode(j: TopLevelFacetSpecCenter): JsValue =
    j match {
      case TopLevelFacetSpecCenterAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:RowColBoolean /* TypeRef */ => RowColBooleanCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigAriaRole (UnionType)
object LineConfigAriaRoleCodec {
  def decode(j: JsValue): LineConfigAriaRole =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigAriaRole] =
    j.asOpt[String].map { LineConfigAriaRoleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigAriaRole): JsValue =
    j match {
      case LineConfigAriaRoleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigStrokeJoin (UnionType)
object LineConfigStrokeJoinCodec {
  def decode(j: JsValue): LineConfigStrokeJoin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigStrokeJoin] =
    StrokeJoinCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigStrokeJoin): JsValue =
    j match {
      case x:StrokeJoin /* TypeRef */ => StrokeJoinCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigRadius (ConstrainedType)
// see MarkConfigRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// RectConfigEndAngle (UnionType)
object RectConfigEndAngleCodec {
  def decode(j: JsValue): RectConfigEndAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigEndAngle] =
    j.asOpt[JsNumber].map { RectConfigEndAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigEndAngle): JsValue =
    j match {
      case RectConfigEndAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ArrayOfFacetedUnitSpecParamsElement (ArrayType)
object ArrayOfFacetedUnitSpecParamsElementCodec {
  def decode(j: JsValue): Seq[FacetedUnitSpecParamsElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[FacetedUnitSpecParamsElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      FacetedUnitSpecParamsElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[FacetedUnitSpecParamsElement]): JsArray =
      JsArray(j.map { x => FacetedUnitSpecParamsElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// BarConfigCornerRadiusTopLeft (UnionType)
object BarConfigCornerRadiusTopLeftCodec {
  def decode(j: JsValue): BarConfigCornerRadiusTopLeft =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigCornerRadiusTopLeft] =
    j.asOpt[JsNumber].map { BarConfigCornerRadiusTopLeftAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigCornerRadiusTopLeft): JsValue =
    j match {
      case BarConfigCornerRadiusTopLeftAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PositionValueDef (StructType)
object PositionValueDefCodec {
  def decode(j: JsValue): PositionValueDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[PositionValueDef] =
    {
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => PositionValueDefValueCodec.decodeOpt(x) }
      if(`value`.isEmpty) { return None }
      return Some(PositionValueDef(
        `value` = `value`.get,
      ))
    }

  def encode(j: PositionValueDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("value" -> PositionValueDefValueCodec.encode(j.`value`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ViewConfigDiscreteHeightAsObject2 (StructType)
object ViewConfigDiscreteHeightAsObject2Codec {
  def decode(j: JsValue): ViewConfigDiscreteHeightAsObject2 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ViewConfigDiscreteHeightAsObject2] =
    {
      val `step` = (j \ "step").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      if(`step`.isEmpty) { return None }
      return Some(ViewConfigDiscreteHeightAsObject2(
        `step` = `step`.get,
      ))
    }

  def encode(j: ViewConfigDiscreteHeightAsObject2): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("step" -> Json.toJson(j.`step`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AxisConfigTitleAlign (UnionType)
object AxisConfigTitleAlignCodec {
  def decode(j: JsValue): AxisConfigTitleAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTitleAlign] =
    AlignCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigTitleAlign): JsValue =
    j match {
      case x:Align /* TypeRef */ => AlignCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// PivotTransform (StructType)
object PivotTransformCodec {
  def decode(j: JsValue): PivotTransform =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[PivotTransform] =
    {
      val `pivot` = (j \ "pivot").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`pivot`.isEmpty) { return None }
      val `groupby` = (j \ "groupby").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) }
      val `limit` = (j \ "limit").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`value`.isEmpty) { return None }
      val `op` = (j \ "op").asOpt[JsValue].flatMap { x => AggregateOpCodec.decodeOpt(x) }
      return Some(PivotTransform(
        `pivot` = `pivot`.get,
        `groupby` = `groupby`,
        `limit` = `limit`,
        `value` = `value`.get,
        `op` = `op`,
      ))
    }

  def encode(j: PivotTransform): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("pivot" -> Json.toJson(j.`pivot`)),
        j.`groupby`.map { x => "groupby" -> ArrayOfStringCodec.encode(x) },
        j.`limit`.map { x => "limit" -> Json.toJson(x) },
        Some("value" -> Json.toJson(j.`value`)),
        j.`op`.map { x => "op" -> AggregateOpCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// MarkDefSize (UnionType)
object MarkDefSizeCodec {
  def decode(j: JsValue): MarkDefSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefSize] =
    j.asOpt[JsNumber].map { MarkDefSizeAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefSize): JsValue =
    j match {
      case MarkDefSizeAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TitleAnchor (EnumType)
object TitleAnchorCodec {
  def decode(j: JsValue): TitleAnchor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleAnchor] =
    j match {
      case JsNull => Some(TitleAnchorUndefined)
      case JsString("start") => Some(TitleAnchorStart)
      case JsString("middle") => Some(TitleAnchorMiddle)
      case JsString("end") => Some(TitleAnchorEnd)
      case _ => None
    }
  def encode(j: TitleAnchor): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// AxisTickSizeAsNumber (ConstrainedType)
object AxisTickSizeAsNumberCodec {
  def decode(j: JsValue): AxisTickSizeAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AxisTickSizeAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AxisTickSizeAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AxisTickSizeAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// LineConfigLineBreak (UnionType)
object LineConfigLineBreakCodec {
  def decode(j: JsValue): LineConfigLineBreak =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigLineBreak] =
    j.asOpt[String].map { LineConfigLineBreakAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigLineBreak): JsValue =
    j match {
      case LineConfigLineBreakAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigOpacity (ConstrainedType)
// see RectConfigOpacity (UnionType)

////////////////////////////////////////////////////////////////////////
// TopLevelFacetSpecAutosize (UnionType)
object TopLevelFacetSpecAutosizeCodec {
  def decode(j: JsValue): TopLevelFacetSpecAutosize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelFacetSpecAutosize] =
    AutosizeTypeCodec.decodeOpt(j).orElse {
    AutoSizeParamsCodec.decodeOpt(j) } 
  def encode(j: TopLevelFacetSpecAutosize): JsValue =
    j match {
      case x:AutosizeType /* TypeRef */ => AutosizeTypeCodec.encode(x)
      case x:AutoSizeParams /* TypeRef */ => AutoSizeParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingTextTimeUnit (UnionType)
object SharedEncodingTextTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingTextTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingTextTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingTextTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleBinParams (StructType)
object ScaleBinParamsCodec {
  def decode(j: JsValue): ScaleBinParams =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ScaleBinParams] =
    {
      val `start` = (j \ "start").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `step` = (j \ "step").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      if(`step`.isEmpty) { return None }
      val `stop` = (j \ "stop").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      return Some(ScaleBinParams(
        `start` = `start`,
        `step` = `step`.get,
        `stop` = `stop`,
      ))
    }

  def encode(j: ScaleBinParams): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`start`.map { x => "start" -> Json.toJson(x) },
        Some("step" -> Json.toJson(j.`step`)),
        j.`stop`.map { x => "stop" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// StringValueDefWithCondition (StructType)
object StringValueDefWithConditionCodec {
  def decode(j: JsValue): StringValueDefWithCondition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[StringValueDefWithCondition] =
    Some(StringValueDefWithCondition(
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => StringValueDefWithConditionConditionCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => StringValueDefWithConditionValueCodec.decodeOpt(x) },
    ))

  def encode(j: StringValueDefWithCondition): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`condition`.map { x => "condition" -> StringValueDefWithConditionConditionCodec.encode(x) },
        j.`value`.map { x => "value" -> StringValueDefWithConditionValueCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// BarConfigDx (UnionType)
object BarConfigDxCodec {
  def decode(j: JsValue): BarConfigDx =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigDx] =
    j.asOpt[JsNumber].map { BarConfigDxAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigDx): JsValue =
    j match {
      case BarConfigDxAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefThickness (ConstrainedType)
object MarkDefThicknessCodec {
  def decode(j: JsValue): MarkDefThickness =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[MarkDefThickness] =
    try {
      j.asOpt[JsNumber]
        .map { MarkDefThickness(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: MarkDefThickness): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AreaConfigDx (UnionType)
object AreaConfigDxCodec {
  def decode(j: JsValue): AreaConfigDx =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigDx] =
    j.asOpt[JsNumber].map { AreaConfigDxAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigDx): JsValue =
    j match {
      case AreaConfigDxAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// EncodingTooltip (UnionType)
object EncodingTooltipCodec {
  def decode(j: JsValue): EncodingTooltip =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[EncodingTooltip] =
    StringFieldDefWithConditionCodec.decodeOpt(j).orElse {
    StringValueDefWithConditionCodec.decodeOpt(j).orElse {
    ArrayOfStringFieldDefCodec.decodeOpt(j).map { EncodingTooltipAsArrayOfStringFieldDef(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => EncodingTooltipAsNull } } } } 
  def encode(j: EncodingTooltip): JsValue =
    j match {
      case x:StringFieldDefWithCondition /* TypeRef */ => StringFieldDefWithConditionCodec.encode(x)
      case x:StringValueDefWithCondition /* TypeRef */ => StringValueDefWithConditionCodec.encode(x)
      case EncodingTooltipAsArrayOfStringFieldDef(x) /* Base, ArrayType */ => ArrayOfStringFieldDefCodec.encode(x)
      case EncodingTooltipAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// WindowFieldDef (StructType)
object WindowFieldDefCodec {
  def decode(j: JsValue): WindowFieldDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[WindowFieldDef] =
    {
      val `as` = (j \ "as").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`as`.isEmpty) { return None }
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `op` = (j \ "op").asOpt[JsValue].flatMap { x => WindowFieldDefOpCodec.decodeOpt(x) }
      if(`op`.isEmpty) { return None }
      val `param` = (j \ "param").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      return Some(WindowFieldDef(
        `as` = `as`.get,
        `field` = `field`,
        `op` = `op`.get,
        `param` = `param`,
      ))
    }

  def encode(j: WindowFieldDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("as" -> Json.toJson(j.`as`)),
        j.`field`.map { x => "field" -> Json.toJson(x) },
        Some("op" -> WindowFieldDefOpCodec.encode(j.`op`)),
        j.`param`.map { x => "param" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TitleConfigSubtitlePadding (UnionType)
object TitleConfigSubtitlePaddingCodec {
  def decode(j: JsValue): TitleConfigSubtitlePadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TitleConfigSubtitlePadding] =
    j.asOpt[JsNumber].map { TitleConfigSubtitlePaddingAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TitleConfigSubtitlePadding): JsValue =
    j match {
      case TitleConfigSubtitlePaddingAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BoxPlotDefColor (UnionType)
object BoxPlotDefColorCodec {
  def decode(j: JsValue): BoxPlotDefColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BoxPlotDefColor] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: BoxPlotDefColor): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelLayerSpecLayerElement (UnionType)
object TopLevelLayerSpecLayerElementCodec {
  def decode(j: JsValue): TopLevelLayerSpecLayerElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelLayerSpecLayerElement] =
    LayerSpecCodec.decodeOpt(j).orElse {
    UnitSpecCodec.decodeOpt(j) } 
  def encode(j: TopLevelLayerSpecLayerElement): JsValue =
    j match {
      case x:LayerSpec /* TypeRef */ => LayerSpecCodec.encode(x)
      case x:UnitSpec /* TypeRef */ => UnitSpecCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelConcatSpecAlign (UnionType)
object TopLevelConcatSpecAlignCodec {
  def decode(j: JsValue): TopLevelConcatSpecAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelConcatSpecAlign] =
    LayoutAlignCodec.decodeOpt(j).orElse {
    RowColLayoutAlignCodec.decodeOpt(j) } 
  def encode(j: TopLevelConcatSpecAlign): JsValue =
    j match {
      case x:LayoutAlign /* TypeRef */ => LayoutAlignCodec.encode(x)
      case x:RowColLayoutAlign /* TypeRef */ => RowColLayoutAlignCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleFieldDef (StructType)
object ScaleFieldDefCodec {
  def decode(j: JsValue): ScaleFieldDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ScaleFieldDef] =
    Some(ScaleFieldDef(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => ScaleFieldDefBandPositionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => ScaleFieldDefBinCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => ScaleFieldDefTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) },
    ))

  def encode(j: ScaleFieldDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> ScaleFieldDefBandPositionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> ScaleFieldDefBinCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> ScaleFieldDefTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// AutoSizeParamsContains (EnumType)
object AutoSizeParamsContainsCodec {
  def decode(j: JsValue): AutoSizeParamsContains =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AutoSizeParamsContains] =
    j match {
      case JsString("content") => Some(AutoSizeParamsContainsContent)
      case JsString("padding") => Some(AutoSizeParamsContainsPadding)
      case _ => None
    }
  def encode(j: AutoSizeParamsContains): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// AxisConfigLabelFontStyle (UnionType)
object AxisConfigLabelFontStyleCodec {
  def decode(j: JsValue): AxisConfigLabelFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigLabelFontStyle] =
    j.asOpt[String].map { AxisConfigLabelFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisLabelFontStyleCodec.decodeOpt(j) } } 
  def encode(j: AxisConfigLabelFontStyle): JsValue =
    j match {
      case AxisConfigLabelFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisLabelFontStyle /* TypeRef */ => ConditionalAxisLabelFontStyleCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefOpacity (UnionType)
object OverlayMarkDefOpacityCodec {
  def decode(j: JsValue): OverlayMarkDefOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefOpacity] =
    j.asOpt[JsNumber].map { OverlayMarkDefOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefOpacity): JsValue =
    j match {
      case OverlayMarkDefOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionMarkPropFieldDefNumberBin (UnionType)
object FieldOrDatumDefWithConditionMarkPropFieldDefNumberBinCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionMarkPropFieldDefNumberBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionMarkPropFieldDefNumberBin] =
    j.asOpt[Boolean].map { FieldOrDatumDefWithConditionMarkPropFieldDefNumberBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => FieldOrDatumDefWithConditionMarkPropFieldDefNumberBinAsNull } } } 
  def encode(j: FieldOrDatumDefWithConditionMarkPropFieldDefNumberBin): JsValue =
    j match {
      case FieldOrDatumDefWithConditionMarkPropFieldDefNumberBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case FieldOrDatumDefWithConditionMarkPropFieldDefNumberBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingHrefTimeUnit (UnionType)
object SharedEncodingHrefTimeUnitCodec {
  def decode(j: JsValue): SharedEncodingHrefTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingHrefTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingHrefTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1TimeUnit (UnionType)
object ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1TimeUnitCodec {
  def decode(j: JsValue): ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1TimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1TimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: ConditionalParameterMarkPropFieldOrDatumDefTypeForShapeAsObject1TimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingShape (StructType)
object SharedEncodingShapeCodec {
  def decode(j: JsValue): SharedEncodingShape =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingShape] =
    Some(SharedEncodingShape(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `scale` = (j \ "scale").asOpt[JsValue].flatMap { x => ScaleCodec.decodeOpt(x).map { Some(_) }.flatten },
      `datum` = (j \ "datum").asOpt[JsValue].flatMap { x => SharedEncodingShapeDatumCodec.decodeOpt(x) },
      `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => SharedEncodingShapeBandPositionCodec.decodeOpt(x) },
      `condition` = (j \ "condition").asOpt[JsValue].flatMap { x => SharedEncodingShapeConditionCodec.decodeOpt(x) },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => SharedEncodingShapeBinCodec.decodeOpt(x) },
      `value` = (j \ "value").asOpt[JsValue].flatMap { x => SharedEncodingShapeValueCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => SharedEncodingShapeTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => SortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => SharedEncodingShapeTypeCodec.decodeOpt(x) },
    ))

  def encode(j: SharedEncodingShape): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`scale`.map { x => "scale" -> ScaleCodec.encode(x) },
        j.`datum`.map { x => "datum" -> SharedEncodingShapeDatumCodec.encode(x) },
        j.`legend`.map { x => "legend" -> LegendCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> SharedEncodingShapeBandPositionCodec.encode(x) },
        j.`condition`.map { x => "condition" -> SharedEncodingShapeConditionCodec.encode(x) },
        j.`bin`.map { x => "bin" -> SharedEncodingShapeBinCodec.encode(x) },
        j.`value`.map { x => "value" -> SharedEncodingShapeValueCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> SharedEncodingShapeTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> SortCodec.encode(x) },
        j.`type`.map { x => "type" -> SharedEncodingShapeTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ProjectionConfigFit (UnionType)
object ProjectionConfigFitCodec {
  def decode(j: JsValue): ProjectionConfigFit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigFit] =
    ArrayOfAnyCodec.decodeOpt(j).map { ProjectionConfigFitAsArrayOfAny(_) }.orElse {
    ArrayOfFitCodec.decodeOpt(j).map { ProjectionConfigFitAsArrayOfFit(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: ProjectionConfigFit): JsValue =
    j match {
      case ProjectionConfigFitAsArrayOfAny(x) /* Base, ArrayType */ => ArrayOfAnyCodec.encode(x)
      case ProjectionConfigFitAsArrayOfFit(x) /* Base, ArrayType */ => ArrayOfFitCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigFillOpacity (UnionType)
object AreaConfigFillOpacityCodec {
  def decode(j: JsValue): AreaConfigFillOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigFillOpacity] =
    AreaConfigFillOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AreaConfigFillOpacity): JsValue =
    j match {
      case x:AreaConfigFillOpacityAsNumber /* TypeRef */ => AreaConfigFillOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigGradientDirection (UnionType)
object LegendConfigGradientDirectionCodec {
  def decode(j: JsValue): LegendConfigGradientDirection =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigGradientDirection] =
    OrientationCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigGradientDirection): JsValue =
    j match {
      case x:Orientation /* TypeRef */ => OrientationCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingStrokeType (UnionType)
object SharedEncodingStrokeTypeCodec {
  def decode(j: JsValue): SharedEncodingStrokeType =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingStrokeType] =
    StandardTypeCodec.decodeOpt(j).orElse {
    TypeCodec.decodeOpt(j) } 
  def encode(j: SharedEncodingStrokeType): JsValue =
    j match {
      case x:StandardType /* TypeRef */ => StandardTypeCodec.encode(x)
      case x:Type /* TypeRef */ => TypeCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Interpolate (EnumType)
object InterpolateCodec {
  def decode(j: JsValue): Interpolate =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Interpolate] =
    j match {
      case JsString("basis") => Some(InterpolateBasis)
      case JsString("basis-open") => Some(InterpolateBasisOpen)
      case JsString("basis-closed") => Some(InterpolateBasisClosed)
      case JsString("bundle") => Some(InterpolateBundle)
      case JsString("cardinal") => Some(InterpolateCardinal)
      case JsString("cardinal-open") => Some(InterpolateCardinalOpen)
      case JsString("cardinal-closed") => Some(InterpolateCardinalClosed)
      case JsString("catmull-rom") => Some(InterpolateCatmullRom)
      case JsString("linear") => Some(InterpolateLinear)
      case JsString("linear-closed") => Some(InterpolateLinearClosed)
      case JsString("monotone") => Some(InterpolateMonotone)
      case JsString("natural") => Some(InterpolateNatural)
      case JsString("step") => Some(InterpolateStep)
      case JsString("step-before") => Some(InterpolateStepBefore)
      case JsString("step-after") => Some(InterpolateStepAfter)
      case _ => None
    }
  def encode(j: Interpolate): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// MarkConfigEllipsis (UnionType)
object MarkConfigEllipsisCodec {
  def decode(j: JsValue): MarkConfigEllipsis =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigEllipsis] =
    j.asOpt[String].map { MarkConfigEllipsisAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigEllipsis): JsValue =
    j match {
      case MarkConfigEllipsisAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigFillOpacity (UnionType)
object TickConfigFillOpacityCodec {
  def decode(j: JsValue): TickConfigFillOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigFillOpacity] =
    TickConfigFillOpacityAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigFillOpacity): JsValue =
    j match {
      case x:TickConfigFillOpacityAsNumber /* TypeRef */ => TickConfigFillOpacityAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigSmooth (UnionType)
object RectConfigSmoothCodec {
  def decode(j: JsValue): RectConfigSmooth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigSmooth] =
    j.asOpt[Boolean].map { RectConfigSmoothAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigSmooth): JsValue =
    j match {
      case RectConfigSmoothAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// StringFieldDefFormat (UnionType)
object StringFieldDefFormatCodec {
  def decode(j: JsValue): StringFieldDefFormat =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[StringFieldDefFormat] =
    j.asOpt[String].map { StringFieldDefFormatAsString(_) }.orElse {
    DictOfAnyCodec.decodeOpt(j).map { StringFieldDefFormatAsDictOfAny(_) } } 
  def encode(j: StringFieldDefFormat): JsValue =
    j match {
      case StringFieldDefFormatAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case StringFieldDefFormatAsDictOfAny(x) /* Base, MapType */ => DictOfAnyCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigDescription (UnionType)
object TickConfigDescriptionCodec {
  def decode(j: JsValue): TickConfigDescription =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigDescription] =
    j.asOpt[String].map { TickConfigDescriptionAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigDescription): JsValue =
    j match {
      case TickConfigDescriptionAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Step (StructType)
object StepCodec {
  def decode(j: JsValue): Step =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Step] =
    {
      val `for` = (j \ "for").asOpt[JsValue].flatMap { x => StepForCodec.decodeOpt(x) }
      val `step` = (j \ "step").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      if(`step`.isEmpty) { return None }
      return Some(Step(
        `for` = `for`,
        `step` = `step`.get,
      ))
    }

  def encode(j: Step): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`for`.map { x => "for" -> StepForCodec.encode(x) },
        Some("step" -> Json.toJson(j.`step`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// OverlayMarkDefSize (UnionType)
object OverlayMarkDefSizeCodec {
  def decode(j: JsValue): OverlayMarkDefSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefSize] =
    j.asOpt[JsNumber].map { OverlayMarkDefSizeAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefSize): JsValue =
    j match {
      case OverlayMarkDefSizeAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigTheta (ConstrainedType)
// see AreaConfigTheta (UnionType)

////////////////////////////////////////////////////////////////////////
// BarConfigInnerRadius (UnionType)
object BarConfigInnerRadiusCodec {
  def decode(j: JsValue): BarConfigInnerRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigInnerRadius] =
    j.asOpt[JsNumber].map { BarConfigInnerRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigInnerRadius): JsValue =
    j match {
      case BarConfigInnerRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefStringNullExprRefAsObject1 (StructType)
object ConditionalPredicateValueDefStringNullExprRefAsObject1Codec {
  def decode(j: JsValue): ConditionalPredicateValueDefStringNullExprRefAsObject1 =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefStringNullExprRefAsObject1] =
    {
      val `test` = (j \ "test").asOpt[JsValue].flatMap { x => PredicateCompositionCodec.decodeOpt(x) }
      if(`test`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => ConditionalPredicateValueDefStringNullExprRefAsObject1ValueCodec.decodeOpt(x) }
      if(`value`.isEmpty) { return None }
      return Some(ConditionalPredicateValueDefStringNullExprRefAsObject1(
        `test` = `test`.get,
        `value` = `value`.get,
      ))
    }

  def encode(j: ConditionalPredicateValueDefStringNullExprRefAsObject1): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("test" -> PredicateCompositionCodec.encode(j.`test`)),
        Some("value" -> ConditionalPredicateValueDefStringNullExprRefAsObject1ValueCodec.encode(j.`value`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LegendStreamBinding (StructType)
object LegendStreamBindingCodec {
  def decode(j: JsValue): LegendStreamBinding =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[LegendStreamBinding] =
    {
      val `legend` = (j \ "legend").asOpt[JsValue].flatMap { x => LegendStreamBindingLegendCodec.decodeOpt(x) }
      if(`legend`.isEmpty) { return None }
      return Some(LegendStreamBinding(
        `legend` = `legend`.get,
      ))
    }

  def encode(j: LegendStreamBinding): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("legend" -> LegendStreamBindingLegendCodec.encode(j.`legend`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// FacetSpecFacet (UnionType)
object FacetSpecFacetCodec {
  def decode(j: JsValue): FacetSpecFacet =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetSpecFacet] =
    FacetFieldDefCodec.decodeOpt(j).orElse {
    FacetMappingCodec.decodeOpt(j) } 
  def encode(j: FacetSpecFacet): JsValue =
    j match {
      case x:FacetFieldDef /* TypeRef */ => FacetFieldDefCodec.encode(x)
      case x:FacetMapping /* TypeRef */ => FacetMappingCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigSize (ConstrainedType)
// see TickConfigSize (UnionType)

////////////////////////////////////////////////////////////////////////
// ArrayOfString (ArrayType)
object ArrayOfStringCodec {
  def decode(j: JsValue): Seq[String] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[String]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      x.asOpt[String].getOrElse { return None } } }
  def encode(j: Seq[String]): JsArray =
      JsArray(j.map { x => Json.toJson(x) })
}

////////////////////////////////////////////////////////////////////////
// UnitSpecWithFrame (StructType)
object UnitSpecWithFrameCodec {
  def decode(j: JsValue): UnitSpecWithFrame =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[UnitSpecWithFrame] =
    {
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `projection` = (j \ "projection").asOpt[JsValue].flatMap { x => ProjectionCodec.decodeOpt(x) }
      val `description` = (j \ "description").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `data` = (j \ "data").asOpt[JsValue].flatMap { x => DataCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `params` = (j \ "params").asOpt[JsValue].flatMap { x => ArrayOfUnitSpecWithFrameParamsElementCodec.decodeOpt(x) }
      val `height` = (j \ "height").asOpt[JsValue].flatMap { x => UnitSpecWithFrameHeightCodec.decodeOpt(x) }
      val `encoding` = (j \ "encoding").asOpt[JsValue].flatMap { x => EncodingCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => UnitSpecWithFrameTitleCodec.decodeOpt(x) }
      val `mark` = (j \ "mark").asOpt[JsValue].flatMap { x => AnyMarkCodec.decodeOpt(x) }
      if(`mark`.isEmpty) { return None }
      val `view` = (j \ "view").asOpt[JsValue].flatMap { x => ViewBackgroundCodec.decodeOpt(x) }
      val `transform` = (j \ "transform").asOpt[JsValue].flatMap { x => ArrayOfTransformCodec.decodeOpt(x) }
      val `width` = (j \ "width").asOpt[JsValue].flatMap { x => UnitSpecWithFrameWidthCodec.decodeOpt(x) }
      return Some(UnitSpecWithFrame(
        `name` = `name`,
        `projection` = `projection`,
        `description` = `description`,
        `data` = `data`,
        `params` = `params`,
        `height` = `height`,
        `encoding` = `encoding`,
        `title` = `title`,
        `mark` = `mark`.get,
        `view` = `view`,
        `transform` = `transform`,
        `width` = `width`,
      ))
    }

  def encode(j: UnitSpecWithFrame): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`projection`.map { x => "projection" -> ProjectionCodec.encode(x) },
        j.`description`.map { x => "description" -> Json.toJson(x) },
        j.`data`.map { x => "data" -> DataCodec.encode(x) },
        j.`params`.map { x => "params" -> ArrayOfUnitSpecWithFrameParamsElementCodec.encode(x) },
        j.`height`.map { x => "height" -> UnitSpecWithFrameHeightCodec.encode(x) },
        j.`encoding`.map { x => "encoding" -> EncodingCodec.encode(x) },
        j.`title`.map { x => "title" -> UnitSpecWithFrameTitleCodec.encode(x) },
        Some("mark" -> AnyMarkCodec.encode(j.`mark`)),
        j.`view`.map { x => "view" -> ViewBackgroundCodec.encode(x) },
        j.`transform`.map { x => "transform" -> ArrayOfTransformCodec.encode(x) },
        j.`width`.map { x => "width" -> UnitSpecWithFrameWidthCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// MarkDefFill (UnionType)
object MarkDefFillCodec {
  def decode(j: JsValue): MarkDefFill =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefFill] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => MarkDefFillAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: MarkDefFill): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case MarkDefFillAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigColumns (UnionType)
object LegendConfigColumnsCodec {
  def decode(j: JsValue): LegendConfigColumns =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigColumns] =
    j.asOpt[JsNumber].map { LegendConfigColumnsAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigColumns): JsValue =
    j match {
      case LegendConfigColumnsAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ErrorBarDefOpacity (ConstrainedType)
object ErrorBarDefOpacityCodec {
  def decode(j: JsValue): ErrorBarDefOpacity =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[ErrorBarDefOpacity] =
    try {
      j.asOpt[JsNumber]
        .map { ErrorBarDefOpacity(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: ErrorBarDefOpacity): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// PositionFieldDefBaseTimeUnit (UnionType)
object PositionFieldDefBaseTimeUnitCodec {
  def decode(j: JsValue): PositionFieldDefBaseTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PositionFieldDefBaseTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: PositionFieldDefBaseTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigAlign (UnionType)
object TickConfigAlignCodec {
  def decode(j: JsValue): TickConfigAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigAlign] =
    AlignCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TickConfigAlign): JsValue =
    j match {
      case x:Align /* TypeRef */ => AlignCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigInnerRadius (ConstrainedType)
// see MarkConfigInnerRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// LegendOrient (EnumType)
object LegendOrientCodec {
  def decode(j: JsValue): LegendOrient =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendOrient] =
    j match {
      case JsString("none") => Some(LegendOrientNone)
      case JsString("left") => Some(LegendOrientLeft)
      case JsString("right") => Some(LegendOrientRight)
      case JsString("top") => Some(LegendOrientTop)
      case JsString("bottom") => Some(LegendOrientBottom)
      case JsString("top-left") => Some(LegendOrientTopLeft)
      case JsString("top-right") => Some(LegendOrientTopRight)
      case JsString("bottom-left") => Some(LegendOrientBottomLeft)
      case JsString("bottom-right") => Some(LegendOrientBottomRight)
      case _ => None
    }
  def encode(j: LegendOrient): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// BarConfigContinuousBandSize (ConstrainedType)
object BarConfigContinuousBandSizeCodec {
  def decode(j: JsValue): BarConfigContinuousBandSize =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[BarConfigContinuousBandSize] =
    try {
      j.asOpt[JsNumber]
        .map { BarConfigContinuousBandSize(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: BarConfigContinuousBandSize): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// ConditionalParameterStringFieldDefTimeUnit (UnionType)
object ConditionalParameterStringFieldDefTimeUnitCodec {
  def decode(j: JsValue): ConditionalParameterStringFieldDefTimeUnit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalParameterStringFieldDefTimeUnit] =
    TimeUnitCodec.decodeOpt(j).orElse {
    TimeUnitParamsCodec.decodeOpt(j) } 
  def encode(j: ConditionalParameterStringFieldDefTimeUnit): JsValue =
    j match {
      case x:TimeUnit /* TypeRef */ => TimeUnitCodec.encode(x)
      case x:TimeUnitParams /* TypeRef */ => TimeUnitParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingFillBin (UnionType)
object SharedEncodingFillBinCodec {
  def decode(j: JsValue): SharedEncodingFillBin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[SharedEncodingFillBin] =
    j.asOpt[Boolean].map { SharedEncodingFillBinAsBool(_) }.orElse {
    BinParamsCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => SharedEncodingFillBinAsNull } } } 
  def encode(j: SharedEncodingFillBin): JsValue =
    j match {
      case SharedEncodingFillBinAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:BinParams /* TypeRef */ => BinParamsCodec.encode(x)
      case SharedEncodingFillBinAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// PointSelectionConfigWithoutTypeClear (UnionType)
object PointSelectionConfigWithoutTypeClearCodec {
  def decode(j: JsValue): PointSelectionConfigWithoutTypeClear =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[PointSelectionConfigWithoutTypeClear] =
    StreamCodec.decodeOpt(j).orElse {
    j.asOpt[String].map { PointSelectionConfigWithoutTypeClearAsString(_) }.orElse {
    j.asOpt[Boolean].map { PointSelectionConfigWithoutTypeClearAsBool(_) } } } 
  def encode(j: PointSelectionConfigWithoutTypeClear): JsValue =
    j match {
      case x:Stream /* TypeRef */ => StreamCodec.encode(x)
      case PointSelectionConfigWithoutTypeClearAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case PointSelectionConfigWithoutTypeClearAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetedEncodingYError (UnionType)
object FacetedEncodingYErrorCodec {
  def decode(j: JsValue): FacetedEncodingYError =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetedEncodingYError] =
    SecondaryFieldDefCodec.decodeOpt(j).orElse {
    ValueDefNumberCodec.decodeOpt(j) } 
  def encode(j: FacetedEncodingYError): JsValue =
    j match {
      case x:SecondaryFieldDef /* TypeRef */ => SecondaryFieldDefCodec.encode(x)
      case x:ValueDefNumber /* TypeRef */ => ValueDefNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigSize (UnionType)
object BarConfigSizeCodec {
  def decode(j: JsValue): BarConfigSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigSize] =
    j.asOpt[JsNumber].map { BarConfigSizeAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigSize): JsValue =
    j match {
      case BarConfigSizeAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ParameterExtent (UnionType)
object ParameterExtentCodec {
  def decode(j: JsValue): ParameterExtent =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ParameterExtent] =
    ParameterExtentAsObject1Codec.decodeOpt(j).orElse {
    ParameterExtentAsObject2Codec.decodeOpt(j) } 
  def encode(j: ParameterExtent): JsValue =
    j match {
      case x:ParameterExtentAsObject1 /* TypeRef */ => ParameterExtentAsObject1Codec.encode(x)
      case x:ParameterExtentAsObject2 /* TypeRef */ => ParameterExtentAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionRatio (UnionType)
object ProjectionRatioCodec {
  def decode(j: JsValue): ProjectionRatio =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionRatio] =
    j.asOpt[JsNumber].map { ProjectionRatioAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionRatio): JsValue =
    j match {
      case ProjectionRatioAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigTooltip (UnionType)
object BarConfigTooltipCodec {
  def decode(j: JsValue): BarConfigTooltip =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigTooltip] =
    j.asOpt[String].map { BarConfigTooltipAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => BarConfigTooltipAsNull }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    TooltipContentCodec.decodeOpt(j).orElse {
    j.asOpt[Boolean].map { BarConfigTooltipAsBool(_) }.orElse {
    j.asOpt[JsNumber].map { BarConfigTooltipAsNumber(_) } } } } } } 
  def encode(j: BarConfigTooltip): JsValue =
    j match {
      case BarConfigTooltipAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case BarConfigTooltipAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:TooltipContent /* TypeRef */ => TooltipContentCodec.encode(x)
      case BarConfigTooltipAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case BarConfigTooltipAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ProjectionConfigRadius (UnionType)
object ProjectionConfigRadiusCodec {
  def decode(j: JsValue): ProjectionConfigRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ProjectionConfigRadius] =
    j.asOpt[JsNumber].map { ProjectionConfigRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: ProjectionConfigRadius): JsValue =
    j match {
      case ProjectionConfigRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisTitleFontWeight (UnionType)
object AxisTitleFontWeightCodec {
  def decode(j: JsValue): AxisTitleFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisTitleFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisTitleFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LegendConfigTitleLimit (UnionType)
object LegendConfigTitleLimitCodec {
  def decode(j: JsValue): LegendConfigTitleLimit =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigTitleLimit] =
    LegendConfigTitleLimitAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigTitleLimit): JsValue =
    j match {
      case x:LegendConfigTitleLimitAsNumber /* TypeRef */ => LegendConfigTitleLimitAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleRangeAsArrayElement (UnionType)
object ScaleRangeAsArrayElementCodec {
  def decode(j: JsValue): ScaleRangeAsArrayElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleRangeAsArrayElement] =
    j.asOpt[JsNumber].map { ScaleRangeAsArrayElementAsNumber(_) }.orElse {
    j.asOpt[String].map { ScaleRangeAsArrayElementAsString(_) }.orElse {
    ArrayOfNumberCodec.decodeOpt(j).map { ScaleRangeAsArrayElementAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: ScaleRangeAsArrayElement): JsValue =
    j match {
      case ScaleRangeAsArrayElementAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case ScaleRangeAsArrayElementAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case ScaleRangeAsArrayElementAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Legend (ConstantType)
object LegendCodec {
  def decode(j: JsValue): Legend =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Legend] =
    j match {
      case JsString("legend") => Some(Legend())
      case _ => None
    }
  def encode(j: Legend): JsValue =
    JsString("legend")
}


////////////////////////////////////////////////////////////////////////
// OverlayMarkDefX2Offset (UnionType)
object OverlayMarkDefX2OffsetCodec {
  def decode(j: JsValue): OverlayMarkDefX2Offset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefX2Offset] =
    j.asOpt[JsNumber].map { OverlayMarkDefX2OffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefX2Offset): JsValue =
    j match {
      case OverlayMarkDefX2OffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisLabelFontSize (UnionType)
object AxisLabelFontSizeCodec {
  def decode(j: JsValue): AxisLabelFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisLabelFontSize] =
    AxisLabelFontSizeAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberCodec.decodeOpt(j) } } 
  def encode(j: AxisLabelFontSize): JsValue =
    j match {
      case x:AxisLabelFontSizeAsNumber /* TypeRef */ => AxisLabelFontSizeAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumber /* TypeRef */ => ConditionalAxisNumberCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingShapeBandPosition (ConstrainedType)
object SharedEncodingShapeBandPositionCodec {
  def decode(j: JsValue): SharedEncodingShapeBandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingShapeBandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingShapeBandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingShapeBandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// MarkConfigSmooth (UnionType)
object MarkConfigSmoothCodec {
  def decode(j: JsValue): MarkConfigSmooth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigSmooth] =
    j.asOpt[Boolean].map { MarkConfigSmoothAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigSmooth): JsValue =
    j match {
      case MarkConfigSmoothAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigGridOpacityAsNumber (ConstrainedType)
object AxisConfigGridOpacityAsNumberCodec {
  def decode(j: JsValue): AxisConfigGridOpacityAsNumber =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[AxisConfigGridOpacityAsNumber] =
    try {
      j.asOpt[JsNumber]
        .map { AxisConfigGridOpacityAsNumber(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: AxisConfigGridOpacityAsNumber): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefEllipsis (UnionType)
object OverlayMarkDefEllipsisCodec {
  def decode(j: JsValue): OverlayMarkDefEllipsis =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefEllipsis] =
    j.asOpt[String].map { OverlayMarkDefEllipsisAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefEllipsis): JsValue =
    j match {
      case OverlayMarkDefEllipsisAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigOuterRadius (UnionType)
object LineConfigOuterRadiusCodec {
  def decode(j: JsValue): LineConfigOuterRadius =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigOuterRadius] =
    j.asOpt[JsNumber].map { LineConfigOuterRadiusAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LineConfigOuterRadius): JsValue =
    j match {
      case LineConfigOuterRadiusAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefAlign (UnionType)
object MarkDefAlignCodec {
  def decode(j: JsValue): MarkDefAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefAlign] =
    AlignCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefAlign): JsValue =
    j match {
      case x:Align /* TypeRef */ => AlignCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Scales (ConstantType)
object ScalesCodec {
  def decode(j: JsValue): Scales =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[Scales] =
    j match {
      case JsString("scales") => Some(Scales())
      case _ => None
    }
  def encode(j: Scales): JsValue =
    JsString("scales")
}


////////////////////////////////////////////////////////////////////////
// TickConfigY (UnionType)
object TickConfigYCodec {
  def decode(j: JsValue): TickConfigY =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigY] =
    j.asOpt[JsNumber].map { TickConfigYAsNumber(_) }.orElse {
    HeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: TickConfigY): JsValue =
    j match {
      case TickConfigYAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Height /* TypeRef */ => HeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigInnerRadius (ConstrainedType)
// see AreaConfigInnerRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// JoinAggregateTransform (StructType)
object JoinAggregateTransformCodec {
  def decode(j: JsValue): JoinAggregateTransform =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[JoinAggregateTransform] =
    {
      val `groupby` = (j \ "groupby").asOpt[JsValue].flatMap { x => ArrayOfStringCodec.decodeOpt(x) }
      val `joinaggregate` = (j \ "joinaggregate").asOpt[JsValue].flatMap { x => ArrayOfJoinAggregateFieldDefCodec.decodeOpt(x) }
      if(`joinaggregate`.isEmpty) { return None }
      return Some(JoinAggregateTransform(
        `groupby` = `groupby`,
        `joinaggregate` = `joinaggregate`.get,
      ))
    }

  def encode(j: JoinAggregateTransform): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`groupby`.map { x => "groupby" -> ArrayOfStringCodec.encode(x) },
        Some("joinaggregate" -> ArrayOfJoinAggregateFieldDefCodec.encode(j.`joinaggregate`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// MarkDefStrokeCap (UnionType)
object MarkDefStrokeCapCodec {
  def decode(j: JsValue): MarkDefStrokeCap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefStrokeCap] =
    StrokeCapCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefStrokeCap): JsValue =
    j match {
      case x:StrokeCap /* TypeRef */ => StrokeCapCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefCornerRadiusTopRight (UnionType)
object MarkDefCornerRadiusTopRightCodec {
  def decode(j: JsValue): MarkDefCornerRadiusTopRight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefCornerRadiusTopRight] =
    j.asOpt[JsNumber].map { MarkDefCornerRadiusTopRightAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefCornerRadiusTopRight): JsValue =
    j match {
      case MarkDefCornerRadiusTopRightAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Diverging (EnumType)
object DivergingCodec {
  def decode(j: JsValue): Diverging =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Diverging] =
    j match {
      case JsString("blueorange") => Some(DivergingBlueorange)
      case JsString("blueorange-3") => Some(DivergingBlueorange3)
      case JsString("blueorange-4") => Some(DivergingBlueorange4)
      case JsString("blueorange-5") => Some(DivergingBlueorange5)
      case JsString("blueorange-6") => Some(DivergingBlueorange6)
      case JsString("blueorange-7") => Some(DivergingBlueorange7)
      case JsString("blueorange-8") => Some(DivergingBlueorange8)
      case JsString("blueorange-9") => Some(DivergingBlueorange9)
      case JsString("blueorange-10") => Some(DivergingBlueorange10)
      case JsString("blueorange-11") => Some(DivergingBlueorange11)
      case JsString("brownbluegreen") => Some(DivergingBrownbluegreen)
      case JsString("brownbluegreen-3") => Some(DivergingBrownbluegreen3)
      case JsString("brownbluegreen-4") => Some(DivergingBrownbluegreen4)
      case JsString("brownbluegreen-5") => Some(DivergingBrownbluegreen5)
      case JsString("brownbluegreen-6") => Some(DivergingBrownbluegreen6)
      case JsString("brownbluegreen-7") => Some(DivergingBrownbluegreen7)
      case JsString("brownbluegreen-8") => Some(DivergingBrownbluegreen8)
      case JsString("brownbluegreen-9") => Some(DivergingBrownbluegreen9)
      case JsString("brownbluegreen-10") => Some(DivergingBrownbluegreen10)
      case JsString("brownbluegreen-11") => Some(DivergingBrownbluegreen11)
      case JsString("purplegreen") => Some(DivergingPurplegreen)
      case JsString("purplegreen-3") => Some(DivergingPurplegreen3)
      case JsString("purplegreen-4") => Some(DivergingPurplegreen4)
      case JsString("purplegreen-5") => Some(DivergingPurplegreen5)
      case JsString("purplegreen-6") => Some(DivergingPurplegreen6)
      case JsString("purplegreen-7") => Some(DivergingPurplegreen7)
      case JsString("purplegreen-8") => Some(DivergingPurplegreen8)
      case JsString("purplegreen-9") => Some(DivergingPurplegreen9)
      case JsString("purplegreen-10") => Some(DivergingPurplegreen10)
      case JsString("purplegreen-11") => Some(DivergingPurplegreen11)
      case JsString("pinkyellowgreen") => Some(DivergingPinkyellowgreen)
      case JsString("pinkyellowgreen-3") => Some(DivergingPinkyellowgreen3)
      case JsString("pinkyellowgreen-4") => Some(DivergingPinkyellowgreen4)
      case JsString("pinkyellowgreen-5") => Some(DivergingPinkyellowgreen5)
      case JsString("pinkyellowgreen-6") => Some(DivergingPinkyellowgreen6)
      case JsString("pinkyellowgreen-7") => Some(DivergingPinkyellowgreen7)
      case JsString("pinkyellowgreen-8") => Some(DivergingPinkyellowgreen8)
      case JsString("pinkyellowgreen-9") => Some(DivergingPinkyellowgreen9)
      case JsString("pinkyellowgreen-10") => Some(DivergingPinkyellowgreen10)
      case JsString("pinkyellowgreen-11") => Some(DivergingPinkyellowgreen11)
      case JsString("purpleorange") => Some(DivergingPurpleorange)
      case JsString("purpleorange-3") => Some(DivergingPurpleorange3)
      case JsString("purpleorange-4") => Some(DivergingPurpleorange4)
      case JsString("purpleorange-5") => Some(DivergingPurpleorange5)
      case JsString("purpleorange-6") => Some(DivergingPurpleorange6)
      case JsString("purpleorange-7") => Some(DivergingPurpleorange7)
      case JsString("purpleorange-8") => Some(DivergingPurpleorange8)
      case JsString("purpleorange-9") => Some(DivergingPurpleorange9)
      case JsString("purpleorange-10") => Some(DivergingPurpleorange10)
      case JsString("purpleorange-11") => Some(DivergingPurpleorange11)
      case JsString("redblue") => Some(DivergingRedblue)
      case JsString("redblue-3") => Some(DivergingRedblue3)
      case JsString("redblue-4") => Some(DivergingRedblue4)
      case JsString("redblue-5") => Some(DivergingRedblue5)
      case JsString("redblue-6") => Some(DivergingRedblue6)
      case JsString("redblue-7") => Some(DivergingRedblue7)
      case JsString("redblue-8") => Some(DivergingRedblue8)
      case JsString("redblue-9") => Some(DivergingRedblue9)
      case JsString("redblue-10") => Some(DivergingRedblue10)
      case JsString("redblue-11") => Some(DivergingRedblue11)
      case JsString("redgrey") => Some(DivergingRedgrey)
      case JsString("redgrey-3") => Some(DivergingRedgrey3)
      case JsString("redgrey-4") => Some(DivergingRedgrey4)
      case JsString("redgrey-5") => Some(DivergingRedgrey5)
      case JsString("redgrey-6") => Some(DivergingRedgrey6)
      case JsString("redgrey-7") => Some(DivergingRedgrey7)
      case JsString("redgrey-8") => Some(DivergingRedgrey8)
      case JsString("redgrey-9") => Some(DivergingRedgrey9)
      case JsString("redgrey-10") => Some(DivergingRedgrey10)
      case JsString("redgrey-11") => Some(DivergingRedgrey11)
      case JsString("redyellowblue") => Some(DivergingRedyellowblue)
      case JsString("redyellowblue-3") => Some(DivergingRedyellowblue3)
      case JsString("redyellowblue-4") => Some(DivergingRedyellowblue4)
      case JsString("redyellowblue-5") => Some(DivergingRedyellowblue5)
      case JsString("redyellowblue-6") => Some(DivergingRedyellowblue6)
      case JsString("redyellowblue-7") => Some(DivergingRedyellowblue7)
      case JsString("redyellowblue-8") => Some(DivergingRedyellowblue8)
      case JsString("redyellowblue-9") => Some(DivergingRedyellowblue9)
      case JsString("redyellowblue-10") => Some(DivergingRedyellowblue10)
      case JsString("redyellowblue-11") => Some(DivergingRedyellowblue11)
      case JsString("redyellowgreen") => Some(DivergingRedyellowgreen)
      case JsString("redyellowgreen-3") => Some(DivergingRedyellowgreen3)
      case JsString("redyellowgreen-4") => Some(DivergingRedyellowgreen4)
      case JsString("redyellowgreen-5") => Some(DivergingRedyellowgreen5)
      case JsString("redyellowgreen-6") => Some(DivergingRedyellowgreen6)
      case JsString("redyellowgreen-7") => Some(DivergingRedyellowgreen7)
      case JsString("redyellowgreen-8") => Some(DivergingRedyellowgreen8)
      case JsString("redyellowgreen-9") => Some(DivergingRedyellowgreen9)
      case JsString("redyellowgreen-10") => Some(DivergingRedyellowgreen10)
      case JsString("redyellowgreen-11") => Some(DivergingRedyellowgreen11)
      case JsString("spectral") => Some(DivergingSpectral)
      case JsString("spectral-3") => Some(DivergingSpectral3)
      case JsString("spectral-4") => Some(DivergingSpectral4)
      case JsString("spectral-5") => Some(DivergingSpectral5)
      case JsString("spectral-6") => Some(DivergingSpectral6)
      case JsString("spectral-7") => Some(DivergingSpectral7)
      case JsString("spectral-8") => Some(DivergingSpectral8)
      case JsString("spectral-9") => Some(DivergingSpectral9)
      case JsString("spectral-10") => Some(DivergingSpectral10)
      case JsString("spectral-11") => Some(DivergingSpectral11)
      case _ => None
    }
  def encode(j: Diverging): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// NamedData (StructType)
object NamedDataCodec {
  def decode(j: JsValue): NamedData =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[NamedData] =
    {
      val `format` = (j \ "format").asOpt[JsValue].flatMap { x => DataFormatCodec.decodeOpt(x) }
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`name`.isEmpty) { return None }
      return Some(NamedData(
        `format` = `format`,
        `name` = `name`.get,
      ))
    }

  def encode(j: NamedData): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`format`.map { x => "format" -> DataFormatCodec.encode(x) },
        Some("name" -> Json.toJson(j.`name`)),
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// RectConfigStrokeWidth (UnionType)
object RectConfigStrokeWidthCodec {
  def decode(j: JsValue): RectConfigStrokeWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigStrokeWidth] =
    RectConfigStrokeWidthAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigStrokeWidth): JsValue =
    j match {
      case x:RectConfigStrokeWidthAsNumber /* TypeRef */ => RectConfigStrokeWidthAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetEncodingFieldDef (StructType)
object FacetEncodingFieldDefCodec {
  def decode(j: JsValue): FacetEncodingFieldDef =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FacetEncodingFieldDef] =
    Some(FacetEncodingFieldDef(
      `field` = (j \ "field").asOpt[JsValue].flatMap { x => FieldCodec.decodeOpt(x) },
      `center` = (j \ "center").asOpt[JsValue].flatMap { x => FacetEncodingFieldDefCenterCodec.decodeOpt(x) },
      `align` = (j \ "align").asOpt[JsValue].flatMap { x => FacetEncodingFieldDefAlignCodec.decodeOpt(x) },
      `bounds` = (j \ "bounds").asOpt[JsValue].flatMap { x => FacetEncodingFieldDefBoundsCodec.decodeOpt(x) },
      `bandPosition` = (j \ "bandPosition").asOpt[JsValue].flatMap { x => FacetEncodingFieldDefBandPositionCodec.decodeOpt(x) },
      `columns` = (j \ "columns").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `header` = (j \ "header").asOpt[JsValue].flatMap { x => HeaderCodec.decodeOpt(x).map { Some(_) }.flatten },
      `bin` = (j \ "bin").asOpt[JsValue].flatMap { x => FacetEncodingFieldDefBinCodec.decodeOpt(x) },
      `spacing` = (j \ "spacing").asOpt[JsValue].flatMap { x => FacetEncodingFieldDefSpacingCodec.decodeOpt(x) },
      `aggregate` = (j \ "aggregate").asOpt[JsValue].flatMap { x => AggregateCodec.decodeOpt(x) },
      `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => FacetEncodingFieldDefTimeUnitCodec.decodeOpt(x) },
      `title` = (j \ "title").asOpt[JsValue].flatMap { x => TextCodec.decodeOpt(x).map { Some(_) }.flatten },
      `sort` = (j \ "sort").asOpt[JsValue].flatMap { x => FacetEncodingFieldDefSortCodec.decodeOpt(x) },
      `type` = (j \ "type").asOpt[JsValue].flatMap { x => StandardTypeCodec.decodeOpt(x) },
    ))

  def encode(j: FacetEncodingFieldDef): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`field`.map { x => "field" -> FieldCodec.encode(x) },
        j.`center`.map { x => "center" -> FacetEncodingFieldDefCenterCodec.encode(x) },
        j.`align`.map { x => "align" -> FacetEncodingFieldDefAlignCodec.encode(x) },
        j.`bounds`.map { x => "bounds" -> FacetEncodingFieldDefBoundsCodec.encode(x) },
        j.`bandPosition`.map { x => "bandPosition" -> FacetEncodingFieldDefBandPositionCodec.encode(x) },
        j.`columns`.map { x => "columns" -> Json.toJson(x) },
        j.`header`.map { x => "header" -> HeaderCodec.encode(x) },
        j.`bin`.map { x => "bin" -> FacetEncodingFieldDefBinCodec.encode(x) },
        j.`spacing`.map { x => "spacing" -> FacetEncodingFieldDefSpacingCodec.encode(x) },
        j.`aggregate`.map { x => "aggregate" -> AggregateCodec.encode(x) },
        j.`timeUnit`.map { x => "timeUnit" -> FacetEncodingFieldDefTimeUnitCodec.encode(x) },
        j.`title`.map { x => "title" -> TextCodec.encode(x) },
        j.`sort`.map { x => "sort" -> FacetEncodingFieldDefSortCodec.encode(x) },
        j.`type`.map { x => "type" -> StandardTypeCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// FieldOrDatumDefWithConditionStringDatumDefTextDatum (UnionType)
object FieldOrDatumDefWithConditionStringDatumDefTextDatumCodec {
  def decode(j: JsValue): FieldOrDatumDefWithConditionStringDatumDefTextDatum =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldOrDatumDefWithConditionStringDatumDefTextDatum] =
    PrimitiveValueCodec.decodeOpt(j).orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    RepeatRefCodec.decodeOpt(j) } } } 
  def encode(j: FieldOrDatumDefWithConditionStringDatumDefTextDatum): JsValue =
    j match {
      case x:PrimitiveValue /* TypeRef */ => PrimitiveValueCodec.encode(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:RepeatRef /* TypeRef */ => RepeatRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefStroke (UnionType)
object MarkDefStrokeCodec {
  def decode(j: JsValue): MarkDefStroke =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefStroke] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => MarkDefStrokeAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: MarkDefStroke): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case MarkDefStrokeAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigLineBreak (UnionType)
object RectConfigLineBreakCodec {
  def decode(j: JsValue): RectConfigLineBreak =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigLineBreak] =
    j.asOpt[String].map { RectConfigLineBreakAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigLineBreak): JsValue =
    j match {
      case RectConfigLineBreakAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefUrl (UnionType)
object MarkDefUrlCodec {
  def decode(j: JsValue): MarkDefUrl =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefUrl] =
    UriReferenceCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefUrl): JsValue =
    j match {
      case x:UriReference /* TypeRef */ => UriReferenceCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// Generator (UnionType)
object GeneratorCodec {
  def decode(j: JsValue): Generator =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Generator] =
    SequenceGeneratorCodec.decodeOpt(j).orElse {
    SphereGeneratorCodec.decodeOpt(j).orElse {
    GraticuleGeneratorCodec.decodeOpt(j) } } 
  def encode(j: Generator): JsValue =
    j match {
      case x:SequenceGenerator /* TypeRef */ => SequenceGeneratorCodec.encode(x)
      case x:SphereGenerator /* TypeRef */ => SphereGeneratorCodec.encode(x)
      case x:GraticuleGenerator /* TypeRef */ => GraticuleGeneratorCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefBaseline (UnionType)
object MarkDefBaselineCodec {
  def decode(j: JsValue): MarkDefBaseline =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkDefBaseline] =
    TextBaselineCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkDefBaseline): JsValue =
    j match {
      case x:TextBaseline /* TypeRef */ => TextBaselineCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelRepeatSpecAsObject1Autosize (UnionType)
object TopLevelRepeatSpecAsObject1AutosizeCodec {
  def decode(j: JsValue): TopLevelRepeatSpecAsObject1Autosize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelRepeatSpecAsObject1Autosize] =
    AutosizeTypeCodec.decodeOpt(j).orElse {
    AutoSizeParamsCodec.decodeOpt(j) } 
  def encode(j: TopLevelRepeatSpecAsObject1Autosize): JsValue =
    j match {
      case x:AutosizeType /* TypeRef */ => AutosizeTypeCodec.encode(x)
      case x:AutoSizeParams /* TypeRef */ => AutoSizeParamsCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfig (StructType)
object RectConfigCodec {
  def decode(j: JsValue): RectConfig =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[RectConfig] =
    Some(RectConfig(
      `continuousBandSize` = (j \ "continuousBandSize").asOpt[JsValue].flatMap { x => RectConfigContinuousBandSizeCodec.decodeOpt(x) },
      `cornerRadiusBottomRight` = (j \ "cornerRadiusBottomRight").asOpt[JsValue].flatMap { x => RectConfigCornerRadiusBottomRightCodec.decodeOpt(x) },
      `fillOpacity` = (j \ "fillOpacity").asOpt[JsValue].flatMap { x => RectConfigFillOpacityCodec.decodeOpt(x) },
      `strokeMiterLimit` = (j \ "strokeMiterLimit").asOpt[JsValue].flatMap { x => RectConfigStrokeMiterLimitCodec.decodeOpt(x) },
      `dir` = (j \ "dir").asOpt[JsValue].flatMap { x => RectConfigDirCodec.decodeOpt(x) },
      `tooltip` = (j \ "tooltip").asOpt[JsValue].flatMap { x => RectConfigTooltipCodec.decodeOpt(x) },
      `timeUnitBandPosition` = (j \ "timeUnitBandPosition").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `cornerRadiusTopRight` = (j \ "cornerRadiusTopRight").asOpt[JsValue].flatMap { x => RectConfigCornerRadiusTopRightCodec.decodeOpt(x) },
      `outerRadius` = (j \ "outerRadius").asOpt[JsValue].flatMap { x => RectConfigOuterRadiusCodec.decodeOpt(x) },
      `x` = (j \ "x").asOpt[JsValue].flatMap { x => RectConfigXCodec.decodeOpt(x) },
      `dy` = (j \ "dy").asOpt[JsValue].flatMap { x => RectConfigDyCodec.decodeOpt(x) },
      `size` = (j \ "size").asOpt[JsValue].flatMap { x => RectConfigSizeCodec.decodeOpt(x) },
      `smooth` = (j \ "smooth").asOpt[JsValue].flatMap { x => RectConfigSmoothCodec.decodeOpt(x) },
      `url` = (j \ "url").asOpt[JsValue].flatMap { x => RectConfigUrlCodec.decodeOpt(x) },
      `y` = (j \ "y").asOpt[JsValue].flatMap { x => RectConfigYCodec.decodeOpt(x) },
      `strokeOpacity` = (j \ "strokeOpacity").asOpt[JsValue].flatMap { x => RectConfigStrokeOpacityCodec.decodeOpt(x) },
      `ellipsis` = (j \ "ellipsis").asOpt[JsValue].flatMap { x => RectConfigEllipsisCodec.decodeOpt(x) },
      `description` = (j \ "description").asOpt[JsValue].flatMap { x => RectConfigDescriptionCodec.decodeOpt(x) },
      `angle` = (j \ "angle").asOpt[JsValue].flatMap { x => RectConfigAngleCodec.decodeOpt(x) },
      `lineBreak` = (j \ "lineBreak").asOpt[JsValue].flatMap { x => RectConfigLineBreakCodec.decodeOpt(x) },
      `tension` = (j \ "tension").asOpt[JsValue].flatMap { x => RectConfigTensionCodec.decodeOpt(x) },
      `cornerRadiusTopLeft` = (j \ "cornerRadiusTopLeft").asOpt[JsValue].flatMap { x => RectConfigCornerRadiusTopLeftCodec.decodeOpt(x) },
      `stroke` = (j \ "stroke").asOpt[JsValue].flatMap { x => RectConfigStrokeCodec.decodeOpt(x) },
      `strokeDashOffset` = (j \ "strokeDashOffset").asOpt[JsValue].flatMap { x => RectConfigStrokeDashOffsetCodec.decodeOpt(x) },
      `align` = (j \ "align").asOpt[JsValue].flatMap { x => RectConfigAlignCodec.decodeOpt(x) },
      `ariaRole` = (j \ "ariaRole").asOpt[JsValue].flatMap { x => RectConfigAriaRoleCodec.decodeOpt(x) },
      `strokeCap` = (j \ "strokeCap").asOpt[JsValue].flatMap { x => RectConfigStrokeCapCodec.decodeOpt(x) },
      `endAngle` = (j \ "endAngle").asOpt[JsValue].flatMap { x => RectConfigEndAngleCodec.decodeOpt(x) },
      `strokeJoin` = (j \ "strokeJoin").asOpt[JsValue].flatMap { x => RectConfigStrokeJoinCodec.decodeOpt(x) },
      `baseline` = (j \ "baseline").asOpt[JsValue].flatMap { x => RectConfigBaselineCodec.decodeOpt(x) },
      `ariaRoleDescription` = (j \ "ariaRoleDescription").asOpt[JsValue].flatMap { x => RectConfigAriaRoleDescriptionCodec.decodeOpt(x) },
      `aspect` = (j \ "aspect").asOpt[JsValue].flatMap { x => RectConfigAspectCodec.decodeOpt(x) },
      `height` = (j \ "height").asOpt[JsValue].flatMap { x => RectConfigHeightCodec.decodeOpt(x) },
      `fontStyle` = (j \ "fontStyle").asOpt[JsValue].flatMap { x => RectConfigFontStyleCodec.decodeOpt(x) },
      `text` = (j \ "text").asOpt[JsValue].flatMap { x => RectConfigTextCodec.decodeOpt(x) },
      `binSpacing` = (j \ "binSpacing").asOpt[JsValue].flatMap { x => RectConfigBinSpacingCodec.decodeOpt(x) },
      `cornerRadius` = (j \ "cornerRadius").asOpt[JsValue].flatMap { x => RectConfigCornerRadiusCodec.decodeOpt(x) },
      `color` = (j \ "color").asOpt[JsValue].flatMap { x => RectConfigColorCodec.decodeOpt(x) },
      `x2` = (j \ "x2").asOpt[JsValue].flatMap { x => RectConfigX2Codec.decodeOpt(x) },
      `padAngle` = (j \ "padAngle").asOpt[JsValue].flatMap { x => RectConfigPadAngleCodec.decodeOpt(x) },
      `cursor` = (j \ "cursor").asOpt[JsValue].flatMap { x => RectConfigCursorCodec.decodeOpt(x) },
      `radius` = (j \ "radius").asOpt[JsValue].flatMap { x => RectConfigRadiusCodec.decodeOpt(x) },
      `timeUnitBandSize` = (j \ "timeUnitBandSize").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] },
      `startAngle` = (j \ "startAngle").asOpt[JsValue].flatMap { x => RectConfigStartAngleCodec.decodeOpt(x) },
      `font` = (j \ "font").asOpt[JsValue].flatMap { x => RectConfigFontCodec.decodeOpt(x) },
      `radius2` = (j \ "radius2").asOpt[JsValue].flatMap { x => RectConfigRadius2Codec.decodeOpt(x) },
      `invalid` = (j \ "invalid").asOpt[JsValue].flatMap { x => RectConfigInvalidCodec.decodeOpt(x) },
      `lineHeight` = (j \ "lineHeight").asOpt[JsValue].flatMap { x => RectConfigLineHeightCodec.decodeOpt(x) },
      `order` = (j \ "order").asOpt[JsValue].flatMap { x => RectConfigOrderCodec.decodeOpt(x) },
      `fill` = (j \ "fill").asOpt[JsValue].flatMap { x => RectConfigFillCodec.decodeOpt(x) },
      `interpolate` = (j \ "interpolate").asOpt[JsValue].flatMap { x => RectConfigInterpolateCodec.decodeOpt(x) },
      `theta` = (j \ "theta").asOpt[JsValue].flatMap { x => RectConfigThetaCodec.decodeOpt(x) },
      `innerRadius` = (j \ "innerRadius").asOpt[JsValue].flatMap { x => RectConfigInnerRadiusCodec.decodeOpt(x) },
      `fontSize` = (j \ "fontSize").asOpt[JsValue].flatMap { x => RectConfigFontSizeCodec.decodeOpt(x) },
      `y2` = (j \ "y2").asOpt[JsValue].flatMap { x => RectConfigY2Codec.decodeOpt(x) },
      `orient` = (j \ "orient").asOpt[JsValue].flatMap { x => OrientationCodec.decodeOpt(x) },
      `discreteBandSize` = (j \ "discreteBandSize").asOpt[JsValue].flatMap { x => RectConfigDiscreteBandSizeCodec.decodeOpt(x) },
      `shape` = (j \ "shape").asOpt[JsValue].flatMap { x => RectConfigShapeCodec.decodeOpt(x) },
      `aria` = (j \ "aria").asOpt[JsValue].flatMap { x => RectConfigAriaCodec.decodeOpt(x) },
      `opacity` = (j \ "opacity").asOpt[JsValue].flatMap { x => RectConfigOpacityCodec.decodeOpt(x) },
      `dx` = (j \ "dx").asOpt[JsValue].flatMap { x => RectConfigDxCodec.decodeOpt(x) },
      `cornerRadiusBottomLeft` = (j \ "cornerRadiusBottomLeft").asOpt[JsValue].flatMap { x => RectConfigCornerRadiusBottomLeftCodec.decodeOpt(x) },
      `href` = (j \ "href").asOpt[JsValue].flatMap { x => RectConfigHrefCodec.decodeOpt(x) },
      `strokeDash` = (j \ "strokeDash").asOpt[JsValue].flatMap { x => RectConfigStrokeDashCodec.decodeOpt(x) },
      `strokeOffset` = (j \ "strokeOffset").asOpt[JsValue].flatMap { x => RectConfigStrokeOffsetCodec.decodeOpt(x) },
      `limit` = (j \ "limit").asOpt[JsValue].flatMap { x => RectConfigLimitCodec.decodeOpt(x) },
      `width` = (j \ "width").asOpt[JsValue].flatMap { x => RectConfigWidthCodec.decodeOpt(x) },
      `fontWeight` = (j \ "fontWeight").asOpt[JsValue].flatMap { x => RectConfigFontWeightCodec.decodeOpt(x) },
      `filled` = (j \ "filled").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] },
      `blend` = (j \ "blend").asOpt[JsValue].flatMap { x => RectConfigBlendCodec.decodeOpt(x) },
      `strokeWidth` = (j \ "strokeWidth").asOpt[JsValue].flatMap { x => RectConfigStrokeWidthCodec.decodeOpt(x) },
      `theta2` = (j \ "theta2").asOpt[JsValue].flatMap { x => RectConfigTheta2Codec.decodeOpt(x) },
    ))

  def encode(j: RectConfig): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`continuousBandSize`.map { x => "continuousBandSize" -> RectConfigContinuousBandSizeCodec.encode(x) },
        j.`cornerRadiusBottomRight`.map { x => "cornerRadiusBottomRight" -> RectConfigCornerRadiusBottomRightCodec.encode(x) },
        j.`fillOpacity`.map { x => "fillOpacity" -> RectConfigFillOpacityCodec.encode(x) },
        j.`strokeMiterLimit`.map { x => "strokeMiterLimit" -> RectConfigStrokeMiterLimitCodec.encode(x) },
        j.`dir`.map { x => "dir" -> RectConfigDirCodec.encode(x) },
        j.`tooltip`.map { x => "tooltip" -> RectConfigTooltipCodec.encode(x) },
        j.`timeUnitBandPosition`.map { x => "timeUnitBandPosition" -> Json.toJson(x) },
        j.`cornerRadiusTopRight`.map { x => "cornerRadiusTopRight" -> RectConfigCornerRadiusTopRightCodec.encode(x) },
        j.`outerRadius`.map { x => "outerRadius" -> RectConfigOuterRadiusCodec.encode(x) },
        j.`x`.map { x => "x" -> RectConfigXCodec.encode(x) },
        j.`dy`.map { x => "dy" -> RectConfigDyCodec.encode(x) },
        j.`size`.map { x => "size" -> RectConfigSizeCodec.encode(x) },
        j.`smooth`.map { x => "smooth" -> RectConfigSmoothCodec.encode(x) },
        j.`url`.map { x => "url" -> RectConfigUrlCodec.encode(x) },
        j.`y`.map { x => "y" -> RectConfigYCodec.encode(x) },
        j.`strokeOpacity`.map { x => "strokeOpacity" -> RectConfigStrokeOpacityCodec.encode(x) },
        j.`ellipsis`.map { x => "ellipsis" -> RectConfigEllipsisCodec.encode(x) },
        j.`description`.map { x => "description" -> RectConfigDescriptionCodec.encode(x) },
        j.`angle`.map { x => "angle" -> RectConfigAngleCodec.encode(x) },
        j.`lineBreak`.map { x => "lineBreak" -> RectConfigLineBreakCodec.encode(x) },
        j.`tension`.map { x => "tension" -> RectConfigTensionCodec.encode(x) },
        j.`cornerRadiusTopLeft`.map { x => "cornerRadiusTopLeft" -> RectConfigCornerRadiusTopLeftCodec.encode(x) },
        j.`stroke`.map { x => "stroke" -> RectConfigStrokeCodec.encode(x) },
        j.`strokeDashOffset`.map { x => "strokeDashOffset" -> RectConfigStrokeDashOffsetCodec.encode(x) },
        j.`align`.map { x => "align" -> RectConfigAlignCodec.encode(x) },
        j.`ariaRole`.map { x => "ariaRole" -> RectConfigAriaRoleCodec.encode(x) },
        j.`strokeCap`.map { x => "strokeCap" -> RectConfigStrokeCapCodec.encode(x) },
        j.`endAngle`.map { x => "endAngle" -> RectConfigEndAngleCodec.encode(x) },
        j.`strokeJoin`.map { x => "strokeJoin" -> RectConfigStrokeJoinCodec.encode(x) },
        j.`baseline`.map { x => "baseline" -> RectConfigBaselineCodec.encode(x) },
        j.`ariaRoleDescription`.map { x => "ariaRoleDescription" -> RectConfigAriaRoleDescriptionCodec.encode(x) },
        j.`aspect`.map { x => "aspect" -> RectConfigAspectCodec.encode(x) },
        j.`height`.map { x => "height" -> RectConfigHeightCodec.encode(x) },
        j.`fontStyle`.map { x => "fontStyle" -> RectConfigFontStyleCodec.encode(x) },
        j.`text`.map { x => "text" -> RectConfigTextCodec.encode(x) },
        j.`binSpacing`.map { x => "binSpacing" -> RectConfigBinSpacingCodec.encode(x) },
        j.`cornerRadius`.map { x => "cornerRadius" -> RectConfigCornerRadiusCodec.encode(x) },
        j.`color`.map { x => "color" -> RectConfigColorCodec.encode(x) },
        j.`x2`.map { x => "x2" -> RectConfigX2Codec.encode(x) },
        j.`padAngle`.map { x => "padAngle" -> RectConfigPadAngleCodec.encode(x) },
        j.`cursor`.map { x => "cursor" -> RectConfigCursorCodec.encode(x) },
        j.`radius`.map { x => "radius" -> RectConfigRadiusCodec.encode(x) },
        j.`timeUnitBandSize`.map { x => "timeUnitBandSize" -> Json.toJson(x) },
        j.`startAngle`.map { x => "startAngle" -> RectConfigStartAngleCodec.encode(x) },
        j.`font`.map { x => "font" -> RectConfigFontCodec.encode(x) },
        j.`radius2`.map { x => "radius2" -> RectConfigRadius2Codec.encode(x) },
        j.`invalid`.map { x => "invalid" -> RectConfigInvalidCodec.encode(x) },
        j.`lineHeight`.map { x => "lineHeight" -> RectConfigLineHeightCodec.encode(x) },
        j.`order`.map { x => "order" -> RectConfigOrderCodec.encode(x) },
        j.`fill`.map { x => "fill" -> RectConfigFillCodec.encode(x) },
        j.`interpolate`.map { x => "interpolate" -> RectConfigInterpolateCodec.encode(x) },
        j.`theta`.map { x => "theta" -> RectConfigThetaCodec.encode(x) },
        j.`innerRadius`.map { x => "innerRadius" -> RectConfigInnerRadiusCodec.encode(x) },
        j.`fontSize`.map { x => "fontSize" -> RectConfigFontSizeCodec.encode(x) },
        j.`y2`.map { x => "y2" -> RectConfigY2Codec.encode(x) },
        j.`orient`.map { x => "orient" -> OrientationCodec.encode(x) },
        j.`discreteBandSize`.map { x => "discreteBandSize" -> RectConfigDiscreteBandSizeCodec.encode(x) },
        j.`shape`.map { x => "shape" -> RectConfigShapeCodec.encode(x) },
        j.`aria`.map { x => "aria" -> RectConfigAriaCodec.encode(x) },
        j.`opacity`.map { x => "opacity" -> RectConfigOpacityCodec.encode(x) },
        j.`dx`.map { x => "dx" -> RectConfigDxCodec.encode(x) },
        j.`cornerRadiusBottomLeft`.map { x => "cornerRadiusBottomLeft" -> RectConfigCornerRadiusBottomLeftCodec.encode(x) },
        j.`href`.map { x => "href" -> RectConfigHrefCodec.encode(x) },
        j.`strokeDash`.map { x => "strokeDash" -> RectConfigStrokeDashCodec.encode(x) },
        j.`strokeOffset`.map { x => "strokeOffset" -> RectConfigStrokeOffsetCodec.encode(x) },
        j.`limit`.map { x => "limit" -> RectConfigLimitCodec.encode(x) },
        j.`width`.map { x => "width" -> RectConfigWidthCodec.encode(x) },
        j.`fontWeight`.map { x => "fontWeight" -> RectConfigFontWeightCodec.encode(x) },
        j.`filled`.map { x => "filled" -> Json.toJson(x) },
        j.`blend`.map { x => "blend" -> RectConfigBlendCodec.encode(x) },
        j.`strokeWidth`.map { x => "strokeWidth" -> RectConfigStrokeWidthCodec.encode(x) },
        j.`theta2`.map { x => "theta2" -> RectConfigTheta2Codec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// OverlayMarkDefThetaOffset (UnionType)
object OverlayMarkDefThetaOffsetCodec {
  def decode(j: JsValue): OverlayMarkDefThetaOffset =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefThetaOffset] =
    j.asOpt[JsNumber].map { OverlayMarkDefThetaOffsetAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefThetaOffset): JsValue =
    j match {
      case OverlayMarkDefThetaOffsetAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConcatSpecGenericSpecAlign (UnionType)
object ConcatSpecGenericSpecAlignCodec {
  def decode(j: JsValue): ConcatSpecGenericSpecAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConcatSpecGenericSpecAlign] =
    LayoutAlignCodec.decodeOpt(j).orElse {
    RowColLayoutAlignCodec.decodeOpt(j) } 
  def encode(j: ConcatSpecGenericSpecAlign): JsValue =
    j match {
      case x:LayoutAlign /* TypeRef */ => LayoutAlignCodec.encode(x)
      case x:RowColLayoutAlign /* TypeRef */ => RowColLayoutAlignCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefColorNullExprRef (UnionType)
object ConditionalPredicateValueDefColorNullExprRefCodec {
  def decode(j: JsValue): ConditionalPredicateValueDefColorNullExprRef =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefColorNullExprRef] =
    ConditionalPredicateValueDefColorNullExprRefAsObject1Codec.decodeOpt(j).orElse {
    ConditionalPredicateValueDefColorNullExprRefAsObject2Codec.decodeOpt(j) } 
  def encode(j: ConditionalPredicateValueDefColorNullExprRef): JsValue =
    j match {
      case x:ConditionalPredicateValueDefColorNullExprRefAsObject1 /* TypeRef */ => ConditionalPredicateValueDefColorNullExprRefAsObject1Codec.encode(x)
      case x:ConditionalPredicateValueDefColorNullExprRefAsObject2 /* TypeRef */ => ConditionalPredicateValueDefColorNullExprRefAsObject2Codec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ImputeParamsFrameElement (UnionType)
object ImputeParamsFrameElementCodec {
  def decode(j: JsValue): ImputeParamsFrameElement =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ImputeParamsFrameElement] =
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ImputeParamsFrameElementAsNull }.orElse {
    j.asOpt[JsNumber].map { ImputeParamsFrameElementAsNumber(_) } } 
  def encode(j: ImputeParamsFrameElement): JsValue =
    j match {
      case ImputeParamsFrameElementAsNull /* Global, NullType$ */ => JsNull
      case ImputeParamsFrameElementAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// BarConfigWidth (UnionType)
object BarConfigWidthCodec {
  def decode(j: JsValue): BarConfigWidth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[BarConfigWidth] =
    j.asOpt[JsNumber].map { BarConfigWidthAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: BarConfigWidth): JsValue =
    j match {
      case BarConfigWidthAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FacetedEncodingTooltip (UnionType)
object FacetedEncodingTooltipCodec {
  def decode(j: JsValue): FacetedEncodingTooltip =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FacetedEncodingTooltip] =
    StringFieldDefWithConditionCodec.decodeOpt(j).orElse {
    StringValueDefWithConditionCodec.decodeOpt(j).orElse {
    ArrayOfStringFieldDefCodec.decodeOpt(j).map { FacetedEncodingTooltipAsArrayOfStringFieldDef(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => FacetedEncodingTooltipAsNull } } } } 
  def encode(j: FacetedEncodingTooltip): JsValue =
    j match {
      case x:StringFieldDefWithCondition /* TypeRef */ => StringFieldDefWithConditionCodec.encode(x)
      case x:StringValueDefWithCondition /* TypeRef */ => StringValueDefWithConditionCodec.encode(x)
      case FacetedEncodingTooltipAsArrayOfStringFieldDef(x) /* Base, ArrayType */ => ArrayOfStringFieldDefCodec.encode(x)
      case FacetedEncodingTooltipAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// FieldGTEPredicateGte (UnionType)
object FieldGTEPredicateGteCodec {
  def decode(j: JsValue): FieldGTEPredicateGte =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[FieldGTEPredicateGte] =
    j.asOpt[String].map { FieldGTEPredicateGteAsString(_) }.orElse {
    j.asOpt[JsNumber].map { FieldGTEPredicateGteAsNumber(_) }.orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: FieldGTEPredicateGte): JsValue =
    j match {
      case FieldGTEPredicateGteAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case FieldGTEPredicateGteAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ErrorBandConfigBorders (UnionType)
object ErrorBandConfigBordersCodec {
  def decode(j: JsValue): ErrorBandConfigBorders =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ErrorBandConfigBorders] =
    j.asOpt[Boolean].map { ErrorBandConfigBordersAsBool(_) }.orElse {
    MarkConfigCodec.decodeOpt(j) } 
  def encode(j: ErrorBandConfigBorders): JsValue =
    j match {
      case ErrorBandConfigBordersAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:MarkConfig /* TypeRef */ => MarkConfigCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefRadius (ConstrainedType)
// see MarkDefRadius (UnionType)

////////////////////////////////////////////////////////////////////////
// RectConfigFontStyle (UnionType)
object RectConfigFontStyleCodec {
  def decode(j: JsValue): RectConfigFontStyle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigFontStyle] =
    j.asOpt[String].map { RectConfigFontStyleAsString(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigFontStyle): JsValue =
    j match {
      case RectConfigFontStyleAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// StepFor (EnumType)
object StepForCodec {
  def decode(j: JsValue): StepFor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[StepFor] =
    j match {
      case JsString("position") => Some(StepForPosition)
      case JsString("offset") => Some(StepForOffset)
      case _ => None
    }
  def encode(j: StepFor): JsValue =
    j.payload
}


////////////////////////////////////////////////////////////////////////
// NumberLocale (StructType)
object NumberLocaleCodec {
  def decode(j: JsValue): NumberLocale =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[NumberLocale] =
    {
      val `minus` = (j \ "minus").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `grouping` = (j \ "grouping").asOpt[JsValue].flatMap { x => ArrayOfNumberCodec.decodeOpt(x) }
      if(`grouping`.isEmpty) { return None }
      val `decimal` = (j \ "decimal").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`decimal`.isEmpty) { return None }
      val `currency` = (j \ "currency").asOpt[JsValue].flatMap { x => Vector2StringCodec.decodeOpt(x) }
      if(`currency`.isEmpty) { return None }
      val `percent` = (j \ "percent").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `thousands` = (j \ "thousands").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`thousands`.isEmpty) { return None }
      val `nan` = (j \ "nan").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `numerals` = (j \ "numerals").asOpt[JsValue].flatMap { x => Vector10StringCodec.decodeOpt(x) }
      return Some(NumberLocale(
        `minus` = `minus`,
        `grouping` = `grouping`.get,
        `decimal` = `decimal`.get,
        `currency` = `currency`.get,
        `percent` = `percent`,
        `thousands` = `thousands`.get,
        `nan` = `nan`,
        `numerals` = `numerals`,
      ))
    }

  def encode(j: NumberLocale): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`minus`.map { x => "minus" -> Json.toJson(x) },
        Some("grouping" -> ArrayOfNumberCodec.encode(j.`grouping`)),
        Some("decimal" -> Json.toJson(j.`decimal`)),
        Some("currency" -> Vector2StringCodec.encode(j.`currency`)),
        j.`percent`.map { x => "percent" -> Json.toJson(x) },
        Some("thousands" -> Json.toJson(j.`thousands`)),
        j.`nan`.map { x => "nan" -> Json.toJson(x) },
        j.`numerals`.map { x => "numerals" -> Vector10StringCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// StringFieldDefWithConditionCondition (UnionType)
object StringFieldDefWithConditionConditionCodec {
  def decode(j: JsValue): StringFieldDefWithConditionCondition =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[StringFieldDefWithConditionCondition] =
    ConditionalValueDefStringExprRefCodec.decodeOpt(j).orElse {
    ArrayOfConditionalValueDefStringExprRefCodec.decodeOpt(j).map { StringFieldDefWithConditionConditionAsArrayOfConditionalValueDefStringExprRef(_) } } 
  def encode(j: StringFieldDefWithConditionCondition): JsValue =
    j match {
      case x:ConditionalValueDefStringExprRef /* TypeRef */ => ConditionalValueDefStringExprRefCodec.encode(x)
      case StringFieldDefWithConditionConditionAsArrayOfConditionalValueDefStringExprRef(x) /* Base, ArrayType */ => ArrayOfConditionalValueDefStringExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefFontWeight (UnionType)
object OverlayMarkDefFontWeightCodec {
  def decode(j: JsValue): OverlayMarkDefFontWeight =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefFontWeight] =
    FontWeightCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefFontWeight): JsValue =
    j match {
      case x:FontWeight /* TypeRef */ => FontWeightCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefFontSize (UnionType)
object OverlayMarkDefFontSizeCodec {
  def decode(j: JsValue): OverlayMarkDefFontSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefFontSize] =
    OverlayMarkDefFontSizeAsNumberCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefFontSize): JsValue =
    j match {
      case x:OverlayMarkDefFontSizeAsNumber /* TypeRef */ => OverlayMarkDefFontSizeAsNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// LineConfigPoint (UnionType)
object LineConfigPointCodec {
  def decode(j: JsValue): LineConfigPoint =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LineConfigPoint] =
    j.asOpt[Boolean].map { LineConfigPointAsBool(_) }.orElse {
    OverlayMarkDefCodec.decodeOpt(j).orElse {
    TransparentCodec.decodeOpt(j) } } 
  def encode(j: LineConfigPoint): JsValue =
    j match {
      case LineConfigPointAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:OverlayMarkDef /* TypeRef */ => OverlayMarkDefCodec.encode(x)
      case x:Transparent /* TypeRef */ => TransparentCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkDefDiscreteBandSize (ConstrainedType)
// see MarkDefDiscreteBandSize (UnionType)

////////////////////////////////////////////////////////////////////////
// ArrayOfFieldRangePredicateRangeAsArrayElement (ArrayType)
object ArrayOfFieldRangePredicateRangeAsArrayElementCodec {
  def decode(j: JsValue): Seq[FieldRangePredicateRangeAsArrayElement] =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[Seq[FieldRangePredicateRangeAsArrayElement]] =
    j.asOpt[Seq[JsValue]].map { _.map { x => 
      FieldRangePredicateRangeAsArrayElementCodec.decodeOpt(x).getOrElse { return None } } }
  def encode(j: Seq[FieldRangePredicateRangeAsArrayElement]): JsArray =
      JsArray(j.map { x => FieldRangePredicateRangeAsArrayElementCodec.encode(x) })
}

////////////////////////////////////////////////////////////////////////
// RectConfigSize (UnionType)
object RectConfigSizeCodec {
  def decode(j: JsValue): RectConfigSize =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigSize] =
    j.asOpt[JsNumber].map { RectConfigSizeAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: RectConfigSize): JsValue =
    j match {
      case RectConfigSizeAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// SharedEncodingX2BandPosition (ConstrainedType)
object SharedEncodingX2BandPositionCodec {
  def decode(j: JsValue): SharedEncodingX2BandPosition =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[SharedEncodingX2BandPosition] =
    try {
      j.asOpt[JsNumber]
        .map { SharedEncodingX2BandPosition(_) }
    } catch {
      case _:AssertionError => None
    }
  def encode(j: SharedEncodingX2BandPosition): JsValue =
    Json.toJson(j.value)
}

////////////////////////////////////////////////////////////////////////
// AxisConfigTitleAngle (UnionType)
object AxisConfigTitleAngleCodec {
  def decode(j: JsValue): AxisConfigTitleAngle =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigTitleAngle] =
    j.asOpt[JsNumber].map { AxisConfigTitleAngleAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigTitleAngle): JsValue =
    j match {
      case AxisConfigTitleAngleAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ScaleDomainMin (UnionType)
object ScaleDomainMinCodec {
  def decode(j: JsValue): ScaleDomainMin =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ScaleDomainMin] =
    j.asOpt[JsNumber].map { ScaleDomainMinAsNumber(_) }.orElse {
    DateTimeCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: ScaleDomainMin): JsValue =
    j match {
      case ScaleDomainMinAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:DateTime /* TypeRef */ => DateTimeCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisFormat (UnionType)
object AxisFormatCodec {
  def decode(j: JsValue): AxisFormat =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisFormat] =
    j.asOpt[String].map { AxisFormatAsString(_) }.orElse {
    DictOfAnyCodec.decodeOpt(j).map { AxisFormatAsDictOfAny(_) } } 
  def encode(j: AxisFormat): JsValue =
    j match {
      case AxisFormatAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case AxisFormatAsDictOfAny(x) /* Base, MapType */ => DictOfAnyCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// OverlayMarkDefSmooth (UnionType)
object OverlayMarkDefSmoothCodec {
  def decode(j: JsValue): OverlayMarkDefSmooth =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[OverlayMarkDefSmooth] =
    j.asOpt[Boolean].map { OverlayMarkDefSmoothAsBool(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: OverlayMarkDefSmooth): JsValue =
    j match {
      case OverlayMarkDefSmoothAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisGridDash (UnionType)
object AxisGridDashCodec {
  def decode(j: JsValue): AxisGridDash =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisGridDash] =
    ArrayOfNumberCodec.decodeOpt(j).map { AxisGridDashAsArrayOfNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    ConditionalAxisNumberArrayCodec.decodeOpt(j) } } 
  def encode(j: AxisGridDash): JsValue =
    j match {
      case AxisGridDashAsArrayOfNumber(x) /* Base, ArrayType */ => ArrayOfNumberCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:ConditionalAxisNumberArray /* TypeRef */ => ConditionalAxisNumberArrayCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// AxisConfigDomainOpacity (UnionType)
object AxisConfigDomainOpacityCodec {
  def decode(j: JsValue): AxisConfigDomainOpacity =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AxisConfigDomainOpacity] =
    j.asOpt[JsNumber].map { AxisConfigDomainOpacityAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: AxisConfigDomainOpacity): JsValue =
    j match {
      case AxisConfigDomainOpacityAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// RectConfigColor (UnionType)
object RectConfigColorCodec {
  def decode(j: JsValue): RectConfigColor =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[RectConfigColor] =
    ColorCodec.decodeOpt(j).orElse {
    GradientCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: RectConfigColor): JsValue =
    j match {
      case x:Color /* TypeRef */ => ColorCodec.encode(x)
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// FieldOneOfPredicate (StructType)
object FieldOneOfPredicateCodec {
  def decode(j: JsValue): FieldOneOfPredicate =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[FieldOneOfPredicate] =
    {
      val `field` = (j \ "field").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`field`.isEmpty) { return None }
      val `oneOf` = (j \ "oneOf").asOpt[JsValue].flatMap { x => FieldOneOfPredicateOneOfCodec.decodeOpt(x) }
      if(`oneOf`.isEmpty) { return None }
      val `timeUnit` = (j \ "timeUnit").asOpt[JsValue].flatMap { x => FieldOneOfPredicateTimeUnitCodec.decodeOpt(x) }
      return Some(FieldOneOfPredicate(
        `field` = `field`.get,
        `oneOf` = `oneOf`.get,
        `timeUnit` = `timeUnit`,
      ))
    }

  def encode(j: FieldOneOfPredicate): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("field" -> Json.toJson(j.`field`)),
        Some("oneOf" -> FieldOneOfPredicateOneOfCodec.encode(j.`oneOf`)),
        j.`timeUnit`.map { x => "timeUnit" -> FieldOneOfPredicateTimeUnitCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// ConditionalPredicateValueDefGradientStringNullExprRefValue (UnionType)
object ConditionalPredicateValueDefGradientStringNullExprRefValueCodec {
  def decode(j: JsValue): ConditionalPredicateValueDefGradientStringNullExprRefValue =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalPredicateValueDefGradientStringNullExprRefValue] =
    GradientCodec.decodeOpt(j).orElse {
    j.asOpt[String].map { ConditionalPredicateValueDefGradientStringNullExprRefValueAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ConditionalPredicateValueDefGradientStringNullExprRefValueAsNull }.orElse {
    ExprRefCodec.decodeOpt(j) } } } 
  def encode(j: ConditionalPredicateValueDefGradientStringNullExprRefValue): JsValue =
    j match {
      case x:Gradient /* TypeRef */ => GradientCodec.encode(x)
      case ConditionalPredicateValueDefGradientStringNullExprRefValueAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case ConditionalPredicateValueDefGradientStringNullExprRefValueAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNull (ConstrainedType)
// see ValueDefWithConditionMarkPropFieldOrDatumDefGradientStringNull (StructType)

////////////////////////////////////////////////////////////////////////
// MarkConfigAlign (UnionType)
object MarkConfigAlignCodec {
  def decode(j: JsValue): MarkConfigAlign =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigAlign] =
    AlignCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigAlign): JsValue =
    j match {
      case x:Align /* TypeRef */ => AlignCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// MarkConfigCornerRadiusTopLeft (UnionType)
object MarkConfigCornerRadiusTopLeftCodec {
  def decode(j: JsValue): MarkConfigCornerRadiusTopLeft =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[MarkConfigCornerRadiusTopLeft] =
    j.asOpt[JsNumber].map { MarkConfigCornerRadiusTopLeftAsNumber(_) }.orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: MarkConfigCornerRadiusTopLeft): JsValue =
    j match {
      case MarkConfigCornerRadiusTopLeftAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TopLevelUnitSpecPadding (UnionType)
object TopLevelUnitSpecPaddingCodec {
  def decode(j: JsValue): TopLevelUnitSpecPadding =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TopLevelUnitSpecPadding] =
    PaddingCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: TopLevelUnitSpecPadding): JsValue =
    j match {
      case x:Padding /* TypeRef */ => PaddingCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// TickConfigTooltip (UnionType)
object TickConfigTooltipCodec {
  def decode(j: JsValue): TickConfigTooltip =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[TickConfigTooltip] =
    j.asOpt[String].map { TickConfigTooltipAsString(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => TickConfigTooltipAsNull }.orElse {
    ExprRefCodec.decodeOpt(j).orElse {
    TooltipContentCodec.decodeOpt(j).orElse {
    j.asOpt[Boolean].map { TickConfigTooltipAsBool(_) }.orElse {
    j.asOpt[JsNumber].map { TickConfigTooltipAsNumber(_) } } } } } } 
  def encode(j: TickConfigTooltip): JsValue =
    j match {
      case TickConfigTooltipAsString(x) /* Base, StringType$ */ => Json.toJson(x)
      case TickConfigTooltipAsNull /* Global, NullType$ */ => JsNull
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
      case x:TooltipContent /* TypeRef */ => TooltipContentCodec.encode(x)
      case TickConfigTooltipAsBool(x) /* Base, BooleanType$ */ => Json.toJson(x)
      case TickConfigTooltipAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
    }
}

////////////////////////////////////////////////////////////////////////
// ConditionalAxisNumberAsObject1Value (UnionType)
object ConditionalAxisNumberAsObject1ValueCodec {
  def decode(j: JsValue): ConditionalAxisNumberAsObject1Value =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[ConditionalAxisNumberAsObject1Value] =
    j.asOpt[JsNumber].map { ConditionalAxisNumberAsObject1ValueAsNumber(_) }.orElse {
    j.asOpt[JsNull.type].map { _ => JsNull }.map { _ => ConditionalAxisNumberAsObject1ValueAsNull } } 
  def encode(j: ConditionalAxisNumberAsObject1Value): JsValue =
    j match {
      case ConditionalAxisNumberAsObject1ValueAsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case ConditionalAxisNumberAsObject1ValueAsNull /* Global, NullType$ */ => JsNull
    }
}

////////////////////////////////////////////////////////////////////////
// AreaConfigX2 (UnionType)
object AreaConfigX2Codec {
  def decode(j: JsValue): AreaConfigX2 =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[AreaConfigX2] =
    j.asOpt[JsNumber].map { AreaConfigX2AsNumber(_) }.orElse {
    WidthCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } } 
  def encode(j: AreaConfigX2): JsValue =
    j match {
      case AreaConfigX2AsNumber(x) /* Base, NumberType$ */ => Json.toJson(x)
      case x:Width /* TypeRef */ => WidthCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}

////////////////////////////////////////////////////////////////////////
// VariableParameter (StructType)
object VariableParameterCodec {
  def decode(j: JsValue): VariableParameter =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[VariableParameter] =
    {
      val `bind` = (j \ "bind").asOpt[JsValue].flatMap { x => BindingCodec.decodeOpt(x) }
      val `expr` = (j \ "expr").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      if(`name`.isEmpty) { return None }
      val `value` = (j \ "value").asOpt[JsValue].flatMap { x => x.asOpt[JsValue] }
      return Some(VariableParameter(
        `bind` = `bind`,
        `expr` = `expr`,
        `name` = `name`.get,
        `value` = `value`,
      ))
    }

  def encode(j: VariableParameter): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        j.`bind`.map { x => "bind" -> BindingCodec.encode(x) },
        j.`expr`.map { x => "expr" -> Json.toJson(x) },
        Some("name" -> Json.toJson(j.`name`)),
        j.`value`.map { x => "value" -> Json.toJson(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// TopLevelHConcatSpec (StructType)
object TopLevelHConcatSpecCodec {
  def decode(j: JsValue): TopLevelHConcatSpec =
    decodeOpt(j).get

  def decodeOpt(j: JsValue): Option[TopLevelHConcatSpec] =
    {
      val `hconcat` = (j \ "hconcat").asOpt[JsValue].flatMap { x => ArrayOfNonNormalizedSpecCodec.decodeOpt(x) }
      if(`hconcat`.isEmpty) { return None }
      val `name` = (j \ "name").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `description` = (j \ "description").asOpt[JsValue].flatMap { x => x.asOpt[String] }
      val `data` = (j \ "data").asOpt[JsValue].flatMap { x => DataCodec.decodeOpt(x).map { Some(_) }.flatten }
      val `params` = (j \ "params").asOpt[JsValue].flatMap { x => ArrayOfTopLevelHConcatSpecParamsElementCodec.decodeOpt(x) }
      val `config` = (j \ "config").asOpt[JsValue].flatMap { x => ConfigCodec.decodeOpt(x) }
      val `bounds` = (j \ "bounds").asOpt[JsValue].flatMap { x => TopLevelHConcatSpecBoundsCodec.decodeOpt(x) }
      val `datasets` = (j \ "datasets").asOpt[JsValue].flatMap { x => DictOfInlineDatasetCodec.decodeOpt(x) }
      val `usermeta` = (j \ "usermeta").asOpt[JsValue].flatMap { x => DictOfAnyCodec.decodeOpt(x) }
      val `resolve` = (j \ "resolve").asOpt[JsValue].flatMap { x => ResolveCodec.decodeOpt(x) }
      val `padding` = (j \ "padding").asOpt[JsValue].flatMap { x => TopLevelHConcatSpecPaddingCodec.decodeOpt(x) }
      val `title` = (j \ "title").asOpt[JsValue].flatMap { x => TopLevelHConcatSpecTitleCodec.decodeOpt(x) }
      val `background` = (j \ "background").asOpt[JsValue].flatMap { x => TopLevelHConcatSpecBackgroundCodec.decodeOpt(x) }
      val `center` = (j \ "center").asOpt[JsValue].flatMap { x => x.asOpt[Boolean] }
      val `spacing` = (j \ "spacing").asOpt[JsValue].flatMap { x => x.asOpt[JsNumber] }
      val `$schema` = (j \ "$schema").asOpt[JsValue].flatMap { x => UriCodec.decodeOpt(x) }
      val `autosize` = (j \ "autosize").asOpt[JsValue].flatMap { x => TopLevelHConcatSpecAutosizeCodec.decodeOpt(x) }
      val `transform` = (j \ "transform").asOpt[JsValue].flatMap { x => ArrayOfTransformCodec.decodeOpt(x) }
      return Some(TopLevelHConcatSpec(
        `hconcat` = `hconcat`.get,
        `name` = `name`,
        `description` = `description`,
        `data` = `data`,
        `params` = `params`,
        `config` = `config`,
        `bounds` = `bounds`,
        `datasets` = `datasets`,
        `usermeta` = `usermeta`,
        `resolve` = `resolve`,
        `padding` = `padding`,
        `title` = `title`,
        `background` = `background`,
        `center` = `center`,
        `spacing` = `spacing`,
        `$schema` = `$schema`,
        `autosize` = `autosize`,
        `transform` = `transform`,
      ))
    }

  def encode(j: TopLevelHConcatSpec): JsObject =
    JsObject(
      Seq[Option[(String,JsValue)]](
        Some("hconcat" -> ArrayOfNonNormalizedSpecCodec.encode(j.`hconcat`)),
        j.`name`.map { x => "name" -> Json.toJson(x) },
        j.`description`.map { x => "description" -> Json.toJson(x) },
        j.`data`.map { x => "data" -> DataCodec.encode(x) },
        j.`params`.map { x => "params" -> ArrayOfTopLevelHConcatSpecParamsElementCodec.encode(x) },
        j.`config`.map { x => "config" -> ConfigCodec.encode(x) },
        j.`bounds`.map { x => "bounds" -> TopLevelHConcatSpecBoundsCodec.encode(x) },
        j.`datasets`.map { x => "datasets" -> DictOfInlineDatasetCodec.encode(x) },
        j.`usermeta`.map { x => "usermeta" -> DictOfAnyCodec.encode(x) },
        j.`resolve`.map { x => "resolve" -> ResolveCodec.encode(x) },
        j.`padding`.map { x => "padding" -> TopLevelHConcatSpecPaddingCodec.encode(x) },
        j.`title`.map { x => "title" -> TopLevelHConcatSpecTitleCodec.encode(x) },
        j.`background`.map { x => "background" -> TopLevelHConcatSpecBackgroundCodec.encode(x) },
        j.`center`.map { x => "center" -> Json.toJson(x) },
        j.`spacing`.map { x => "spacing" -> Json.toJson(x) },
        j.`$schema`.map { x => "$schema" -> UriCodec.encode(x) },
        j.`autosize`.map { x => "autosize" -> TopLevelHConcatSpecAutosizeCodec.encode(x) },
        j.`transform`.map { x => "transform" -> ArrayOfTransformCodec.encode(x) },
      ).flatten.toMap
    )
}


////////////////////////////////////////////////////////////////////////
// LegendConfigLabelOverlap (UnionType)
object LegendConfigLabelOverlapCodec {
  def decode(j: JsValue): LegendConfigLabelOverlap =
    decodeOpt(j).get
  def decodeOpt(j: JsValue): Option[LegendConfigLabelOverlap] =
    LabelOverlapCodec.decodeOpt(j).orElse {
    ExprRefCodec.decodeOpt(j) } 
  def encode(j: LegendConfigLabelOverlap): JsValue =
    j match {
      case x:LabelOverlap /* TypeRef */ => LabelOverlapCodec.encode(x)
      case x:ExprRef /* TypeRef */ => ExprRefCodec.encode(x)
    }
}
